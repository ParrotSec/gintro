# dependencies:
# xlib-2.0
# GLib-2.0
# Gdk-3.0
# HarfBuzz-0.0
# GdkPixbuf-2.0
# cairo-1.0
# GObject-2.0
# Pango-1.0
# Gio-2.0
# GModule-2.0
# Atk-1.0
# immediate dependencies:
# xlib-2.0
# Gdk-3.0
# Atk-1.0
# libraries:
# libgtk-3.so.0,libgdk-3.so.0
{.warning[UnusedImport]: off.}
import xlib, glib, gdk, harfbuzz, gdkpixbuf, cairo, gobject, pango, gio, gmodule, atk
const Lib = "libgtk-3.so.0"
{.pragma: libprag, cdecl, dynlib: Lib.}

proc finalizeGObject*[T](o: ref T) =
  if not o.ignoreFinalizer:
    gobject.g_object_remove_toggle_ref(o.impl, gobject.toggleNotify, addr(o[]))

type
  TextDirection* {.size: sizeof(cint), pure.} = enum
    none = 0
    ltr = 1
    rtl = 2

type
  SelectionData00* {.pure.} = object
  SelectionData* = ref object
    impl*: ptr SelectionData00
    ignoreFinalizer*: bool

proc gtk_selection_data_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkSelectionData*(self: SelectionData) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_selection_data_get_type(), cast[ptr SelectionData00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SelectionData()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_selection_data_get_type(), cast[ptr SelectionData00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var SelectionData) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkSelectionData)

proc gtk_selection_data_free(self: ptr SelectionData00) {.
    importc, libprag.}

proc free*(self: SelectionData) =
  gtk_selection_data_free(cast[ptr SelectionData00](self.impl))

proc finalizerfree*(self: SelectionData) =
  if not self.ignoreFinalizer:
    gtk_selection_data_free(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_copy(self: ptr SelectionData00): ptr SelectionData00 {.
    importc, libprag.}

proc copy*(self: SelectionData): SelectionData =
  fnew(result, gBoxedFreeGtkSelectionData)
  result.impl = gtk_selection_data_copy(cast[ptr SelectionData00](self.impl))

proc gtk_selection_data_get_data_type(self: ptr SelectionData00): ptr gdk.Atom00 {.
    importc, libprag.}

proc getDataType*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_data_type(cast[ptr SelectionData00](self.impl))
  result.ignoreFinalizer = true

proc dataType*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_data_type(cast[ptr SelectionData00](self.impl))
  result.ignoreFinalizer = true

proc gtk_selection_data_get_data_with_length(self: ptr SelectionData00; length: var int32): ptr uint8 {.
    importc, libprag.}

proc getData*(self: SelectionData; length: var int): seq[uint8] =
  var length_00: int32
  result = uint8ArrayToSeq(gtk_selection_data_get_data_with_length(cast[ptr SelectionData00](self.impl), length_00), length.int)
  if length.addr != nil:
    length = int(length_00)

proc gtk_selection_data_get_display(self: ptr SelectionData00): ptr gdk.Display00 {.
    importc, libprag.}

proc getDisplay*(self: SelectionData): gdk.Display =
  let gobj = gtk_selection_data_get_display(cast[ptr SelectionData00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: SelectionData): gdk.Display =
  let gobj = gtk_selection_data_get_display(cast[ptr SelectionData00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_selection_data_get_format(self: ptr SelectionData00): int32 {.
    importc, libprag.}

proc getFormat*(self: SelectionData): int =
  int(gtk_selection_data_get_format(cast[ptr SelectionData00](self.impl)))

proc format*(self: SelectionData): int =
  int(gtk_selection_data_get_format(cast[ptr SelectionData00](self.impl)))

proc gtk_selection_data_get_length(self: ptr SelectionData00): int32 {.
    importc, libprag.}

proc getLength*(self: SelectionData): int =
  int(gtk_selection_data_get_length(cast[ptr SelectionData00](self.impl)))

proc length*(self: SelectionData): int =
  int(gtk_selection_data_get_length(cast[ptr SelectionData00](self.impl)))

proc gtk_selection_data_get_pixbuf(self: ptr SelectionData00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPixbuf*(self: SelectionData): gdkpixbuf.Pixbuf =
  let gobj = gtk_selection_data_get_pixbuf(cast[ptr SelectionData00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: SelectionData): gdkpixbuf.Pixbuf =
  let gobj = gtk_selection_data_get_pixbuf(cast[ptr SelectionData00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_selection_data_get_selection(self: ptr SelectionData00): ptr gdk.Atom00 {.
    importc, libprag.}

proc getSelection*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_selection(cast[ptr SelectionData00](self.impl))
  result.ignoreFinalizer = true

proc selection*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_selection(cast[ptr SelectionData00](self.impl))
  result.ignoreFinalizer = true

proc gtk_selection_data_get_target(self: ptr SelectionData00): ptr gdk.Atom00 {.
    importc, libprag.}

proc getTarget*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_target(cast[ptr SelectionData00](self.impl))
  result.ignoreFinalizer = true

proc target*(self: SelectionData): gdk.Atom =
  new(result)
  result.impl = gtk_selection_data_get_target(cast[ptr SelectionData00](self.impl))
  result.ignoreFinalizer = true

proc gtk_selection_data_get_text(self: ptr SelectionData00): cstring {.
    importc, libprag.}

proc getText*(self: SelectionData): string =
  let resul0 = gtk_selection_data_get_text(cast[ptr SelectionData00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc text*(self: SelectionData): string =
  let resul0 = gtk_selection_data_get_text(cast[ptr SelectionData00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_selection_data_get_uris(self: ptr SelectionData00): ptr cstring {.
    importc, libprag.}

proc getUris*(self: SelectionData): seq[string] =
  let resul0 = gtk_selection_data_get_uris(cast[ptr SelectionData00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc uris*(self: SelectionData): seq[string] =
  let resul0 = gtk_selection_data_get_uris(cast[ptr SelectionData00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_selection_data_set(self: ptr SelectionData00; `type`: ptr gdk.Atom00;
    format: int32; data: ptr uint8; length: int32) {.
    importc, libprag.}

proc set*(self: SelectionData; `type`: gdk.Atom; format: int;
    data: seq[uint8] | string) =
  let length = int(data.len)
  gtk_selection_data_set(cast[ptr SelectionData00](self.impl), cast[ptr gdk.Atom00](`type`.impl), int32(format), cast[ptr uint8](unsafeaddr(data[0])), int32(length))

proc gtk_selection_data_set_pixbuf(self: ptr SelectionData00; pixbuf: ptr gdkpixbuf.Pixbuf00): gboolean {.
    importc, libprag.}

proc setPixbuf*(self: SelectionData; pixbuf: gdkpixbuf.Pixbuf): bool =
  toBool(gtk_selection_data_set_pixbuf(cast[ptr SelectionData00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl)))

proc gtk_selection_data_set_text(self: ptr SelectionData00; str: cstring;
    len: int32): gboolean {.
    importc, libprag.}

proc setText*(self: SelectionData; str: cstring; len: int): bool =
  toBool(gtk_selection_data_set_text(cast[ptr SelectionData00](self.impl), str, int32(len)))

proc gtk_selection_data_set_uris(self: ptr SelectionData00; uris: ptr cstring): gboolean {.
    importc, libprag.}

proc setUris*(self: SelectionData; uris: varargs[string, `$`]): bool =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  toBool(gtk_selection_data_set_uris(cast[ptr SelectionData00](self.impl), seq2CstringArray(uris, fs469n23)))

proc gtk_selection_data_targets_include_image(self: ptr SelectionData00;
    writable: gboolean): gboolean {.
    importc, libprag.}

proc targetsIncludeImage*(self: SelectionData; writable: bool): bool =
  toBool(gtk_selection_data_targets_include_image(cast[ptr SelectionData00](self.impl), gboolean(writable)))

proc gtk_selection_data_targets_include_text(self: ptr SelectionData00): gboolean {.
    importc, libprag.}

proc targetsIncludeText*(self: SelectionData): bool =
  toBool(gtk_selection_data_targets_include_text(cast[ptr SelectionData00](self.impl)))

proc gtk_selection_data_targets_include_uri(self: ptr SelectionData00): gboolean {.
    importc, libprag.}

proc targetsIncludeUri*(self: SelectionData): bool =
  toBool(gtk_selection_data_targets_include_uri(cast[ptr SelectionData00](self.impl)))

type
  DragResult* {.size: sizeof(cint), pure.} = enum
    success = 0
    noTarget = 1
    userCancelled = 2
    timeoutExpired = 3
    grabBroken = 4
    error = 5

type
  DirectionType* {.size: sizeof(cint), pure.} = enum
    tabForward = 0
    tabBackward = 1
    up = 2
    down = 3
    left = 4
    right = 5

type
  Tooltip* = ref object of gobject.Object
  Tooltip00* = object of gobject.Object00

proc gtk_tooltip_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Tooltip()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tooltip_trigger_tooltip_query(display: ptr gdk.Display00) {.
    importc, libprag.}

proc triggerTooltipQuery*(display: gdk.Display) =
  gtk_tooltip_trigger_tooltip_query(cast[ptr gdk.Display00](display.impl))

proc gtk_tooltip_set_icon(self: ptr Tooltip00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setIcon*(self: Tooltip; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_tooltip_set_icon(cast[ptr Tooltip00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `icon=`*(self: Tooltip; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_tooltip_set_icon(cast[ptr Tooltip00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_tooltip_set_icon_from_gicon(self: ptr Tooltip00; gicon: ptr gio.Icon00;
    size: int32) {.
    importc, libprag.}

proc setIconFromGicon*(self: Tooltip; gicon: gio.Icon = nil;
    size: int) =
  gtk_tooltip_set_icon_from_gicon(cast[ptr Tooltip00](self.impl), if gicon.isNil: nil else: cast[ptr gio.Icon00](gicon.impl), int32(size))

proc gtk_tooltip_set_icon_from_icon_name(self: ptr Tooltip00; iconName: cstring;
    size: int32) {.
    importc, libprag.}

proc setIconFromIconName*(self: Tooltip; iconName: cstring = nil;
    size: int) =
  gtk_tooltip_set_icon_from_icon_name(cast[ptr Tooltip00](self.impl), iconName, int32(size))

proc gtk_tooltip_set_icon_from_stock(self: ptr Tooltip00; stockId: cstring;
    size: int32) {.
    importc, libprag.}

proc setIconFromStock*(self: Tooltip; stockId: cstring = nil;
    size: int) =
  gtk_tooltip_set_icon_from_stock(cast[ptr Tooltip00](self.impl), stockId, int32(size))

proc gtk_tooltip_set_markup(self: ptr Tooltip00; markup: cstring) {.
    importc, libprag.}

proc setMarkup*(self: Tooltip; markup: cstring = nil) =
  gtk_tooltip_set_markup(cast[ptr Tooltip00](self.impl), markup)

proc `markup=`*(self: Tooltip; markup: cstring = nil) =
  gtk_tooltip_set_markup(cast[ptr Tooltip00](self.impl), markup)

proc gtk_tooltip_set_text(self: ptr Tooltip00; text: cstring) {.
    importc, libprag.}

proc setText*(self: Tooltip; text: cstring = nil) =
  gtk_tooltip_set_text(cast[ptr Tooltip00](self.impl), text)

proc `text=`*(self: Tooltip; text: cstring = nil) =
  gtk_tooltip_set_text(cast[ptr Tooltip00](self.impl), text)

proc gtk_tooltip_set_tip_area(self: ptr Tooltip00; rect: gdk.Rectangle) {.
    importc, libprag.}

proc setTipArea*(self: Tooltip; rect: gdk.Rectangle) =
  gtk_tooltip_set_tip_area(cast[ptr Tooltip00](self.impl), rect)

proc `tipArea=`*(self: Tooltip; rect: gdk.Rectangle) =
  gtk_tooltip_set_tip_area(cast[ptr Tooltip00](self.impl), rect)

type
  WidgetHelpType* {.size: sizeof(cint), pure.} = enum
    tooltip = 0
    whatsThis = 1

type
  StateType* {.size: sizeof(cint), pure.} = enum
    normal = 0
    active = 1
    prelight = 2
    selected = 3
    insensitive = 4
    inconsistent = 5
    focused = 6

type
  StateFlag* {.size: sizeof(cint), pure.} = enum
    active = 0
    prelight = 1
    selected = 2
    insensitive = 3
    inconsistent = 4
    focused = 5
    backdrop = 6
    dirLtr = 7
    dirRtl = 8
    link = 9
    visited = 10
    checked = 11
    dropActive = 12

  StateFlags* {.size: sizeof(cint).} = set[StateFlag]

const
  StateFlagsNormal* = StateFlags({})
proc normal*(t: typedesc[StateFlags]): StateFlags = StateFlags({})

type
  Style* = ref object of gobject.Object
  Style00* = object of gobject.Object00

proc gtk_style_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Style()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scRealize*(self: Style;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "realize", cast[GCallback](p), xdata, nil, cf)

proc scUnrealize*(self: Style;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unrealize", cast[GCallback](p), xdata, nil, cf)

proc gtk_style_new(): ptr Style00 {.
    importc, libprag.}

proc newStyle*(): Style {.deprecated.}  =
  let gobj = gtk_style_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStyle*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is Style)
  let gobj = gtk_style_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStyle*[T](result: var T) {.deprecated.} =
  assert(result is Style)
  let gobj = gtk_style_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_apply_default_background(self: ptr Style00; cr: ptr cairo.Context00;
    window: ptr gdk.Window00; stateType: StateType; x: int32; y: int32; width: int32;
    height: int32) {.
    importc, libprag.}

proc applyDefaultBackground*(self: Style; cr: cairo.Context; window: gdk.Window;
    stateType: StateType; x: int; y: int; width: int; height: int) =
  gtk_style_apply_default_background(cast[ptr Style00](self.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr gdk.Window00](window.impl), stateType, int32(x), int32(y), int32(width), int32(height))

proc gtk_style_copy(self: ptr Style00): ptr Style00 {.
    importc, libprag.}

proc copy*(self: Style): Style =
  let gobj = gtk_style_copy(cast[ptr Style00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_detach(self: ptr Style00) {.
    importc, libprag.}

proc detach*(self: Style) =
  gtk_style_detach(cast[ptr Style00](self.impl))

proc gtk_style_get_style_property(self: ptr Style00; widgetType: GType; propertyName: cstring;
    value: var gobject.Value) {.
    importc, libprag.}

proc getStyleProperty*(self: Style; widgetType: GType; propertyName: cstring;
    value: var gobject.Value) =
  gtk_style_get_style_property(cast[ptr Style00](self.impl), widgetType, propertyName, value)

proc gtk_style_has_context(self: ptr Style00): gboolean {.
    importc, libprag.}

proc hasContext*(self: Style): bool =
  toBool(gtk_style_has_context(cast[ptr Style00](self.impl)))

proc gtk_style_lookup_color(self: ptr Style00; colorName: cstring; color: var gdk.Color): gboolean {.
    importc, libprag.}

proc lookupColor*(self: Style; colorName: cstring; color: var gdk.Color): bool =
  toBool(gtk_style_lookup_color(cast[ptr Style00](self.impl), colorName, color))

proc gtk_style_set_background(self: ptr Style00; window: ptr gdk.Window00;
    stateType: StateType) {.
    importc, libprag.}

proc setBackground*(self: Style; window: gdk.Window; stateType: StateType) =
  gtk_style_set_background(cast[ptr Style00](self.impl), cast[ptr gdk.Window00](window.impl), stateType)

type
  Widget* = ref object of gobject.InitiallyUnowned
  Widget00* = object of gobject.InitiallyUnowned00

proc gtk_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Widget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAccelClosuresChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accel-closures-changed", cast[GCallback](p), xdata, nil, cf)

proc scButtonPressEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "button-press-event", cast[GCallback](p), xdata, nil, cf)

proc scButtonReleaseEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "button-release-event", cast[GCallback](p), xdata, nil, cf)

proc scCanActivateAccel*(self: Widget;  p: proc (self: ptr Widget00; signalId: uint32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "can-activate-accel", cast[GCallback](p), xdata, nil, cf)

proc scChildNotify*(self: Widget;  p: proc (self: ptr Widget00; childProperty: ptr gobject.ParamSpec00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "child-notify", cast[GCallback](p), xdata, nil, cf)

proc scCompositedChanged*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "composited-changed", cast[GCallback](p), xdata, nil, cf)

proc scConfigureEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventConfigure00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "configure-event", cast[GCallback](p), xdata, nil, cf)

proc scDamageEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventExpose00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "damage-event", cast[GCallback](p), xdata, nil, cf)

proc scDeleteEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-event", cast[GCallback](p), xdata, nil, cf)

proc scDestroy*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "destroy", cast[GCallback](p), xdata, nil, cf)

proc scDestroyEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "destroy-event", cast[GCallback](p), xdata, nil, cf)

proc scDirectionChanged*(self: Widget;  p: proc (self: ptr Widget00; previousDirection: TextDirection; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "direction-changed", cast[GCallback](p), xdata, nil, cf)

proc scDragBegin*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-begin", cast[GCallback](p), xdata, nil, cf)

proc scDragDataDelete*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-data-delete", cast[GCallback](p), xdata, nil, cf)

proc scDragDataGet*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; data: ptr SelectionData00; info: uint32;
    time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-data-get", cast[GCallback](p), xdata, nil, cf)

proc scDragDataReceived*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; x: int32; y: int32; data: ptr SelectionData00;
    info: uint32; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-data-received", cast[GCallback](p), xdata, nil, cf)

proc scDragDrop*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; x: int32; y: int32; time: uint32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-drop", cast[GCallback](p), xdata, nil, cf)

proc scDragEnd*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-end", cast[GCallback](p), xdata, nil, cf)

proc scDragFailed*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; resu: DragResult; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-failed", cast[GCallback](p), xdata, nil, cf)

proc scDragLeave*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-leave", cast[GCallback](p), xdata, nil, cf)

proc scDragMotion*(self: Widget;  p: proc (self: ptr Widget00; context: ptr gdk.DragContext00; x: int32; y: int32; time: uint32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-motion", cast[GCallback](p), xdata, nil, cf)

proc scDraw*(self: Widget;  p: proc (self: ptr Widget00; cr: ptr cairo.Context00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "draw", cast[GCallback](p), xdata, nil, cf)

proc scEnterNotifyEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventCrossing00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enter-notify-event", cast[GCallback](p), xdata, nil, cf)

proc scEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "event", cast[GCallback](p), xdata, nil, cf)

proc scEventAfter*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.Event00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "event-after", cast[GCallback](p), xdata, nil, cf)

proc scFocus*(self: Widget;  p: proc (self: ptr Widget00; direction: DirectionType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus", cast[GCallback](p), xdata, nil, cf)

proc scFocusInEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventFocus00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-in-event", cast[GCallback](p), xdata, nil, cf)

proc scFocusOutEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventFocus00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-out-event", cast[GCallback](p), xdata, nil, cf)

proc scGrabBrokenEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventGrabBroken00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "grab-broken-event", cast[GCallback](p), xdata, nil, cf)

proc scGrabFocus*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "grab-focus", cast[GCallback](p), xdata, nil, cf)

proc scGrabNotify*(self: Widget;  p: proc (self: ptr Widget00; wasGrabbed: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "grab-notify", cast[GCallback](p), xdata, nil, cf)

proc scHide*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "hide", cast[GCallback](p), xdata, nil, cf)

proc scHierarchyChanged*(self: Widget;  p: proc (self: ptr Widget00; previousToplevel: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "hierarchy-changed", cast[GCallback](p), xdata, nil, cf)

proc scKeyPressEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventKey00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "key-press-event", cast[GCallback](p), xdata, nil, cf)

proc scKeyReleaseEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventKey00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "key-release-event", cast[GCallback](p), xdata, nil, cf)

proc scKeynavFailed*(self: Widget;  p: proc (self: ptr Widget00; direction: DirectionType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "keynav-failed", cast[GCallback](p), xdata, nil, cf)

proc scLeaveNotifyEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventCrossing00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "leave-notify-event", cast[GCallback](p), xdata, nil, cf)

proc scMap*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "map", cast[GCallback](p), xdata, nil, cf)

proc scMapEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventAny00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "map-event", cast[GCallback](p), xdata, nil, cf)

proc scMnemonicActivate*(self: Widget;  p: proc (self: ptr Widget00; groupCycling: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "mnemonic-activate", cast[GCallback](p), xdata, nil, cf)

proc scMotionNotifyEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventMotion00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "motion-notify-event", cast[GCallback](p), xdata, nil, cf)

proc scMoveFocus*(self: Widget;  p: proc (self: ptr Widget00; direction: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-focus", cast[GCallback](p), xdata, nil, cf)

proc scParentSet*(self: Widget;  p: proc (self: ptr Widget00; oldParent: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "parent-set", cast[GCallback](p), xdata, nil, cf)

proc scPopupMenu*(self: Widget;  p: proc (self: ptr Widget00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popup-menu", cast[GCallback](p), xdata, nil, cf)

proc scPropertyNotifyEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventProperty00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "property-notify-event", cast[GCallback](p), xdata, nil, cf)

proc scProximityInEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventProximity00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "proximity-in-event", cast[GCallback](p), xdata, nil, cf)

proc scProximityOutEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventProximity00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "proximity-out-event", cast[GCallback](p), xdata, nil, cf)

proc scQueryTooltip*(self: Widget;  p: proc (self: ptr Widget00; x: int32; y: int32; keyboardMode: gboolean; tooltip: ptr Tooltip00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "query-tooltip", cast[GCallback](p), xdata, nil, cf)

proc scRealize*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "realize", cast[GCallback](p), xdata, nil, cf)

proc scScreenChanged*(self: Widget;  p: proc (self: ptr Widget00; previousScreen: ptr gdk.Screen00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "screen-changed", cast[GCallback](p), xdata, nil, cf)

proc scScrollEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventScroll00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-event", cast[GCallback](p), xdata, nil, cf)

proc scSelectionClearEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventSelection00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-clear-event", cast[GCallback](p), xdata, nil, cf)

proc scSelectionGet*(self: Widget;  p: proc (self: ptr Widget00; data: ptr SelectionData00; info: uint32; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-get", cast[GCallback](p), xdata, nil, cf)

proc scSelectionNotifyEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventSelection00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-notify-event", cast[GCallback](p), xdata, nil, cf)

proc scSelectionReceived*(self: Widget;  p: proc (self: ptr Widget00; data: ptr SelectionData00; time: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-received", cast[GCallback](p), xdata, nil, cf)

proc scSelectionRequestEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventSelection00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-request-event", cast[GCallback](p), xdata, nil, cf)

proc scShow*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show", cast[GCallback](p), xdata, nil, cf)

proc scShowHelp*(self: Widget;  p: proc (self: ptr Widget00; helpType: WidgetHelpType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-help", cast[GCallback](p), xdata, nil, cf)

proc scSizeAllocate*(self: Widget;  p: proc (self: ptr Widget00; allocation: gdk.Rectangle; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "size-allocate", cast[GCallback](p), xdata, nil, cf)

proc scStateChanged*(self: Widget;  p: proc (self: ptr Widget00; state: StateType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "state-changed", cast[GCallback](p), xdata, nil, cf)

proc scStateFlagsChanged*(self: Widget;  p: proc (self: ptr Widget00; flags: StateFlags; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "state-flags-changed", cast[GCallback](p), xdata, nil, cf)

proc scStyleSet*(self: Widget;  p: proc (self: ptr Widget00; previousStyle: ptr Style00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "style-set", cast[GCallback](p), xdata, nil, cf)

proc scStyleUpdated*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "style-updated", cast[GCallback](p), xdata, nil, cf)

proc scTouchEvent*(self: Widget;  p: proc (self: ptr Widget00; `object`: ptr gdk.Event00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "touch-event", cast[GCallback](p), xdata, nil, cf)

proc scUnmap*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unmap", cast[GCallback](p), xdata, nil, cf)

proc scUnmapEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventAny00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unmap-event", cast[GCallback](p), xdata, nil, cf)

proc scUnrealize*(self: Widget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unrealize", cast[GCallback](p), xdata, nil, cf)

proc scVisibilityNotifyEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventVisibility00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "visibility-notify-event", cast[GCallback](p), xdata, nil, cf)

proc scWindowStateEvent*(self: Widget;  p: proc (self: ptr Widget00; event: ptr gdk.EventWindowState00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "window-state-event", cast[GCallback](p), xdata, nil, cf)

proc getDefaultDirection*(): TextDirection {.
    importc: "gtk_widget_get_default_direction", libprag.}

proc gtk_widget_get_default_style(): ptr Style00 {.
    importc, libprag.}

proc getDefaultStyle*(): Style =
  let gobj = gtk_widget_get_default_style()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popCompositeChild*() {.
    importc: "gtk_widget_pop_composite_child", libprag.}

proc pushCompositeChild*() {.
    importc: "gtk_widget_push_composite_child", libprag.}

proc setDefaultDirection*(dir: TextDirection) {.
    importc: "gtk_widget_set_default_direction", libprag.}

proc gtk_widget_activate(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc activate*(self: Widget): bool =
  toBool(gtk_widget_activate(cast[ptr Widget00](self.impl)))

proc gtk_widget_add_device_events(self: ptr Widget00; device: ptr gdk.Device00;
    events: gdk.EventMask) {.
    importc, libprag.}

proc addDeviceEvents*(self: Widget; device: gdk.Device; events: gdk.EventMask) =
  gtk_widget_add_device_events(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl), events)

proc gtk_widget_add_events(self: ptr Widget00; events: gdk.EventMask) {.
    importc, libprag.}

proc addEvents*(self: Widget; events: gdk.EventMask) =
  gtk_widget_add_events(cast[ptr Widget00](self.impl), events)

proc gtk_widget_add_mnemonic_label(self: ptr Widget00; label: ptr Widget00) {.
    importc, libprag.}

proc addMnemonicLabel*(self: Widget; label: Widget) =
  gtk_widget_add_mnemonic_label(cast[ptr Widget00](self.impl), cast[ptr Widget00](label.impl))

proc gtk_widget_can_activate_accel(self: ptr Widget00; signalId: uint32): gboolean {.
    importc, libprag.}

proc canActivateAccel*(self: Widget; signalId: int): bool =
  toBool(gtk_widget_can_activate_accel(cast[ptr Widget00](self.impl), uint32(signalId)))

proc gtk_widget_child_focus(self: ptr Widget00; direction: DirectionType): gboolean {.
    importc, libprag.}

proc childFocus*(self: Widget; direction: DirectionType): bool =
  toBool(gtk_widget_child_focus(cast[ptr Widget00](self.impl), direction))

proc gtk_widget_child_notify(self: ptr Widget00; childProperty: cstring) {.
    importc, libprag.}

proc childNotify*(self: Widget; childProperty: cstring) =
  gtk_widget_child_notify(cast[ptr Widget00](self.impl), childProperty)

proc gtk_widget_class_path(self: ptr Widget00; pathLength: var uint32; path: var cstring;
    pathReversed: var cstring) {.
    importc, libprag.}

proc classPath*(self: Widget; pathLength: var int = cast[var int](nil);
    path: var string = cast[var string](nil); pathReversed: var string = cast[var string](nil)) =
  var path_00: cstring
  var pathReversed_00: cstring
  var pathLength_00: uint32
  gtk_widget_class_path(cast[ptr Widget00](self.impl), pathLength_00, path_00, pathReversed_00)
  if path.addr != nil:
    path = $(path_00)
  if pathReversed.addr != nil:
    pathReversed = $(pathReversed_00)
  if pathLength.addr != nil:
    pathLength = int(pathLength_00)

proc gtk_widget_create_pango_context(self: ptr Widget00): ptr pango.Context00 {.
    importc, libprag.}

proc createPangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_create_pango_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_create_pango_layout(self: ptr Widget00; text: cstring): ptr pango.Layout00 {.
    importc, libprag.}

proc createPangoLayout*(self: Widget; text: cstring = nil): pango.Layout =
  let gobj = gtk_widget_create_pango_layout(cast[ptr Widget00](self.impl), text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_destroy(self: ptr Widget00) {.
    importc, libprag.}

proc destroy*(self: Widget) =
  gtk_widget_destroy(cast[ptr Widget00](self.impl))

proc gtk_widget_device_is_shadowed(self: ptr Widget00; device: ptr gdk.Device00): gboolean {.
    importc, libprag.}

proc deviceIsShadowed*(self: Widget; device: gdk.Device): bool =
  toBool(gtk_widget_device_is_shadowed(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl)))

proc gtk_drag_check_threshold(self: ptr Widget00; startX: int32; startY: int32;
    currentX: int32; currentY: int32): gboolean {.
    importc, libprag.}

proc dragCheckThreshold*(self: Widget; startX: int; startY: int; currentX: int;
    currentY: int): bool =
  toBool(gtk_drag_check_threshold(cast[ptr Widget00](self.impl), int32(startX), int32(startY), int32(currentX), int32(currentY)))

proc gtk_drag_dest_add_image_targets(self: ptr Widget00) {.
    importc, libprag.}

proc dragDestAddImageTargets*(self: Widget) =
  gtk_drag_dest_add_image_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_dest_add_text_targets(self: ptr Widget00) {.
    importc, libprag.}

proc dragDestAddTextTargets*(self: Widget) =
  gtk_drag_dest_add_text_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_dest_add_uri_targets(self: ptr Widget00) {.
    importc, libprag.}

proc dragDestAddUriTargets*(self: Widget) =
  gtk_drag_dest_add_uri_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_dest_get_track_motion(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc dragDestGetTrackMotion*(self: Widget): bool =
  toBool(gtk_drag_dest_get_track_motion(cast[ptr Widget00](self.impl)))

proc gtk_drag_dest_set_proxy(self: ptr Widget00; proxyWindow: ptr gdk.Window00;
    protocol: gdk.DragProtocol; useCoordinates: gboolean) {.
    importc, libprag.}

proc dragDestSetProxy*(self: Widget; proxyWindow: gdk.Window; protocol: gdk.DragProtocol;
    useCoordinates: bool) =
  gtk_drag_dest_set_proxy(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](proxyWindow.impl), protocol, gboolean(useCoordinates))

proc gtk_drag_dest_set_track_motion(self: ptr Widget00; trackMotion: gboolean) {.
    importc, libprag.}

proc dragDestSetTrackMotion*(self: Widget; trackMotion: bool = true) =
  gtk_drag_dest_set_track_motion(cast[ptr Widget00](self.impl), gboolean(trackMotion))

proc gtk_drag_dest_unset(self: ptr Widget00) {.
    importc, libprag.}

proc dragDestUnset*(self: Widget) =
  gtk_drag_dest_unset(cast[ptr Widget00](self.impl))

proc gtk_drag_get_data(self: ptr Widget00; context: ptr gdk.DragContext00;
    target: ptr gdk.Atom00; time: uint32) {.
    importc, libprag.}

proc dragGetData*(self: Widget; context: gdk.DragContext; target: gdk.Atom;
    time: int) =
  gtk_drag_get_data(cast[ptr Widget00](self.impl), cast[ptr gdk.DragContext00](context.impl), cast[ptr gdk.Atom00](target.impl), uint32(time))

proc gtk_drag_highlight(self: ptr Widget00) {.
    importc, libprag.}

proc dragHighlight*(self: Widget) =
  gtk_drag_highlight(cast[ptr Widget00](self.impl))

proc gtk_drag_source_add_image_targets(self: ptr Widget00) {.
    importc, libprag.}

proc dragSourceAddImageTargets*(self: Widget) =
  gtk_drag_source_add_image_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_source_add_text_targets(self: ptr Widget00) {.
    importc, libprag.}

proc dragSourceAddTextTargets*(self: Widget) =
  gtk_drag_source_add_text_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_source_add_uri_targets(self: ptr Widget00) {.
    importc, libprag.}

proc dragSourceAddUriTargets*(self: Widget) =
  gtk_drag_source_add_uri_targets(cast[ptr Widget00](self.impl))

proc gtk_drag_source_set_icon_gicon(self: ptr Widget00; icon: ptr gio.Icon00) {.
    importc, libprag.}

proc dragSourceSetIconGicon*(self: Widget; icon: gio.Icon) =
  gtk_drag_source_set_icon_gicon(cast[ptr Widget00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_drag_source_set_icon_name(self: ptr Widget00; iconName: cstring) {.
    importc, libprag.}

proc dragSourceSetIconName*(self: Widget; iconName: cstring) =
  gtk_drag_source_set_icon_name(cast[ptr Widget00](self.impl), iconName)

proc gtk_drag_source_set_icon_pixbuf(self: ptr Widget00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc dragSourceSetIconPixbuf*(self: Widget; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_drag_source_set_icon_pixbuf(cast[ptr Widget00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_drag_source_set_icon_stock(self: ptr Widget00; stockId: cstring) {.
    importc, libprag.}

proc dragSourceSetIconStock*(self: Widget; stockId: cstring) =
  gtk_drag_source_set_icon_stock(cast[ptr Widget00](self.impl), stockId)

proc gtk_drag_source_unset(self: ptr Widget00) {.
    importc, libprag.}

proc dragSourceUnset*(self: Widget) =
  gtk_drag_source_unset(cast[ptr Widget00](self.impl))

proc gtk_drag_unhighlight(self: ptr Widget00) {.
    importc, libprag.}

proc dragUnhighlight*(self: Widget) =
  gtk_drag_unhighlight(cast[ptr Widget00](self.impl))

proc gtk_widget_draw(self: ptr Widget00; cr: ptr cairo.Context00) {.
    importc, libprag.}

proc draw*(self: Widget; cr: cairo.Context) =
  gtk_widget_draw(cast[ptr Widget00](self.impl), cast[ptr cairo.Context00](cr.impl))

proc gtk_widget_ensure_style(self: ptr Widget00) {.
    importc, libprag.}

proc ensureStyle*(self: Widget) =
  gtk_widget_ensure_style(cast[ptr Widget00](self.impl))

proc gtk_widget_error_bell(self: ptr Widget00) {.
    importc, libprag.}

proc errorBell*(self: Widget) =
  gtk_widget_error_bell(cast[ptr Widget00](self.impl))

proc gtk_widget_event(self: ptr Widget00; event: ptr gdk.Event00): gboolean {.
    importc, libprag.}

proc event*(self: Widget; event: gdk.Event): bool =
  toBool(gtk_widget_event(cast[ptr Widget00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_widget_freeze_child_notify(self: ptr Widget00) {.
    importc, libprag.}

proc freezeChildNotify*(self: Widget) =
  gtk_widget_freeze_child_notify(cast[ptr Widget00](self.impl))

proc gtk_widget_get_accessible(self: ptr Widget00): ptr atk.Object00 {.
    importc, libprag.}

proc getAccessible*(self: Widget): atk.Object =
  let gobj = gtk_widget_get_accessible(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, atk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accessible*(self: Widget): atk.Object =
  let gobj = gtk_widget_get_accessible(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, atk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_action_group(self: ptr Widget00; prefix: cstring): ptr gio.ActionGroup00 {.
    importc, libprag.}

proc getActionGroup*(self: Widget; prefix: cstring): gio.ActionGroup =
  let gobj = gtk_widget_get_action_group(cast[ptr Widget00](self.impl), prefix)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_allocated_baseline(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getAllocatedBaseline*(self: Widget): int =
  int(gtk_widget_get_allocated_baseline(cast[ptr Widget00](self.impl)))

proc allocatedBaseline*(self: Widget): int =
  int(gtk_widget_get_allocated_baseline(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocated_height(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getAllocatedHeight*(self: Widget): int =
  int(gtk_widget_get_allocated_height(cast[ptr Widget00](self.impl)))

proc allocatedHeight*(self: Widget): int =
  int(gtk_widget_get_allocated_height(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocated_size(self: ptr Widget00; allocation: var gdk.Rectangle;
    baseline: var int32) {.
    importc, libprag.}

proc getAllocatedSize*(self: Widget; allocation: var gdk.Rectangle;
    baseline: var int = cast[var int](nil)) =
  var baseline_00: int32
  gtk_widget_get_allocated_size(cast[ptr Widget00](self.impl), allocation, baseline_00)
  if baseline.addr != nil:
    baseline = int(baseline_00)

proc gtk_widget_get_allocated_width(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getAllocatedWidth*(self: Widget): int =
  int(gtk_widget_get_allocated_width(cast[ptr Widget00](self.impl)))

proc allocatedWidth*(self: Widget): int =
  int(gtk_widget_get_allocated_width(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_allocation(self: ptr Widget00; allocation: var gdk.Rectangle) {.
    importc, libprag.}

proc getAllocation*(self: Widget; allocation: var gdk.Rectangle) =
  gtk_widget_get_allocation(cast[ptr Widget00](self.impl), allocation)

proc getAllocation*(self: Widget): gdk.Rectangle =
  gtk_widget_get_allocation(cast[ptr Widget00](self.impl), result)

proc gtk_widget_get_ancestor(self: ptr Widget00; widgetType: GType): ptr Widget00 {.
    importc, libprag.}

proc getAncestor*(self: Widget; widgetType: GType): Widget =
  let gobj = gtk_widget_get_ancestor(cast[ptr Widget00](self.impl), widgetType)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_app_paintable(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getAppPaintable*(self: Widget): bool =
  toBool(gtk_widget_get_app_paintable(cast[ptr Widget00](self.impl)))

proc appPaintable*(self: Widget): bool =
  toBool(gtk_widget_get_app_paintable(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_can_default(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getCanDefault*(self: Widget): bool =
  toBool(gtk_widget_get_can_default(cast[ptr Widget00](self.impl)))

proc canDefault*(self: Widget): bool =
  toBool(gtk_widget_get_can_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_can_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getCanFocus*(self: Widget): bool =
  toBool(gtk_widget_get_can_focus(cast[ptr Widget00](self.impl)))

proc canFocus*(self: Widget): bool =
  toBool(gtk_widget_get_can_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_child_visible(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getChildVisible*(self: Widget): bool =
  toBool(gtk_widget_get_child_visible(cast[ptr Widget00](self.impl)))

proc childVisible*(self: Widget): bool =
  toBool(gtk_widget_get_child_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_clip(self: ptr Widget00; clip: var gdk.Rectangle) {.
    importc, libprag.}

proc getClip*(self: Widget; clip: var gdk.Rectangle) =
  gtk_widget_get_clip(cast[ptr Widget00](self.impl), clip)

proc getClip*(self: Widget): gdk.Rectangle =
  gtk_widget_get_clip(cast[ptr Widget00](self.impl), result)

proc gtk_widget_get_composite_name(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getCompositeName*(self: Widget): string =
  let resul0 = gtk_widget_get_composite_name(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc compositeName*(self: Widget): string =
  let resul0 = gtk_widget_get_composite_name(cast[ptr Widget00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_widget_get_device_enabled(self: ptr Widget00; device: ptr gdk.Device00): gboolean {.
    importc, libprag.}

proc getDeviceEnabled*(self: Widget; device: gdk.Device): bool =
  toBool(gtk_widget_get_device_enabled(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl)))

proc gtk_widget_get_device_events(self: ptr Widget00; device: ptr gdk.Device00): gdk.EventMask {.
    importc, libprag.}

proc getDeviceEvents*(self: Widget; device: gdk.Device): gdk.EventMask =
  gtk_widget_get_device_events(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl))

proc gtk_widget_get_direction(self: ptr Widget00): TextDirection {.
    importc, libprag.}

proc getDirection*(self: Widget): TextDirection =
  gtk_widget_get_direction(cast[ptr Widget00](self.impl))

proc direction*(self: Widget): TextDirection =
  gtk_widget_get_direction(cast[ptr Widget00](self.impl))

proc gtk_widget_get_display(self: ptr Widget00): ptr gdk.Display00 {.
    importc, libprag.}

proc getDisplay*(self: Widget): gdk.Display =
  let gobj = gtk_widget_get_display(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: Widget): gdk.Display =
  let gobj = gtk_widget_get_display(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_double_buffered(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getDoubleBuffered*(self: Widget): bool =
  toBool(gtk_widget_get_double_buffered(cast[ptr Widget00](self.impl)))

proc doubleBuffered*(self: Widget): bool =
  toBool(gtk_widget_get_double_buffered(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_events(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getEvents*(self: Widget): int =
  int(gtk_widget_get_events(cast[ptr Widget00](self.impl)))

proc events*(self: Widget): int =
  int(gtk_widget_get_events(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_focus_on_click(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getFocusOnClick*(self: Widget): bool =
  toBool(gtk_widget_get_focus_on_click(cast[ptr Widget00](self.impl)))

proc focusOnClick*(self: Widget): bool =
  toBool(gtk_widget_get_focus_on_click(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_font_map(self: ptr Widget00): ptr pango.FontMap00 {.
    importc, libprag.}

proc getFontMap*(self: Widget): pango.FontMap =
  let gobj = gtk_widget_get_font_map(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontMap*(self: Widget): pango.FontMap =
  let gobj = gtk_widget_get_font_map(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_font_options(self: ptr Widget00): ptr cairo.FontOptions00 {.
    importc, libprag.}

proc getFontOptions*(self: Widget): cairo.FontOptions =
  let impl0 = gtk_widget_get_font_options(cast[ptr Widget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeCairoFontOptions)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_font_options_get_type(), impl0))

proc fontOptions*(self: Widget): cairo.FontOptions =
  let impl0 = gtk_widget_get_font_options(cast[ptr Widget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeCairoFontOptions)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_font_options_get_type(), impl0))

proc gtk_widget_get_frame_clock(self: ptr Widget00): ptr gdk.FrameClock00 {.
    importc, libprag.}

proc getFrameClock*(self: Widget): gdk.FrameClock =
  let gobj = gtk_widget_get_frame_clock(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc frameClock*(self: Widget): gdk.FrameClock =
  let gobj = gtk_widget_get_frame_clock(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_has_tooltip(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getHasTooltip*(self: Widget): bool =
  toBool(gtk_widget_get_has_tooltip(cast[ptr Widget00](self.impl)))

proc hasTooltip*(self: Widget): bool =
  toBool(gtk_widget_get_has_tooltip(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_has_window(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getHasWindow*(self: Widget): bool =
  toBool(gtk_widget_get_has_window(cast[ptr Widget00](self.impl)))

proc hasWindow*(self: Widget): bool =
  toBool(gtk_widget_get_has_window(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_hexpand(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getHexpand*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand(cast[ptr Widget00](self.impl)))

proc hexpand*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_hexpand_set(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getHexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand_set(cast[ptr Widget00](self.impl)))

proc hexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_hexpand_set(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_mapped(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getMapped*(self: Widget): bool =
  toBool(gtk_widget_get_mapped(cast[ptr Widget00](self.impl)))

proc mapped*(self: Widget): bool =
  toBool(gtk_widget_get_mapped(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_bottom(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginBottom*(self: Widget): int =
  int(gtk_widget_get_margin_bottom(cast[ptr Widget00](self.impl)))

proc marginBottom*(self: Widget): int =
  int(gtk_widget_get_margin_bottom(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_end(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginEnd*(self: Widget): int =
  int(gtk_widget_get_margin_end(cast[ptr Widget00](self.impl)))

proc marginEnd*(self: Widget): int =
  int(gtk_widget_get_margin_end(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_left(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginLeft*(self: Widget): int =
  int(gtk_widget_get_margin_left(cast[ptr Widget00](self.impl)))

proc marginLeft*(self: Widget): int =
  int(gtk_widget_get_margin_left(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_right(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginRight*(self: Widget): int =
  int(gtk_widget_get_margin_right(cast[ptr Widget00](self.impl)))

proc marginRight*(self: Widget): int =
  int(gtk_widget_get_margin_right(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_start(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginStart*(self: Widget): int =
  int(gtk_widget_get_margin_start(cast[ptr Widget00](self.impl)))

proc marginStart*(self: Widget): int =
  int(gtk_widget_get_margin_start(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_margin_top(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getMarginTop*(self: Widget): int =
  int(gtk_widget_get_margin_top(cast[ptr Widget00](self.impl)))

proc marginTop*(self: Widget): int =
  int(gtk_widget_get_margin_top(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_modifier_mask(self: ptr Widget00; intent: gdk.ModifierIntent): gdk.ModifierType {.
    importc, libprag.}

proc getModifierMask*(self: Widget; intent: gdk.ModifierIntent): gdk.ModifierType =
  gtk_widget_get_modifier_mask(cast[ptr Widget00](self.impl), intent)

proc gtk_widget_get_name(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getName*(self: Widget): string =
  result = $gtk_widget_get_name(cast[ptr Widget00](self.impl))

proc name*(self: Widget): string =
  result = $gtk_widget_get_name(cast[ptr Widget00](self.impl))

proc gtk_widget_get_no_show_all(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getNoShowAll*(self: Widget): bool =
  toBool(gtk_widget_get_no_show_all(cast[ptr Widget00](self.impl)))

proc noShowAll*(self: Widget): bool =
  toBool(gtk_widget_get_no_show_all(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_opacity(self: ptr Widget00): cdouble {.
    importc, libprag.}

proc getOpacity*(self: Widget): cdouble =
  gtk_widget_get_opacity(cast[ptr Widget00](self.impl))

proc opacity*(self: Widget): cdouble =
  gtk_widget_get_opacity(cast[ptr Widget00](self.impl))

proc gtk_widget_get_pango_context(self: ptr Widget00): ptr pango.Context00 {.
    importc, libprag.}

proc getPangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_get_pango_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pangoContext*(self: Widget): pango.Context =
  let gobj = gtk_widget_get_pango_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_parent(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getParent*(self: Widget): Widget =
  let gobj = gtk_widget_get_parent(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: Widget): Widget =
  let gobj = gtk_widget_get_parent(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_parent_window(self: ptr Widget00): ptr gdk.Window00 {.
    importc, libprag.}

proc getParentWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_parent_window(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parentWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_parent_window(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_pointer(self: ptr Widget00; x: var int32; y: var int32) {.
    importc, libprag.}

proc getPointer*(self: Widget; x: var int = cast[var int](nil);
    y: var int = cast[var int](nil)) =
  var y_00: int32
  var x_00: int32
  gtk_widget_get_pointer(cast[ptr Widget00](self.impl), x_00, y_00)
  if y.addr != nil:
    y = int(y_00)
  if x.addr != nil:
    x = int(x_00)

proc gtk_widget_get_preferred_height(self: ptr Widget00; minimumHeight: var int32;
    naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeight*(self: Widget; minimumHeight: var int = cast[var int](nil);
    naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_widget_get_preferred_height(cast[ptr Widget00](self.impl), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_widget_get_preferred_height_and_baseline_for_width(self: ptr Widget00;
    width: int32; minimumHeight: var int32; naturalHeight: var int32; minimumBaseline: var int32;
    naturalBaseline: var int32) {.
    importc, libprag.}

proc getPreferredHeightAndBaselineForWidth*(self: Widget;
    width: int; minimumHeight: var int = cast[var int](nil); naturalHeight: var int = cast[var int](nil);
    minimumBaseline: var int = cast[var int](nil); naturalBaseline: var int = cast[var int](nil)) =
  var minimumBaseline_00: int32
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  var naturalBaseline_00: int32
  gtk_widget_get_preferred_height_and_baseline_for_width(cast[ptr Widget00](self.impl), int32(width), minimumHeight_00, naturalHeight_00, minimumBaseline_00, naturalBaseline_00)
  if minimumBaseline.addr != nil:
    minimumBaseline = int(minimumBaseline_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)
  if naturalBaseline.addr != nil:
    naturalBaseline = int(naturalBaseline_00)

proc gtk_widget_get_preferred_height_for_width(self: ptr Widget00; width: int32;
    minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeightForWidth*(self: Widget; width: int;
    minimumHeight: var int = cast[var int](nil); naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_widget_get_preferred_height_for_width(cast[ptr Widget00](self.impl), int32(width), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_widget_get_preferred_width(self: ptr Widget00; minimumWidth: var int32;
    naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidth*(self: Widget; minimumWidth: var int = cast[var int](nil);
    naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_widget_get_preferred_width(cast[ptr Widget00](self.impl), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_widget_get_preferred_width_for_height(self: ptr Widget00; height: int32;
    minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidthForHeight*(self: Widget; height: int;
    minimumWidth: var int = cast[var int](nil); naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_widget_get_preferred_width_for_height(cast[ptr Widget00](self.impl), int32(height), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_widget_get_realized(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getRealized*(self: Widget): bool =
  toBool(gtk_widget_get_realized(cast[ptr Widget00](self.impl)))

proc realized*(self: Widget): bool =
  toBool(gtk_widget_get_realized(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_receives_default(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getReceivesDefault*(self: Widget): bool =
  toBool(gtk_widget_get_receives_default(cast[ptr Widget00](self.impl)))

proc receivesDefault*(self: Widget): bool =
  toBool(gtk_widget_get_receives_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_root_window(self: ptr Widget00): ptr gdk.Window00 {.
    importc, libprag.}

proc getRootWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_root_window(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc rootWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_root_window(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_scale_factor(self: ptr Widget00): int32 {.
    importc, libprag.}

proc getScaleFactor*(self: Widget): int =
  int(gtk_widget_get_scale_factor(cast[ptr Widget00](self.impl)))

proc scaleFactor*(self: Widget): int =
  int(gtk_widget_get_scale_factor(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_screen(self: ptr Widget00): ptr gdk.Screen00 {.
    importc, libprag.}

proc getScreen*(self: Widget): gdk.Screen =
  let gobj = gtk_widget_get_screen(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: Widget): gdk.Screen =
  let gobj = gtk_widget_get_screen(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_sensitive(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getSensitive*(self: Widget): bool =
  toBool(gtk_widget_get_sensitive(cast[ptr Widget00](self.impl)))

proc sensitive*(self: Widget): bool =
  toBool(gtk_widget_get_sensitive(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_size_request(self: ptr Widget00; width: var int32; height: var int32) {.
    importc, libprag.}

proc getSizeRequest*(self: Widget; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var width_00: int32
  var height_00: int32
  gtk_widget_get_size_request(cast[ptr Widget00](self.impl), width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_widget_get_state(self: ptr Widget00): StateType {.
    importc, libprag.}

proc getState*(self: Widget): StateType =
  gtk_widget_get_state(cast[ptr Widget00](self.impl))

proc state*(self: Widget): StateType =
  gtk_widget_get_state(cast[ptr Widget00](self.impl))

proc gtk_widget_get_state_flags(self: ptr Widget00): StateFlags {.
    importc, libprag.}

proc getStateFlags*(self: Widget): StateFlags =
  gtk_widget_get_state_flags(cast[ptr Widget00](self.impl))

proc stateFlags*(self: Widget): StateFlags =
  gtk_widget_get_state_flags(cast[ptr Widget00](self.impl))

proc gtk_widget_get_style(self: ptr Widget00): ptr Style00 {.
    importc, libprag.}

proc getStyle*(self: Widget): Style =
  let gobj = gtk_widget_get_style(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc style*(self: Widget): Style =
  let gobj = gtk_widget_get_style(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_support_multidevice(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getSupportMultidevice*(self: Widget): bool =
  toBool(gtk_widget_get_support_multidevice(cast[ptr Widget00](self.impl)))

proc supportMultidevice*(self: Widget): bool =
  toBool(gtk_widget_get_support_multidevice(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_template_child(self: ptr Widget00; widgetType: GType;
    name: cstring): ptr gobject.Object00 {.
    importc, libprag.}

proc getTemplateChild*(self: Widget; widgetType: GType; name: cstring): gobject.Object =
  let gobj = gtk_widget_get_template_child(cast[ptr Widget00](self.impl), widgetType, name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_tooltip_markup(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getTooltipMarkup*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_markup(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc tooltipMarkup*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_markup(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_widget_get_tooltip_text(self: ptr Widget00): cstring {.
    importc, libprag.}

proc getTooltipText*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_text(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc tooltipText*(self: Widget): string =
  let resul0 = gtk_widget_get_tooltip_text(cast[ptr Widget00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_widget_get_toplevel(self: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getToplevel*(self: Widget): Widget =
  let gobj = gtk_widget_get_toplevel(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc toplevel*(self: Widget): Widget =
  let gobj = gtk_widget_get_toplevel(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_vexpand(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getVexpand*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand(cast[ptr Widget00](self.impl)))

proc vexpand*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_vexpand_set(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getVexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand_set(cast[ptr Widget00](self.impl)))

proc vexpandSet*(self: Widget): bool =
  toBool(gtk_widget_get_vexpand_set(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_visible(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc getVisible*(self: Widget): bool =
  toBool(gtk_widget_get_visible(cast[ptr Widget00](self.impl)))

proc visible*(self: Widget): bool =
  toBool(gtk_widget_get_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_get_visual(self: ptr Widget00): ptr gdk.Visual00 {.
    importc, libprag.}

proc getVisual*(self: Widget): gdk.Visual =
  let gobj = gtk_widget_get_visual(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc visual*(self: Widget): gdk.Visual =
  let gobj = gtk_widget_get_visual(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_window(self: ptr Widget00): ptr gdk.Window00 {.
    importc, libprag.}

proc getWindow*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_window(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc window*(self: Widget): gdk.Window =
  let gobj = gtk_widget_get_window(cast[ptr Widget00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grab_add(self: ptr Widget00) {.
    importc, libprag.}

proc grabAdd*(self: Widget) =
  gtk_grab_add(cast[ptr Widget00](self.impl))

proc gtk_widget_grab_default(self: ptr Widget00) {.
    importc, libprag.}

proc grabDefault*(self: Widget) =
  gtk_widget_grab_default(cast[ptr Widget00](self.impl))

proc gtk_widget_grab_focus(self: ptr Widget00) {.
    importc, libprag.}

proc grabFocus*(self: Widget) =
  gtk_widget_grab_focus(cast[ptr Widget00](self.impl))

proc gtk_grab_remove(self: ptr Widget00) {.
    importc, libprag.}

proc grabRemove*(self: Widget) =
  gtk_grab_remove(cast[ptr Widget00](self.impl))

proc gtk_widget_has_default(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasDefault*(self: Widget): bool =
  toBool(gtk_widget_has_default(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasFocus*(self: Widget): bool =
  toBool(gtk_widget_has_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_grab(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasGrab*(self: Widget): bool =
  toBool(gtk_widget_has_grab(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_rc_style(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasRcStyle*(self: Widget): bool =
  toBool(gtk_widget_has_rc_style(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_screen(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasScreen*(self: Widget): bool =
  toBool(gtk_widget_has_screen(cast[ptr Widget00](self.impl)))

proc gtk_widget_has_visible_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hasVisibleFocus*(self: Widget): bool =
  toBool(gtk_widget_has_visible_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_hide(self: ptr Widget00) {.
    importc, libprag.}

proc hide*(self: Widget) =
  gtk_widget_hide(cast[ptr Widget00](self.impl))

proc gtk_widget_hide_on_delete(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc hideOnDelete*(self: Widget): bool =
  toBool(gtk_widget_hide_on_delete(cast[ptr Widget00](self.impl)))

proc gtk_widget_in_destruction(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc inDestruction*(self: Widget): bool =
  toBool(gtk_widget_in_destruction(cast[ptr Widget00](self.impl)))

proc gtk_widget_init_template(self: ptr Widget00) {.
    importc, libprag.}

proc initTemplate*(self: Widget) =
  gtk_widget_init_template(cast[ptr Widget00](self.impl))

proc gtk_widget_input_shape_combine_region(self: ptr Widget00; region: ptr cairo.Region00) {.
    importc, libprag.}

proc inputShapeCombineRegion*(self: Widget; region: cairo.Region = nil) =
  gtk_widget_input_shape_combine_region(cast[ptr Widget00](self.impl), if region.isNil: nil else: cast[ptr cairo.Region00](region.impl))

proc gtk_widget_insert_action_group(self: ptr Widget00; name: cstring; group: ptr gio.ActionGroup00) {.
    importc, libprag.}

proc insertActionGroup*(self: Widget; name: cstring; group: gio.ActionGroup | gio.SimpleActionGroup = nil) =
  gtk_widget_insert_action_group(cast[ptr Widget00](self.impl), name, if group.isNil: nil else: cast[ptr gio.ActionGroup00](group.impl))

proc gtk_widget_intersect(self: ptr Widget00; area: gdk.Rectangle; intersection: var gdk.Rectangle): gboolean {.
    importc, libprag.}

proc intersect*(self: Widget; area: gdk.Rectangle; intersection: var gdk.Rectangle = cast[var gdk.Rectangle](nil)): bool =
  toBool(gtk_widget_intersect(cast[ptr Widget00](self.impl), area, intersection))

proc gtk_widget_is_ancestor(self: ptr Widget00; ancestor: ptr Widget00): gboolean {.
    importc, libprag.}

proc isAncestor*(self: Widget; ancestor: Widget): bool =
  toBool(gtk_widget_is_ancestor(cast[ptr Widget00](self.impl), cast[ptr Widget00](ancestor.impl)))

proc gtk_widget_is_composited(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isComposited*(self: Widget): bool =
  toBool(gtk_widget_is_composited(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_drawable(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isDrawable*(self: Widget): bool =
  toBool(gtk_widget_is_drawable(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_focus(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isFocus*(self: Widget): bool =
  toBool(gtk_widget_is_focus(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_sensitive(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isSensitive*(self: Widget): bool =
  toBool(gtk_widget_is_sensitive(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_toplevel(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isToplevel*(self: Widget): bool =
  toBool(gtk_widget_is_toplevel(cast[ptr Widget00](self.impl)))

proc gtk_widget_is_visible(self: ptr Widget00): gboolean {.
    importc, libprag.}

proc isVisible*(self: Widget): bool =
  toBool(gtk_widget_is_visible(cast[ptr Widget00](self.impl)))

proc gtk_widget_keynav_failed(self: ptr Widget00; direction: DirectionType): gboolean {.
    importc, libprag.}

proc keynavFailed*(self: Widget; direction: DirectionType): bool =
  toBool(gtk_widget_keynav_failed(cast[ptr Widget00](self.impl), direction))

proc gtk_widget_list_accel_closures(self: ptr Widget00): ptr glib.List {.
    importc, libprag.}

proc listAccelClosures*(self: Widget): seq[gobject.Closure] =
  let resul0 = gtk_widget_list_accel_closures(cast[ptr Widget00](self.impl))
  result = glistStructs2seq[gobject.Closure](resul0, true)
  g_list_free(resul0)

proc gtk_widget_list_action_prefixes(self: ptr Widget00): ptr cstring {.
    importc, libprag.}

proc listActionPrefixes*(self: Widget): seq[string] =
  cstringArrayToSeq(gtk_widget_list_action_prefixes(cast[ptr Widget00](self.impl)))

proc gtk_widget_list_mnemonic_labels(self: ptr Widget00): ptr glib.List {.
    importc, libprag.}

proc listMnemonicLabels*(self: Widget): seq[Widget] =
  let resul0 = gtk_widget_list_mnemonic_labels(cast[ptr Widget00](self.impl))
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc gtk_widget_map(self: ptr Widget00) {.
    importc, libprag.}

proc map*(self: Widget) =
  gtk_widget_map(cast[ptr Widget00](self.impl))

proc gtk_widget_mnemonic_activate(self: ptr Widget00; groupCycling: gboolean): gboolean {.
    importc, libprag.}

proc mnemonicActivate*(self: Widget; groupCycling: bool): bool =
  toBool(gtk_widget_mnemonic_activate(cast[ptr Widget00](self.impl), gboolean(groupCycling)))

proc gtk_widget_modify_base(self: ptr Widget00; state: StateType; color: gdk.Color) {.
    importc, libprag.}

proc modifyBase*(self: Widget; state: StateType; color: gdk.Color = cast[var gdk.Color](nil)) =
  gtk_widget_modify_base(cast[ptr Widget00](self.impl), state, color)

proc gtk_widget_modify_bg(self: ptr Widget00; state: StateType; color: gdk.Color) {.
    importc, libprag.}

proc modifyBg*(self: Widget; state: StateType; color: gdk.Color = cast[var gdk.Color](nil)) =
  gtk_widget_modify_bg(cast[ptr Widget00](self.impl), state, color)

proc gtk_widget_modify_cursor(self: ptr Widget00; primary: gdk.Color; secondary: gdk.Color) {.
    importc, libprag.}

proc modifyCursor*(self: Widget; primary: gdk.Color = cast[var gdk.Color](nil);
    secondary: gdk.Color = cast[var gdk.Color](nil)) =
  gtk_widget_modify_cursor(cast[ptr Widget00](self.impl), primary, secondary)

proc gtk_widget_modify_fg(self: ptr Widget00; state: StateType; color: gdk.Color) {.
    importc, libprag.}

proc modifyFg*(self: Widget; state: StateType; color: gdk.Color = cast[var gdk.Color](nil)) =
  gtk_widget_modify_fg(cast[ptr Widget00](self.impl), state, color)

proc gtk_widget_modify_font(self: ptr Widget00; fontDesc: ptr pango.FontDescription00) {.
    importc, libprag.}

proc modifyFont*(self: Widget; fontDesc: pango.FontDescription = nil) =
  gtk_widget_modify_font(cast[ptr Widget00](self.impl), if fontDesc.isNil: nil else: cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_widget_modify_text(self: ptr Widget00; state: StateType; color: gdk.Color) {.
    importc, libprag.}

proc modifyText*(self: Widget; state: StateType; color: gdk.Color = cast[var gdk.Color](nil)) =
  gtk_widget_modify_text(cast[ptr Widget00](self.impl), state, color)

proc gtk_widget_override_background_color(self: ptr Widget00; state: StateFlags;
    color: gdk.RGBA) {.
    importc, libprag.}

proc overrideBackgroundColor*(self: Widget; state: StateFlags;
    color: gdk.RGBA = cast[var gdk.RGBA](nil)) =
  gtk_widget_override_background_color(cast[ptr Widget00](self.impl), state, color)

proc gtk_widget_override_color(self: ptr Widget00; state: StateFlags; color: gdk.RGBA) {.
    importc, libprag.}

proc overrideColor*(self: Widget; state: StateFlags; color: gdk.RGBA = cast[var gdk.RGBA](nil)) =
  gtk_widget_override_color(cast[ptr Widget00](self.impl), state, color)

proc gtk_widget_override_cursor(self: ptr Widget00; cursor: gdk.RGBA; secondaryCursor: gdk.RGBA) {.
    importc, libprag.}

proc overrideCursor*(self: Widget; cursor: gdk.RGBA = cast[var gdk.RGBA](nil);
    secondaryCursor: gdk.RGBA = cast[var gdk.RGBA](nil)) =
  gtk_widget_override_cursor(cast[ptr Widget00](self.impl), cursor, secondaryCursor)

proc gtk_widget_override_font(self: ptr Widget00; fontDesc: ptr pango.FontDescription00) {.
    importc, libprag.}

proc overrideFont*(self: Widget; fontDesc: pango.FontDescription = nil) =
  gtk_widget_override_font(cast[ptr Widget00](self.impl), if fontDesc.isNil: nil else: cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_widget_override_symbolic_color(self: ptr Widget00; name: cstring;
    color: gdk.RGBA) {.
    importc, libprag.}

proc overrideSymbolicColor*(self: Widget; name: cstring; color: gdk.RGBA = cast[var gdk.RGBA](nil)) =
  gtk_widget_override_symbolic_color(cast[ptr Widget00](self.impl), name, color)

proc gtk_widget_path(self: ptr Widget00; pathLength: var uint32; path: var cstring;
    pathReversed: var cstring) {.
    importc, libprag.}

proc path*(self: Widget; pathLength: var int = cast[var int](nil);
    path: var string = cast[var string](nil); pathReversed: var string = cast[var string](nil)) =
  var path_00: cstring
  var pathReversed_00: cstring
  var pathLength_00: uint32
  gtk_widget_path(cast[ptr Widget00](self.impl), pathLength_00, path_00, pathReversed_00)
  if path.addr != nil:
    path = $(path_00)
  if pathReversed.addr != nil:
    pathReversed = $(pathReversed_00)
  if pathLength.addr != nil:
    pathLength = int(pathLength_00)

proc gtk_widget_queue_allocate(self: ptr Widget00) {.
    importc, libprag.}

proc queueAllocate*(self: Widget) =
  gtk_widget_queue_allocate(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_compute_expand(self: ptr Widget00) {.
    importc, libprag.}

proc queueComputeExpand*(self: Widget) =
  gtk_widget_queue_compute_expand(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_draw(self: ptr Widget00) {.
    importc, libprag.}

proc queueDraw*(self: Widget) =
  gtk_widget_queue_draw(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_draw_area(self: ptr Widget00; x: int32; y: int32; width: int32;
    height: int32) {.
    importc, libprag.}

proc queueDrawArea*(self: Widget; x: int; y: int; width: int;
    height: int) =
  gtk_widget_queue_draw_area(cast[ptr Widget00](self.impl), int32(x), int32(y), int32(width), int32(height))

proc gtk_widget_queue_draw_region(self: ptr Widget00; region: ptr cairo.Region00) {.
    importc, libprag.}

proc queueDrawRegion*(self: Widget; region: cairo.Region) =
  gtk_widget_queue_draw_region(cast[ptr Widget00](self.impl), cast[ptr cairo.Region00](region.impl))

proc gtk_widget_queue_resize(self: ptr Widget00) {.
    importc, libprag.}

proc queueResize*(self: Widget) =
  gtk_widget_queue_resize(cast[ptr Widget00](self.impl))

proc gtk_widget_queue_resize_no_redraw(self: ptr Widget00) {.
    importc, libprag.}

proc queueResizeNoRedraw*(self: Widget) =
  gtk_widget_queue_resize_no_redraw(cast[ptr Widget00](self.impl))

proc gtk_widget_realize(self: ptr Widget00) {.
    importc, libprag.}

proc realize*(self: Widget) =
  gtk_widget_realize(cast[ptr Widget00](self.impl))

proc gtk_widget_region_intersect(self: ptr Widget00; region: ptr cairo.Region00): ptr cairo.Region00 {.
    importc, libprag.}

proc regionIntersect*(self: Widget; region: cairo.Region): cairo.Region =
  fnew(result, gBoxedFreeCairoRegion)
  result.impl = gtk_widget_region_intersect(cast[ptr Widget00](self.impl), cast[ptr cairo.Region00](region.impl))

proc gtk_widget_register_window(self: ptr Widget00; window: ptr gdk.Window00) {.
    importc, libprag.}

proc registerWindow*(self: Widget; window: gdk.Window) =
  gtk_widget_register_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_widget_remove_mnemonic_label(self: ptr Widget00; label: ptr Widget00) {.
    importc, libprag.}

proc removeMnemonicLabel*(self: Widget; label: Widget) =
  gtk_widget_remove_mnemonic_label(cast[ptr Widget00](self.impl), cast[ptr Widget00](label.impl))

proc gtk_widget_remove_tick_callback(self: ptr Widget00; id: uint32) {.
    importc, libprag.}

proc removeTickCallback*(self: Widget; id: int) =
  gtk_widget_remove_tick_callback(cast[ptr Widget00](self.impl), uint32(id))

proc gtk_widget_render_icon(self: ptr Widget00; stockId: cstring; size: int32;
    detail: cstring): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc renderIcon*(self: Widget; stockId: cstring; size: int; detail: cstring = nil): gdkpixbuf.Pixbuf =
  let gobj = gtk_widget_render_icon(cast[ptr Widget00](self.impl), stockId, int32(size), detail)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_render_icon_pixbuf(self: ptr Widget00; stockId: cstring;
    size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc renderIconPixbuf*(self: Widget; stockId: cstring; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_widget_render_icon_pixbuf(cast[ptr Widget00](self.impl), stockId, int32(size))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_reparent(self: ptr Widget00; newParent: ptr Widget00) {.
    importc, libprag.}

proc reparent*(self: Widget; newParent: Widget) =
  gtk_widget_reparent(cast[ptr Widget00](self.impl), cast[ptr Widget00](newParent.impl))

proc gtk_widget_reset_rc_styles(self: ptr Widget00) {.
    importc, libprag.}

proc resetRcStyles*(self: Widget) =
  gtk_widget_reset_rc_styles(cast[ptr Widget00](self.impl))

proc gtk_widget_reset_style(self: ptr Widget00) {.
    importc, libprag.}

proc resetStyle*(self: Widget) =
  gtk_widget_reset_style(cast[ptr Widget00](self.impl))

proc gtk_widget_send_expose(self: ptr Widget00; event: ptr gdk.Event00): int32 {.
    importc, libprag.}

proc sendExpose*(self: Widget; event: gdk.Event): int =
  int(gtk_widget_send_expose(cast[ptr Widget00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_widget_send_focus_change(self: ptr Widget00; event: ptr gdk.Event00): gboolean {.
    importc, libprag.}

proc sendFocusChange*(self: Widget; event: gdk.Event): bool =
  toBool(gtk_widget_send_focus_change(cast[ptr Widget00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_widget_set_allocation(self: ptr Widget00; allocation: gdk.Rectangle) {.
    importc, libprag.}

proc setAllocation*(self: Widget; allocation: gdk.Rectangle) =
  gtk_widget_set_allocation(cast[ptr Widget00](self.impl), allocation)

proc `allocation=`*(self: Widget; allocation: gdk.Rectangle) =
  gtk_widget_set_allocation(cast[ptr Widget00](self.impl), allocation)

proc gtk_widget_set_app_paintable(self: ptr Widget00; appPaintable: gboolean) {.
    importc, libprag.}

proc setAppPaintable*(self: Widget; appPaintable: bool = true) =
  gtk_widget_set_app_paintable(cast[ptr Widget00](self.impl), gboolean(appPaintable))

proc `appPaintable=`*(self: Widget; appPaintable: bool) =
  gtk_widget_set_app_paintable(cast[ptr Widget00](self.impl), gboolean(appPaintable))

proc gtk_widget_set_can_default(self: ptr Widget00; canDefault: gboolean) {.
    importc, libprag.}

proc setCanDefault*(self: Widget; canDefault: bool = true) =
  gtk_widget_set_can_default(cast[ptr Widget00](self.impl), gboolean(canDefault))

proc `canDefault=`*(self: Widget; canDefault: bool) =
  gtk_widget_set_can_default(cast[ptr Widget00](self.impl), gboolean(canDefault))

proc gtk_widget_set_can_focus(self: ptr Widget00; canFocus: gboolean) {.
    importc, libprag.}

proc setCanFocus*(self: Widget; canFocus: bool = true) =
  gtk_widget_set_can_focus(cast[ptr Widget00](self.impl), gboolean(canFocus))

proc `canFocus=`*(self: Widget; canFocus: bool) =
  gtk_widget_set_can_focus(cast[ptr Widget00](self.impl), gboolean(canFocus))

proc gtk_widget_set_child_visible(self: ptr Widget00; isVisible: gboolean) {.
    importc, libprag.}

proc setChildVisible*(self: Widget; isVisible: bool = true) =
  gtk_widget_set_child_visible(cast[ptr Widget00](self.impl), gboolean(isVisible))

proc `childVisible=`*(self: Widget; isVisible: bool) =
  gtk_widget_set_child_visible(cast[ptr Widget00](self.impl), gboolean(isVisible))

proc gtk_widget_set_clip(self: ptr Widget00; clip: gdk.Rectangle) {.
    importc, libprag.}

proc setClip*(self: Widget; clip: gdk.Rectangle) =
  gtk_widget_set_clip(cast[ptr Widget00](self.impl), clip)

proc `clip=`*(self: Widget; clip: gdk.Rectangle) =
  gtk_widget_set_clip(cast[ptr Widget00](self.impl), clip)

proc gtk_widget_set_composite_name(self: ptr Widget00; name: cstring) {.
    importc, libprag.}

proc setCompositeName*(self: Widget; name: cstring) =
  gtk_widget_set_composite_name(cast[ptr Widget00](self.impl), name)

proc `compositeName=`*(self: Widget; name: cstring) =
  gtk_widget_set_composite_name(cast[ptr Widget00](self.impl), name)

proc gtk_widget_set_device_enabled(self: ptr Widget00; device: ptr gdk.Device00;
    enabled: gboolean) {.
    importc, libprag.}

proc setDeviceEnabled*(self: Widget; device: gdk.Device; enabled: bool) =
  gtk_widget_set_device_enabled(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl), gboolean(enabled))

proc gtk_widget_set_device_events(self: ptr Widget00; device: ptr gdk.Device00;
    events: gdk.EventMask) {.
    importc, libprag.}

proc setDeviceEvents*(self: Widget; device: gdk.Device; events: gdk.EventMask) =
  gtk_widget_set_device_events(cast[ptr Widget00](self.impl), cast[ptr gdk.Device00](device.impl), events)

proc gtk_widget_set_direction(self: ptr Widget00; dir: TextDirection) {.
    importc, libprag.}

proc setDirection*(self: Widget; dir: TextDirection) =
  gtk_widget_set_direction(cast[ptr Widget00](self.impl), dir)

proc `direction=`*(self: Widget; dir: TextDirection) =
  gtk_widget_set_direction(cast[ptr Widget00](self.impl), dir)

proc gtk_widget_set_double_buffered(self: ptr Widget00; doubleBuffered: gboolean) {.
    importc, libprag.}

proc setDoubleBuffered*(self: Widget; doubleBuffered: bool = true) =
  gtk_widget_set_double_buffered(cast[ptr Widget00](self.impl), gboolean(doubleBuffered))

proc `doubleBuffered=`*(self: Widget; doubleBuffered: bool) =
  gtk_widget_set_double_buffered(cast[ptr Widget00](self.impl), gboolean(doubleBuffered))

proc gtk_widget_set_events(self: ptr Widget00; events: gdk.EventMask) {.
    importc, libprag.}

proc setEvents*(self: Widget; events: gdk.EventMask) =
  gtk_widget_set_events(cast[ptr Widget00](self.impl), events)

proc `events=`*(self: Widget; events: gdk.EventMask) =
  gtk_widget_set_events(cast[ptr Widget00](self.impl), events)

proc gtk_widget_set_focus_on_click(self: ptr Widget00; focusOnClick: gboolean) {.
    importc, libprag.}

proc setFocusOnClick*(self: Widget; focusOnClick: bool = true) =
  gtk_widget_set_focus_on_click(cast[ptr Widget00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: Widget; focusOnClick: bool) =
  gtk_widget_set_focus_on_click(cast[ptr Widget00](self.impl), gboolean(focusOnClick))

proc gtk_widget_set_font_map(self: ptr Widget00; fontMap: ptr pango.FontMap00) {.
    importc, libprag.}

proc setFontMap*(self: Widget; fontMap: pango.FontMap = nil) =
  gtk_widget_set_font_map(cast[ptr Widget00](self.impl), if fontMap.isNil: nil else: cast[ptr pango.FontMap00](fontMap.impl))

proc `fontMap=`*(self: Widget; fontMap: pango.FontMap = nil) =
  gtk_widget_set_font_map(cast[ptr Widget00](self.impl), if fontMap.isNil: nil else: cast[ptr pango.FontMap00](fontMap.impl))

proc gtk_widget_set_font_options(self: ptr Widget00; options: ptr cairo.FontOptions00) {.
    importc, libprag.}

proc setFontOptions*(self: Widget; options: cairo.FontOptions = nil) =
  gtk_widget_set_font_options(cast[ptr Widget00](self.impl), if options.isNil: nil else: cast[ptr cairo.FontOptions00](options.impl))

proc `fontOptions=`*(self: Widget; options: cairo.FontOptions = nil) =
  gtk_widget_set_font_options(cast[ptr Widget00](self.impl), if options.isNil: nil else: cast[ptr cairo.FontOptions00](options.impl))

proc gtk_widget_set_has_tooltip(self: ptr Widget00; hasTooltip: gboolean) {.
    importc, libprag.}

proc setHasTooltip*(self: Widget; hasTooltip: bool = true) =
  gtk_widget_set_has_tooltip(cast[ptr Widget00](self.impl), gboolean(hasTooltip))

proc `hasTooltip=`*(self: Widget; hasTooltip: bool) =
  gtk_widget_set_has_tooltip(cast[ptr Widget00](self.impl), gboolean(hasTooltip))

proc gtk_widget_set_has_window(self: ptr Widget00; hasWindow: gboolean) {.
    importc, libprag.}

proc setHasWindow*(self: Widget; hasWindow: bool = true) =
  gtk_widget_set_has_window(cast[ptr Widget00](self.impl), gboolean(hasWindow))

proc `hasWindow=`*(self: Widget; hasWindow: bool) =
  gtk_widget_set_has_window(cast[ptr Widget00](self.impl), gboolean(hasWindow))

proc gtk_widget_set_hexpand(self: ptr Widget00; expand: gboolean) {.
    importc, libprag.}

proc setHexpand*(self: Widget; expand: bool = true) =
  gtk_widget_set_hexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc `hexpand=`*(self: Widget; expand: bool) =
  gtk_widget_set_hexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc gtk_widget_set_hexpand_set(self: ptr Widget00; set: gboolean) {.
    importc, libprag.}

proc setHexpandSet*(self: Widget; set: bool = true) =
  gtk_widget_set_hexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc `hexpandSet=`*(self: Widget; set: bool) =
  gtk_widget_set_hexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc gtk_widget_set_mapped(self: ptr Widget00; mapped: gboolean) {.
    importc, libprag.}

proc setMapped*(self: Widget; mapped: bool = true) =
  gtk_widget_set_mapped(cast[ptr Widget00](self.impl), gboolean(mapped))

proc `mapped=`*(self: Widget; mapped: bool) =
  gtk_widget_set_mapped(cast[ptr Widget00](self.impl), gboolean(mapped))

proc gtk_widget_set_margin_bottom(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginBottom*(self: Widget; margin: int) =
  gtk_widget_set_margin_bottom(cast[ptr Widget00](self.impl), int32(margin))

proc `marginBottom=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_bottom(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_end(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginEnd*(self: Widget; margin: int) =
  gtk_widget_set_margin_end(cast[ptr Widget00](self.impl), int32(margin))

proc `marginEnd=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_end(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_left(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginLeft*(self: Widget; margin: int) =
  gtk_widget_set_margin_left(cast[ptr Widget00](self.impl), int32(margin))

proc `marginLeft=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_left(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_right(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginRight*(self: Widget; margin: int) =
  gtk_widget_set_margin_right(cast[ptr Widget00](self.impl), int32(margin))

proc `marginRight=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_right(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_start(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginStart*(self: Widget; margin: int) =
  gtk_widget_set_margin_start(cast[ptr Widget00](self.impl), int32(margin))

proc `marginStart=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_start(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_margin_top(self: ptr Widget00; margin: int32) {.
    importc, libprag.}

proc setMarginTop*(self: Widget; margin: int) =
  gtk_widget_set_margin_top(cast[ptr Widget00](self.impl), int32(margin))

proc `marginTop=`*(self: Widget; margin: int) =
  gtk_widget_set_margin_top(cast[ptr Widget00](self.impl), int32(margin))

proc gtk_widget_set_name(self: ptr Widget00; name: cstring) {.
    importc, libprag.}

proc setName*(self: Widget; name: cstring) =
  gtk_widget_set_name(cast[ptr Widget00](self.impl), name)

proc `name=`*(self: Widget; name: cstring) =
  gtk_widget_set_name(cast[ptr Widget00](self.impl), name)

proc gtk_widget_set_no_show_all(self: ptr Widget00; noShowAll: gboolean) {.
    importc, libprag.}

proc setNoShowAll*(self: Widget; noShowAll: bool = true) =
  gtk_widget_set_no_show_all(cast[ptr Widget00](self.impl), gboolean(noShowAll))

proc `noShowAll=`*(self: Widget; noShowAll: bool) =
  gtk_widget_set_no_show_all(cast[ptr Widget00](self.impl), gboolean(noShowAll))

proc gtk_widget_set_opacity(self: ptr Widget00; opacity: cdouble) {.
    importc, libprag.}

proc setOpacity*(self: Widget; opacity: cdouble) =
  gtk_widget_set_opacity(cast[ptr Widget00](self.impl), opacity)

proc `opacity=`*(self: Widget; opacity: cdouble) =
  gtk_widget_set_opacity(cast[ptr Widget00](self.impl), opacity)

proc gtk_widget_set_parent(self: ptr Widget00; parent: ptr Widget00) {.
    importc, libprag.}

proc setParent*(self: Widget; parent: Widget) =
  gtk_widget_set_parent(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl))

proc `parent=`*(self: Widget; parent: Widget) =
  gtk_widget_set_parent(cast[ptr Widget00](self.impl), cast[ptr Widget00](parent.impl))

proc gtk_widget_set_parent_window(self: ptr Widget00; parentWindow: ptr gdk.Window00) {.
    importc, libprag.}

proc setParentWindow*(self: Widget; parentWindow: gdk.Window) =
  gtk_widget_set_parent_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](parentWindow.impl))

proc `parentWindow=`*(self: Widget; parentWindow: gdk.Window) =
  gtk_widget_set_parent_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](parentWindow.impl))

proc gtk_widget_set_realized(self: ptr Widget00; realized: gboolean) {.
    importc, libprag.}

proc setRealized*(self: Widget; realized: bool = true) =
  gtk_widget_set_realized(cast[ptr Widget00](self.impl), gboolean(realized))

proc `realized=`*(self: Widget; realized: bool) =
  gtk_widget_set_realized(cast[ptr Widget00](self.impl), gboolean(realized))

proc gtk_widget_set_receives_default(self: ptr Widget00; receivesDefault: gboolean) {.
    importc, libprag.}

proc setReceivesDefault*(self: Widget; receivesDefault: bool = true) =
  gtk_widget_set_receives_default(cast[ptr Widget00](self.impl), gboolean(receivesDefault))

proc `receivesDefault=`*(self: Widget; receivesDefault: bool) =
  gtk_widget_set_receives_default(cast[ptr Widget00](self.impl), gboolean(receivesDefault))

proc gtk_widget_set_redraw_on_allocate(self: ptr Widget00; redrawOnAllocate: gboolean) {.
    importc, libprag.}

proc setRedrawOnAllocate*(self: Widget; redrawOnAllocate: bool = true) =
  gtk_widget_set_redraw_on_allocate(cast[ptr Widget00](self.impl), gboolean(redrawOnAllocate))

proc `redrawOnAllocate=`*(self: Widget; redrawOnAllocate: bool) =
  gtk_widget_set_redraw_on_allocate(cast[ptr Widget00](self.impl), gboolean(redrawOnAllocate))

proc gtk_widget_set_sensitive(self: ptr Widget00; sensitive: gboolean) {.
    importc, libprag.}

proc setSensitive*(self: Widget; sensitive: bool = true) =
  gtk_widget_set_sensitive(cast[ptr Widget00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: Widget; sensitive: bool) =
  gtk_widget_set_sensitive(cast[ptr Widget00](self.impl), gboolean(sensitive))

proc gtk_widget_set_size_request(self: ptr Widget00; width: int32; height: int32) {.
    importc, libprag.}

proc setSizeRequest*(self: Widget; width: int; height: int) =
  gtk_widget_set_size_request(cast[ptr Widget00](self.impl), int32(width), int32(height))

proc gtk_widget_set_state(self: ptr Widget00; state: StateType) {.
    importc, libprag.}

proc setState*(self: Widget; state: StateType) =
  gtk_widget_set_state(cast[ptr Widget00](self.impl), state)

proc `state=`*(self: Widget; state: StateType) =
  gtk_widget_set_state(cast[ptr Widget00](self.impl), state)

proc gtk_widget_set_state_flags(self: ptr Widget00; flags: StateFlags; clear: gboolean) {.
    importc, libprag.}

proc setStateFlags*(self: Widget; flags: StateFlags; clear: bool) =
  gtk_widget_set_state_flags(cast[ptr Widget00](self.impl), flags, gboolean(clear))

proc gtk_widget_set_style(self: ptr Widget00; style: ptr Style00) {.
    importc, libprag.}

proc setStyle*(self: Widget; style: Style = nil) =
  gtk_widget_set_style(cast[ptr Widget00](self.impl), if style.isNil: nil else: cast[ptr Style00](style.impl))

proc `style=`*(self: Widget; style: Style = nil) =
  gtk_widget_set_style(cast[ptr Widget00](self.impl), if style.isNil: nil else: cast[ptr Style00](style.impl))

proc gtk_widget_set_support_multidevice(self: ptr Widget00; supportMultidevice: gboolean) {.
    importc, libprag.}

proc setSupportMultidevice*(self: Widget; supportMultidevice: bool = true) =
  gtk_widget_set_support_multidevice(cast[ptr Widget00](self.impl), gboolean(supportMultidevice))

proc `supportMultidevice=`*(self: Widget; supportMultidevice: bool) =
  gtk_widget_set_support_multidevice(cast[ptr Widget00](self.impl), gboolean(supportMultidevice))

proc gtk_widget_set_tooltip_markup(self: ptr Widget00; markup: cstring) {.
    importc, libprag.}

proc setTooltipMarkup*(self: Widget; markup: cstring = nil) =
  gtk_widget_set_tooltip_markup(cast[ptr Widget00](self.impl), markup)

proc `tooltipMarkup=`*(self: Widget; markup: cstring = nil) =
  gtk_widget_set_tooltip_markup(cast[ptr Widget00](self.impl), markup)

proc gtk_widget_set_tooltip_text(self: ptr Widget00; text: cstring) {.
    importc, libprag.}

proc setTooltipText*(self: Widget; text: cstring = nil) =
  gtk_widget_set_tooltip_text(cast[ptr Widget00](self.impl), text)

proc `tooltipText=`*(self: Widget; text: cstring = nil) =
  gtk_widget_set_tooltip_text(cast[ptr Widget00](self.impl), text)

proc gtk_widget_set_vexpand(self: ptr Widget00; expand: gboolean) {.
    importc, libprag.}

proc setVexpand*(self: Widget; expand: bool = true) =
  gtk_widget_set_vexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc `vexpand=`*(self: Widget; expand: bool) =
  gtk_widget_set_vexpand(cast[ptr Widget00](self.impl), gboolean(expand))

proc gtk_widget_set_vexpand_set(self: ptr Widget00; set: gboolean) {.
    importc, libprag.}

proc setVexpandSet*(self: Widget; set: bool = true) =
  gtk_widget_set_vexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc `vexpandSet=`*(self: Widget; set: bool) =
  gtk_widget_set_vexpand_set(cast[ptr Widget00](self.impl), gboolean(set))

proc gtk_widget_set_visible(self: ptr Widget00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: Widget; visible: bool = true) =
  gtk_widget_set_visible(cast[ptr Widget00](self.impl), gboolean(visible))

proc `visible=`*(self: Widget; visible: bool) =
  gtk_widget_set_visible(cast[ptr Widget00](self.impl), gboolean(visible))

proc gtk_widget_set_visual(self: ptr Widget00; visual: ptr gdk.Visual00) {.
    importc, libprag.}

proc setVisual*(self: Widget; visual: gdk.Visual = nil) =
  gtk_widget_set_visual(cast[ptr Widget00](self.impl), if visual.isNil: nil else: cast[ptr gdk.Visual00](visual.impl))

proc `visual=`*(self: Widget; visual: gdk.Visual = nil) =
  gtk_widget_set_visual(cast[ptr Widget00](self.impl), if visual.isNil: nil else: cast[ptr gdk.Visual00](visual.impl))

proc gtk_widget_set_window(self: ptr Widget00; window: ptr gdk.Window00) {.
    importc, libprag.}

proc setWindow*(self: Widget; window: gdk.Window) =
  gtk_widget_set_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](g_object_ref(window.impl)))

proc `window=`*(self: Widget; window: gdk.Window) =
  gtk_widget_set_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](g_object_ref(window.impl)))

proc gtk_widget_shape_combine_region(self: ptr Widget00; region: ptr cairo.Region00) {.
    importc, libprag.}

proc shapeCombineRegion*(self: Widget; region: cairo.Region = nil) =
  gtk_widget_shape_combine_region(cast[ptr Widget00](self.impl), if region.isNil: nil else: cast[ptr cairo.Region00](region.impl))

proc gtk_widget_show(self: ptr Widget00) {.
    importc, libprag.}

proc show*(self: Widget) =
  gtk_widget_show(cast[ptr Widget00](self.impl))

proc gtk_widget_show_all(self: ptr Widget00) {.
    importc, libprag.}

proc showAll*(self: Widget) =
  gtk_widget_show_all(cast[ptr Widget00](self.impl))

proc gtk_widget_show_now(self: ptr Widget00) {.
    importc, libprag.}

proc showNow*(self: Widget) =
  gtk_widget_show_now(cast[ptr Widget00](self.impl))

proc gtk_widget_size_allocate(self: ptr Widget00; allocation: gdk.Rectangle) {.
    importc, libprag.}

proc sizeAllocate*(self: Widget; allocation: gdk.Rectangle) =
  gtk_widget_size_allocate(cast[ptr Widget00](self.impl), allocation)

proc gtk_widget_size_allocate_with_baseline(self: ptr Widget00; allocation: gdk.Rectangle;
    baseline: int32) {.
    importc, libprag.}

proc sizeAllocateWithBaseline*(self: Widget; allocation: gdk.Rectangle;
    baseline: int) =
  gtk_widget_size_allocate_with_baseline(cast[ptr Widget00](self.impl), allocation, int32(baseline))

proc gtk_widget_style_attach(self: ptr Widget00) {.
    importc, libprag.}

proc styleAttach*(self: Widget) =
  gtk_widget_style_attach(cast[ptr Widget00](self.impl))

proc gtk_widget_style_get_property(self: ptr Widget00; propertyName: cstring;
    value: gobject.Value) {.
    importc, libprag.}

proc styleGetProperty*(self: Widget; propertyName: cstring; value: gobject.Value) =
  gtk_widget_style_get_property(cast[ptr Widget00](self.impl), propertyName, value)

proc gtk_widget_thaw_child_notify(self: ptr Widget00) {.
    importc, libprag.}

proc thawChildNotify*(self: Widget) =
  gtk_widget_thaw_child_notify(cast[ptr Widget00](self.impl))

proc gtk_widget_translate_coordinates(self: ptr Widget00; destWidget: ptr Widget00;
    srcX: int32; srcY: int32; destX: var int32; destY: var int32): gboolean {.
    importc, libprag.}

proc translateCoordinates*(self: Widget; destWidget: Widget; srcX: int;
    srcY: int; destX: var int = cast[var int](nil); destY: var int = cast[var int](nil)): bool =
  var destY_00: int32
  var destX_00: int32
  result = toBool(gtk_widget_translate_coordinates(cast[ptr Widget00](self.impl), cast[ptr Widget00](destWidget.impl), int32(srcX), int32(srcY), destX_00, destY_00))
  if destY.addr != nil:
    destY = int(destY_00)
  if destX.addr != nil:
    destX = int(destX_00)

proc gtk_widget_trigger_tooltip_query(self: ptr Widget00) {.
    importc, libprag.}

proc triggerTooltipQuery*(self: Widget) =
  gtk_widget_trigger_tooltip_query(cast[ptr Widget00](self.impl))

proc gtk_widget_unmap(self: ptr Widget00) {.
    importc, libprag.}

proc unmap*(self: Widget) =
  gtk_widget_unmap(cast[ptr Widget00](self.impl))

proc gtk_widget_unparent(self: ptr Widget00) {.
    importc, libprag.}

proc unparent*(self: Widget) =
  gtk_widget_unparent(cast[ptr Widget00](self.impl))

proc gtk_widget_unrealize(self: ptr Widget00) {.
    importc, libprag.}

proc unrealize*(self: Widget) =
  gtk_widget_unrealize(cast[ptr Widget00](self.impl))

proc gtk_widget_unregister_window(self: ptr Widget00; window: ptr gdk.Window00) {.
    importc, libprag.}

proc unregisterWindow*(self: Widget; window: gdk.Window) =
  gtk_widget_unregister_window(cast[ptr Widget00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_widget_unset_state_flags(self: ptr Widget00; flags: StateFlags) {.
    importc, libprag.}

proc unsetStateFlags*(self: Widget; flags: StateFlags) =
  gtk_widget_unset_state_flags(cast[ptr Widget00](self.impl), flags)

type
  Container* = ref object of Widget
  Container00* = object of Widget00

proc gtk_container_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Container()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAdd*(self: Container;  p: proc (self: ptr Container00; `object`: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "add", cast[GCallback](p), xdata, nil, cf)

proc scCheckResize*(self: Container;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "check-resize", cast[GCallback](p), xdata, nil, cf)

proc scRemove*(self: Container;  p: proc (self: ptr Container00; `object`: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "remove", cast[GCallback](p), xdata, nil, cf)

proc scSetFocusChild*(self: Container;  p: proc (self: ptr Container00; `object`: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "set-focus-child", cast[GCallback](p), xdata, nil, cf)

proc gtk_container_add(self: ptr Container00; widget: ptr Widget00) {.
    importc, libprag.}

proc add*(self: Container; widget: Widget) =
  gtk_container_add(cast[ptr Container00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_container_check_resize(self: ptr Container00) {.
    importc, libprag.}

proc checkResize*(self: Container) =
  gtk_container_check_resize(cast[ptr Container00](self.impl))

proc gtk_container_child_get_property(self: ptr Container00; child: ptr Widget00;
    propertyName: cstring; value: gobject.Value) {.
    importc, libprag.}

proc childGetProperty*(self: Container; child: Widget; propertyName: cstring;
    value: gobject.Value) =
  gtk_container_child_get_property(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), propertyName, value)

proc gtk_container_child_notify(self: ptr Container00; child: ptr Widget00;
    childProperty: cstring) {.
    importc, libprag.}

proc childNotify*(self: Container; child: Widget; childProperty: cstring) =
  gtk_container_child_notify(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), childProperty)

proc gtk_container_child_notify_by_pspec(self: ptr Container00; child: ptr Widget00;
    pspec: ptr gobject.ParamSpec00) {.
    importc, libprag.}

proc childNotifyByPspec*(self: Container; child: Widget;
    pspec: gobject.ParamSpec) =
  gtk_container_child_notify_by_pspec(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_container_child_set_property(self: ptr Container00; child: ptr Widget00;
    propertyName: cstring; value: gobject.Value) {.
    importc, libprag.}

proc childSetProperty*(self: Container; child: Widget; propertyName: cstring;
    value: gobject.Value) =
  gtk_container_child_set_property(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), propertyName, value)

proc gtk_container_child_type(self: ptr Container00): GType {.
    importc, libprag.}

proc childType*(self: Container): GType =
  gtk_container_child_type(cast[ptr Container00](self.impl))

proc gtk_container_get_border_width(self: ptr Container00): uint32 {.
    importc, libprag.}

proc getBorderWidth*(self: Container): int =
  int(gtk_container_get_border_width(cast[ptr Container00](self.impl)))

proc borderWidth*(self: Container): int =
  int(gtk_container_get_border_width(cast[ptr Container00](self.impl)))

proc gtk_container_get_children(self: ptr Container00): ptr glib.List {.
    importc, libprag.}

proc getChildren*(self: Container): seq[Widget] =
  let resul0 = gtk_container_get_children(cast[ptr Container00](self.impl))
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc children*(self: Container): seq[Widget] =
  let resul0 = gtk_container_get_children(cast[ptr Container00](self.impl))
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc gtk_container_get_focus_child(self: ptr Container00): ptr Widget00 {.
    importc, libprag.}

proc getFocusChild*(self: Container): Widget =
  let gobj = gtk_container_get_focus_child(cast[ptr Container00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusChild*(self: Container): Widget =
  let gobj = gtk_container_get_focus_child(cast[ptr Container00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_propagate_draw(self: ptr Container00; child: ptr Widget00;
    cr: ptr cairo.Context00) {.
    importc, libprag.}

proc propagateDraw*(self: Container; child: Widget; cr: cairo.Context) =
  gtk_container_propagate_draw(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl), cast[ptr cairo.Context00](cr.impl))

proc gtk_container_remove(self: ptr Container00; widget: ptr Widget00) {.
    importc, libprag.}

proc remove*(self: Container; widget: Widget) =
  gtk_container_remove(cast[ptr Container00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_container_resize_children(self: ptr Container00) {.
    importc, libprag.}

proc resizeChildren*(self: Container) =
  gtk_container_resize_children(cast[ptr Container00](self.impl))

proc gtk_container_set_border_width(self: ptr Container00; borderWidth: uint32) {.
    importc, libprag.}

proc setBorderWidth*(self: Container; borderWidth: int) =
  gtk_container_set_border_width(cast[ptr Container00](self.impl), uint32(borderWidth))

proc `borderWidth=`*(self: Container; borderWidth: int) =
  gtk_container_set_border_width(cast[ptr Container00](self.impl), uint32(borderWidth))

proc gtk_container_set_focus_chain(self: ptr Container00; focusableWidgets: ptr glib.List) {.
    importc, libprag.}

proc setFocusChain*(self: Container; focusableWidgets: seq[Widget]) =
  var tempResGL = seq2GList(focusableWidgets)
  gtk_container_set_focus_chain(cast[ptr Container00](self.impl), tempResGL)
  g_list_free(tempResGL)

proc `focusChain=`*(self: Container; focusableWidgets: seq[Widget]) =
  var tempResGL = seq2GList(focusableWidgets)
  gtk_container_set_focus_chain(cast[ptr Container00](self.impl), tempResGL)
  g_list_free(tempResGL)

proc gtk_container_set_focus_child(self: ptr Container00; child: ptr Widget00) {.
    importc, libprag.}

proc setFocusChild*(self: Container; child: Widget = nil) =
  gtk_container_set_focus_child(cast[ptr Container00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc `focusChild=`*(self: Container; child: Widget = nil) =
  gtk_container_set_focus_child(cast[ptr Container00](self.impl), if child.isNil: nil else: cast[ptr Widget00](child.impl))

proc gtk_container_set_reallocate_redraws(self: ptr Container00; needsRedraws: gboolean) {.
    importc, libprag.}

proc setReallocateRedraws*(self: Container; needsRedraws: bool = true) =
  gtk_container_set_reallocate_redraws(cast[ptr Container00](self.impl), gboolean(needsRedraws))

proc `reallocateRedraws=`*(self: Container; needsRedraws: bool) =
  gtk_container_set_reallocate_redraws(cast[ptr Container00](self.impl), gboolean(needsRedraws))

proc gtk_container_unset_focus_chain(self: ptr Container00) {.
    importc, libprag.}

proc unsetFocusChain*(self: Container) =
  gtk_container_unset_focus_chain(cast[ptr Container00](self.impl))

type
  Bin* = ref object of Container
  Bin00* = object of Container00

proc gtk_bin_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Bin()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_bin_get_child(self: ptr Bin00): ptr Widget00 {.
    importc, libprag.}

proc getChild*(self: Bin): Widget =
  let gobj = gtk_bin_get_child(cast[ptr Bin00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child*(self: Bin): Widget =
  let gobj = gtk_bin_get_child(cast[ptr Bin00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tooltip_set_custom(self: ptr Tooltip00; customWidget: ptr Widget00) {.
    importc, libprag.}

proc setCustom*(self: Tooltip; customWidget: Widget = nil) =
  gtk_tooltip_set_custom(cast[ptr Tooltip00](self.impl), if customWidget.isNil: nil else: cast[ptr Widget00](customWidget.impl))

proc `custom=`*(self: Tooltip; customWidget: Widget = nil) =
  gtk_tooltip_set_custom(cast[ptr Tooltip00](self.impl), if customWidget.isNil: nil else: cast[ptr Widget00](customWidget.impl))

type
  Accessible* = ref object of atk.Object
  Accessible00* = object of atk.Object00

proc gtk_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Accessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_accessible_connect_widget_destroyed(self: ptr Accessible00) {.
    importc, libprag.}

proc connectWidgetDestroyed*(self: Accessible) =
  gtk_accessible_connect_widget_destroyed(cast[ptr Accessible00](self.impl))

proc gtk_accessible_get_widget(self: ptr Accessible00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: Accessible): Widget =
  let gobj = gtk_accessible_get_widget(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: Accessible): Widget =
  let gobj = gtk_accessible_get_widget(cast[ptr Accessible00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accessible_set_widget(self: ptr Accessible00; widget: ptr Widget00) {.
    importc, libprag.}

proc setWidget*(self: Accessible; widget: Widget = nil) =
  gtk_accessible_set_widget(cast[ptr Accessible00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `widget=`*(self: Accessible; widget: Widget = nil) =
  gtk_accessible_set_widget(cast[ptr Accessible00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

type
  WidgetAccessible* = ref object of Accessible
  WidgetAccessible00* = object of Accessible00

proc gtk_widget_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WidgetAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ContainerAccessible* = ref object of WidgetAccessible
  ContainerAccessible00* = object of WidgetAccessible00

proc gtk_container_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ContainerAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  WindowAccessible* = ref object of ContainerAccessible
  WindowAccessible00* = object of ContainerAccessible00

proc gtk_window_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WindowAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  PlugAccessible* = ref object of WindowAccessible
  PlugAccessible00* = object of WindowAccessible00

proc gtk_plug_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PlugAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_plug_accessible_get_id(self: ptr PlugAccessible00): cstring {.
    importc, libprag.}

proc getId*(self: PlugAccessible): string =
  let resul0 = gtk_plug_accessible_get_id(cast[ptr PlugAccessible00](self.impl))
  result = $resul0
  cogfree(resul0)

proc id*(self: PlugAccessible): string =
  let resul0 = gtk_plug_accessible_get_id(cast[ptr PlugAccessible00](self.impl))
  result = $resul0
  cogfree(resul0)

type
  Window* = ref object of Bin
  Window00* = object of Bin00

proc gtk_window_get_type*(): GType {.importc, libprag.}

proc scActivateDefault*(self: Window | PlugAccessible | WindowAccessible;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-default", cast[GCallback](p), xdata, nil, cf)

proc scActivateFocus*(self: Window | PlugAccessible | WindowAccessible;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-focus", cast[GCallback](p), xdata, nil, cf)

proc scEnableDebugging*(self: Window | PlugAccessible | WindowAccessible;  p: proc (self: ptr Window00; toggle: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enable-debugging", cast[GCallback](p), xdata, nil, cf)

proc scKeysChanged*(self: Window | PlugAccessible | WindowAccessible;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "keys-changed", cast[GCallback](p), xdata, nil, cf)

proc scSetFocus*(self: Window | PlugAccessible | WindowAccessible;  p: proc (self: ptr Window00; widget: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "set-focus", cast[GCallback](p), xdata, nil, cf)

proc gtk_window_get_default_icon_list(): ptr glib.List {.
    importc, libprag.}

proc getDefaultIconList*(): seq[gdkpixbuf.Pixbuf] =
  let resul0 = gtk_window_get_default_icon_list()
  result = glistObjects2seq(gdkpixbuf.Pixbuf, resul0, false)
  g_list_free(resul0)

proc gtk_window_get_default_icon_name(): cstring {.
    importc, libprag.}

proc getDefaultIconName*(): string =
  result = $gtk_window_get_default_icon_name()

proc gtk_window_list_toplevels(): ptr glib.List {.
    importc, libprag.}

proc listToplevels*(): seq[Widget] =
  let resul0 = gtk_window_list_toplevels()
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc gtk_window_set_auto_startup_notification(setting: gboolean) {.
    importc, libprag.}

proc setAutoStartupNotification*(setting: bool = true) =
  gtk_window_set_auto_startup_notification(gboolean(setting))

proc gtk_window_set_default_icon(icon: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setDefaultIcon*(icon: gdkpixbuf.Pixbuf) =
  gtk_window_set_default_icon(cast[ptr gdkpixbuf.Pixbuf00](icon.impl))

proc gtk_window_set_default_icon_from_file(filename: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setDefaultIconFromFile*(filename: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_window_set_default_icon_from_file(filename, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc setDefaultIconList*(list: ptr glib.List) {.
    importc: "gtk_window_set_default_icon_list", libprag.}

proc setDefaultIconName*(name: cstring) {.
    importc: "gtk_window_set_default_icon_name", libprag.}

proc gtk_window_set_interactive_debugging(enable: gboolean) {.
    importc, libprag.}

proc setInteractiveDebugging*(enable: bool = true) =
  gtk_window_set_interactive_debugging(gboolean(enable))

proc gtk_window_activate_default(self: ptr Window00): gboolean {.
    importc, libprag.}

proc activateDefault*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_activate_default(cast[ptr Window00](self.impl)))

proc gtk_window_activate_focus(self: ptr Window00): gboolean {.
    importc, libprag.}

proc activateFocus*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_activate_focus(cast[ptr Window00](self.impl)))

proc gtk_window_activate_key(self: ptr Window00; event: ptr gdk.EventKey00): gboolean {.
    importc, libprag.}

proc activateKey*(self: Window | PlugAccessible | WindowAccessible;
    event: gdk.EventKey): bool =
  toBool(gtk_window_activate_key(cast[ptr Window00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_window_add_mnemonic(self: ptr Window00; keyval: uint32; target: ptr Widget00) {.
    importc, libprag.}

proc addMnemonic*(self: Window | PlugAccessible | WindowAccessible;
    keyval: int; target: Widget) =
  gtk_window_add_mnemonic(cast[ptr Window00](self.impl), uint32(keyval), cast[ptr Widget00](target.impl))

proc gtk_window_begin_move_drag(self: ptr Window00; button: int32; rootX: int32;
    rootY: int32; timestamp: uint32) {.
    importc, libprag.}

proc beginMoveDrag*(self: Window | PlugAccessible | WindowAccessible;
    button: int; rootX: int; rootY: int; timestamp: int) =
  gtk_window_begin_move_drag(cast[ptr Window00](self.impl), int32(button), int32(rootX), int32(rootY), uint32(timestamp))

proc gtk_window_begin_resize_drag(self: ptr Window00; edge: gdk.WindowEdge;
    button: int32; rootX: int32; rootY: int32; timestamp: uint32) {.
    importc, libprag.}

proc beginResizeDrag*(self: Window | PlugAccessible | WindowAccessible;
    edge: gdk.WindowEdge; button: int; rootX: int; rootY: int; timestamp: int) =
  gtk_window_begin_resize_drag(cast[ptr Window00](self.impl), edge, int32(button), int32(rootX), int32(rootY), uint32(timestamp))

proc gtk_window_close(self: ptr Window00) {.
    importc, libprag.}

proc close*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_close(cast[ptr Window00](self.impl))

proc gtk_window_deiconify(self: ptr Window00) {.
    importc, libprag.}

proc deiconify*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_deiconify(cast[ptr Window00](self.impl))

proc gtk_window_fullscreen(self: ptr Window00) {.
    importc, libprag.}

proc fullscreen*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_fullscreen(cast[ptr Window00](self.impl))

proc gtk_window_fullscreen_on_monitor(self: ptr Window00; screen: ptr gdk.Screen00;
    monitor: int32) {.
    importc, libprag.}

proc fullscreenOnMonitor*(self: Window | PlugAccessible | WindowAccessible;
    screen: gdk.Screen; monitor: int) =
  gtk_window_fullscreen_on_monitor(cast[ptr Window00](self.impl), cast[ptr gdk.Screen00](screen.impl), int32(monitor))

proc gtk_window_get_accept_focus(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getAcceptFocus*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_accept_focus(cast[ptr Window00](self.impl)))

proc acceptFocus*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_accept_focus(cast[ptr Window00](self.impl)))

proc gtk_window_get_attached_to(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getAttachedTo*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_attached_to(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc attachedTo*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_attached_to(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_decorated(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getDecorated*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_decorated(cast[ptr Window00](self.impl)))

proc decorated*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_decorated(cast[ptr Window00](self.impl)))

proc gtk_window_get_default_size(self: ptr Window00; width: var int32; height: var int32) {.
    importc, libprag.}

proc getDefaultSize*(self: Window | PlugAccessible | WindowAccessible;
    width: var int = cast[var int](nil); height: var int = cast[var int](nil)) =
  var width_00: int32
  var height_00: int32
  gtk_window_get_default_size(cast[ptr Window00](self.impl), width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_window_get_default_widget(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getDefaultWidget*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_default_widget(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultWidget*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_default_widget(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_deletable(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getDeletable*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_deletable(cast[ptr Window00](self.impl)))

proc deletable*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_deletable(cast[ptr Window00](self.impl)))

proc gtk_window_get_destroy_with_parent(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getDestroyWithParent*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_destroy_with_parent(cast[ptr Window00](self.impl)))

proc destroyWithParent*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_destroy_with_parent(cast[ptr Window00](self.impl)))

proc gtk_window_get_focus(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getFocus*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_focus(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focus*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_focus(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_focus_on_map(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getFocusOnMap*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_focus_on_map(cast[ptr Window00](self.impl)))

proc focusOnMap*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_focus_on_map(cast[ptr Window00](self.impl)))

proc gtk_window_get_focus_visible(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getFocusVisible*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_focus_visible(cast[ptr Window00](self.impl)))

proc focusVisible*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_focus_visible(cast[ptr Window00](self.impl)))

proc gtk_window_get_gravity(self: ptr Window00): gdk.Gravity {.
    importc, libprag.}

proc getGravity*(self: Window | PlugAccessible | WindowAccessible): gdk.Gravity =
  gtk_window_get_gravity(cast[ptr Window00](self.impl))

proc gravity*(self: Window | PlugAccessible | WindowAccessible): gdk.Gravity =
  gtk_window_get_gravity(cast[ptr Window00](self.impl))

proc gtk_window_get_has_resize_grip(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getHasResizeGrip*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_has_resize_grip(cast[ptr Window00](self.impl)))

proc hasResizeGrip*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_has_resize_grip(cast[ptr Window00](self.impl)))

proc gtk_window_get_hide_titlebar_when_maximized(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getHideTitlebarWhenMaximized*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_hide_titlebar_when_maximized(cast[ptr Window00](self.impl)))

proc hideTitlebarWhenMaximized*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_hide_titlebar_when_maximized(cast[ptr Window00](self.impl)))

proc gtk_window_get_icon(self: ptr Window00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getIcon*(self: Window | PlugAccessible | WindowAccessible): gdkpixbuf.Pixbuf =
  let gobj = gtk_window_get_icon(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc icon*(self: Window | PlugAccessible | WindowAccessible): gdkpixbuf.Pixbuf =
  let gobj = gtk_window_get_icon(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_icon_list(self: ptr Window00): ptr glib.List {.
    importc, libprag.}

proc getIconList*(self: Window | PlugAccessible | WindowAccessible): seq[gdkpixbuf.Pixbuf] =
  let resul0 = gtk_window_get_icon_list(cast[ptr Window00](self.impl))
  result = glistObjects2seq(gdkpixbuf.Pixbuf, resul0, false)
  g_list_free(resul0)

proc iconList*(self: Window | PlugAccessible | WindowAccessible): seq[gdkpixbuf.Pixbuf] =
  let resul0 = gtk_window_get_icon_list(cast[ptr Window00](self.impl))
  result = glistObjects2seq(gdkpixbuf.Pixbuf, resul0, false)
  g_list_free(resul0)

proc gtk_window_get_icon_name(self: ptr Window00): cstring {.
    importc, libprag.}

proc getIconName*(self: Window | PlugAccessible | WindowAccessible): string =
  let resul0 = gtk_window_get_icon_name(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: Window | PlugAccessible | WindowAccessible): string =
  let resul0 = gtk_window_get_icon_name(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_window_get_mnemonic_modifier(self: ptr Window00): gdk.ModifierType {.
    importc, libprag.}

proc getMnemonicModifier*(self: Window | PlugAccessible | WindowAccessible): gdk.ModifierType =
  gtk_window_get_mnemonic_modifier(cast[ptr Window00](self.impl))

proc mnemonicModifier*(self: Window | PlugAccessible | WindowAccessible): gdk.ModifierType =
  gtk_window_get_mnemonic_modifier(cast[ptr Window00](self.impl))

proc gtk_window_get_mnemonics_visible(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getMnemonicsVisible*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_mnemonics_visible(cast[ptr Window00](self.impl)))

proc mnemonicsVisible*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_mnemonics_visible(cast[ptr Window00](self.impl)))

proc gtk_window_get_modal(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getModal*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_modal(cast[ptr Window00](self.impl)))

proc modal*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_modal(cast[ptr Window00](self.impl)))

proc gtk_window_get_opacity(self: ptr Window00): cdouble {.
    importc, libprag.}

proc getOpacity*(self: Window | PlugAccessible | WindowAccessible): cdouble =
  gtk_window_get_opacity(cast[ptr Window00](self.impl))

proc opacity*(self: Window | PlugAccessible | WindowAccessible): cdouble =
  gtk_window_get_opacity(cast[ptr Window00](self.impl))

proc gtk_window_get_position(self: ptr Window00; rootX: var int32; rootY: var int32) {.
    importc, libprag.}

proc getPosition*(self: Window | PlugAccessible | WindowAccessible;
    rootX: var int = cast[var int](nil); rootY: var int = cast[var int](nil)) =
  var rootY_00: int32
  var rootX_00: int32
  gtk_window_get_position(cast[ptr Window00](self.impl), rootX_00, rootY_00)
  if rootY.addr != nil:
    rootY = int(rootY_00)
  if rootX.addr != nil:
    rootX = int(rootX_00)

proc gtk_window_get_resizable(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getResizable*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_resizable(cast[ptr Window00](self.impl)))

proc resizable*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_resizable(cast[ptr Window00](self.impl)))

proc gtk_window_get_resize_grip_area(self: ptr Window00; rect: var gdk.Rectangle): gboolean {.
    importc, libprag.}

proc getResizeGripArea*(self: Window | PlugAccessible | WindowAccessible;
    rect: var gdk.Rectangle): bool =
  toBool(gtk_window_get_resize_grip_area(cast[ptr Window00](self.impl), rect))

proc gtk_window_get_role(self: ptr Window00): cstring {.
    importc, libprag.}

proc getRole*(self: Window | PlugAccessible | WindowAccessible): string =
  let resul0 = gtk_window_get_role(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc role*(self: Window | PlugAccessible | WindowAccessible): string =
  let resul0 = gtk_window_get_role(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_window_get_screen(self: ptr Window00): ptr gdk.Screen00 {.
    importc, libprag.}

proc getScreen*(self: Window | PlugAccessible | WindowAccessible): gdk.Screen =
  let gobj = gtk_window_get_screen(cast[ptr Window00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: Window | PlugAccessible | WindowAccessible): gdk.Screen =
  let gobj = gtk_window_get_screen(cast[ptr Window00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_size(self: ptr Window00; width: var int32; height: var int32) {.
    importc, libprag.}

proc getSize*(self: Window | PlugAccessible | WindowAccessible;
    width: var int; height: var int) =
  var width_00: int32
  var height_00: int32
  gtk_window_get_size(cast[ptr Window00](self.impl), width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_window_get_skip_pager_hint(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getSkipPagerHint*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_skip_pager_hint(cast[ptr Window00](self.impl)))

proc skipPagerHint*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_skip_pager_hint(cast[ptr Window00](self.impl)))

proc gtk_window_get_skip_taskbar_hint(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getSkipTaskbarHint*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_skip_taskbar_hint(cast[ptr Window00](self.impl)))

proc skipTaskbarHint*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_skip_taskbar_hint(cast[ptr Window00](self.impl)))

proc gtk_window_get_title(self: ptr Window00): cstring {.
    importc, libprag.}

proc getTitle*(self: Window | PlugAccessible | WindowAccessible): string =
  let resul0 = gtk_window_get_title(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc title*(self: Window | PlugAccessible | WindowAccessible): string =
  let resul0 = gtk_window_get_title(cast[ptr Window00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_window_get_titlebar(self: ptr Window00): ptr Widget00 {.
    importc, libprag.}

proc getTitlebar*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_titlebar(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc titlebar*(self: Window | PlugAccessible | WindowAccessible): Widget =
  let gobj = gtk_window_get_titlebar(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_transient_for(self: ptr Window00): ptr Window00 {.
    importc, libprag.}

proc getTransientFor*(self: Window | PlugAccessible | WindowAccessible): Window =
  let gobj = gtk_window_get_transient_for(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc transientFor*(self: Window | PlugAccessible | WindowAccessible): Window =
  let gobj = gtk_window_get_transient_for(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_type_hint(self: ptr Window00): gdk.WindowTypeHint {.
    importc, libprag.}

proc getTypeHint*(self: Window | PlugAccessible | WindowAccessible): gdk.WindowTypeHint =
  gtk_window_get_type_hint(cast[ptr Window00](self.impl))

proc typeHint*(self: Window | PlugAccessible | WindowAccessible): gdk.WindowTypeHint =
  gtk_window_get_type_hint(cast[ptr Window00](self.impl))

proc gtk_window_get_urgency_hint(self: ptr Window00): gboolean {.
    importc, libprag.}

proc getUrgencyHint*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_urgency_hint(cast[ptr Window00](self.impl)))

proc urgencyHint*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_get_urgency_hint(cast[ptr Window00](self.impl)))

proc gtk_window_has_group(self: ptr Window00): gboolean {.
    importc, libprag.}

proc hasGroup*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_has_group(cast[ptr Window00](self.impl)))

proc gtk_window_has_toplevel_focus(self: ptr Window00): gboolean {.
    importc, libprag.}

proc hasToplevelFocus*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_has_toplevel_focus(cast[ptr Window00](self.impl)))

proc gtk_window_iconify(self: ptr Window00) {.
    importc, libprag.}

proc iconify*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_iconify(cast[ptr Window00](self.impl))

proc gtk_window_is_active(self: ptr Window00): gboolean {.
    importc, libprag.}

proc isActive*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_is_active(cast[ptr Window00](self.impl)))

proc gtk_window_is_maximized(self: ptr Window00): gboolean {.
    importc, libprag.}

proc isMaximized*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_is_maximized(cast[ptr Window00](self.impl)))

proc gtk_window_maximize(self: ptr Window00) {.
    importc, libprag.}

proc maximize*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_maximize(cast[ptr Window00](self.impl))

proc gtk_window_mnemonic_activate(self: ptr Window00; keyval: uint32; modifier: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc mnemonicActivate*(self: Window | PlugAccessible | WindowAccessible;
    keyval: int; modifier: gdk.ModifierType): bool =
  toBool(gtk_window_mnemonic_activate(cast[ptr Window00](self.impl), uint32(keyval), modifier))

proc gtk_window_move(self: ptr Window00; x: int32; y: int32) {.
    importc, libprag.}

proc move*(self: Window | PlugAccessible | WindowAccessible; x: int;
    y: int) =
  gtk_window_move(cast[ptr Window00](self.impl), int32(x), int32(y))

proc gtk_window_parse_geometry(self: ptr Window00; geometry: cstring): gboolean {.
    importc, libprag.}

proc parseGeometry*(self: Window | PlugAccessible | WindowAccessible;
    geometry: cstring): bool =
  toBool(gtk_window_parse_geometry(cast[ptr Window00](self.impl), geometry))

proc gtk_window_present(self: ptr Window00) {.
    importc, libprag.}

proc present*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_present(cast[ptr Window00](self.impl))

proc gtk_window_present_with_time(self: ptr Window00; timestamp: uint32) {.
    importc, libprag.}

proc presentWithTime*(self: Window | PlugAccessible | WindowAccessible;
    timestamp: int) =
  gtk_window_present_with_time(cast[ptr Window00](self.impl), uint32(timestamp))

proc gtk_window_propagate_key_event(self: ptr Window00; event: ptr gdk.EventKey00): gboolean {.
    importc, libprag.}

proc propagateKeyEvent*(self: Window | PlugAccessible | WindowAccessible;
    event: gdk.EventKey): bool =
  toBool(gtk_window_propagate_key_event(cast[ptr Window00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_window_remove_mnemonic(self: ptr Window00; keyval: uint32; target: ptr Widget00) {.
    importc, libprag.}

proc removeMnemonic*(self: Window | PlugAccessible | WindowAccessible;
    keyval: int; target: Widget) =
  gtk_window_remove_mnemonic(cast[ptr Window00](self.impl), uint32(keyval), cast[ptr Widget00](target.impl))

proc gtk_window_reshow_with_initial_size(self: ptr Window00) {.
    importc, libprag.}

proc reshowWithInitialSize*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_reshow_with_initial_size(cast[ptr Window00](self.impl))

proc gtk_window_resize(self: ptr Window00; width: int32; height: int32) {.
    importc, libprag.}

proc resize*(self: Window | PlugAccessible | WindowAccessible;
    width: int; height: int) =
  gtk_window_resize(cast[ptr Window00](self.impl), int32(width), int32(height))

proc gtk_window_resize_grip_is_visible(self: ptr Window00): gboolean {.
    importc, libprag.}

proc resizeGripIsVisible*(self: Window | PlugAccessible | WindowAccessible): bool =
  toBool(gtk_window_resize_grip_is_visible(cast[ptr Window00](self.impl)))

proc gtk_window_resize_to_geometry(self: ptr Window00; width: int32; height: int32) {.
    importc, libprag.}

proc resizeToGeometry*(self: Window | PlugAccessible | WindowAccessible;
    width: int; height: int) =
  gtk_window_resize_to_geometry(cast[ptr Window00](self.impl), int32(width), int32(height))

proc gtk_window_set_accept_focus(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setAcceptFocus*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_accept_focus(cast[ptr Window00](self.impl), gboolean(setting))

proc `acceptFocus=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_accept_focus(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_attached_to(self: ptr Window00; attachWidget: ptr Widget00) {.
    importc, libprag.}

proc setAttachedTo*(self: Window | PlugAccessible | WindowAccessible;
    attachWidget: Widget = nil) =
  gtk_window_set_attached_to(cast[ptr Window00](self.impl), if attachWidget.isNil: nil else: cast[ptr Widget00](attachWidget.impl))

proc `attachedTo=`*(self: Window | PlugAccessible | WindowAccessible;
    attachWidget: Widget = nil) =
  gtk_window_set_attached_to(cast[ptr Window00](self.impl), if attachWidget.isNil: nil else: cast[ptr Widget00](attachWidget.impl))

proc gtk_window_set_decorated(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setDecorated*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_decorated(cast[ptr Window00](self.impl), gboolean(setting))

proc `decorated=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_decorated(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_default(self: ptr Window00; defaultWidget: ptr Widget00) {.
    importc, libprag.}

proc setDefault*(self: Window | PlugAccessible | WindowAccessible;
    defaultWidget: Widget = nil) =
  gtk_window_set_default(cast[ptr Window00](self.impl), if defaultWidget.isNil: nil else: cast[ptr Widget00](defaultWidget.impl))

proc `default=`*(self: Window | PlugAccessible | WindowAccessible;
    defaultWidget: Widget = nil) =
  gtk_window_set_default(cast[ptr Window00](self.impl), if defaultWidget.isNil: nil else: cast[ptr Widget00](defaultWidget.impl))

proc gtk_window_set_default_geometry(self: ptr Window00; width: int32; height: int32) {.
    importc, libprag.}

proc setDefaultGeometry*(self: Window | PlugAccessible | WindowAccessible;
    width: int; height: int) =
  gtk_window_set_default_geometry(cast[ptr Window00](self.impl), int32(width), int32(height))

proc gtk_window_set_default_size(self: ptr Window00; width: int32; height: int32) {.
    importc, libprag.}

proc setDefaultSize*(self: Window | PlugAccessible | WindowAccessible;
    width: int; height: int) =
  gtk_window_set_default_size(cast[ptr Window00](self.impl), int32(width), int32(height))

proc `defaultSize=`*(self: Window; dim: tuple[width: int; height: int]) =
  gtk_window_set_default_size(cast[ptr Window00](self.impl), int32(dim[0]), int32(dim[1]))

proc gtk_window_set_deletable(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setDeletable*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_deletable(cast[ptr Window00](self.impl), gboolean(setting))

proc `deletable=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_deletable(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_destroy_with_parent(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setDestroyWithParent*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_destroy_with_parent(cast[ptr Window00](self.impl), gboolean(setting))

proc `destroyWithParent=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_destroy_with_parent(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_focus(self: ptr Window00; focus: ptr Widget00) {.
    importc, libprag.}

proc setFocus*(self: Window | PlugAccessible | WindowAccessible;
    focus: Widget = nil) =
  gtk_window_set_focus(cast[ptr Window00](self.impl), if focus.isNil: nil else: cast[ptr Widget00](focus.impl))

proc `focus=`*(self: Window | PlugAccessible | WindowAccessible;
    focus: Widget = nil) =
  gtk_window_set_focus(cast[ptr Window00](self.impl), if focus.isNil: nil else: cast[ptr Widget00](focus.impl))

proc gtk_window_set_focus_on_map(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setFocusOnMap*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_focus_on_map(cast[ptr Window00](self.impl), gboolean(setting))

proc `focusOnMap=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_focus_on_map(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_focus_visible(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setFocusVisible*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_focus_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc `focusVisible=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_focus_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_geometry_hints(self: ptr Window00; geometryWidget: ptr Widget00;
    geometry: gdk.Geometry; geomMask: gdk.WindowHints) {.
    importc, libprag.}

proc setGeometryHints*(self: Window | PlugAccessible | WindowAccessible;
    geometryWidget: Widget = nil; geometry: gdk.Geometry = cast[var gdk.Geometry](nil);
    geomMask: gdk.WindowHints) =
  gtk_window_set_geometry_hints(cast[ptr Window00](self.impl), if geometryWidget.isNil: nil else: cast[ptr Widget00](geometryWidget.impl), geometry, geomMask)

proc gtk_window_set_gravity(self: ptr Window00; gravity: gdk.Gravity) {.
    importc, libprag.}

proc setGravity*(self: Window | PlugAccessible | WindowAccessible;
    gravity: gdk.Gravity) =
  gtk_window_set_gravity(cast[ptr Window00](self.impl), gravity)

proc `gravity=`*(self: Window | PlugAccessible | WindowAccessible;
    gravity: gdk.Gravity) =
  gtk_window_set_gravity(cast[ptr Window00](self.impl), gravity)

proc gtk_window_set_has_resize_grip(self: ptr Window00; value: gboolean) {.
    importc, libprag.}

proc setHasResizeGrip*(self: Window | PlugAccessible | WindowAccessible;
    value: bool = true) =
  gtk_window_set_has_resize_grip(cast[ptr Window00](self.impl), gboolean(value))

proc `hasResizeGrip=`*(self: Window | PlugAccessible | WindowAccessible;
    value: bool) =
  gtk_window_set_has_resize_grip(cast[ptr Window00](self.impl), gboolean(value))

proc gtk_window_set_has_user_ref_count(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setHasUserRefCount*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_has_user_ref_count(cast[ptr Window00](self.impl), gboolean(setting))

proc `hasUserRefCount=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_has_user_ref_count(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_hide_titlebar_when_maximized(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setHideTitlebarWhenMaximized*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_hide_titlebar_when_maximized(cast[ptr Window00](self.impl), gboolean(setting))

proc `hideTitlebarWhenMaximized=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_hide_titlebar_when_maximized(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_icon(self: ptr Window00; icon: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setIcon*(self: Window | PlugAccessible | WindowAccessible;
    icon: gdkpixbuf.Pixbuf = nil) =
  gtk_window_set_icon(cast[ptr Window00](self.impl), if icon.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](icon.impl))

proc `icon=`*(self: Window | PlugAccessible | WindowAccessible;
    icon: gdkpixbuf.Pixbuf = nil) =
  gtk_window_set_icon(cast[ptr Window00](self.impl), if icon.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](icon.impl))

proc gtk_window_set_icon_from_file(self: ptr Window00; filename: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setIconFromFile*(self: Window | PlugAccessible | WindowAccessible;
    filename: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_window_set_icon_from_file(cast[ptr Window00](self.impl), filename, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_window_set_icon_list(self: ptr Window00; list: ptr glib.List) {.
    importc, libprag.}

proc setIconList*(self: Window | PlugAccessible | WindowAccessible;
    list: seq[gdkpixbuf.Pixbuf]) =
  var tempResGL = seq2GList(list)
  gtk_window_set_icon_list(cast[ptr Window00](self.impl), tempResGL)
  g_list_free(tempResGL)

proc `iconList=`*(self: Window | PlugAccessible | WindowAccessible;
    list: seq[gdkpixbuf.Pixbuf]) =
  var tempResGL = seq2GList(list)
  gtk_window_set_icon_list(cast[ptr Window00](self.impl), tempResGL)
  g_list_free(tempResGL)

proc gtk_window_set_icon_name(self: ptr Window00; name: cstring) {.
    importc, libprag.}

proc setIconName*(self: Window | PlugAccessible | WindowAccessible;
    name: cstring = nil) =
  gtk_window_set_icon_name(cast[ptr Window00](self.impl), name)

proc `iconName=`*(self: Window | PlugAccessible | WindowAccessible;
    name: cstring = nil) =
  gtk_window_set_icon_name(cast[ptr Window00](self.impl), name)

proc gtk_window_set_keep_above(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setKeepAbove*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_keep_above(cast[ptr Window00](self.impl), gboolean(setting))

proc `keepAbove=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_keep_above(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_keep_below(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setKeepBelow*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_keep_below(cast[ptr Window00](self.impl), gboolean(setting))

proc `keepBelow=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_keep_below(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_mnemonic_modifier(self: ptr Window00; modifier: gdk.ModifierType) {.
    importc, libprag.}

proc setMnemonicModifier*(self: Window | PlugAccessible | WindowAccessible;
    modifier: gdk.ModifierType) =
  gtk_window_set_mnemonic_modifier(cast[ptr Window00](self.impl), modifier)

proc `mnemonicModifier=`*(self: Window | PlugAccessible | WindowAccessible;
    modifier: gdk.ModifierType) =
  gtk_window_set_mnemonic_modifier(cast[ptr Window00](self.impl), modifier)

proc gtk_window_set_mnemonics_visible(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setMnemonicsVisible*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_mnemonics_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc `mnemonicsVisible=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_mnemonics_visible(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_modal(self: ptr Window00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: Window | PlugAccessible | WindowAccessible;
    modal: bool = true) =
  gtk_window_set_modal(cast[ptr Window00](self.impl), gboolean(modal))

proc `modal=`*(self: Window | PlugAccessible | WindowAccessible;
    modal: bool) =
  gtk_window_set_modal(cast[ptr Window00](self.impl), gboolean(modal))

proc gtk_window_set_opacity(self: ptr Window00; opacity: cdouble) {.
    importc, libprag.}

proc setOpacity*(self: Window | PlugAccessible | WindowAccessible;
    opacity: cdouble) =
  gtk_window_set_opacity(cast[ptr Window00](self.impl), opacity)

proc `opacity=`*(self: Window | PlugAccessible | WindowAccessible;
    opacity: cdouble) =
  gtk_window_set_opacity(cast[ptr Window00](self.impl), opacity)

proc gtk_window_set_resizable(self: ptr Window00; resizable: gboolean) {.
    importc, libprag.}

proc setResizable*(self: Window | PlugAccessible | WindowAccessible;
    resizable: bool = true) =
  gtk_window_set_resizable(cast[ptr Window00](self.impl), gboolean(resizable))

proc `resizable=`*(self: Window | PlugAccessible | WindowAccessible;
    resizable: bool) =
  gtk_window_set_resizable(cast[ptr Window00](self.impl), gboolean(resizable))

proc gtk_window_set_role(self: ptr Window00; role: cstring) {.
    importc, libprag.}

proc setRole*(self: Window | PlugAccessible | WindowAccessible;
    role: cstring) =
  gtk_window_set_role(cast[ptr Window00](self.impl), role)

proc `role=`*(self: Window | PlugAccessible | WindowAccessible;
    role: cstring) =
  gtk_window_set_role(cast[ptr Window00](self.impl), role)

proc gtk_window_set_screen(self: ptr Window00; screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc setScreen*(self: Window | PlugAccessible | WindowAccessible;
    screen: gdk.Screen) =
  gtk_window_set_screen(cast[ptr Window00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: Window | PlugAccessible | WindowAccessible;
    screen: gdk.Screen) =
  gtk_window_set_screen(cast[ptr Window00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_window_set_skip_pager_hint(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setSkipPagerHint*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_skip_pager_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc `skipPagerHint=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_skip_pager_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_skip_taskbar_hint(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setSkipTaskbarHint*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_skip_taskbar_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc `skipTaskbarHint=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_skip_taskbar_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_startup_id(self: ptr Window00; startupId: cstring) {.
    importc, libprag.}

proc setStartupId*(self: Window | PlugAccessible | WindowAccessible;
    startupId: cstring) =
  gtk_window_set_startup_id(cast[ptr Window00](self.impl), startupId)

proc `startupId=`*(self: Window | PlugAccessible | WindowAccessible;
    startupId: cstring) =
  gtk_window_set_startup_id(cast[ptr Window00](self.impl), startupId)

proc gtk_window_set_title(self: ptr Window00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: Window | PlugAccessible | WindowAccessible;
    title: cstring) =
  gtk_window_set_title(cast[ptr Window00](self.impl), title)

proc `title=`*(self: Window | PlugAccessible | WindowAccessible;
    title: cstring) =
  gtk_window_set_title(cast[ptr Window00](self.impl), title)

proc gtk_window_set_titlebar(self: ptr Window00; titlebar: ptr Widget00) {.
    importc, libprag.}

proc setTitlebar*(self: Window | PlugAccessible | WindowAccessible;
    titlebar: Widget = nil) =
  gtk_window_set_titlebar(cast[ptr Window00](self.impl), if titlebar.isNil: nil else: cast[ptr Widget00](titlebar.impl))

proc `titlebar=`*(self: Window | PlugAccessible | WindowAccessible;
    titlebar: Widget = nil) =
  gtk_window_set_titlebar(cast[ptr Window00](self.impl), if titlebar.isNil: nil else: cast[ptr Widget00](titlebar.impl))

proc gtk_window_set_transient_for(self: ptr Window00; parent: ptr Window00) {.
    importc, libprag.}

proc setTransientFor*(self: Window | PlugAccessible | WindowAccessible;
    parent: Window = nil) =
  gtk_window_set_transient_for(cast[ptr Window00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc `transientFor=`*(self: Window | PlugAccessible | WindowAccessible;
    parent: Window = nil) =
  gtk_window_set_transient_for(cast[ptr Window00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc gtk_window_set_type_hint(self: ptr Window00; hint: gdk.WindowTypeHint) {.
    importc, libprag.}

proc setTypeHint*(self: Window | PlugAccessible | WindowAccessible;
    hint: gdk.WindowTypeHint) =
  gtk_window_set_type_hint(cast[ptr Window00](self.impl), hint)

proc `typeHint=`*(self: Window | PlugAccessible | WindowAccessible;
    hint: gdk.WindowTypeHint) =
  gtk_window_set_type_hint(cast[ptr Window00](self.impl), hint)

proc gtk_window_set_urgency_hint(self: ptr Window00; setting: gboolean) {.
    importc, libprag.}

proc setUrgencyHint*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool = true) =
  gtk_window_set_urgency_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc `urgencyHint=`*(self: Window | PlugAccessible | WindowAccessible;
    setting: bool) =
  gtk_window_set_urgency_hint(cast[ptr Window00](self.impl), gboolean(setting))

proc gtk_window_set_wmclass(self: ptr Window00; wmclassName: cstring; wmclassClass: cstring) {.
    importc, libprag.}

proc setWmclass*(self: Window | PlugAccessible | WindowAccessible;
    wmclassName: cstring; wmclassClass: cstring) =
  gtk_window_set_wmclass(cast[ptr Window00](self.impl), wmclassName, wmclassClass)

proc gtk_window_stick(self: ptr Window00) {.
    importc, libprag.}

proc stick*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_stick(cast[ptr Window00](self.impl))

proc gtk_window_unfullscreen(self: ptr Window00) {.
    importc, libprag.}

proc unfullscreen*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_unfullscreen(cast[ptr Window00](self.impl))

proc gtk_window_unmaximize(self: ptr Window00) {.
    importc, libprag.}

proc unmaximize*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_unmaximize(cast[ptr Window00](self.impl))

proc gtk_window_unstick(self: ptr Window00) {.
    importc, libprag.}

proc unstick*(self: Window | PlugAccessible | WindowAccessible) =
  gtk_window_unstick(cast[ptr Window00](self.impl))

type
  Dialog* = ref object of Window
  Dialog00* = object of Window00

proc gtk_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Dialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClose*(self: Dialog;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scResponse*(self: Dialog;  p: proc (self: ptr Dialog00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cf)

proc gtk_dialog_new(): ptr Dialog00 {.
    importc, libprag.}

proc newDialog*(): Dialog =
  let gobj = gtk_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDialog*(tdesc: typedesc): tdesc =
  assert(result is Dialog)
  let gobj = gtk_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDialog*[T](result: var T) {.deprecated.} =
  assert(result is Dialog)
  let gobj = gtk_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_add_action_widget(self: ptr Dialog00; child: ptr Widget00;
    responseId: int32) {.
    importc, libprag.}

proc addActionWidget*(self: Dialog; child: Widget; responseId: int) =
  gtk_dialog_add_action_widget(cast[ptr Dialog00](self.impl), cast[ptr Widget00](child.impl), int32(responseId))

proc gtk_dialog_add_button(self: ptr Dialog00; buttonText: cstring; responseId: int32): ptr Widget00 {.
    importc, libprag.}

proc addButton*(self: Dialog; buttonText: cstring; responseId: int): Widget =
  let gobj = gtk_dialog_add_button(cast[ptr Dialog00](self.impl), buttonText, int32(responseId))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_get_response_for_widget(self: ptr Dialog00; widget: ptr Widget00): int32 {.
    importc, libprag.}

proc getResponseForWidget*(self: Dialog; widget: Widget): int =
  int(gtk_dialog_get_response_for_widget(cast[ptr Dialog00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_dialog_get_widget_for_response(self: ptr Dialog00; responseId: int32): ptr Widget00 {.
    importc, libprag.}

proc getWidgetForResponse*(self: Dialog; responseId: int): Widget =
  let gobj = gtk_dialog_get_widget_for_response(cast[ptr Dialog00](self.impl), int32(responseId))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_response(self: ptr Dialog00; responseId: int32) {.
    importc, libprag.}

proc response*(self: Dialog; responseId: int) =
  gtk_dialog_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc gtk_dialog_run(self: ptr Dialog00): int32 {.
    importc, libprag.}

proc run*(self: Dialog): int =
  int(gtk_dialog_run(cast[ptr Dialog00](self.impl)))

proc gtk_dialog_set_alternative_button_order_from_array(self: ptr Dialog00;
    nParams: int32; newOrder: ptr int32) {.
    importc, libprag.}

proc setAlternativeButtonOrderFromArray*(self: Dialog; newOrder: seq[int32]) =
  let nParams = int(newOrder.len)
  gtk_dialog_set_alternative_button_order_from_array(cast[ptr Dialog00](self.impl), int32(nParams), cast[ptr int32](unsafeaddr(newOrder[0])))

proc gtk_dialog_set_default_response(self: ptr Dialog00; responseId: int32) {.
    importc, libprag.}

proc setDefaultResponse*(self: Dialog; responseId: int) =
  gtk_dialog_set_default_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc `defaultResponse=`*(self: Dialog; responseId: int) =
  gtk_dialog_set_default_response(cast[ptr Dialog00](self.impl), int32(responseId))

proc gtk_dialog_set_response_sensitive(self: ptr Dialog00; responseId: int32;
    setting: gboolean) {.
    importc, libprag.}

proc setResponseSensitive*(self: Dialog; responseId: int; setting: bool) =
  gtk_dialog_set_response_sensitive(cast[ptr Dialog00](self.impl), int32(responseId), gboolean(setting))

type
  AboutDialog* = ref object of Dialog
  AboutDialog00* = object of Dialog00

proc gtk_about_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AboutDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateLink*(self: AboutDialog;  p: proc (self: ptr AboutDialog00; uri: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cf)

proc gtk_about_dialog_new(): ptr AboutDialog00 {.
    importc, libprag.}

proc newAboutDialog*(): AboutDialog =
  let gobj = gtk_about_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAboutDialog*(tdesc: typedesc): tdesc =
  assert(result is AboutDialog)
  let gobj = gtk_about_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAboutDialog*[T](result: var T) {.deprecated.} =
  assert(result is AboutDialog)
  let gobj = gtk_about_dialog_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_about_dialog_add_credit_section(self: ptr AboutDialog00; sectionName: cstring;
    people: ptr cstring) {.
    importc, libprag.}

proc addCreditSection*(self: AboutDialog; sectionName: cstring;
    people: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_add_credit_section(cast[ptr AboutDialog00](self.impl), sectionName, seq2CstringArray(people, fs469n23))

proc gtk_about_dialog_get_artists(self: ptr AboutDialog00): ptr cstring {.
    importc, libprag.}

proc getArtists*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_artists(cast[ptr AboutDialog00](self.impl)))

proc artists*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_artists(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_get_authors(self: ptr AboutDialog00): ptr cstring {.
    importc, libprag.}

proc getAuthors*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_authors(cast[ptr AboutDialog00](self.impl)))

proc authors*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_authors(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_get_comments(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getComments*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_comments(cast[ptr AboutDialog00](self.impl))

proc comments*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_comments(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_copyright(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getCopyright*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_copyright(cast[ptr AboutDialog00](self.impl))

proc copyright*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_copyright(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_documenters(self: ptr AboutDialog00): ptr cstring {.
    importc, libprag.}

proc getDocumenters*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_documenters(cast[ptr AboutDialog00](self.impl)))

proc documenters*(self: AboutDialog): seq[string] =
  cstringArrayToSeq(gtk_about_dialog_get_documenters(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_get_license(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getLicense*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_license(cast[ptr AboutDialog00](self.impl))

proc license*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_license(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_logo(self: ptr AboutDialog00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getLogo*(self: AboutDialog): gdkpixbuf.Pixbuf =
  let gobj = gtk_about_dialog_get_logo(cast[ptr AboutDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc logo*(self: AboutDialog): gdkpixbuf.Pixbuf =
  let gobj = gtk_about_dialog_get_logo(cast[ptr AboutDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_about_dialog_get_logo_icon_name(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getLogoIconName*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_logo_icon_name(cast[ptr AboutDialog00](self.impl))

proc logoIconName*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_logo_icon_name(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_program_name(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getProgramName*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_program_name(cast[ptr AboutDialog00](self.impl))

proc programName*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_program_name(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_translator_credits(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getTranslatorCredits*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_translator_credits(cast[ptr AboutDialog00](self.impl))

proc translatorCredits*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_translator_credits(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_version(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getVersion*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_version(cast[ptr AboutDialog00](self.impl))

proc version*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_version(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_website(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getWebsite*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_website(cast[ptr AboutDialog00](self.impl))

proc website*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_website(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_website_label(self: ptr AboutDialog00): cstring {.
    importc, libprag.}

proc getWebsiteLabel*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_website_label(cast[ptr AboutDialog00](self.impl))

proc websiteLabel*(self: AboutDialog): string =
  result = $gtk_about_dialog_get_website_label(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_get_wrap_license(self: ptr AboutDialog00): gboolean {.
    importc, libprag.}

proc getWrapLicense*(self: AboutDialog): bool =
  toBool(gtk_about_dialog_get_wrap_license(cast[ptr AboutDialog00](self.impl)))

proc wrapLicense*(self: AboutDialog): bool =
  toBool(gtk_about_dialog_get_wrap_license(cast[ptr AboutDialog00](self.impl)))

proc gtk_about_dialog_set_artists(self: ptr AboutDialog00; artists: ptr cstring) {.
    importc, libprag.}

proc setArtists*(self: AboutDialog; artists: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_artists(cast[ptr AboutDialog00](self.impl), seq2CstringArray(artists, fs469n23))

proc `artists=`*(self: AboutDialog; artists: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_artists(cast[ptr AboutDialog00](self.impl), seq2CstringArray(artists, fs469n23))

proc gtk_about_dialog_set_authors(self: ptr AboutDialog00; authors: ptr cstring) {.
    importc, libprag.}

proc setAuthors*(self: AboutDialog; authors: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_authors(cast[ptr AboutDialog00](self.impl), seq2CstringArray(authors, fs469n23))

proc `authors=`*(self: AboutDialog; authors: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_authors(cast[ptr AboutDialog00](self.impl), seq2CstringArray(authors, fs469n23))

proc gtk_about_dialog_set_comments(self: ptr AboutDialog00; comments: cstring) {.
    importc, libprag.}

proc setComments*(self: AboutDialog; comments: cstring = nil) =
  gtk_about_dialog_set_comments(cast[ptr AboutDialog00](self.impl), comments)

proc `comments=`*(self: AboutDialog; comments: cstring = nil) =
  gtk_about_dialog_set_comments(cast[ptr AboutDialog00](self.impl), comments)

proc gtk_about_dialog_set_copyright(self: ptr AboutDialog00; copyright: cstring) {.
    importc, libprag.}

proc setCopyright*(self: AboutDialog; copyright: cstring = nil) =
  gtk_about_dialog_set_copyright(cast[ptr AboutDialog00](self.impl), copyright)

proc `copyright=`*(self: AboutDialog; copyright: cstring = nil) =
  gtk_about_dialog_set_copyright(cast[ptr AboutDialog00](self.impl), copyright)

proc gtk_about_dialog_set_documenters(self: ptr AboutDialog00; documenters: ptr cstring) {.
    importc, libprag.}

proc setDocumenters*(self: AboutDialog; documenters: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_documenters(cast[ptr AboutDialog00](self.impl), seq2CstringArray(documenters, fs469n23))

proc `documenters=`*(self: AboutDialog; documenters: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_about_dialog_set_documenters(cast[ptr AboutDialog00](self.impl), seq2CstringArray(documenters, fs469n23))

proc gtk_about_dialog_set_license(self: ptr AboutDialog00; license: cstring) {.
    importc, libprag.}

proc setLicense*(self: AboutDialog; license: cstring = nil) =
  gtk_about_dialog_set_license(cast[ptr AboutDialog00](self.impl), license)

proc `license=`*(self: AboutDialog; license: cstring = nil) =
  gtk_about_dialog_set_license(cast[ptr AboutDialog00](self.impl), license)

proc gtk_about_dialog_set_logo(self: ptr AboutDialog00; logo: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setLogo*(self: AboutDialog; logo: gdkpixbuf.Pixbuf = nil) =
  gtk_about_dialog_set_logo(cast[ptr AboutDialog00](self.impl), if logo.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](logo.impl))

proc `logo=`*(self: AboutDialog; logo: gdkpixbuf.Pixbuf = nil) =
  gtk_about_dialog_set_logo(cast[ptr AboutDialog00](self.impl), if logo.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](logo.impl))

proc gtk_about_dialog_set_logo_icon_name(self: ptr AboutDialog00; iconName: cstring) {.
    importc, libprag.}

proc setLogoIconName*(self: AboutDialog; iconName: cstring = nil) =
  gtk_about_dialog_set_logo_icon_name(cast[ptr AboutDialog00](self.impl), iconName)

proc `logoIconName=`*(self: AboutDialog; iconName: cstring = nil) =
  gtk_about_dialog_set_logo_icon_name(cast[ptr AboutDialog00](self.impl), iconName)

proc gtk_about_dialog_set_program_name(self: ptr AboutDialog00; name: cstring) {.
    importc, libprag.}

proc setProgramName*(self: AboutDialog; name: cstring) =
  gtk_about_dialog_set_program_name(cast[ptr AboutDialog00](self.impl), name)

proc `programName=`*(self: AboutDialog; name: cstring) =
  gtk_about_dialog_set_program_name(cast[ptr AboutDialog00](self.impl), name)

proc gtk_about_dialog_set_translator_credits(self: ptr AboutDialog00; translatorCredits: cstring) {.
    importc, libprag.}

proc setTranslatorCredits*(self: AboutDialog; translatorCredits: cstring = nil) =
  gtk_about_dialog_set_translator_credits(cast[ptr AboutDialog00](self.impl), translatorCredits)

proc `translatorCredits=`*(self: AboutDialog; translatorCredits: cstring = nil) =
  gtk_about_dialog_set_translator_credits(cast[ptr AboutDialog00](self.impl), translatorCredits)

proc gtk_about_dialog_set_version(self: ptr AboutDialog00; version: cstring) {.
    importc, libprag.}

proc setVersion*(self: AboutDialog; version: cstring = nil) =
  gtk_about_dialog_set_version(cast[ptr AboutDialog00](self.impl), version)

proc `version=`*(self: AboutDialog; version: cstring = nil) =
  gtk_about_dialog_set_version(cast[ptr AboutDialog00](self.impl), version)

proc gtk_about_dialog_set_website(self: ptr AboutDialog00; website: cstring) {.
    importc, libprag.}

proc setWebsite*(self: AboutDialog; website: cstring = nil) =
  gtk_about_dialog_set_website(cast[ptr AboutDialog00](self.impl), website)

proc `website=`*(self: AboutDialog; website: cstring = nil) =
  gtk_about_dialog_set_website(cast[ptr AboutDialog00](self.impl), website)

proc gtk_about_dialog_set_website_label(self: ptr AboutDialog00; websiteLabel: cstring) {.
    importc, libprag.}

proc setWebsiteLabel*(self: AboutDialog; websiteLabel: cstring) =
  gtk_about_dialog_set_website_label(cast[ptr AboutDialog00](self.impl), websiteLabel)

proc `websiteLabel=`*(self: AboutDialog; websiteLabel: cstring) =
  gtk_about_dialog_set_website_label(cast[ptr AboutDialog00](self.impl), websiteLabel)

proc gtk_about_dialog_set_wrap_license(self: ptr AboutDialog00; wrapLicense: gboolean) {.
    importc, libprag.}

proc setWrapLicense*(self: AboutDialog; wrapLicense: bool = true) =
  gtk_about_dialog_set_wrap_license(cast[ptr AboutDialog00](self.impl), gboolean(wrapLicense))

proc `wrapLicense=`*(self: AboutDialog; wrapLicense: bool) =
  gtk_about_dialog_set_wrap_license(cast[ptr AboutDialog00](self.impl), gboolean(wrapLicense))

proc gtk_widget_get_tooltip_window(self: ptr Widget00): ptr Window00 {.
    importc, libprag.}

proc getTooltipWindow*(self: Widget): Window =
  let gobj = gtk_widget_get_tooltip_window(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc tooltipWindow*(self: Widget): Window =
  let gobj = gtk_widget_get_tooltip_window(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_set_tooltip_window(self: ptr Widget00; customWindow: ptr Window00) {.
    importc, libprag.}

proc setTooltipWindow*(self: Widget; customWindow: Window = nil) =
  gtk_widget_set_tooltip_window(cast[ptr Widget00](self.impl), if customWindow.isNil: nil else: cast[ptr Window00](customWindow.impl))

proc `tooltipWindow=`*(self: Widget; customWindow: Window = nil) =
  gtk_widget_set_tooltip_window(cast[ptr Widget00](self.impl), if customWindow.isNil: nil else: cast[ptr Window00](customWindow.impl))

type
  WindowGroup* = ref object of gobject.Object
  WindowGroup00* = object of gobject.Object00

proc gtk_window_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WindowGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_window_group_new(): ptr WindowGroup00 {.
    importc, libprag.}

proc newWindowGroup*(): WindowGroup =
  let gobj = gtk_window_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newWindowGroup*(tdesc: typedesc): tdesc =
  assert(result is WindowGroup)
  let gobj = gtk_window_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindowGroup*[T](result: var T) {.deprecated.} =
  assert(result is WindowGroup)
  let gobj = gtk_window_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_group_add_window(self: ptr WindowGroup00; window: ptr Window00) {.
    importc, libprag.}

proc addWindow*(self: WindowGroup; window: Window) =
  gtk_window_group_add_window(cast[ptr WindowGroup00](self.impl), cast[ptr Window00](window.impl))

proc gtk_window_group_get_current_device_grab(self: ptr WindowGroup00; device: ptr gdk.Device00): ptr Widget00 {.
    importc, libprag.}

proc getCurrentDeviceGrab*(self: WindowGroup; device: gdk.Device): Widget =
  let gobj = gtk_window_group_get_current_device_grab(cast[ptr WindowGroup00](self.impl), cast[ptr gdk.Device00](device.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_group_get_current_grab(self: ptr WindowGroup00): ptr Widget00 {.
    importc, libprag.}

proc getCurrentGrab*(self: WindowGroup): Widget =
  let gobj = gtk_window_group_get_current_grab(cast[ptr WindowGroup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentGrab*(self: WindowGroup): Widget =
  let gobj = gtk_window_group_get_current_grab(cast[ptr WindowGroup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_group_list_windows(self: ptr WindowGroup00): ptr glib.List {.
    importc, libprag.}

proc listWindows*(self: WindowGroup): seq[Window] =
  let resul0 = gtk_window_group_list_windows(cast[ptr WindowGroup00](self.impl))
  result = glistObjects2seq(Window, resul0, false)
  g_list_free(resul0)

proc gtk_window_group_remove_window(self: ptr WindowGroup00; window: ptr Window00) {.
    importc, libprag.}

proc removeWindow*(self: WindowGroup; window: Window) =
  gtk_window_group_remove_window(cast[ptr WindowGroup00](self.impl), cast[ptr Window00](window.impl))

proc gtk_window_get_group(self: ptr Window00): ptr WindowGroup00 {.
    importc, libprag.}

proc getGroup*(self: Window | PlugAccessible | WindowAccessible): WindowGroup =
  let gobj = gtk_window_get_group(cast[ptr Window00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc group*(self: Window | PlugAccessible | WindowAccessible): WindowGroup =
  let gobj = gtk_window_get_group(cast[ptr Window00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  WindowType* {.size: sizeof(cint), pure.} = enum
    toplevel = 0
    popup = 1

proc gtk_window_new(`type`: WindowType): ptr Window00 {.
    importc, libprag.}

proc newWindow*(`type`: WindowType = WindowType.toplevel): Window =
  let gobj = gtk_window_new(`type`)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newWindow*(tdesc: typedesc; `type`: WindowType = WindowType.toplevel): tdesc =
  assert(result is Window)
  let gobj = gtk_window_new(`type`)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initWindow*[T](result: var T; `type`: WindowType = WindowType.toplevel) {.deprecated.} =
  assert(result is Window)
  let gobj = gtk_window_new(`type`)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_get_window_type(self: ptr Window00): WindowType {.
    importc, libprag.}

proc getWindowType*(self: Window | PlugAccessible | WindowAccessible): WindowType =
  gtk_window_get_window_type(cast[ptr Window00](self.impl))

proc windowType*(self: Window | PlugAccessible | WindowAccessible): WindowType =
  gtk_window_get_window_type(cast[ptr Window00](self.impl))

type
  Application* = ref object of gio.GApplication
  Application00* = object of gio.GApplication00

proc gtk_application_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Application()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scQueryEnd*(self: Application;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "query-end", cast[GCallback](p), xdata, nil, cf)

proc scWindowAdded*(self: Application;  p: proc (self: ptr Application00; window: ptr Window00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "window-added", cast[GCallback](p), xdata, nil, cf)

proc scWindowRemoved*(self: Application;  p: proc (self: ptr Application00; window: ptr Window00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "window-removed", cast[GCallback](p), xdata, nil, cf)

proc gtk_application_new(applicationId: cstring; flags: gio.ApplicationFlags): ptr Application00 {.
    importc, libprag.}

proc newApplication*(applicationId: cstring = nil; flags: gio.ApplicationFlags = {}): Application =
  let gobj = gtk_application_new(applicationId, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newApplication*(tdesc: typedesc; applicationId: cstring = nil; flags: gio.ApplicationFlags = {}): tdesc =
  assert(result is Application)
  let gobj = gtk_application_new(applicationId, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initApplication*[T](result: var T; applicationId: cstring = nil; flags: gio.ApplicationFlags = {}) {.deprecated.} =
  assert(result is Application)
  let gobj = gtk_application_new(applicationId, flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_add_accelerator(self: ptr Application00; accelerator: cstring;
    actionName: cstring; parameter: ptr glib.Variant00) {.
    importc, libprag.}

proc addAccelerator*(self: Application; accelerator: cstring;
    actionName: cstring; parameter: glib.Variant = nil) =
  gtk_application_add_accelerator(cast[ptr Application00](self.impl), accelerator, actionName, if parameter.isNil: nil else: cast[ptr glib.Variant00](parameter.impl))

proc gtk_application_add_window(self: ptr Application00; window: ptr Window00) {.
    importc, libprag.}

proc addWindow*(self: Application; window: Window) =
  gtk_application_add_window(cast[ptr Application00](self.impl), cast[ptr Window00](window.impl))

proc gtk_application_get_accels_for_action(self: ptr Application00; detailedActionName: cstring): ptr cstring {.
    importc, libprag.}

proc getAccelsForAction*(self: Application; detailedActionName: cstring): seq[string] =
  let resul0 = gtk_application_get_accels_for_action(cast[ptr Application00](self.impl), detailedActionName)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_application_get_actions_for_accel(self: ptr Application00; accel: cstring): ptr cstring {.
    importc, libprag.}

proc getActionsForAccel*(self: Application; accel: cstring): seq[string] =
  let resul0 = gtk_application_get_actions_for_accel(cast[ptr Application00](self.impl), accel)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_application_get_active_window(self: ptr Application00): ptr Window00 {.
    importc, libprag.}

proc getActiveWindow*(self: Application): Window =
  let gobj = gtk_application_get_active_window(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc activeWindow*(self: Application): Window =
  let gobj = gtk_application_get_active_window(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_app_menu(self: ptr Application00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getAppMenu*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_app_menu(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc appMenu*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_app_menu(cast[ptr Application00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_menu_by_id(self: ptr Application00; id: cstring): ptr gio.Menu00 {.
    importc, libprag.}

proc getMenuById*(self: Application; id: cstring): gio.Menu =
  let gobj = gtk_application_get_menu_by_id(cast[ptr Application00](self.impl), id)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_menubar(self: ptr Application00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getMenubar*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_menubar(cast[ptr Application00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menubar*(self: Application): gio.MenuModel =
  let gobj = gtk_application_get_menubar(cast[ptr Application00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_window_by_id(self: ptr Application00; id: uint32): ptr Window00 {.
    importc, libprag.}

proc getWindowById*(self: Application; id: int): Window =
  let gobj = gtk_application_get_window_by_id(cast[ptr Application00](self.impl), uint32(id))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_get_windows(self: ptr Application00): ptr glib.List {.
    importc, libprag.}

proc getWindows*(self: Application): seq[Window] =
  result = glistObjects2seq(Window, gtk_application_get_windows(cast[ptr Application00](self.impl)), false)

proc windows*(self: Application): seq[Window] =
  result = glistObjects2seq(Window, gtk_application_get_windows(cast[ptr Application00](self.impl)), false)

proc gtk_application_list_action_descriptions(self: ptr Application00): ptr cstring {.
    importc, libprag.}

proc listActionDescriptions*(self: Application): seq[string] =
  let resul0 = gtk_application_list_action_descriptions(cast[ptr Application00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_application_prefers_app_menu(self: ptr Application00): gboolean {.
    importc, libprag.}

proc prefersAppMenu*(self: Application): bool =
  toBool(gtk_application_prefers_app_menu(cast[ptr Application00](self.impl)))

proc gtk_application_remove_accelerator(self: ptr Application00; actionName: cstring;
    parameter: ptr glib.Variant00) {.
    importc, libprag.}

proc removeAccelerator*(self: Application; actionName: cstring;
    parameter: glib.Variant = nil) =
  gtk_application_remove_accelerator(cast[ptr Application00](self.impl), actionName, if parameter.isNil: nil else: cast[ptr glib.Variant00](parameter.impl))

proc gtk_application_remove_window(self: ptr Application00; window: ptr Window00) {.
    importc, libprag.}

proc removeWindow*(self: Application; window: Window) =
  gtk_application_remove_window(cast[ptr Application00](self.impl), cast[ptr Window00](window.impl))

proc gtk_application_set_accels_for_action(self: ptr Application00; detailedActionName: cstring;
    accels: ptr cstring) {.
    importc, libprag.}

proc setAccelsForAction*(self: Application; detailedActionName: cstring;
    accels: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_application_set_accels_for_action(cast[ptr Application00](self.impl), detailedActionName, seq2CstringArray(accels, fs469n23))

proc gtk_application_set_app_menu(self: ptr Application00; appMenu: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setAppMenu*(self: Application; appMenu: gio.MenuModel = nil) =
  gtk_application_set_app_menu(cast[ptr Application00](self.impl), if appMenu.isNil: nil else: cast[ptr gio.MenuModel00](appMenu.impl))

proc `appMenu=`*(self: Application; appMenu: gio.MenuModel = nil) =
  gtk_application_set_app_menu(cast[ptr Application00](self.impl), if appMenu.isNil: nil else: cast[ptr gio.MenuModel00](appMenu.impl))

proc gtk_application_set_menubar(self: ptr Application00; menubar: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setMenubar*(self: Application; menubar: gio.MenuModel = nil) =
  gtk_application_set_menubar(cast[ptr Application00](self.impl), if menubar.isNil: nil else: cast[ptr gio.MenuModel00](menubar.impl))

proc `menubar=`*(self: Application; menubar: gio.MenuModel = nil) =
  gtk_application_set_menubar(cast[ptr Application00](self.impl), if menubar.isNil: nil else: cast[ptr gio.MenuModel00](menubar.impl))

proc gtk_application_uninhibit(self: ptr Application00; cookie: uint32) {.
    importc, libprag.}

proc uninhibit*(self: Application; cookie: int) =
  gtk_application_uninhibit(cast[ptr Application00](self.impl), uint32(cookie))

proc gtk_window_get_application(self: ptr Window00): ptr Application00 {.
    importc, libprag.}

proc getApplication*(self: Window | PlugAccessible | WindowAccessible): Application =
  let gobj = gtk_window_get_application(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc application*(self: Window | PlugAccessible | WindowAccessible): Application =
  let gobj = gtk_window_get_application(cast[ptr Window00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_window_set_application(self: ptr Window00; application: ptr Application00) {.
    importc, libprag.}

proc setApplication*(self: Window | PlugAccessible | WindowAccessible;
    application: Application = nil) =
  gtk_window_set_application(cast[ptr Window00](self.impl), if application.isNil: nil else: cast[ptr Application00](application.impl))

proc `application=`*(self: Window | PlugAccessible | WindowAccessible;
    application: Application = nil) =
  gtk_window_set_application(cast[ptr Window00](self.impl), if application.isNil: nil else: cast[ptr Application00](application.impl))

type
  ApplicationInhibitFlag* {.size: sizeof(cint), pure.} = enum
    logout = 0
    switch = 1
    suspend = 2
    idle = 3

  ApplicationInhibitFlags* {.size: sizeof(cint).} = set[ApplicationInhibitFlag]

proc gtk_application_inhibit(self: ptr Application00; window: ptr Window00;
    flags: ApplicationInhibitFlags; reason: cstring): uint32 {.
    importc, libprag.}

proc inhibit*(self: Application; window: Window = nil; flags: ApplicationInhibitFlags;
    reason: cstring = nil): int =
  int(gtk_application_inhibit(cast[ptr Application00](self.impl), if window.isNil: nil else: cast[ptr Window00](window.impl), flags, reason))

proc gtk_application_is_inhibited(self: ptr Application00; flags: ApplicationInhibitFlags): gboolean {.
    importc, libprag.}

proc isInhibited*(self: Application; flags: ApplicationInhibitFlags): bool =
  toBool(gtk_application_is_inhibited(cast[ptr Application00](self.impl), flags))

type
  WindowPosition* {.size: sizeof(cint), pure.} = enum
    none = 0
    center = 1
    mouse = 2
    centerAlways = 3
    centerOnParent = 4

proc gtk_window_set_position(self: ptr Window00; position: WindowPosition) {.
    importc, libprag.}

proc setPosition*(self: Window | PlugAccessible | WindowAccessible;
    position: WindowPosition) =
  gtk_window_set_position(cast[ptr Window00](self.impl), position)

proc `position=`*(self: Window | PlugAccessible | WindowAccessible;
    position: WindowPosition) =
  gtk_window_set_position(cast[ptr Window00](self.impl), position)

type
  Box* = ref object of Container
  Box00* = object of Container00

proc gtk_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Box()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_box_get_center_widget(self: ptr Box00): ptr Widget00 {.
    importc, libprag.}

proc getCenterWidget*(self: Box): Widget =
  let gobj = gtk_box_get_center_widget(cast[ptr Box00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc centerWidget*(self: Box): Widget =
  let gobj = gtk_box_get_center_widget(cast[ptr Box00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_box_get_homogeneous(self: ptr Box00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: Box): bool =
  toBool(gtk_box_get_homogeneous(cast[ptr Box00](self.impl)))

proc homogeneous*(self: Box): bool =
  toBool(gtk_box_get_homogeneous(cast[ptr Box00](self.impl)))

proc gtk_box_get_spacing(self: ptr Box00): int32 {.
    importc, libprag.}

proc getSpacing*(self: Box): int =
  int(gtk_box_get_spacing(cast[ptr Box00](self.impl)))

proc spacing*(self: Box): int =
  int(gtk_box_get_spacing(cast[ptr Box00](self.impl)))

proc gtk_box_pack_end(self: ptr Box00; child: ptr Widget00; expand: gboolean;
    fill: gboolean; padding: uint32) {.
    importc, libprag.}

proc packEnd*(self: Box; child: Widget; expand: bool; fill: bool;
    padding: int) =
  gtk_box_pack_end(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), gboolean(expand), gboolean(fill), uint32(padding))

proc gtk_box_pack_start(self: ptr Box00; child: ptr Widget00; expand: gboolean;
    fill: gboolean; padding: uint32) {.
    importc, libprag.}

proc packStart*(self: Box; child: Widget; expand: bool; fill: bool;
    padding: int) =
  gtk_box_pack_start(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), gboolean(expand), gboolean(fill), uint32(padding))

proc gtk_box_reorder_child(self: ptr Box00; child: ptr Widget00; position: int32) {.
    importc, libprag.}

proc reorderChild*(self: Box; child: Widget; position: int) =
  gtk_box_reorder_child(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_box_set_center_widget(self: ptr Box00; widget: ptr Widget00) {.
    importc, libprag.}

proc setCenterWidget*(self: Box; widget: Widget = nil) =
  gtk_box_set_center_widget(cast[ptr Box00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `centerWidget=`*(self: Box; widget: Widget = nil) =
  gtk_box_set_center_widget(cast[ptr Box00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_box_set_homogeneous(self: ptr Box00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: Box; homogeneous: bool = true) =
  gtk_box_set_homogeneous(cast[ptr Box00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: Box; homogeneous: bool) =
  gtk_box_set_homogeneous(cast[ptr Box00](self.impl), gboolean(homogeneous))

proc gtk_box_set_spacing(self: ptr Box00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: Box; spacing: int) =
  gtk_box_set_spacing(cast[ptr Box00](self.impl), int32(spacing))

proc `spacing=`*(self: Box; spacing: int) =
  gtk_box_set_spacing(cast[ptr Box00](self.impl), int32(spacing))

proc gtk_dialog_get_action_area(self: ptr Dialog00): ptr Box00 {.
    importc, libprag.}

proc getActionArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_action_area(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc actionArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_action_area(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_dialog_get_content_area(self: ptr Dialog00): ptr Box00 {.
    importc, libprag.}

proc getContentArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_content_area(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc contentArea*(self: Dialog): Box =
  let gobj = gtk_dialog_get_content_area(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  BaselinePosition* {.size: sizeof(cint), pure.} = enum
    top = 0
    center = 1
    bottom = 2

proc gtk_box_get_baseline_position(self: ptr Box00): BaselinePosition {.
    importc, libprag.}

proc getBaselinePosition*(self: Box): BaselinePosition =
  gtk_box_get_baseline_position(cast[ptr Box00](self.impl))

proc baselinePosition*(self: Box): BaselinePosition =
  gtk_box_get_baseline_position(cast[ptr Box00](self.impl))

proc gtk_box_set_baseline_position(self: ptr Box00; position: BaselinePosition) {.
    importc, libprag.}

proc setBaselinePosition*(self: Box; position: BaselinePosition) =
  gtk_box_set_baseline_position(cast[ptr Box00](self.impl), position)

proc `baselinePosition=`*(self: Box; position: BaselinePosition) =
  gtk_box_set_baseline_position(cast[ptr Box00](self.impl), position)

type
  PackType* {.size: sizeof(cint), pure.} = enum
    start = 0
    `end` = 1

proc gtk_box_query_child_packing(self: ptr Box00; child: ptr Widget00; expand: var gboolean;
    fill: var gboolean; padding: var uint32; packType: var PackType) {.
    importc, libprag.}

proc queryChildPacking*(self: Box; child: Widget; expand: var bool;
    fill: var bool; padding: var int; packType: var PackType) =
  var fill_00: gboolean
  var padding_00: uint32
  var expand_00: gboolean
  gtk_box_query_child_packing(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), expand_00, fill_00, padding_00, packType)
  if fill.addr != nil:
    fill = toBool(fill_00)
  if padding.addr != nil:
    padding = int(padding_00)
  if expand.addr != nil:
    expand = toBool(expand_00)

proc gtk_box_set_child_packing(self: ptr Box00; child: ptr Widget00; expand: gboolean;
    fill: gboolean; padding: uint32; packType: PackType) {.
    importc, libprag.}

proc setChildPacking*(self: Box; child: Widget; expand: bool; fill: bool;
    padding: int; packType: PackType) =
  gtk_box_set_child_packing(cast[ptr Box00](self.impl), cast[ptr Widget00](child.impl), gboolean(expand), gboolean(fill), uint32(padding), packType)

type
  HeaderBar* = ref object of Container
  HeaderBar00* = object of Container00

proc gtk_header_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HeaderBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_header_bar_new(): ptr HeaderBar00 {.
    importc, libprag.}

proc newHeaderBar*(): HeaderBar =
  let gobj = gtk_header_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHeaderBar*(tdesc: typedesc): tdesc =
  assert(result is HeaderBar)
  let gobj = gtk_header_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHeaderBar*[T](result: var T) {.deprecated.} =
  assert(result is HeaderBar)
  let gobj = gtk_header_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_header_bar_get_custom_title(self: ptr HeaderBar00): ptr Widget00 {.
    importc, libprag.}

proc getCustomTitle*(self: HeaderBar): Widget =
  let gobj = gtk_header_bar_get_custom_title(cast[ptr HeaderBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc customTitle*(self: HeaderBar): Widget =
  let gobj = gtk_header_bar_get_custom_title(cast[ptr HeaderBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_header_bar_get_decoration_layout(self: ptr HeaderBar00): cstring {.
    importc, libprag.}

proc getDecorationLayout*(self: HeaderBar): string =
  result = $gtk_header_bar_get_decoration_layout(cast[ptr HeaderBar00](self.impl))

proc decorationLayout*(self: HeaderBar): string =
  result = $gtk_header_bar_get_decoration_layout(cast[ptr HeaderBar00](self.impl))

proc gtk_header_bar_get_has_subtitle(self: ptr HeaderBar00): gboolean {.
    importc, libprag.}

proc getHasSubtitle*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_has_subtitle(cast[ptr HeaderBar00](self.impl)))

proc hasSubtitle*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_has_subtitle(cast[ptr HeaderBar00](self.impl)))

proc gtk_header_bar_get_show_close_button(self: ptr HeaderBar00): gboolean {.
    importc, libprag.}

proc getShowCloseButton*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_show_close_button(cast[ptr HeaderBar00](self.impl)))

proc showCloseButton*(self: HeaderBar): bool =
  toBool(gtk_header_bar_get_show_close_button(cast[ptr HeaderBar00](self.impl)))

proc gtk_header_bar_get_subtitle(self: ptr HeaderBar00): cstring {.
    importc, libprag.}

proc getSubtitle*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_subtitle(cast[ptr HeaderBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc subtitle*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_subtitle(cast[ptr HeaderBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_header_bar_get_title(self: ptr HeaderBar00): cstring {.
    importc, libprag.}

proc getTitle*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_title(cast[ptr HeaderBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc title*(self: HeaderBar): string =
  let resul0 = gtk_header_bar_get_title(cast[ptr HeaderBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_header_bar_pack_end(self: ptr HeaderBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packEnd*(self: HeaderBar; child: Widget) =
  gtk_header_bar_pack_end(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_header_bar_pack_start(self: ptr HeaderBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packStart*(self: HeaderBar; child: Widget) =
  gtk_header_bar_pack_start(cast[ptr HeaderBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_header_bar_set_custom_title(self: ptr HeaderBar00; titleWidget: ptr Widget00) {.
    importc, libprag.}

proc setCustomTitle*(self: HeaderBar; titleWidget: Widget = nil) =
  gtk_header_bar_set_custom_title(cast[ptr HeaderBar00](self.impl), if titleWidget.isNil: nil else: cast[ptr Widget00](titleWidget.impl))

proc `customTitle=`*(self: HeaderBar; titleWidget: Widget = nil) =
  gtk_header_bar_set_custom_title(cast[ptr HeaderBar00](self.impl), if titleWidget.isNil: nil else: cast[ptr Widget00](titleWidget.impl))

proc gtk_header_bar_set_decoration_layout(self: ptr HeaderBar00; layout: cstring) {.
    importc, libprag.}

proc setDecorationLayout*(self: HeaderBar; layout: cstring = nil) =
  gtk_header_bar_set_decoration_layout(cast[ptr HeaderBar00](self.impl), layout)

proc `decorationLayout=`*(self: HeaderBar; layout: cstring = nil) =
  gtk_header_bar_set_decoration_layout(cast[ptr HeaderBar00](self.impl), layout)

proc gtk_header_bar_set_has_subtitle(self: ptr HeaderBar00; setting: gboolean) {.
    importc, libprag.}

proc setHasSubtitle*(self: HeaderBar; setting: bool = true) =
  gtk_header_bar_set_has_subtitle(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc `hasSubtitle=`*(self: HeaderBar; setting: bool) =
  gtk_header_bar_set_has_subtitle(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc gtk_header_bar_set_show_close_button(self: ptr HeaderBar00; setting: gboolean) {.
    importc, libprag.}

proc setShowCloseButton*(self: HeaderBar; setting: bool = true) =
  gtk_header_bar_set_show_close_button(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc `showCloseButton=`*(self: HeaderBar; setting: bool) =
  gtk_header_bar_set_show_close_button(cast[ptr HeaderBar00](self.impl), gboolean(setting))

proc gtk_header_bar_set_subtitle(self: ptr HeaderBar00; subtitle: cstring) {.
    importc, libprag.}

proc setSubtitle*(self: HeaderBar; subtitle: cstring = nil) =
  gtk_header_bar_set_subtitle(cast[ptr HeaderBar00](self.impl), subtitle)

proc `subtitle=`*(self: HeaderBar; subtitle: cstring = nil) =
  gtk_header_bar_set_subtitle(cast[ptr HeaderBar00](self.impl), subtitle)

proc gtk_header_bar_set_title(self: ptr HeaderBar00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: HeaderBar; title: cstring = nil) =
  gtk_header_bar_set_title(cast[ptr HeaderBar00](self.impl), title)

proc `title=`*(self: HeaderBar; title: cstring = nil) =
  gtk_header_bar_set_title(cast[ptr HeaderBar00](self.impl), title)

proc gtk_dialog_get_header_bar(self: ptr Dialog00): ptr HeaderBar00 {.
    importc, libprag.}

proc getHeaderBar*(self: Dialog): HeaderBar =
  let gobj = gtk_dialog_get_header_bar(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc headerBar*(self: Dialog): HeaderBar =
  let gobj = gtk_dialog_get_header_bar(cast[ptr Dialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  License* {.size: sizeof(cint), pure.} = enum
    unknown = 0
    custom = 1
    gpl_2_0 = 2
    gpl_3_0 = 3
    lgpl_2_1 = 4
    lgpl_3_0 = 5
    bsd = 6
    mitX11 = 7
    artistic = 8
    gpl_2_0Only = 9
    gpl_3_0Only = 10
    lgpl_2_1Only = 11
    lgpl_3_0Only = 12
    agpl_3_0 = 13
    agpl_3_0Only = 14
    bsd_3 = 15
    apache_2_0 = 16
    mpl_2_0 = 17

proc gtk_about_dialog_get_license_type(self: ptr AboutDialog00): License {.
    importc, libprag.}

proc getLicenseType*(self: AboutDialog): License =
  gtk_about_dialog_get_license_type(cast[ptr AboutDialog00](self.impl))

proc licenseType*(self: AboutDialog): License =
  gtk_about_dialog_get_license_type(cast[ptr AboutDialog00](self.impl))

proc gtk_about_dialog_set_license_type(self: ptr AboutDialog00; licenseType: License) {.
    importc, libprag.}

proc setLicenseType*(self: AboutDialog; licenseType: License) =
  gtk_about_dialog_set_license_type(cast[ptr AboutDialog00](self.impl), licenseType)

proc `licenseType=`*(self: AboutDialog; licenseType: License) =
  gtk_about_dialog_set_license_type(cast[ptr AboutDialog00](self.impl), licenseType)

type
  IconSet00* {.pure.} = object
  IconSet* = ref object
    impl*: ptr IconSet00
    ignoreFinalizer*: bool

proc gtk_icon_set_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkIconSet*(self: IconSet) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_icon_set_get_type(), cast[ptr IconSet00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconSet()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_icon_set_get_type(), cast[ptr IconSet00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var IconSet) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkIconSet)

proc gtk_icon_set_unref(self: ptr IconSet00) {.
    importc, libprag.}

proc unref*(self: IconSet) =
  gtk_icon_set_unref(cast[ptr IconSet00](self.impl))

proc finalizerunref*(self: IconSet) =
  if not self.ignoreFinalizer:
    gtk_icon_set_unref(cast[ptr IconSet00](self.impl))

proc gtk_icon_set_new_from_pixbuf(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr IconSet00 {.
    importc, libprag.}

proc newIconSetFromPixbuf*(pixbuf: gdkpixbuf.Pixbuf): IconSet {.deprecated.}  =
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc newIconSetFromPixbuf*(tdesc: typedesc; pixbuf: gdkpixbuf.Pixbuf): tdesc {.deprecated.}  =
  assert(result is IconSet)
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc initIconSetFromPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf) {.deprecated.} =
  assert(result is IconSet)
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_icon_set_copy(self: ptr IconSet00): ptr IconSet00 {.
    importc, libprag.}

proc copy*(self: IconSet): IconSet =
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_copy(cast[ptr IconSet00](self.impl))

proc gtk_icon_set_ref(self: ptr IconSet00): ptr IconSet00 {.
    importc, libprag.}

proc `ref`*(self: IconSet): IconSet =
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_ref(cast[ptr IconSet00](self.impl))

proc gtk_icon_set_render_icon(self: ptr IconSet00; style: ptr Style00; direction: TextDirection;
    state: StateType; size: int32; widget: ptr Widget00; detail: cstring): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc renderIcon*(self: IconSet; style: Style = nil; direction: TextDirection;
    state: StateType; size: int; widget: Widget = nil; detail: cstring = nil): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_set_render_icon(cast[ptr IconSet00](self.impl), if style.isNil: nil else: cast[ptr Style00](style.impl), direction, state, int32(size), if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_new(): ptr IconSet00 {.
    importc, libprag.}

proc newIconSet*(): IconSet {.deprecated.}  =
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_new()

proc newIconSet*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is IconSet)
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_new()

proc initIconSet*[T](result: var T) {.deprecated.} =
  assert(result is IconSet)
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_set_new()

proc gtk_style_lookup_icon_set(self: ptr Style00; stockId: cstring): ptr IconSet00 {.
    importc, libprag.}

proc lookupIconSet*(self: Style; stockId: cstring): IconSet =
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_style_lookup_icon_set(cast[ptr Style00](self.impl), stockId)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_icon_set_get_type(), result.impl))

type
  IconSource00* {.pure.} = object
  IconSource* = ref object
    impl*: ptr IconSource00
    ignoreFinalizer*: bool

proc gtk_icon_source_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkIconSource*(self: IconSource) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_icon_source_get_type(), cast[ptr IconSource00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconSource()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_icon_source_get_type(), cast[ptr IconSource00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var IconSource) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkIconSource)

proc gtk_icon_source_free(self: ptr IconSource00) {.
    importc, libprag.}

proc free*(self: IconSource) =
  gtk_icon_source_free(cast[ptr IconSource00](self.impl))

proc finalizerfree*(self: IconSource) =
  if not self.ignoreFinalizer:
    gtk_icon_source_free(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_copy(self: ptr IconSource00): ptr IconSource00 {.
    importc, libprag.}

proc copy*(self: IconSource): IconSource =
  fnew(result, gBoxedFreeGtkIconSource)
  result.impl = gtk_icon_source_copy(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_new(): ptr IconSource00 {.
    importc, libprag.}

proc newIconSource*(): IconSource {.deprecated.}  =
  fnew(result, gBoxedFreeGtkIconSource)
  result.impl = gtk_icon_source_new()

proc newIconSource*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is IconSource)
  fnew(result, gBoxedFreeGtkIconSource)
  result.impl = gtk_icon_source_new()

proc initIconSource*[T](result: var T) {.deprecated.} =
  assert(result is IconSource)
  fnew(result, gBoxedFreeGtkIconSource)
  result.impl = gtk_icon_source_new()

proc gtk_icon_source_get_direction(self: ptr IconSource00): TextDirection {.
    importc, libprag.}

proc getDirection*(self: IconSource): TextDirection =
  gtk_icon_source_get_direction(cast[ptr IconSource00](self.impl))

proc direction*(self: IconSource): TextDirection =
  gtk_icon_source_get_direction(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_direction_wildcarded(self: ptr IconSource00): gboolean {.
    importc, libprag.}

proc getDirectionWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_direction_wildcarded(cast[ptr IconSource00](self.impl)))

proc directionWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_direction_wildcarded(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_get_filename(self: ptr IconSource00): cstring {.
    importc, libprag.}

proc getFilename*(self: IconSource): string =
  result = $gtk_icon_source_get_filename(cast[ptr IconSource00](self.impl))

proc filename*(self: IconSource): string =
  result = $gtk_icon_source_get_filename(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_icon_name(self: ptr IconSource00): cstring {.
    importc, libprag.}

proc getIconName*(self: IconSource): string =
  result = $gtk_icon_source_get_icon_name(cast[ptr IconSource00](self.impl))

proc iconName*(self: IconSource): string =
  result = $gtk_icon_source_get_icon_name(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_pixbuf(self: ptr IconSource00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPixbuf*(self: IconSource): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_source_get_pixbuf(cast[ptr IconSource00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: IconSource): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_source_get_pixbuf(cast[ptr IconSource00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_source_get_size(self: ptr IconSource00): int32 {.
    importc, libprag.}

proc getSize*(self: IconSource): int =
  int(gtk_icon_source_get_size(cast[ptr IconSource00](self.impl)))

proc size*(self: IconSource): int =
  int(gtk_icon_source_get_size(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_get_size_wildcarded(self: ptr IconSource00): gboolean {.
    importc, libprag.}

proc getSizeWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_size_wildcarded(cast[ptr IconSource00](self.impl)))

proc sizeWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_size_wildcarded(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_get_state(self: ptr IconSource00): StateType {.
    importc, libprag.}

proc getState*(self: IconSource): StateType =
  gtk_icon_source_get_state(cast[ptr IconSource00](self.impl))

proc state*(self: IconSource): StateType =
  gtk_icon_source_get_state(cast[ptr IconSource00](self.impl))

proc gtk_icon_source_get_state_wildcarded(self: ptr IconSource00): gboolean {.
    importc, libprag.}

proc getStateWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_state_wildcarded(cast[ptr IconSource00](self.impl)))

proc stateWildcarded*(self: IconSource): bool =
  toBool(gtk_icon_source_get_state_wildcarded(cast[ptr IconSource00](self.impl)))

proc gtk_icon_source_set_direction(self: ptr IconSource00; direction: TextDirection) {.
    importc, libprag.}

proc setDirection*(self: IconSource; direction: TextDirection) =
  gtk_icon_source_set_direction(cast[ptr IconSource00](self.impl), direction)

proc `direction=`*(self: IconSource; direction: TextDirection) =
  gtk_icon_source_set_direction(cast[ptr IconSource00](self.impl), direction)

proc gtk_icon_source_set_direction_wildcarded(self: ptr IconSource00; setting: gboolean) {.
    importc, libprag.}

proc setDirectionWildcarded*(self: IconSource; setting: bool = true) =
  gtk_icon_source_set_direction_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc `directionWildcarded=`*(self: IconSource; setting: bool) =
  gtk_icon_source_set_direction_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc gtk_icon_source_set_filename(self: ptr IconSource00; filename: cstring) {.
    importc, libprag.}

proc setFilename*(self: IconSource; filename: cstring) =
  gtk_icon_source_set_filename(cast[ptr IconSource00](self.impl), filename)

proc `filename=`*(self: IconSource; filename: cstring) =
  gtk_icon_source_set_filename(cast[ptr IconSource00](self.impl), filename)

proc gtk_icon_source_set_icon_name(self: ptr IconSource00; iconName: cstring) {.
    importc, libprag.}

proc setIconName*(self: IconSource; iconName: cstring = nil) =
  gtk_icon_source_set_icon_name(cast[ptr IconSource00](self.impl), iconName)

proc `iconName=`*(self: IconSource; iconName: cstring = nil) =
  gtk_icon_source_set_icon_name(cast[ptr IconSource00](self.impl), iconName)

proc gtk_icon_source_set_pixbuf(self: ptr IconSource00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setPixbuf*(self: IconSource; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_icon_source_set_pixbuf(cast[ptr IconSource00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `pixbuf=`*(self: IconSource; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_icon_source_set_pixbuf(cast[ptr IconSource00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_icon_source_set_size(self: ptr IconSource00; size: int32) {.
    importc, libprag.}

proc setSize*(self: IconSource; size: int) =
  gtk_icon_source_set_size(cast[ptr IconSource00](self.impl), int32(size))

proc `size=`*(self: IconSource; size: int) =
  gtk_icon_source_set_size(cast[ptr IconSource00](self.impl), int32(size))

proc gtk_icon_source_set_size_wildcarded(self: ptr IconSource00; setting: gboolean) {.
    importc, libprag.}

proc setSizeWildcarded*(self: IconSource; setting: bool = true) =
  gtk_icon_source_set_size_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc `sizeWildcarded=`*(self: IconSource; setting: bool) =
  gtk_icon_source_set_size_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc gtk_icon_source_set_state(self: ptr IconSource00; state: StateType) {.
    importc, libprag.}

proc setState*(self: IconSource; state: StateType) =
  gtk_icon_source_set_state(cast[ptr IconSource00](self.impl), state)

proc `state=`*(self: IconSource; state: StateType) =
  gtk_icon_source_set_state(cast[ptr IconSource00](self.impl), state)

proc gtk_icon_source_set_state_wildcarded(self: ptr IconSource00; setting: gboolean) {.
    importc, libprag.}

proc setStateWildcarded*(self: IconSource; setting: bool = true) =
  gtk_icon_source_set_state_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc `stateWildcarded=`*(self: IconSource; setting: bool) =
  gtk_icon_source_set_state_wildcarded(cast[ptr IconSource00](self.impl), gboolean(setting))

proc gtk_style_render_icon(self: ptr Style00; source: ptr IconSource00; direction: TextDirection;
    state: StateType; size: int32; widget: ptr Widget00; detail: cstring): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc renderIcon*(self: Style; source: IconSource; direction: TextDirection;
    state: StateType; size: int; widget: Widget = nil; detail: cstring = nil): gdkpixbuf.Pixbuf =
  let gobj = gtk_style_render_icon(cast[ptr Style00](self.impl), cast[ptr IconSource00](source.impl), direction, state, int32(size), if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_add_source(self: ptr IconSet00; source: ptr IconSource00) {.
    importc, libprag.}

proc addSource*(self: IconSet; source: IconSource) =
  gtk_icon_set_add_source(cast[ptr IconSet00](self.impl), cast[ptr IconSource00](source.impl))

type
  Orientation* {.size: sizeof(cint), pure.} = enum
    horizontal = 0
    vertical = 1

proc gtk_widget_compute_expand(self: ptr Widget00; orientation: Orientation): gboolean {.
    importc, libprag.}

proc computeExpand*(self: Widget; orientation: Orientation): bool =
  toBool(gtk_widget_compute_expand(cast[ptr Widget00](self.impl), orientation))

proc gtk_box_new(orientation: Orientation; spacing: int32): ptr Box00 {.
    importc, libprag.}

proc newBox*(orientation: Orientation; spacing: int = 0): Box =
  let gobj = gtk_box_new(orientation, int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBox*(tdesc: typedesc; orientation: Orientation; spacing: int = 0): tdesc =
  assert(result is Box)
  let gobj = gtk_box_new(orientation, int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBox*[T](result: var T; orientation: Orientation; spacing: int = 0) {.deprecated.} =
  assert(result is Box)
  let gobj = gtk_box_new(orientation, int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  DestFlag* {.size: sizeof(cint), pure.} = enum
    motion = 0
    highlight = 1
    drop = 2

  DestDefaults* {.size: sizeof(cint).} = set[DestFlag]

type
  TargetEntry00* {.pure.} = object
    target*: cstring
    flags*: uint32
    info*: uint32
  TargetEntry* = ref object
    impl*: ptr TargetEntry00
    ignoreFinalizer*: bool

proc gtk_target_entry_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkTargetEntry*(self: TargetEntry) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_target_entry_get_type(), cast[ptr TargetEntry00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TargetEntry()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_target_entry_get_type(), cast[ptr TargetEntry00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var TargetEntry) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkTargetEntry)

proc seq2TargetEntryArray(s: openarray[TargetEntry]; a: var cstringArray):  ptr TargetEntry00 =
  assert s.high < 256
  let x = cast[ptr UncheckedArray[ptr TargetEntry00]](a)
  for i, o in s:
    x[i] = o.impl
  return cast[ptr TargetEntry00](x)

proc newTargetEntry*(target: cstring; flags: int; info: int): TargetEntry

proc priv_target_table_free(targets: ptr TargetEntry00; nTargets: int32) {.importc: "gtk_target_table_free", libprag.}

proc targetEntryArrayToSeq(s: ptr TargetEntry00; n: int):  seq[TargetEntry] =
  let a = cast[ptr UncheckedArray[ptr TargetEntry00]](s)
  for i in 0 ..< n:
    result.add(newTargetEntry(a[i].target,  a[i].flags.int, a[i].info.int))
  priv_target_table_free(s, n.int32)



proc gtk_target_entry_free(self: ptr TargetEntry00) {.
    importc, libprag.}

proc free*(self: TargetEntry) =
  gtk_target_entry_free(cast[ptr TargetEntry00](self.impl))

proc finalizerfree*(self: TargetEntry) =
  if not self.ignoreFinalizer:
    gtk_target_entry_free(cast[ptr TargetEntry00](self.impl))

proc gtk_target_entry_copy(self: ptr TargetEntry00): ptr TargetEntry00 {.
    importc, libprag.}

proc copy*(self: TargetEntry): TargetEntry =
  fnew(result, gBoxedFreeGtkTargetEntry)
  result.impl = gtk_target_entry_copy(cast[ptr TargetEntry00](self.impl))

proc gtk_target_entry_new(target: cstring; flags: uint32; info: uint32): ptr TargetEntry00 {.
    importc, libprag.}

proc newTargetEntry*(target: cstring; flags: int; info: int): TargetEntry =
  fnew(result, gBoxedFreeGtkTargetEntry)
  result.impl = gtk_target_entry_new(target, uint32(flags), uint32(info))

proc newTargetEntry*(tdesc: typedesc; target: cstring; flags: int; info: int): tdesc =
  assert(result is TargetEntry)
  fnew(result, gBoxedFreeGtkTargetEntry)
  result.impl = gtk_target_entry_new(target, uint32(flags), uint32(info))

proc initTargetEntry*[T](result: var T; target: cstring; flags: int; info: int) {.deprecated.} =
  assert(result is TargetEntry)
  fnew(result, gBoxedFreeGtkTargetEntry)
  result.impl = gtk_target_entry_new(target, uint32(flags), uint32(info))

proc gtk_drag_dest_set(self: ptr Widget00; flags: DestDefaults; targets: ptr TargetEntry00;
    nTargets: int32; actions: gdk.DragAction) {.
    importc, libprag.}

proc dragDestSet*(self: Widget; flags: DestDefaults; targets: seq[TargetEntry];
    actions: gdk.DragAction) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_drag_dest_set(cast[ptr Widget00](self.impl), flags, seq2TargetEntryArray(targets, fs469n23), int32(nTargets), actions)

proc gtk_drag_source_set(self: ptr Widget00; startButtonMask: gdk.ModifierType;
    targets: ptr TargetEntry00; nTargets: int32; actions: gdk.DragAction) {.
    importc, libprag.}

proc dragSourceSet*(self: Widget; startButtonMask: gdk.ModifierType;
    targets: seq[TargetEntry]; actions: gdk.DragAction) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_drag_source_set(cast[ptr Widget00](self.impl), startButtonMask, seq2TargetEntryArray(targets, fs469n23), int32(nTargets), actions)

type
  TargetList00* {.pure.} = object
  TargetList* = ref object
    impl*: ptr TargetList00
    ignoreFinalizer*: bool

proc gtk_target_list_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkTargetList*(self: TargetList) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_target_list_get_type(), cast[ptr TargetList00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TargetList()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_target_list_get_type(), cast[ptr TargetList00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var TargetList) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkTargetList)

proc gtk_target_list_unref(self: ptr TargetList00) {.
    importc, libprag.}

proc unref*(self: TargetList) =
  gtk_target_list_unref(cast[ptr TargetList00](self.impl))

proc finalizerunref*(self: TargetList) =
  if not self.ignoreFinalizer:
    gtk_target_list_unref(cast[ptr TargetList00](self.impl))

proc gtk_target_list_add(self: ptr TargetList00; target: ptr gdk.Atom00;
    flags: uint32; info: uint32) {.
    importc, libprag.}

proc add*(self: TargetList; target: gdk.Atom; flags: int;
    info: int) =
  gtk_target_list_add(cast[ptr TargetList00](self.impl), cast[ptr gdk.Atom00](target.impl), uint32(flags), uint32(info))

proc gtk_target_list_add_image_targets(self: ptr TargetList00; info: uint32;
    writable: gboolean) {.
    importc, libprag.}

proc addImageTargets*(self: TargetList; info: int; writable: bool) =
  gtk_target_list_add_image_targets(cast[ptr TargetList00](self.impl), uint32(info), gboolean(writable))

proc gtk_target_list_add_table(self: ptr TargetList00; targets: ptr TargetEntry00;
    ntargets: uint32) {.
    importc, libprag.}

proc addTable*(self: TargetList; targets: seq[TargetEntry]) =
  let ntargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_target_list_add_table(cast[ptr TargetList00](self.impl), seq2TargetEntryArray(targets, fs469n23), uint32(ntargets))

proc gtk_target_list_add_text_targets(self: ptr TargetList00; info: uint32) {.
    importc, libprag.}

proc addTextTargets*(self: TargetList; info: int) =
  gtk_target_list_add_text_targets(cast[ptr TargetList00](self.impl), uint32(info))

proc gtk_target_list_add_uri_targets(self: ptr TargetList00; info: uint32) {.
    importc, libprag.}

proc addUriTargets*(self: TargetList; info: int) =
  gtk_target_list_add_uri_targets(cast[ptr TargetList00](self.impl), uint32(info))

proc gtk_target_list_find(self: ptr TargetList00; target: ptr gdk.Atom00;
    info: var uint32): gboolean {.
    importc, libprag.}

proc findTargetList*(self: TargetList; target: gdk.Atom; info: var int = cast[var int](nil)): bool =
  var info_00: uint32
  result = toBool(gtk_target_list_find(cast[ptr TargetList00](self.impl), cast[ptr gdk.Atom00](target.impl), info_00))
  if info.addr != nil:
    info = int(info_00)

proc gtk_target_list_ref(self: ptr TargetList00): ptr TargetList00 {.
    importc, libprag.}

proc `ref`*(self: TargetList): TargetList =
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_target_list_ref(cast[ptr TargetList00](self.impl))

proc gtk_target_list_remove(self: ptr TargetList00; target: ptr gdk.Atom00) {.
    importc, libprag.}

proc remove*(self: TargetList; target: gdk.Atom) =
  gtk_target_list_remove(cast[ptr TargetList00](self.impl), cast[ptr gdk.Atom00](target.impl))

proc gtk_target_list_new(targets: ptr TargetEntry00; ntargets: uint32): ptr TargetList00 {.
    importc, libprag.}

proc newTargetList*(targets: seq[TargetEntry]): TargetList =
  let ntargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_target_list_new(seq2TargetEntryArray(targets, fs469n23), uint32(ntargets))

proc newTargetList*(tdesc: typedesc; targets: seq[TargetEntry]): tdesc =
  let ntargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is TargetList)
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_target_list_new(seq2TargetEntryArray(targets, fs469n23), uint32(ntargets))

proc initTargetList*[T](result: var T; targets: seq[TargetEntry]) {.deprecated.} =
  let ntargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is TargetList)
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_target_list_new(seq2TargetEntryArray(targets, fs469n23), uint32(ntargets))

proc gtk_drag_begin(self: ptr Widget00; targets: ptr TargetList00; actions: gdk.DragAction;
    button: int32; event: ptr gdk.Event00): ptr gdk.DragContext00 {.
    importc, libprag.}

proc dragBegin*(self: Widget; targets: TargetList; actions: gdk.DragAction;
    button: int; event: gdk.Event = nil): gdk.DragContext =
  let gobj = gtk_drag_begin(cast[ptr Widget00](self.impl), cast[ptr TargetList00](targets.impl), actions, int32(button), if event.isNil: nil else: cast[ptr gdk.Event00](event.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_begin_with_coordinates(self: ptr Widget00; targets: ptr TargetList00;
    actions: gdk.DragAction; button: int32; event: ptr gdk.Event00; x: int32;
    y: int32): ptr gdk.DragContext00 {.
    importc, libprag.}

proc dragBeginWithCoordinates*(self: Widget; targets: TargetList; actions: gdk.DragAction;
    button: int; event: gdk.Event = nil; x: int; y: int): gdk.DragContext =
  let gobj = gtk_drag_begin_with_coordinates(cast[ptr Widget00](self.impl), cast[ptr TargetList00](targets.impl), actions, int32(button), if event.isNil: nil else: cast[ptr gdk.Event00](event.impl), int32(x), int32(y))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_dest_find_target(self: ptr Widget00; context: ptr gdk.DragContext00;
    targetList: ptr TargetList00): ptr gdk.Atom00 {.
    importc, libprag.}

proc dragDestFindTarget*(self: Widget; context: gdk.DragContext; targetList: TargetList = nil): gdk.Atom =
  new(result)
  result.impl = gtk_drag_dest_find_target(cast[ptr Widget00](self.impl), cast[ptr gdk.DragContext00](context.impl), if targetList.isNil: nil else: cast[ptr TargetList00](targetList.impl))
  result.ignoreFinalizer = true

proc gtk_drag_dest_get_target_list(self: ptr Widget00): ptr TargetList00 {.
    importc, libprag.}

proc dragDestGetTargetList*(self: Widget): TargetList =
  let impl0 = gtk_drag_dest_get_target_list(cast[ptr Widget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_list_get_type(), impl0))

proc gtk_drag_dest_set_target_list(self: ptr Widget00; targetList: ptr TargetList00) {.
    importc, libprag.}

proc dragDestSetTargetList*(self: Widget; targetList: TargetList = nil) =
  gtk_drag_dest_set_target_list(cast[ptr Widget00](self.impl), if targetList.isNil: nil else: cast[ptr TargetList00](targetList.impl))

proc gtk_drag_source_get_target_list(self: ptr Widget00): ptr TargetList00 {.
    importc, libprag.}

proc dragSourceGetTargetList*(self: Widget): TargetList =
  let impl0 = gtk_drag_source_get_target_list(cast[ptr Widget00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_list_get_type(), impl0))

proc gtk_drag_source_set_target_list(self: ptr Widget00; targetList: ptr TargetList00) {.
    importc, libprag.}

proc dragSourceSetTargetList*(self: Widget; targetList: TargetList = nil) =
  gtk_drag_source_set_target_list(cast[ptr Widget00](self.impl), if targetList.isNil: nil else: cast[ptr TargetList00](targetList.impl))

type
  Clipboard* = ref object of gobject.Object
  Clipboard00* = object of gobject.Object00

proc gtk_clipboard_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Clipboard()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scOwnerChange*(self: Clipboard;  p: proc (self: ptr Clipboard00; event: ptr gdk.EventOwnerChange00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "owner-change", cast[GCallback](p), xdata, nil, cf)

proc gtk_clipboard_get(selection: ptr gdk.Atom00): ptr Clipboard00 {.
    importc, libprag.}

proc getClipboard*(selection: gdk.Atom): Clipboard =
  let gobj = gtk_clipboard_get(cast[ptr gdk.Atom00](selection.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc clipboard*(selection: gdk.Atom): Clipboard =
  let gobj = gtk_clipboard_get(cast[ptr gdk.Atom00](selection.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_get_default(display: ptr gdk.Display00): ptr Clipboard00 {.
    importc, libprag.}

proc getDefaultClipboard*(display: gdk.Display): Clipboard =
  let gobj = gtk_clipboard_get_default(cast[ptr gdk.Display00](display.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultClipboard*(display: gdk.Display): Clipboard =
  let gobj = gtk_clipboard_get_default(cast[ptr gdk.Display00](display.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_get_for_display(display: ptr gdk.Display00; selection: ptr gdk.Atom00): ptr Clipboard00 {.
    importc, libprag.}

proc getForDisplay*(display: gdk.Display; selection: gdk.Atom): Clipboard =
  let gobj = gtk_clipboard_get_for_display(cast[ptr gdk.Display00](display.impl), cast[ptr gdk.Atom00](selection.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_clear(self: ptr Clipboard00) {.
    importc, libprag.}

proc clear*(self: Clipboard) =
  gtk_clipboard_clear(cast[ptr Clipboard00](self.impl))

proc gtk_clipboard_get_display(self: ptr Clipboard00): ptr gdk.Display00 {.
    importc, libprag.}

proc getDisplay*(self: Clipboard): gdk.Display =
  let gobj = gtk_clipboard_get_display(cast[ptr Clipboard00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc display*(self: Clipboard): gdk.Display =
  let gobj = gtk_clipboard_get_display(cast[ptr Clipboard00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_get_owner(self: ptr Clipboard00): ptr gobject.Object00 {.
    importc, libprag.}

proc getOwner*(self: Clipboard): gobject.Object =
  let gobj = gtk_clipboard_get_owner(cast[ptr Clipboard00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc owner*(self: Clipboard): gobject.Object =
  let gobj = gtk_clipboard_get_owner(cast[ptr Clipboard00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_set_can_store(self: ptr Clipboard00; targets: ptr TargetEntry00;
    nTargets: int32) {.
    importc, libprag.}

proc setCanStore*(self: Clipboard; targets: seq[TargetEntry]) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_clipboard_set_can_store(cast[ptr Clipboard00](self.impl), seq2TargetEntryArray(targets, fs469n23), int32(nTargets))

proc gtk_clipboard_set_image(self: ptr Clipboard00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setImage*(self: Clipboard; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_clipboard_set_image(cast[ptr Clipboard00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `image=`*(self: Clipboard; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_clipboard_set_image(cast[ptr Clipboard00](self.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_clipboard_set_text(self: ptr Clipboard00; text: cstring; len: int32) {.
    importc, libprag.}

proc setText*(self: Clipboard; text: cstring; len: int) =
  gtk_clipboard_set_text(cast[ptr Clipboard00](self.impl), text, int32(len))

proc gtk_clipboard_store(self: ptr Clipboard00) {.
    importc, libprag.}

proc store*(self: Clipboard) =
  gtk_clipboard_store(cast[ptr Clipboard00](self.impl))

proc gtk_clipboard_wait_for_contents(self: ptr Clipboard00; target: ptr gdk.Atom00): ptr SelectionData00 {.
    importc, libprag.}

proc waitForContents*(self: Clipboard; target: gdk.Atom): SelectionData =
  let impl0 = gtk_clipboard_wait_for_contents(cast[ptr Clipboard00](self.impl), cast[ptr gdk.Atom00](target.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkSelectionData)
  result.impl = impl0

proc gtk_clipboard_wait_for_image(self: ptr Clipboard00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc waitForImage*(self: Clipboard): gdkpixbuf.Pixbuf =
  let gobj = gtk_clipboard_wait_for_image(cast[ptr Clipboard00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_clipboard_wait_for_targets(self: ptr Clipboard00; targets: var ptr ptr gdk.Atom00;
    nTargets: var int32): gboolean {.
    importc, libprag.}

proc waitForTargets*(self: Clipboard; targets: var ptr ptr gdk.Atom00;
    nTargets: var int): bool =
  var nTargets_00: int32
  result = toBool(gtk_clipboard_wait_for_targets(cast[ptr Clipboard00](self.impl), targets, nTargets_00))
  if nTargets.addr != nil:
    nTargets = int(nTargets_00)

proc gtk_clipboard_wait_for_text(self: ptr Clipboard00): cstring {.
    importc, libprag.}

proc waitForText*(self: Clipboard): string =
  let resul0 = gtk_clipboard_wait_for_text(cast[ptr Clipboard00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_clipboard_wait_for_uris(self: ptr Clipboard00): ptr cstring {.
    importc, libprag.}

proc waitForUris*(self: Clipboard): seq[string] =
  let resul0 = gtk_clipboard_wait_for_uris(cast[ptr Clipboard00](self.impl))
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_clipboard_wait_is_image_available(self: ptr Clipboard00): gboolean {.
    importc, libprag.}

proc waitIsImageAvailable*(self: Clipboard): bool =
  toBool(gtk_clipboard_wait_is_image_available(cast[ptr Clipboard00](self.impl)))

proc gtk_clipboard_wait_is_target_available(self: ptr Clipboard00; target: ptr gdk.Atom00): gboolean {.
    importc, libprag.}

proc waitIsTargetAvailable*(self: Clipboard; target: gdk.Atom): bool =
  toBool(gtk_clipboard_wait_is_target_available(cast[ptr Clipboard00](self.impl), cast[ptr gdk.Atom00](target.impl)))

proc gtk_clipboard_wait_is_text_available(self: ptr Clipboard00): gboolean {.
    importc, libprag.}

proc waitIsTextAvailable*(self: Clipboard): bool =
  toBool(gtk_clipboard_wait_is_text_available(cast[ptr Clipboard00](self.impl)))

proc gtk_clipboard_wait_is_uris_available(self: ptr Clipboard00): gboolean {.
    importc, libprag.}

proc waitIsUrisAvailable*(self: Clipboard): bool =
  toBool(gtk_clipboard_wait_is_uris_available(cast[ptr Clipboard00](self.impl)))

proc gtk_widget_get_clipboard(self: ptr Widget00; selection: ptr gdk.Atom00): ptr Clipboard00 {.
    importc, libprag.}

proc getClipboard*(self: Widget; selection: gdk.Atom): Clipboard =
  let gobj = gtk_widget_get_clipboard(cast[ptr Widget00](self.impl), cast[ptr gdk.Atom00](selection.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SizeRequestMode* {.size: sizeof(cint), pure.} = enum
    heightForWidth = 0
    widthForHeight = 1
    constantSize = 2

proc gtk_widget_get_request_mode(self: ptr Widget00): SizeRequestMode {.
    importc, libprag.}

proc getRequestMode*(self: Widget): SizeRequestMode =
  gtk_widget_get_request_mode(cast[ptr Widget00](self.impl))

proc requestMode*(self: Widget): SizeRequestMode =
  gtk_widget_get_request_mode(cast[ptr Widget00](self.impl))

type
  Settings* = ref object of gobject.Object
  Settings00* = object of gobject.Object00

proc gtk_settings_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Settings()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_settings_get_default(): ptr Settings00 {.
    importc, libprag.}

proc getDefaultSettings*(): Settings =
  let gobj = gtk_settings_get_default()
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_settings_get_for_screen(screen: ptr gdk.Screen00): ptr Settings00 {.
    importc, libprag.}

proc getSettingsForScreen*(screen: gdk.Screen): Settings =
  let gobj = gtk_settings_get_for_screen(cast[ptr gdk.Screen00](screen.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_settings_install_property(pspec: ptr gobject.ParamSpec00) {.
    importc, libprag.}

proc installProperty*(pspec: gobject.ParamSpec) =
  gtk_settings_install_property(cast[ptr gobject.ParamSpec00](pspec.impl))

proc gtk_settings_reset_property(self: ptr Settings00; name: cstring) {.
    importc, libprag.}

proc resetProperty*(self: Settings; name: cstring) =
  gtk_settings_reset_property(cast[ptr Settings00](self.impl), name)

proc gtk_settings_set_double_property(self: ptr Settings00; name: cstring;
    vDouble: cdouble; origin: cstring) {.
    importc, libprag.}

proc setDoubleProperty*(self: Settings; name: cstring; vDouble: cdouble;
    origin: cstring) =
  gtk_settings_set_double_property(cast[ptr Settings00](self.impl), name, vDouble, origin)

proc gtk_settings_set_long_property(self: ptr Settings00; name: cstring;
    vLong: int64; origin: cstring) {.
    importc, libprag.}

proc setLongProperty*(self: Settings; name: cstring; vLong: int64;
    origin: cstring) =
  gtk_settings_set_long_property(cast[ptr Settings00](self.impl), name, vLong, origin)

proc gtk_settings_set_string_property(self: ptr Settings00; name: cstring;
    vString: cstring; origin: cstring) {.
    importc, libprag.}

proc setStringProperty*(self: Settings; name: cstring; vString: cstring;
    origin: cstring) =
  gtk_settings_set_string_property(cast[ptr Settings00](self.impl), name, vString, origin)

proc gtk_widget_get_settings(self: ptr Widget00): ptr Settings00 {.
    importc, libprag.}

proc getSettings*(self: Widget): Settings =
  let gobj = gtk_widget_get_settings(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SettingsValue* {.pure, byRef.} = object
    origin*: cstring
    value*: gobject.Value

proc gtk_settings_set_property_value(self: ptr Settings00; name: cstring;
    svalue: SettingsValue) {.
    importc, libprag.}

proc setPropertyValue*(self: Settings; name: cstring; svalue: SettingsValue) =
  gtk_settings_set_property_value(cast[ptr Settings00](self.impl), name, svalue)

type
  StyleContext* = ref object of gobject.Object
  StyleContext00* = object of gobject.Object00

proc gtk_style_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StyleContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: StyleContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_style_context_new(): ptr StyleContext00 {.
    importc, libprag.}

proc newStyleContext*(): StyleContext =
  let gobj = gtk_style_context_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStyleContext*(tdesc: typedesc): tdesc =
  assert(result is StyleContext)
  let gobj = gtk_style_context_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStyleContext*[T](result: var T) {.deprecated.} =
  assert(result is StyleContext)
  let gobj = gtk_style_context_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_reset_widgets(screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc resetWidgets*(screen: gdk.Screen) =
  gtk_style_context_reset_widgets(cast[ptr gdk.Screen00](screen.impl))

proc gtk_style_context_add_class(self: ptr StyleContext00; className: cstring) {.
    importc, libprag.}

proc addClass*(self: StyleContext; className: cstring) =
  gtk_style_context_add_class(cast[ptr StyleContext00](self.impl), className)

proc gtk_style_context_cancel_animations(self: ptr StyleContext00; regionId: pointer) {.
    importc, libprag.}

proc cancelAnimations*(self: StyleContext; regionId: pointer) =
  gtk_style_context_cancel_animations(cast[ptr StyleContext00](self.impl), regionId)

proc gtk_style_context_get_background_color(self: ptr StyleContext00; state: StateFlags;
    color: var gdk.RGBA) {.
    importc, libprag.}

proc getBackgroundColor*(self: StyleContext; state: StateFlags;
    color: var gdk.RGBA) =
  gtk_style_context_get_background_color(cast[ptr StyleContext00](self.impl), state, color)

proc gtk_style_context_get_border_color(self: ptr StyleContext00; state: StateFlags;
    color: var gdk.RGBA) {.
    importc, libprag.}

proc getBorderColor*(self: StyleContext; state: StateFlags;
    color: var gdk.RGBA) =
  gtk_style_context_get_border_color(cast[ptr StyleContext00](self.impl), state, color)

proc gtk_style_context_get_color(self: ptr StyleContext00; state: StateFlags;
    color: var gdk.RGBA) {.
    importc, libprag.}

proc getColor*(self: StyleContext; state: StateFlags; color: var gdk.RGBA) =
  gtk_style_context_get_color(cast[ptr StyleContext00](self.impl), state, color)

proc gtk_style_context_get_direction(self: ptr StyleContext00): TextDirection {.
    importc, libprag.}

proc getDirection*(self: StyleContext): TextDirection =
  gtk_style_context_get_direction(cast[ptr StyleContext00](self.impl))

proc direction*(self: StyleContext): TextDirection =
  gtk_style_context_get_direction(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_get_font(self: ptr StyleContext00; state: StateFlags): ptr pango.FontDescription00 {.
    importc, libprag.}

proc getFont*(self: StyleContext; state: StateFlags): pango.FontDescription =
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = gtk_style_context_get_font(cast[ptr StyleContext00](self.impl), state)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_font_description_get_type(), result.impl))

proc gtk_style_context_get_frame_clock(self: ptr StyleContext00): ptr gdk.FrameClock00 {.
    importc, libprag.}

proc getFrameClock*(self: StyleContext): gdk.FrameClock =
  let gobj = gtk_style_context_get_frame_clock(cast[ptr StyleContext00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc frameClock*(self: StyleContext): gdk.FrameClock =
  let gobj = gtk_style_context_get_frame_clock(cast[ptr StyleContext00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_get_parent(self: ptr StyleContext00): ptr StyleContext00 {.
    importc, libprag.}

proc getParent*(self: StyleContext): StyleContext =
  let gobj = gtk_style_context_get_parent(cast[ptr StyleContext00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: StyleContext): StyleContext =
  let gobj = gtk_style_context_get_parent(cast[ptr StyleContext00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_get_property(self: ptr StyleContext00; property: cstring;
    state: StateFlags; value: var gobject.Value) {.
    importc, libprag.}

proc getProperty*(self: StyleContext; property: cstring;
    state: StateFlags; value: var gobject.Value) =
  gtk_style_context_get_property(cast[ptr StyleContext00](self.impl), property, state, value)

proc gtk_style_context_get_scale(self: ptr StyleContext00): int32 {.
    importc, libprag.}

proc getScale*(self: StyleContext): int =
  int(gtk_style_context_get_scale(cast[ptr StyleContext00](self.impl)))

proc scale*(self: StyleContext): int =
  int(gtk_style_context_get_scale(cast[ptr StyleContext00](self.impl)))

proc gtk_style_context_get_screen(self: ptr StyleContext00): ptr gdk.Screen00 {.
    importc, libprag.}

proc getScreen*(self: StyleContext): gdk.Screen =
  let gobj = gtk_style_context_get_screen(cast[ptr StyleContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: StyleContext): gdk.Screen =
  let gobj = gtk_style_context_get_screen(cast[ptr StyleContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_context_get_state(self: ptr StyleContext00): StateFlags {.
    importc, libprag.}

proc getState*(self: StyleContext): StateFlags =
  gtk_style_context_get_state(cast[ptr StyleContext00](self.impl))

proc state*(self: StyleContext): StateFlags =
  gtk_style_context_get_state(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_get_style_property(self: ptr StyleContext00; propertyName: cstring;
    value: gobject.Value) {.
    importc, libprag.}

proc getStyleProperty*(self: StyleContext; propertyName: cstring;
    value: gobject.Value) =
  gtk_style_context_get_style_property(cast[ptr StyleContext00](self.impl), propertyName, value)

proc gtk_style_context_has_class(self: ptr StyleContext00; className: cstring): gboolean {.
    importc, libprag.}

proc hasClass*(self: StyleContext; className: cstring): bool =
  toBool(gtk_style_context_has_class(cast[ptr StyleContext00](self.impl), className))

proc gtk_style_context_invalidate(self: ptr StyleContext00) {.
    importc, libprag.}

proc invalidate*(self: StyleContext) =
  gtk_style_context_invalidate(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_list_classes(self: ptr StyleContext00): ptr glib.List {.
    importc, libprag.}

proc listClasses*(self: StyleContext): seq[cstring] =
  let resul0 = gtk_style_context_list_classes(cast[ptr StyleContext00](self.impl))
  g_list_free(resul0)

proc gtk_style_context_list_regions(self: ptr StyleContext00): ptr glib.List {.
    importc, libprag.}

proc listRegions*(self: StyleContext): seq[cstring] =
  let resul0 = gtk_style_context_list_regions(cast[ptr StyleContext00](self.impl))
  g_list_free(resul0)

proc gtk_style_context_lookup_color(self: ptr StyleContext00; colorName: cstring;
    color: var gdk.RGBA): gboolean {.
    importc, libprag.}

proc lookupColor*(self: StyleContext; colorName: cstring;
    color: var gdk.RGBA): bool =
  toBool(gtk_style_context_lookup_color(cast[ptr StyleContext00](self.impl), colorName, color))

proc gtk_style_context_lookup_icon_set(self: ptr StyleContext00; stockId: cstring): ptr IconSet00 {.
    importc, libprag.}

proc lookupIconSet*(self: StyleContext; stockId: cstring): IconSet =
  let impl0 = gtk_style_context_lookup_icon_set(cast[ptr StyleContext00](self.impl), stockId)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_icon_set_get_type(), impl0))

proc gtk_style_context_notify_state_change(self: ptr StyleContext00; window: ptr gdk.Window00;
    regionId: pointer; state: StateType; stateValue: gboolean) {.
    importc, libprag.}

proc notifyStateChange*(self: StyleContext; window: gdk.Window;
    regionId: pointer; state: StateType; stateValue: bool) =
  gtk_style_context_notify_state_change(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl), regionId, state, gboolean(stateValue))

proc gtk_style_context_pop_animatable_region(self: ptr StyleContext00) {.
    importc, libprag.}

proc popAnimatableRegion*(self: StyleContext) =
  gtk_style_context_pop_animatable_region(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_push_animatable_region(self: ptr StyleContext00; regionId: pointer) {.
    importc, libprag.}

proc pushAnimatableRegion*(self: StyleContext; regionId: pointer) =
  gtk_style_context_push_animatable_region(cast[ptr StyleContext00](self.impl), regionId)

proc gtk_style_context_remove_class(self: ptr StyleContext00; className: cstring) {.
    importc, libprag.}

proc removeClass*(self: StyleContext; className: cstring) =
  gtk_style_context_remove_class(cast[ptr StyleContext00](self.impl), className)

proc gtk_style_context_remove_region(self: ptr StyleContext00; regionName: cstring) {.
    importc, libprag.}

proc removeRegion*(self: StyleContext; regionName: cstring) =
  gtk_style_context_remove_region(cast[ptr StyleContext00](self.impl), regionName)

proc gtk_style_context_restore(self: ptr StyleContext00) {.
    importc, libprag.}

proc restore*(self: StyleContext) =
  gtk_style_context_restore(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_save(self: ptr StyleContext00) {.
    importc, libprag.}

proc save*(self: StyleContext) =
  gtk_style_context_save(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_scroll_animations(self: ptr StyleContext00; window: ptr gdk.Window00;
    dx: int32; dy: int32) {.
    importc, libprag.}

proc scrollAnimations*(self: StyleContext; window: gdk.Window;
    dx: int; dy: int) =
  gtk_style_context_scroll_animations(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl), int32(dx), int32(dy))

proc gtk_style_context_set_background(self: ptr StyleContext00; window: ptr gdk.Window00) {.
    importc, libprag.}

proc setBackground*(self: StyleContext; window: gdk.Window) =
  gtk_style_context_set_background(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl))

proc `background=`*(self: StyleContext; window: gdk.Window) =
  gtk_style_context_set_background(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_style_context_set_direction(self: ptr StyleContext00; direction: TextDirection) {.
    importc, libprag.}

proc setDirection*(self: StyleContext; direction: TextDirection) =
  gtk_style_context_set_direction(cast[ptr StyleContext00](self.impl), direction)

proc `direction=`*(self: StyleContext; direction: TextDirection) =
  gtk_style_context_set_direction(cast[ptr StyleContext00](self.impl), direction)

proc gtk_style_context_set_frame_clock(self: ptr StyleContext00; frameClock: ptr gdk.FrameClock00) {.
    importc, libprag.}

proc setFrameClock*(self: StyleContext; frameClock: gdk.FrameClock) =
  gtk_style_context_set_frame_clock(cast[ptr StyleContext00](self.impl), cast[ptr gdk.FrameClock00](frameClock.impl))

proc `frameClock=`*(self: StyleContext; frameClock: gdk.FrameClock) =
  gtk_style_context_set_frame_clock(cast[ptr StyleContext00](self.impl), cast[ptr gdk.FrameClock00](frameClock.impl))

proc gtk_style_context_set_parent(self: ptr StyleContext00; parent: ptr StyleContext00) {.
    importc, libprag.}

proc setParent*(self: StyleContext; parent: StyleContext = nil) =
  gtk_style_context_set_parent(cast[ptr StyleContext00](self.impl), if parent.isNil: nil else: cast[ptr StyleContext00](parent.impl))

proc `parent=`*(self: StyleContext; parent: StyleContext = nil) =
  gtk_style_context_set_parent(cast[ptr StyleContext00](self.impl), if parent.isNil: nil else: cast[ptr StyleContext00](parent.impl))

proc gtk_style_context_set_scale(self: ptr StyleContext00; scale: int32) {.
    importc, libprag.}

proc setScale*(self: StyleContext; scale: int) =
  gtk_style_context_set_scale(cast[ptr StyleContext00](self.impl), int32(scale))

proc `scale=`*(self: StyleContext; scale: int) =
  gtk_style_context_set_scale(cast[ptr StyleContext00](self.impl), int32(scale))

proc gtk_style_context_set_screen(self: ptr StyleContext00; screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc setScreen*(self: StyleContext; screen: gdk.Screen) =
  gtk_style_context_set_screen(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: StyleContext; screen: gdk.Screen) =
  gtk_style_context_set_screen(cast[ptr StyleContext00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_style_context_set_state(self: ptr StyleContext00; flags: StateFlags) {.
    importc, libprag.}

proc setState*(self: StyleContext; flags: StateFlags) =
  gtk_style_context_set_state(cast[ptr StyleContext00](self.impl), flags)

proc `state=`*(self: StyleContext; flags: StateFlags) =
  gtk_style_context_set_state(cast[ptr StyleContext00](self.impl), flags)

proc gtk_style_context_state_is_running(self: ptr StyleContext00; state: StateType;
    progress: var cdouble): gboolean {.
    importc, libprag.}

proc stateIsRunning*(self: StyleContext; state: StateType;
    progress: var cdouble): bool =
  toBool(gtk_style_context_state_is_running(cast[ptr StyleContext00](self.impl), state, progress))

proc gtk_widget_get_style_context(self: ptr Widget00): ptr StyleContext00 {.
    importc, libprag.}

proc getStyleContext*(self: Widget): StyleContext =
  let gobj = gtk_widget_get_style_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc styleContext*(self: Widget): StyleContext =
  let gobj = gtk_widget_get_style_context(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_render_icon_pixbuf(self: ptr IconSet00; context: ptr StyleContext00;
    size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc renderIconPixbuf*(self: IconSet; context: StyleContext;
    size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_set_render_icon_pixbuf(cast[ptr IconSet00](self.impl), cast[ptr StyleContext00](context.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_set_render_icon_surface(self: ptr IconSet00; context: ptr StyleContext00;
    size: int32; scale: int32; forWindow: ptr gdk.Window00): ptr cairo.Surface00 {.
    importc, libprag.}

proc renderIconSurface*(self: IconSet; context: StyleContext;
    size: int; scale: int; forWindow: gdk.Window = nil): cairo.Surface =
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = gtk_icon_set_render_icon_surface(cast[ptr IconSet00](self.impl), cast[ptr StyleContext00](context.impl), int32(size), int32(scale), if forWindow.isNil: nil else: cast[ptr gdk.Window00](forWindow.impl))

type
  Border* {.pure, byRef.} = object
    left*: int16
    right*: int16
    top*: int16
    bottom*: int16

proc gtk_border_get_type*(): GType {.importc, libprag.}

proc gtk_border_free(self: Border) {.
    importc, libprag.}

proc free*(self: Border) =
  gtk_border_free(self)

proc gtk_border_copy(self: Border): ptr Border {.
    importc, libprag.}

proc copy*(self: Border): ptr Border =
  gtk_border_copy(self)

proc new*(): ptr Border {.
    importc: "gtk_border_new", libprag.}

proc gtk_style_context_get_border(self: ptr StyleContext00; state: StateFlags;
    border: var Border) {.
    importc, libprag.}

proc getBorder*(self: StyleContext; state: StateFlags;
    border: var Border) =
  gtk_style_context_get_border(cast[ptr StyleContext00](self.impl), state, border)

proc gtk_style_context_get_margin(self: ptr StyleContext00; state: StateFlags;
    margin: var Border) {.
    importc, libprag.}

proc getMargin*(self: StyleContext; state: StateFlags;
    margin: var Border) =
  gtk_style_context_get_margin(cast[ptr StyleContext00](self.impl), state, margin)

proc gtk_style_context_get_padding(self: ptr StyleContext00; state: StateFlags;
    padding: var Border) {.
    importc, libprag.}

proc getPadding*(self: StyleContext; state: StateFlags;
    padding: var Border) =
  gtk_style_context_get_padding(cast[ptr StyleContext00](self.impl), state, padding)

type
  CssSection00* {.pure.} = object
  CssSection* = ref object
    impl*: ptr CssSection00
    ignoreFinalizer*: bool

proc gtk_css_section_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkCssSection*(self: CssSection) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_css_section_get_type(), cast[ptr CssSection00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CssSection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_css_section_get_type(), cast[ptr CssSection00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var CssSection) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkCssSection)

proc gtk_css_section_unref(self: ptr CssSection00) {.
    importc, libprag.}

proc unref*(self: CssSection) =
  gtk_css_section_unref(cast[ptr CssSection00](self.impl))

proc finalizerunref*(self: CssSection) =
  if not self.ignoreFinalizer:
    gtk_css_section_unref(cast[ptr CssSection00](self.impl))

proc gtk_css_section_get_end_position(self: ptr CssSection00): uint32 {.
    importc, libprag.}

proc getEndPosition*(self: CssSection): int =
  int(gtk_css_section_get_end_position(cast[ptr CssSection00](self.impl)))

proc endPosition*(self: CssSection): int =
  int(gtk_css_section_get_end_position(cast[ptr CssSection00](self.impl)))

proc gtk_css_section_get_file(self: ptr CssSection00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: CssSection): gio.GFile =
  let gobj = gtk_css_section_get_file(cast[ptr CssSection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: CssSection): gio.GFile =
  let gobj = gtk_css_section_get_file(cast[ptr CssSection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_section_get_parent(self: ptr CssSection00): ptr CssSection00 {.
    importc, libprag.}

proc getParent*(self: CssSection): CssSection =
  let impl0 = gtk_css_section_get_parent(cast[ptr CssSection00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_css_section_get_type(), impl0))

proc parent*(self: CssSection): CssSection =
  let impl0 = gtk_css_section_get_parent(cast[ptr CssSection00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_css_section_get_type(), impl0))

proc gtk_css_section_get_start_line(self: ptr CssSection00): uint32 {.
    importc, libprag.}

proc getStartLine*(self: CssSection): int =
  int(gtk_css_section_get_start_line(cast[ptr CssSection00](self.impl)))

proc startLine*(self: CssSection): int =
  int(gtk_css_section_get_start_line(cast[ptr CssSection00](self.impl)))

proc gtk_css_section_get_start_position(self: ptr CssSection00): uint32 {.
    importc, libprag.}

proc getStartPosition*(self: CssSection): int =
  int(gtk_css_section_get_start_position(cast[ptr CssSection00](self.impl)))

proc startPosition*(self: CssSection): int =
  int(gtk_css_section_get_start_position(cast[ptr CssSection00](self.impl)))

proc gtk_css_section_ref(self: ptr CssSection00): ptr CssSection00 {.
    importc, libprag.}

proc `ref`*(self: CssSection): CssSection =
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = gtk_css_section_ref(cast[ptr CssSection00](self.impl))

proc gtk_css_section_get_end_line(self: ptr CssSection00): uint32 {.
    importc, libprag.}

proc getEndLine*(self: CssSection): int =
  int(gtk_css_section_get_end_line(cast[ptr CssSection00](self.impl)))

proc endLine*(self: CssSection): int =
  int(gtk_css_section_get_end_line(cast[ptr CssSection00](self.impl)))

proc gtk_style_context_get_section(self: ptr StyleContext00; property: cstring): ptr CssSection00 {.
    importc, libprag.}

proc getSection*(self: StyleContext; property: cstring): CssSection =
  let impl0 = gtk_style_context_get_section(cast[ptr StyleContext00](self.impl), property)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkCssSection)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_css_section_get_type(), impl0))

type
  CssSectionType* {.size: sizeof(cint), pure.} = enum
    document = 0
    `import` = 1
    colorDefinition = 2
    bindingSet = 3
    ruleset = 4
    selector = 5
    declaration = 6
    value = 7
    keyframes = 8

proc gtk_css_section_get_section_type(self: ptr CssSection00): CssSectionType {.
    importc, libprag.}

proc getSectionType*(self: CssSection): CssSectionType =
  gtk_css_section_get_section_type(cast[ptr CssSection00](self.impl))

proc sectionType*(self: CssSection): CssSectionType =
  gtk_css_section_get_section_type(cast[ptr CssSection00](self.impl))

type
  RegionFlag* {.size: sizeof(cint), pure.} = enum
    even = 0
    odd = 1
    first = 2
    last = 3
    only = 4
    sorted = 5

  RegionFlags* {.size: sizeof(cint).} = set[RegionFlag]

proc gtk_style_context_add_region(self: ptr StyleContext00; regionName: cstring;
    flags: RegionFlags) {.
    importc, libprag.}

proc addRegion*(self: StyleContext; regionName: cstring;
    flags: RegionFlags) =
  gtk_style_context_add_region(cast[ptr StyleContext00](self.impl), regionName, flags)

proc gtk_style_context_has_region(self: ptr StyleContext00; regionName: cstring;
    flagsReturn: var RegionFlags): gboolean {.
    importc, libprag.}

proc hasRegion*(self: StyleContext; regionName: cstring;
    flagsReturn: var RegionFlags = cast[var RegionFlags](nil)): bool =
  toBool(gtk_style_context_has_region(cast[ptr StyleContext00](self.impl), regionName, flagsReturn))

type
  StyleProvider00* = object of gobject.Object00
  StyleProvider* = ref object of gobject.Object

type
  StyleProperties* = ref object of gobject.Object
  StyleProperties00* = object of gobject.Object00

proc gtk_style_properties_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StyleProperties()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_style_properties_new(): ptr StyleProperties00 {.
    importc, libprag.}

proc newStyleProperties*(): StyleProperties {.deprecated.}  =
  let gobj = gtk_style_properties_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStyleProperties*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is StyleProperties)
  let gobj = gtk_style_properties_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStyleProperties*[T](result: var T) {.deprecated.} =
  assert(result is StyleProperties)
  let gobj = gtk_style_properties_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_properties_clear(self: ptr StyleProperties00) {.
    importc, libprag.}

proc clear*(self: StyleProperties) =
  gtk_style_properties_clear(cast[ptr StyleProperties00](self.impl))

proc gtk_style_properties_get_property(self: ptr StyleProperties00; property: cstring;
    state: StateFlags; value: var gobject.Value): gboolean {.
    importc, libprag.}

proc getProperty*(self: StyleProperties; property: cstring;
    state: StateFlags; value: var gobject.Value): bool =
  toBool(gtk_style_properties_get_property(cast[ptr StyleProperties00](self.impl), property, state, value))

proc gtk_style_properties_merge(self: ptr StyleProperties00; propsToMerge: ptr StyleProperties00;
    replace: gboolean) {.
    importc, libprag.}

proc merge*(self: StyleProperties; propsToMerge: StyleProperties;
    replace: bool) =
  gtk_style_properties_merge(cast[ptr StyleProperties00](self.impl), cast[ptr StyleProperties00](propsToMerge.impl), gboolean(replace))

proc gtk_style_properties_set_property(self: ptr StyleProperties00; property: cstring;
    state: StateFlags; value: gobject.Value) {.
    importc, libprag.}

proc setProperty*(self: StyleProperties; property: cstring;
    state: StateFlags; value: gobject.Value) =
  gtk_style_properties_set_property(cast[ptr StyleProperties00](self.impl), property, state, value)

proc gtk_style_properties_unset_property(self: ptr StyleProperties00; property: cstring;
    state: StateFlags) {.
    importc, libprag.}

proc unsetProperty*(self: StyleProperties; property: cstring;
    state: StateFlags) =
  gtk_style_properties_unset_property(cast[ptr StyleProperties00](self.impl), property, state)

type
  CssProvider* = ref object of gobject.Object
  CssProvider00* = object of gobject.Object00

proc gtk_css_provider_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CssProvider()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scParsingError*(self: CssProvider;  p: proc (self: ptr CssProvider00; section: ptr CssSection00; error: ptr glib.Error; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "parsing-error", cast[GCallback](p), xdata, nil, cf)

proc gtk_css_provider_new(): ptr CssProvider00 {.
    importc, libprag.}

proc newCssProvider*(): CssProvider =
  let gobj = gtk_css_provider_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCssProvider*(tdesc: typedesc): tdesc =
  assert(result is CssProvider)
  let gobj = gtk_css_provider_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCssProvider*[T](result: var T) {.deprecated.} =
  assert(result is CssProvider)
  let gobj = gtk_css_provider_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_provider_get_default(): ptr CssProvider00 {.
    importc, libprag.}

proc getDefaultCssProvider*(): CssProvider =
  let gobj = gtk_css_provider_get_default()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_provider_get_named(name: cstring; variant: cstring): ptr CssProvider00 {.
    importc, libprag.}

proc getNamed*(name: cstring; variant: cstring = nil): CssProvider =
  let gobj = gtk_css_provider_get_named(name, variant)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_css_provider_load_from_data(self: ptr CssProvider00; data: ptr uint8;
    length: int64; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadFromData*(self: CssProvider; data: seq[uint8] | string): bool =
  let length = int64(data.len)
  var gerror: ptr glib.Error
  let resul0 = gtk_css_provider_load_from_data(cast[ptr CssProvider00](self.impl), cast[ptr uint8](unsafeaddr(data[0])), length, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_css_provider_load_from_file(self: ptr CssProvider00; file: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadFromFile*(self: CssProvider; file: gio.GFile): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_css_provider_load_from_file(cast[ptr CssProvider00](self.impl), cast[ptr gio.GFile00](file.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_css_provider_load_from_path(self: ptr CssProvider00; path: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadFromPath*(self: CssProvider; path: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_css_provider_load_from_path(cast[ptr CssProvider00](self.impl), path, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_css_provider_load_from_resource(self: ptr CssProvider00; resourcePath: cstring) {.
    importc, libprag.}

proc loadFromResource*(self: CssProvider; resourcePath: cstring) =
  gtk_css_provider_load_from_resource(cast[ptr CssProvider00](self.impl), resourcePath)

proc gtk_css_provider_to_string(self: ptr CssProvider00): cstring {.
    importc, libprag.}

proc toString*(self: CssProvider): string =
  let resul0 = gtk_css_provider_to_string(cast[ptr CssProvider00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_style_context_add_provider_for_screen(screen: ptr gdk.Screen00;
    provider: ptr StyleProvider00; priority: uint32) {.
    importc, libprag.}

proc addProviderForScreen*(screen: gdk.Screen; provider: StyleProvider | StyleProperties | CssProvider | Settings;
    priority: int) =
  gtk_style_context_add_provider_for_screen(cast[ptr gdk.Screen00](screen.impl), cast[ptr StyleProvider00](provider.impl), uint32(priority))

proc gtk_style_context_remove_provider_for_screen(screen: ptr gdk.Screen00;
    provider: ptr StyleProvider00) {.
    importc, libprag.}

proc removeProviderForScreen*(screen: gdk.Screen; provider: StyleProvider | StyleProperties | CssProvider | Settings) =
  gtk_style_context_remove_provider_for_screen(cast[ptr gdk.Screen00](screen.impl), cast[ptr StyleProvider00](provider.impl))

proc gtk_style_context_add_provider(self: ptr StyleContext00; provider: ptr StyleProvider00;
    priority: uint32) {.
    importc, libprag.}

proc addProvider*(self: StyleContext; provider: StyleProvider | StyleProperties | CssProvider | Settings;
    priority: int) =
  gtk_style_context_add_provider(cast[ptr StyleContext00](self.impl), cast[ptr StyleProvider00](provider.impl), uint32(priority))

proc gtk_style_context_remove_provider(self: ptr StyleContext00; provider: ptr StyleProvider00) {.
    importc, libprag.}

proc removeProvider*(self: StyleContext; provider: StyleProvider | StyleProperties | CssProvider | Settings) =
  gtk_style_context_remove_provider(cast[ptr StyleContext00](self.impl), cast[ptr StyleProvider00](provider.impl))

type
  SymbolicColor00* {.pure.} = object
  SymbolicColor* = ref object
    impl*: ptr SymbolicColor00
    ignoreFinalizer*: bool

proc gtk_symbolic_color_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkSymbolicColor*(self: SymbolicColor) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_symbolic_color_get_type(), cast[ptr SymbolicColor00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SymbolicColor()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_symbolic_color_get_type(), cast[ptr SymbolicColor00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var SymbolicColor) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkSymbolicColor)

proc gtk_symbolic_color_unref(self: ptr SymbolicColor00) {.
    importc, libprag.}

proc unref*(self: SymbolicColor) =
  gtk_symbolic_color_unref(cast[ptr SymbolicColor00](self.impl))

proc finalizerunref*(self: SymbolicColor) =
  if not self.ignoreFinalizer:
    gtk_symbolic_color_unref(cast[ptr SymbolicColor00](self.impl))

proc gtk_symbolic_color_new_literal(color: gdk.RGBA): ptr SymbolicColor00 {.
    importc, libprag.}

proc newSymbolicColorLiteral*(color: gdk.RGBA): SymbolicColor {.deprecated.}  =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_literal(color)

proc newSymbolicColorLiteral*(tdesc: typedesc; color: gdk.RGBA): tdesc {.deprecated.}  =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_literal(color)

proc initSymbolicColorLiteral*[T](result: var T; color: gdk.RGBA) {.deprecated.} =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_literal(color)

proc gtk_symbolic_color_new_mix(color1: ptr SymbolicColor00; color2: ptr SymbolicColor00;
    factor: cdouble): ptr SymbolicColor00 {.
    importc, libprag.}

proc newSymbolicColorMix*(color1: SymbolicColor; color2: SymbolicColor;
    factor: cdouble): SymbolicColor {.deprecated.}  =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_mix(cast[ptr SymbolicColor00](color1.impl), cast[ptr SymbolicColor00](color2.impl), factor)

proc newSymbolicColorMix*(tdesc: typedesc; color1: SymbolicColor; color2: SymbolicColor;
    factor: cdouble): tdesc {.deprecated.}  =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_mix(cast[ptr SymbolicColor00](color1.impl), cast[ptr SymbolicColor00](color2.impl), factor)

proc initSymbolicColorMix*[T](result: var T; color1: SymbolicColor; color2: SymbolicColor;
    factor: cdouble) {.deprecated.} =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_mix(cast[ptr SymbolicColor00](color1.impl), cast[ptr SymbolicColor00](color2.impl), factor)

proc gtk_symbolic_color_new_name(name: cstring): ptr SymbolicColor00 {.
    importc, libprag.}

proc newSymbolicColorName*(name: cstring): SymbolicColor {.deprecated.}  =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_name(name)

proc newSymbolicColorName*(tdesc: typedesc; name: cstring): tdesc {.deprecated.}  =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_name(name)

proc initSymbolicColorName*[T](result: var T; name: cstring) {.deprecated.} =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_name(name)

proc gtk_symbolic_color_new_shade(color: ptr SymbolicColor00; factor: cdouble): ptr SymbolicColor00 {.
    importc, libprag.}

proc newSymbolicColorShade*(color: SymbolicColor; factor: cdouble): SymbolicColor {.deprecated.}  =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_shade(cast[ptr SymbolicColor00](color.impl), factor)

proc newSymbolicColorShade*(tdesc: typedesc; color: SymbolicColor; factor: cdouble): tdesc {.deprecated.}  =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_shade(cast[ptr SymbolicColor00](color.impl), factor)

proc initSymbolicColorShade*[T](result: var T; color: SymbolicColor; factor: cdouble) {.deprecated.} =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_shade(cast[ptr SymbolicColor00](color.impl), factor)

proc gtk_symbolic_color_new_win32(themeClass: cstring; id: int32): ptr SymbolicColor00 {.
    importc, libprag.}

proc newSymbolicColorWin32*(themeClass: cstring; id: int): SymbolicColor {.deprecated.}  =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_win32(themeClass, int32(id))

proc newSymbolicColorWin32*(tdesc: typedesc; themeClass: cstring; id: int): tdesc {.deprecated.}  =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_win32(themeClass, int32(id))

proc initSymbolicColorWin32*[T](result: var T; themeClass: cstring; id: int) {.deprecated.} =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_win32(themeClass, int32(id))

proc gtk_symbolic_color_ref(self: ptr SymbolicColor00): ptr SymbolicColor00 {.
    importc, libprag.}

proc `ref`*(self: SymbolicColor): SymbolicColor =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_ref(cast[ptr SymbolicColor00](self.impl))

proc gtk_symbolic_color_resolve(self: ptr SymbolicColor00; props: ptr StyleProperties00;
    resolvedColor: var gdk.RGBA): gboolean {.
    importc, libprag.}

proc resolve*(self: SymbolicColor; props: StyleProperties = nil;
    resolvedColor: var gdk.RGBA): bool =
  toBool(gtk_symbolic_color_resolve(cast[ptr SymbolicColor00](self.impl), if props.isNil: nil else: cast[ptr StyleProperties00](props.impl), resolvedColor))

proc gtk_symbolic_color_to_string(self: ptr SymbolicColor00): cstring {.
    importc, libprag.}

proc toString*(self: SymbolicColor): string =
  let resul0 = gtk_symbolic_color_to_string(cast[ptr SymbolicColor00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_symbolic_color_new_alpha(color: ptr SymbolicColor00; factor: cdouble): ptr SymbolicColor00 {.
    importc, libprag.}

proc newSymbolicColorAlpha*(color: SymbolicColor; factor: cdouble): SymbolicColor {.deprecated.}  =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_alpha(cast[ptr SymbolicColor00](color.impl), factor)

proc newSymbolicColorAlpha*(tdesc: typedesc; color: SymbolicColor; factor: cdouble): tdesc {.deprecated.}  =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_alpha(cast[ptr SymbolicColor00](color.impl), factor)

proc initSymbolicColorAlpha*[T](result: var T; color: SymbolicColor; factor: cdouble) {.deprecated.} =
  assert(result is SymbolicColor)
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_symbolic_color_new_alpha(cast[ptr SymbolicColor00](color.impl), factor)

proc gtk_style_properties_lookup_color(self: ptr StyleProperties00; name: cstring): ptr SymbolicColor00 {.
    importc, libprag.}

proc lookupColor*(self: StyleProperties; name: cstring): SymbolicColor =
  fnew(result, gBoxedFreeGtkSymbolicColor)
  result.impl = gtk_style_properties_lookup_color(cast[ptr StyleProperties00](self.impl), name)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_symbolic_color_get_type(), result.impl))

proc gtk_style_properties_map_color(self: ptr StyleProperties00; name: cstring;
    color: ptr SymbolicColor00) {.
    importc, libprag.}

proc mapColor*(self: StyleProperties; name: cstring;
    color: SymbolicColor) =
  gtk_style_properties_map_color(cast[ptr StyleProperties00](self.impl), name, cast[ptr SymbolicColor00](color.impl))

type
  JunctionSides* {.size: sizeof(cint), pure.} = enum
    none = 0
    cornerTopleft = 1
    cornerTopright = 2
    top = 3
    cornerBottomleft = 4
    left = 5
    cornerBottomright = 8
    right = 10
    bottom = 12

proc gtk_style_context_get_junction_sides(self: ptr StyleContext00): JunctionSides {.
    importc, libprag.}

proc getJunctionSides*(self: StyleContext): JunctionSides =
  gtk_style_context_get_junction_sides(cast[ptr StyleContext00](self.impl))

proc junctionSides*(self: StyleContext): JunctionSides =
  gtk_style_context_get_junction_sides(cast[ptr StyleContext00](self.impl))

proc gtk_style_context_set_junction_sides(self: ptr StyleContext00; sides: JunctionSides) {.
    importc, libprag.}

proc setJunctionSides*(self: StyleContext; sides: JunctionSides) =
  gtk_style_context_set_junction_sides(cast[ptr StyleContext00](self.impl), sides)

proc `junctionSides=`*(self: StyleContext; sides: JunctionSides) =
  gtk_style_context_set_junction_sides(cast[ptr StyleContext00](self.impl), sides)

type
  StyleContextPrintFlag* {.size: sizeof(cint), pure.} = enum
    recurse = 0
    showStyle = 1

  StyleContextPrintFlags* {.size: sizeof(cint).} = set[StyleContextPrintFlag]

const
  StyleContextPrintFlagsNone* = StyleContextPrintFlags({})
proc none*(t: typedesc[StyleContextPrintFlags]): StyleContextPrintFlags = StyleContextPrintFlags({})

proc gtk_style_context_to_string(self: ptr StyleContext00; flags: StyleContextPrintFlags): cstring {.
    importc, libprag.}

proc toString*(self: StyleContext; flags: StyleContextPrintFlags): string =
  let resul0 = gtk_style_context_to_string(cast[ptr StyleContext00](self.impl), flags)
  result = $resul0
  cogfree(resul0)

type
  RcStyle* = ref object of gobject.Object
  RcStyle00* = object of gobject.Object00

proc gtk_rc_style_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RcStyle()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_rc_style_new(): ptr RcStyle00 {.
    importc, libprag.}

proc newRcStyle*(): RcStyle {.deprecated.}  =
  let gobj = gtk_rc_style_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRcStyle*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is RcStyle)
  let gobj = gtk_rc_style_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRcStyle*[T](result: var T) {.deprecated.} =
  assert(result is RcStyle)
  let gobj = gtk_rc_style_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_rc_style_copy(self: ptr RcStyle00): ptr RcStyle00 {.
    importc, libprag.}

proc copy*(self: RcStyle): RcStyle =
  let gobj = gtk_rc_style_copy(cast[ptr RcStyle00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_get_modifier_style(self: ptr Widget00): ptr RcStyle00 {.
    importc, libprag.}

proc getModifierStyle*(self: Widget): RcStyle =
  let gobj = gtk_widget_get_modifier_style(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc modifierStyle*(self: Widget): RcStyle =
  let gobj = gtk_widget_get_modifier_style(cast[ptr Widget00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_widget_modify_style(self: ptr Widget00; style: ptr RcStyle00) {.
    importc, libprag.}

proc modifyStyle*(self: Widget; style: RcStyle) =
  gtk_widget_modify_style(cast[ptr Widget00](self.impl), cast[ptr RcStyle00](style.impl))

type
  AccelGroup* = ref object of gobject.Object
  AccelGroup00* = object of gobject.Object00

proc gtk_accel_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AccelGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAccelActivate*(self: AccelGroup;  p: proc (self: ptr AccelGroup00; acceleratable: ptr gobject.Object00; keyval: uint32; modifier: gdk.ModifierType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accel-activate", cast[GCallback](p), xdata, nil, cf)

proc scAccelChanged*(self: AccelGroup;  p: proc (self: ptr AccelGroup00; keyval: uint32; modifier: gdk.ModifierType; accelClosure: ptr gobject.Closure00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accel-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_accel_group_new(): ptr AccelGroup00 {.
    importc, libprag.}

proc newAccelGroup*(): AccelGroup =
  let gobj = gtk_accel_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAccelGroup*(tdesc: typedesc): tdesc =
  assert(result is AccelGroup)
  let gobj = gtk_accel_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAccelGroup*[T](result: var T) {.deprecated.} =
  assert(result is AccelGroup)
  let gobj = gtk_accel_group_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_group_from_accel_closure(closure: ptr gobject.Closure00): ptr AccelGroup00 {.
    importc, libprag.}

proc fromAccelClosure*(closure: gobject.Closure): AccelGroup =
  let gobj = gtk_accel_group_from_accel_closure(cast[ptr gobject.Closure00](closure.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_group_activate(self: ptr AccelGroup00; accelQuark: uint32;
    acceleratable: ptr gobject.Object00; accelKey: uint32; accelMods: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc activate*(self: AccelGroup; accelQuark: int; acceleratable: gobject.Object;
    accelKey: int; accelMods: gdk.ModifierType): bool =
  toBool(gtk_accel_group_activate(cast[ptr AccelGroup00](self.impl), uint32(accelQuark), cast[ptr gobject.Object00](acceleratable.impl), uint32(accelKey), accelMods))

proc gtk_accel_group_connect_by_path(self: ptr AccelGroup00; accelPath: cstring;
    closure: ptr gobject.Closure00) {.
    importc, libprag.}

proc connectByPath*(self: AccelGroup; accelPath: cstring;
    closure: gobject.Closure) =
  gtk_accel_group_connect_by_path(cast[ptr AccelGroup00](self.impl), accelPath, cast[ptr gobject.Closure00](closure.impl))

proc gtk_accel_group_disconnect(self: ptr AccelGroup00; closure: ptr gobject.Closure00): gboolean {.
    importc, libprag.}

proc disconnect*(self: AccelGroup; closure: gobject.Closure = nil): bool =
  toBool(gtk_accel_group_disconnect(cast[ptr AccelGroup00](self.impl), if closure.isNil: nil else: cast[ptr gobject.Closure00](closure.impl)))

proc gtk_accel_group_disconnect_key(self: ptr AccelGroup00; accelKey: uint32;
    accelMods: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc disconnectKey*(self: AccelGroup; accelKey: int; accelMods: gdk.ModifierType): bool =
  toBool(gtk_accel_group_disconnect_key(cast[ptr AccelGroup00](self.impl), uint32(accelKey), accelMods))

proc gtk_accel_group_get_is_locked(self: ptr AccelGroup00): gboolean {.
    importc, libprag.}

proc getIsLocked*(self: AccelGroup): bool =
  toBool(gtk_accel_group_get_is_locked(cast[ptr AccelGroup00](self.impl)))

proc isLocked*(self: AccelGroup): bool =
  toBool(gtk_accel_group_get_is_locked(cast[ptr AccelGroup00](self.impl)))

proc gtk_accel_group_get_modifier_mask(self: ptr AccelGroup00): gdk.ModifierType {.
    importc, libprag.}

proc getModifierMask*(self: AccelGroup): gdk.ModifierType =
  gtk_accel_group_get_modifier_mask(cast[ptr AccelGroup00](self.impl))

proc modifierMask*(self: AccelGroup): gdk.ModifierType =
  gtk_accel_group_get_modifier_mask(cast[ptr AccelGroup00](self.impl))

proc gtk_accel_group_lock(self: ptr AccelGroup00) {.
    importc, libprag.}

proc lock*(self: AccelGroup) =
  gtk_accel_group_lock(cast[ptr AccelGroup00](self.impl))

proc gtk_accel_group_unlock(self: ptr AccelGroup00) {.
    importc, libprag.}

proc unlock*(self: AccelGroup) =
  gtk_accel_group_unlock(cast[ptr AccelGroup00](self.impl))

proc gtk_widget_remove_accelerator(self: ptr Widget00; accelGroup: ptr AccelGroup00;
    accelKey: uint32; accelMods: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc removeAccelerator*(self: Widget; accelGroup: AccelGroup;
    accelKey: int; accelMods: gdk.ModifierType): bool =
  toBool(gtk_widget_remove_accelerator(cast[ptr Widget00](self.impl), cast[ptr AccelGroup00](accelGroup.impl), uint32(accelKey), accelMods))

proc gtk_widget_set_accel_path(self: ptr Widget00; accelPath: cstring; accelGroup: ptr AccelGroup00) {.
    importc, libprag.}

proc setAccelPath*(self: Widget; accelPath: cstring = nil; accelGroup: AccelGroup = nil) =
  gtk_widget_set_accel_path(cast[ptr Widget00](self.impl), accelPath, if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_window_add_accel_group(self: ptr Window00; accelGroup: ptr AccelGroup00) {.
    importc, libprag.}

proc addAccelGroup*(self: Window | PlugAccessible | WindowAccessible;
    accelGroup: AccelGroup) =
  gtk_window_add_accel_group(cast[ptr Window00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_window_remove_accel_group(self: ptr Window00; accelGroup: ptr AccelGroup00) {.
    importc, libprag.}

proc removeAccelGroup*(self: Window | PlugAccessible | WindowAccessible;
    accelGroup: AccelGroup) =
  gtk_window_remove_accel_group(cast[ptr Window00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

type
  AccelFlag* {.size: sizeof(cint), pure.} = enum
    visible = 0
    locked = 1

  AccelFlags* {.size: sizeof(cint).} = set[AccelFlag]

proc gtk_widget_add_accelerator(self: ptr Widget00; accelSignal: cstring;
    accelGroup: ptr AccelGroup00; accelKey: uint32; accelMods: gdk.ModifierType;
    accelFlags: AccelFlags) {.
    importc, libprag.}

proc addAccelerator*(self: Widget; accelSignal: cstring; accelGroup: AccelGroup;
    accelKey: int; accelMods: gdk.ModifierType; accelFlags: AccelFlags) =
  gtk_widget_add_accelerator(cast[ptr Widget00](self.impl), accelSignal, cast[ptr AccelGroup00](accelGroup.impl), uint32(accelKey), accelMods, accelFlags)

proc gtk_accel_group_connect(self: ptr AccelGroup00; accelKey: uint32; accelMods: gdk.ModifierType;
    accelFlags: AccelFlags; closure: ptr gobject.Closure00) {.
    importc, libprag.}

proc connect*(self: AccelGroup; accelKey: int; accelMods: gdk.ModifierType;
    accelFlags: AccelFlags; closure: gobject.Closure) =
  gtk_accel_group_connect(cast[ptr AccelGroup00](self.impl), uint32(accelKey), accelMods, accelFlags, cast[ptr gobject.Closure00](closure.impl))

type
  AccelGroupEntry00* {.pure.} = object
  AccelGroupEntry* = ref object
    impl*: ptr AccelGroupEntry00
    ignoreFinalizer*: bool

proc gtk_accel_group_query(self: ptr AccelGroup00; accelKey: uint32; accelMods: gdk.ModifierType;
    nEntries: var uint32): ptr AccelGroupEntry00 {.
    importc, libprag.}

proc query*(self: AccelGroup; accelKey: int; accelMods: gdk.ModifierType;
    nEntries: var int = cast[var int](nil)): ptr AccelGroupEntry00 =
  var nEntries_00: uint32
  let resul0 = gtk_accel_group_query(cast[ptr AccelGroup00](self.impl), uint32(accelKey), accelMods, nEntries_00)
  if resul0.isNil:
    return
  result = resul0
  if nEntries.addr != nil:
    nEntries = int(nEntries_00)

type
  Align* {.size: sizeof(cint), pure.} = enum
    fill = 0
    start = 1
    `end` = 2
    center = 3
    baseline = 4

proc gtk_widget_get_halign(self: ptr Widget00): Align {.
    importc, libprag.}

proc getHalign*(self: Widget): Align =
  gtk_widget_get_halign(cast[ptr Widget00](self.impl))

proc halign*(self: Widget): Align =
  gtk_widget_get_halign(cast[ptr Widget00](self.impl))

proc gtk_widget_get_valign(self: ptr Widget00): Align {.
    importc, libprag.}

proc getValign*(self: Widget): Align =
  gtk_widget_get_valign(cast[ptr Widget00](self.impl))

proc valign*(self: Widget): Align =
  gtk_widget_get_valign(cast[ptr Widget00](self.impl))

proc gtk_widget_get_valign_with_baseline(self: ptr Widget00): Align {.
    importc, libprag.}

proc getValignWithBaseline*(self: Widget): Align =
  gtk_widget_get_valign_with_baseline(cast[ptr Widget00](self.impl))

proc valignWithBaseline*(self: Widget): Align =
  gtk_widget_get_valign_with_baseline(cast[ptr Widget00](self.impl))

proc gtk_widget_set_halign(self: ptr Widget00; align: Align) {.
    importc, libprag.}

proc setHalign*(self: Widget; align: Align) =
  gtk_widget_set_halign(cast[ptr Widget00](self.impl), align)

proc `halign=`*(self: Widget; align: Align) =
  gtk_widget_set_halign(cast[ptr Widget00](self.impl), align)

proc gtk_widget_set_valign(self: ptr Widget00; align: Align) {.
    importc, libprag.}

proc setValign*(self: Widget; align: Align) =
  gtk_widget_set_valign(cast[ptr Widget00](self.impl), align)

proc `valign=`*(self: Widget; align: Align) =
  gtk_widget_set_valign(cast[ptr Widget00](self.impl), align)

type
  Requisition* {.pure, byRef.} = object
    width*: int32
    height*: int32

proc gtk_requisition_get_type*(): GType {.importc, libprag.}

proc gtk_requisition_free(self: Requisition) {.
    importc, libprag.}

proc free*(self: Requisition) =
  gtk_requisition_free(self)

proc gtk_requisition_copy(self: Requisition): ptr Requisition {.
    importc, libprag.}

proc copy*(self: Requisition): ptr Requisition =
  gtk_requisition_copy(self)

proc newRequisition*(): ptr Requisition {.
    importc: "gtk_requisition_new", libprag.}

proc gtk_widget_get_child_requisition(self: ptr Widget00; requisition: var Requisition) {.
    importc, libprag.}

proc getChildRequisition*(self: Widget; requisition: var Requisition) =
  gtk_widget_get_child_requisition(cast[ptr Widget00](self.impl), requisition)

proc getChildRequisition*(self: Widget): Requisition =
  gtk_widget_get_child_requisition(cast[ptr Widget00](self.impl), result)

proc gtk_widget_get_preferred_size(self: ptr Widget00; minimumSize: var Requisition;
    naturalSize: var Requisition) {.
    importc, libprag.}

proc getPreferredSize*(self: Widget; minimumSize: var Requisition = cast[var Requisition](nil);
    naturalSize: var Requisition = cast[var Requisition](nil)) =
  gtk_widget_get_preferred_size(cast[ptr Widget00](self.impl), minimumSize, naturalSize)

proc gtk_widget_get_requisition(self: ptr Widget00; requisition: var Requisition) {.
    importc, libprag.}

proc getRequisition*(self: Widget; requisition: var Requisition) =
  gtk_widget_get_requisition(cast[ptr Widget00](self.impl), requisition)

proc getRequisition*(self: Widget): Requisition =
  gtk_widget_get_requisition(cast[ptr Widget00](self.impl), result)

proc gtk_widget_size_request(self: ptr Widget00; requisition: var Requisition) {.
    importc, libprag.}

proc sizeRequest*(self: Widget; requisition: var Requisition) =
  gtk_widget_size_request(cast[ptr Widget00](self.impl), requisition)

proc sizeRequest*(self: Widget): Requisition =
  gtk_widget_size_request(cast[ptr Widget00](self.impl), result)

type
  WidgetPath00* {.pure.} = object
  WidgetPath* = ref object
    impl*: ptr WidgetPath00
    ignoreFinalizer*: bool

proc gtk_widget_path_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkWidgetPath*(self: WidgetPath) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_widget_path_get_type(), cast[ptr WidgetPath00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(WidgetPath()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_widget_path_get_type(), cast[ptr WidgetPath00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var WidgetPath) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkWidgetPath)

proc gtk_widget_path_free(self: ptr WidgetPath00) {.
    importc, libprag.}

proc free*(self: WidgetPath) =
  gtk_widget_path_free(cast[ptr WidgetPath00](self.impl))

proc finalizerfree*(self: WidgetPath) =
  if not self.ignoreFinalizer:
    gtk_widget_path_free(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_append_for_widget(self: ptr WidgetPath00; widget: ptr Widget00): int32 {.
    importc, libprag.}

proc appendForWidget*(self: WidgetPath; widget: Widget): int =
  int(gtk_widget_path_append_for_widget(cast[ptr WidgetPath00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_widget_path_append_type(self: ptr WidgetPath00; `type`: GType): int32 {.
    importc, libprag.}

proc appendType*(self: WidgetPath; `type`: GType): int =
  int(gtk_widget_path_append_type(cast[ptr WidgetPath00](self.impl), `type`))

proc gtk_widget_path_append_with_siblings(self: ptr WidgetPath00; siblings: ptr WidgetPath00;
    siblingIndex: uint32): int32 {.
    importc, libprag.}

proc appendWithSiblings*(self: WidgetPath; siblings: WidgetPath;
    siblingIndex: int): int =
  int(gtk_widget_path_append_with_siblings(cast[ptr WidgetPath00](self.impl), cast[ptr WidgetPath00](siblings.impl), uint32(siblingIndex)))

proc gtk_widget_path_copy(self: ptr WidgetPath00): ptr WidgetPath00 {.
    importc, libprag.}

proc copy*(self: WidgetPath): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_path_copy(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_new(): ptr WidgetPath00 {.
    importc, libprag.}

proc newWidgetPath*(): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_path_new()

proc newWidgetPath*(tdesc: typedesc): tdesc =
  assert(result is WidgetPath)
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_path_new()

proc initWidgetPath*[T](result: var T) {.deprecated.} =
  assert(result is WidgetPath)
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_path_new()

proc gtk_widget_path_get_object_type(self: ptr WidgetPath00): GType {.
    importc, libprag.}

proc getObjectType*(self: WidgetPath): GType =
  gtk_widget_path_get_object_type(cast[ptr WidgetPath00](self.impl))

proc objectType*(self: WidgetPath): GType =
  gtk_widget_path_get_object_type(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_has_parent(self: ptr WidgetPath00; `type`: GType): gboolean {.
    importc, libprag.}

proc hasParent*(self: WidgetPath; `type`: GType): bool =
  toBool(gtk_widget_path_has_parent(cast[ptr WidgetPath00](self.impl), `type`))

proc gtk_widget_path_is_type(self: ptr WidgetPath00; `type`: GType): gboolean {.
    importc, libprag.}

proc isType*(self: WidgetPath; `type`: GType): bool =
  toBool(gtk_widget_path_is_type(cast[ptr WidgetPath00](self.impl), `type`))

proc gtk_widget_path_iter_add_class(self: ptr WidgetPath00; pos: int32; name: cstring) {.
    importc, libprag.}

proc iterAddClass*(self: WidgetPath; pos: int; name: cstring) =
  gtk_widget_path_iter_add_class(cast[ptr WidgetPath00](self.impl), int32(pos), name)

proc gtk_widget_path_iter_add_region(self: ptr WidgetPath00; pos: int32;
    name: cstring; flags: RegionFlags) {.
    importc, libprag.}

proc iterAddRegion*(self: WidgetPath; pos: int; name: cstring;
    flags: RegionFlags) =
  gtk_widget_path_iter_add_region(cast[ptr WidgetPath00](self.impl), int32(pos), name, flags)

proc gtk_widget_path_iter_clear_classes(self: ptr WidgetPath00; pos: int32) {.
    importc, libprag.}

proc iterClearClasses*(self: WidgetPath; pos: int) =
  gtk_widget_path_iter_clear_classes(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_clear_regions(self: ptr WidgetPath00; pos: int32) {.
    importc, libprag.}

proc iterClearRegions*(self: WidgetPath; pos: int) =
  gtk_widget_path_iter_clear_regions(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_get_name(self: ptr WidgetPath00; pos: int32): cstring {.
    importc, libprag.}

proc iterGetName*(self: WidgetPath; pos: int): string =
  let resul0 = gtk_widget_path_iter_get_name(cast[ptr WidgetPath00](self.impl), int32(pos))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_widget_path_iter_get_object_name(self: ptr WidgetPath00; pos: int32): cstring {.
    importc, libprag.}

proc iterGetObjectName*(self: WidgetPath; pos: int): string =
  let resul0 = gtk_widget_path_iter_get_object_name(cast[ptr WidgetPath00](self.impl), int32(pos))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_widget_path_iter_get_object_type(self: ptr WidgetPath00; pos: int32): GType {.
    importc, libprag.}

proc iterGetObjectType*(self: WidgetPath; pos: int): GType =
  gtk_widget_path_iter_get_object_type(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_get_sibling_index(self: ptr WidgetPath00; pos: int32): uint32 {.
    importc, libprag.}

proc iterGetSiblingIndex*(self: WidgetPath; pos: int): int =
  int(gtk_widget_path_iter_get_sibling_index(cast[ptr WidgetPath00](self.impl), int32(pos)))

proc gtk_widget_path_iter_get_siblings(self: ptr WidgetPath00; pos: int32): ptr WidgetPath00 {.
    importc, libprag.}

proc iterGetSiblings*(self: WidgetPath; pos: int): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_path_iter_get_siblings(cast[ptr WidgetPath00](self.impl), int32(pos))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_widget_path_get_type(), result.impl))

proc gtk_widget_path_iter_get_state(self: ptr WidgetPath00; pos: int32): StateFlags {.
    importc, libprag.}

proc iterGetState*(self: WidgetPath; pos: int): StateFlags =
  gtk_widget_path_iter_get_state(cast[ptr WidgetPath00](self.impl), int32(pos))

proc gtk_widget_path_iter_has_class(self: ptr WidgetPath00; pos: int32; name: cstring): gboolean {.
    importc, libprag.}

proc iterHasClass*(self: WidgetPath; pos: int; name: cstring): bool =
  toBool(gtk_widget_path_iter_has_class(cast[ptr WidgetPath00](self.impl), int32(pos), name))

proc gtk_widget_path_iter_has_name(self: ptr WidgetPath00; pos: int32; name: cstring): gboolean {.
    importc, libprag.}

proc iterHasName*(self: WidgetPath; pos: int; name: cstring): bool =
  toBool(gtk_widget_path_iter_has_name(cast[ptr WidgetPath00](self.impl), int32(pos), name))

proc gtk_widget_path_iter_has_qclass(self: ptr WidgetPath00; pos: int32;
    qname: uint32): gboolean {.
    importc, libprag.}

proc iterHasQclass*(self: WidgetPath; pos: int; qname: int): bool =
  toBool(gtk_widget_path_iter_has_qclass(cast[ptr WidgetPath00](self.impl), int32(pos), uint32(qname)))

proc gtk_widget_path_iter_has_qname(self: ptr WidgetPath00; pos: int32; qname: uint32): gboolean {.
    importc, libprag.}

proc iterHasQname*(self: WidgetPath; pos: int; qname: int): bool =
  toBool(gtk_widget_path_iter_has_qname(cast[ptr WidgetPath00](self.impl), int32(pos), uint32(qname)))

proc gtk_widget_path_iter_has_qregion(self: ptr WidgetPath00; pos: int32;
    qname: uint32; flags: var RegionFlags): gboolean {.
    importc, libprag.}

proc iterHasQregion*(self: WidgetPath; pos: int; qname: int;
    flags: var RegionFlags): bool =
  toBool(gtk_widget_path_iter_has_qregion(cast[ptr WidgetPath00](self.impl), int32(pos), uint32(qname), flags))

proc gtk_widget_path_iter_has_region(self: ptr WidgetPath00; pos: int32;
    name: cstring; flags: var RegionFlags): gboolean {.
    importc, libprag.}

proc iterHasRegion*(self: WidgetPath; pos: int; name: cstring;
    flags: var RegionFlags): bool =
  toBool(gtk_widget_path_iter_has_region(cast[ptr WidgetPath00](self.impl), int32(pos), name, flags))

proc gtk_widget_path_iter_list_classes(self: ptr WidgetPath00; pos: int32): ptr glib.SList {.
    importc, libprag.}

proc iterListClasses*(self: WidgetPath; pos: int): seq[cstring] =
  let resul0 = gtk_widget_path_iter_list_classes(cast[ptr WidgetPath00](self.impl), int32(pos))
  g_slist_free(resul0)

proc gtk_widget_path_iter_list_regions(self: ptr WidgetPath00; pos: int32): ptr glib.SList {.
    importc, libprag.}

proc iterListRegions*(self: WidgetPath; pos: int): seq[cstring] =
  let resul0 = gtk_widget_path_iter_list_regions(cast[ptr WidgetPath00](self.impl), int32(pos))
  g_slist_free(resul0)

proc gtk_widget_path_iter_remove_class(self: ptr WidgetPath00; pos: int32;
    name: cstring) {.
    importc, libprag.}

proc iterRemoveClass*(self: WidgetPath; pos: int; name: cstring) =
  gtk_widget_path_iter_remove_class(cast[ptr WidgetPath00](self.impl), int32(pos), name)

proc gtk_widget_path_iter_remove_region(self: ptr WidgetPath00; pos: int32;
    name: cstring) {.
    importc, libprag.}

proc iterRemoveRegion*(self: WidgetPath; pos: int; name: cstring) =
  gtk_widget_path_iter_remove_region(cast[ptr WidgetPath00](self.impl), int32(pos), name)

proc gtk_widget_path_iter_set_name(self: ptr WidgetPath00; pos: int32; name: cstring) {.
    importc, libprag.}

proc iterSetName*(self: WidgetPath; pos: int; name: cstring) =
  gtk_widget_path_iter_set_name(cast[ptr WidgetPath00](self.impl), int32(pos), name)

proc gtk_widget_path_iter_set_object_name(self: ptr WidgetPath00; pos: int32;
    name: cstring) {.
    importc, libprag.}

proc iterSetObjectName*(self: WidgetPath; pos: int; name: cstring = nil) =
  gtk_widget_path_iter_set_object_name(cast[ptr WidgetPath00](self.impl), int32(pos), name)

proc gtk_widget_path_iter_set_object_type(self: ptr WidgetPath00; pos: int32;
    `type`: GType) {.
    importc, libprag.}

proc iterSetObjectType*(self: WidgetPath; pos: int; `type`: GType) =
  gtk_widget_path_iter_set_object_type(cast[ptr WidgetPath00](self.impl), int32(pos), `type`)

proc gtk_widget_path_iter_set_state(self: ptr WidgetPath00; pos: int32; state: StateFlags) {.
    importc, libprag.}

proc iterSetState*(self: WidgetPath; pos: int; state: StateFlags) =
  gtk_widget_path_iter_set_state(cast[ptr WidgetPath00](self.impl), int32(pos), state)

proc gtk_widget_path_length(self: ptr WidgetPath00): int32 {.
    importc, libprag.}

proc length*(self: WidgetPath): int =
  int(gtk_widget_path_length(cast[ptr WidgetPath00](self.impl)))

proc gtk_widget_path_prepend_type(self: ptr WidgetPath00; `type`: GType) {.
    importc, libprag.}

proc prependType*(self: WidgetPath; `type`: GType) =
  gtk_widget_path_prepend_type(cast[ptr WidgetPath00](self.impl), `type`)

proc gtk_widget_path_ref(self: ptr WidgetPath00): ptr WidgetPath00 {.
    importc, libprag.}

proc `ref`*(self: WidgetPath): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_path_ref(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_path_to_string(self: ptr WidgetPath00): cstring {.
    importc, libprag.}

proc toString*(self: WidgetPath): string =
  let resul0 = gtk_widget_path_to_string(cast[ptr WidgetPath00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_widget_path_unref(self: ptr WidgetPath00) {.
    importc, libprag.}

proc unref*(self: WidgetPath) =
  gtk_widget_path_unref(cast[ptr WidgetPath00](self.impl))

proc finalizerunref*(self: WidgetPath) =
  if not self.ignoreFinalizer:
    gtk_widget_path_unref(cast[ptr WidgetPath00](self.impl))

proc gtk_widget_get_path(self: ptr Widget00): ptr WidgetPath00 {.
    importc, libprag.}

proc getPath*(self: Widget): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_get_path(cast[ptr Widget00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_widget_path_get_type(), result.impl))

proc path*(self: Widget): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_widget_get_path(cast[ptr Widget00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_widget_path_get_type(), result.impl))

proc gtk_container_get_path_for_child(self: ptr Container00; child: ptr Widget00): ptr WidgetPath00 {.
    importc, libprag.}

proc getPathForChild*(self: Container; child: Widget): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_container_get_path_for_child(cast[ptr Container00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_style_context_get_path(self: ptr StyleContext00): ptr WidgetPath00 {.
    importc, libprag.}

proc getPath*(self: StyleContext): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_style_context_get_path(cast[ptr StyleContext00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_widget_path_get_type(), result.impl))

proc path*(self: StyleContext): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_style_context_get_path(cast[ptr StyleContext00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_widget_path_get_type(), result.impl))

proc gtk_style_context_set_path(self: ptr StyleContext00; path: ptr WidgetPath00) {.
    importc, libprag.}

proc setPath*(self: StyleContext; path: WidgetPath) =
  gtk_style_context_set_path(cast[ptr StyleContext00](self.impl), cast[ptr WidgetPath00](path.impl))

proc `path=`*(self: StyleContext; path: WidgetPath) =
  gtk_style_context_set_path(cast[ptr StyleContext00](self.impl), cast[ptr WidgetPath00](path.impl))

proc gtk_style_provider_get_style(self: ptr StyleProvider00; path: ptr WidgetPath00): ptr StyleProperties00 {.
    importc, libprag.}

proc getStyle*(self: StyleProvider | StyleProperties | CssProvider | Settings;
    path: WidgetPath): StyleProperties =
  let gobj = gtk_style_provider_get_style(cast[ptr StyleProvider00](self.impl), cast[ptr WidgetPath00](path.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_style_provider_get_style_property(self: ptr StyleProvider00; path: ptr WidgetPath00;
    state: StateFlags; pspec: ptr gobject.ParamSpec00; value: var gobject.Value): gboolean {.
    importc, libprag.}

proc getStyleProperty*(self: StyleProvider | StyleProperties | CssProvider | Settings;
    path: WidgetPath; state: StateFlags; pspec: gobject.ParamSpec; value: var gobject.Value): bool =
  toBool(gtk_style_provider_get_style_property(cast[ptr StyleProvider00](self.impl), cast[ptr WidgetPath00](path.impl), state, cast[ptr gobject.ParamSpec00](pspec.impl), value))

type
  IconFactory* = ref object of gobject.Object
  IconFactory00* = object of gobject.Object00

proc gtk_icon_factory_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconFactory()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_icon_factory_new(): ptr IconFactory00 {.
    importc, libprag.}

proc newIconFactory*(): IconFactory {.deprecated.}  =
  let gobj = gtk_icon_factory_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconFactory*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is IconFactory)
  let gobj = gtk_icon_factory_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconFactory*[T](result: var T) {.deprecated.} =
  assert(result is IconFactory)
  let gobj = gtk_icon_factory_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_factory_lookup_default(stockId: cstring): ptr IconSet00 {.
    importc, libprag.}

proc lookupDefault*(stockId: cstring): IconSet =
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_factory_lookup_default(stockId)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_icon_set_get_type(), result.impl))

proc gtk_icon_factory_add(self: ptr IconFactory00; stockId: cstring; iconSet: ptr IconSet00) {.
    importc, libprag.}

proc add*(self: IconFactory; stockId: cstring; iconSet: IconSet) =
  gtk_icon_factory_add(cast[ptr IconFactory00](self.impl), stockId, cast[ptr IconSet00](iconSet.impl))

proc gtk_icon_factory_add_default(self: ptr IconFactory00) {.
    importc, libprag.}

proc addDefault*(self: IconFactory) =
  gtk_icon_factory_add_default(cast[ptr IconFactory00](self.impl))

proc gtk_icon_factory_lookup(self: ptr IconFactory00; stockId: cstring): ptr IconSet00 {.
    importc, libprag.}

proc lookup*(self: IconFactory; stockId: cstring): IconSet =
  fnew(result, gBoxedFreeGtkIconSet)
  result.impl = gtk_icon_factory_lookup(cast[ptr IconFactory00](self.impl), stockId)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_icon_set_get_type(), result.impl))

proc gtk_icon_factory_remove_default(self: ptr IconFactory00) {.
    importc, libprag.}

proc removeDefault*(self: IconFactory) =
  gtk_icon_factory_remove_default(cast[ptr IconFactory00](self.impl))

proc gtk_style_provider_get_icon_factory(self: ptr StyleProvider00; path: ptr WidgetPath00): ptr IconFactory00 {.
    importc, libprag.}

proc getIconFactory*(self: StyleProvider | StyleProperties | CssProvider | Settings;
    path: WidgetPath): IconFactory =
  let gobj = gtk_style_provider_get_icon_factory(cast[ptr StyleProvider00](self.impl), cast[ptr WidgetPath00](path.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Adjustment* = ref object of gobject.InitiallyUnowned
  Adjustment00* = object of gobject.InitiallyUnowned00

proc gtk_adjustment_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Adjustment()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: Adjustment;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: Adjustment;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_adjustment_new(value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble): ptr Adjustment00 {.
    importc, libprag.}

proc newAdjustment*(value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble = 1.0): Adjustment =
  let gobj = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAdjustment*(tdesc: typedesc; value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble = 1.0): tdesc =
  assert(result is Adjustment)
  let gobj = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAdjustment*[T](result: var T; value: cdouble; lower: cdouble; upper: cdouble; stepIncrement: cdouble;
    pageIncrement: cdouble; pageSize: cdouble = 1.0) {.deprecated.} =
  assert(result is Adjustment)
  let gobj = gtk_adjustment_new(value, lower, upper, stepIncrement, pageIncrement, pageSize)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_adjustment_changed(self: ptr Adjustment00) {.
    importc, libprag.}

proc changed*(self: Adjustment) =
  gtk_adjustment_changed(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_clamp_page(self: ptr Adjustment00; lower: cdouble; upper: cdouble) {.
    importc, libprag.}

proc clampPage*(self: Adjustment; lower: cdouble; upper: cdouble) =
  gtk_adjustment_clamp_page(cast[ptr Adjustment00](self.impl), lower, upper)

proc gtk_adjustment_configure(self: ptr Adjustment00; value: cdouble; lower: cdouble;
    upper: cdouble; stepIncrement: cdouble; pageIncrement: cdouble; pageSize: cdouble) {.
    importc, libprag.}

proc configure*(self: Adjustment; value: cdouble; lower: cdouble;
    upper: cdouble; stepIncrement: cdouble; pageIncrement: cdouble; pageSize: cdouble) =
  gtk_adjustment_configure(cast[ptr Adjustment00](self.impl), value, lower, upper, stepIncrement, pageIncrement, pageSize)

proc gtk_adjustment_get_lower(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getLower*(self: Adjustment): cdouble =
  gtk_adjustment_get_lower(cast[ptr Adjustment00](self.impl))

proc lower*(self: Adjustment): cdouble =
  gtk_adjustment_get_lower(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_minimum_increment(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getMinimumIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_minimum_increment(cast[ptr Adjustment00](self.impl))

proc minimumIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_minimum_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_page_increment(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getPageIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_increment(cast[ptr Adjustment00](self.impl))

proc pageIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_page_size(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getPageSize*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_size(cast[ptr Adjustment00](self.impl))

proc pageSize*(self: Adjustment): cdouble =
  gtk_adjustment_get_page_size(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_step_increment(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getStepIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_step_increment(cast[ptr Adjustment00](self.impl))

proc stepIncrement*(self: Adjustment): cdouble =
  gtk_adjustment_get_step_increment(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_upper(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getUpper*(self: Adjustment): cdouble =
  gtk_adjustment_get_upper(cast[ptr Adjustment00](self.impl))

proc upper*(self: Adjustment): cdouble =
  gtk_adjustment_get_upper(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_get_value(self: ptr Adjustment00): cdouble {.
    importc, libprag.}

proc getValue*(self: Adjustment): cdouble =
  gtk_adjustment_get_value(cast[ptr Adjustment00](self.impl))

proc value*(self: Adjustment): cdouble =
  gtk_adjustment_get_value(cast[ptr Adjustment00](self.impl))

proc gtk_adjustment_set_lower(self: ptr Adjustment00; lower: cdouble) {.
    importc, libprag.}

proc setLower*(self: Adjustment; lower: cdouble) =
  gtk_adjustment_set_lower(cast[ptr Adjustment00](self.impl), lower)

proc `lower=`*(self: Adjustment; lower: cdouble) =
  gtk_adjustment_set_lower(cast[ptr Adjustment00](self.impl), lower)

proc gtk_adjustment_set_page_increment(self: ptr Adjustment00; pageIncrement: cdouble) {.
    importc, libprag.}

proc setPageIncrement*(self: Adjustment; pageIncrement: cdouble) =
  gtk_adjustment_set_page_increment(cast[ptr Adjustment00](self.impl), pageIncrement)

proc `pageIncrement=`*(self: Adjustment; pageIncrement: cdouble) =
  gtk_adjustment_set_page_increment(cast[ptr Adjustment00](self.impl), pageIncrement)

proc gtk_adjustment_set_page_size(self: ptr Adjustment00; pageSize: cdouble) {.
    importc, libprag.}

proc setPageSize*(self: Adjustment; pageSize: cdouble) =
  gtk_adjustment_set_page_size(cast[ptr Adjustment00](self.impl), pageSize)

proc `pageSize=`*(self: Adjustment; pageSize: cdouble) =
  gtk_adjustment_set_page_size(cast[ptr Adjustment00](self.impl), pageSize)

proc gtk_adjustment_set_step_increment(self: ptr Adjustment00; stepIncrement: cdouble) {.
    importc, libprag.}

proc setStepIncrement*(self: Adjustment; stepIncrement: cdouble) =
  gtk_adjustment_set_step_increment(cast[ptr Adjustment00](self.impl), stepIncrement)

proc `stepIncrement=`*(self: Adjustment; stepIncrement: cdouble) =
  gtk_adjustment_set_step_increment(cast[ptr Adjustment00](self.impl), stepIncrement)

proc gtk_adjustment_set_upper(self: ptr Adjustment00; upper: cdouble) {.
    importc, libprag.}

proc setUpper*(self: Adjustment; upper: cdouble) =
  gtk_adjustment_set_upper(cast[ptr Adjustment00](self.impl), upper)

proc `upper=`*(self: Adjustment; upper: cdouble) =
  gtk_adjustment_set_upper(cast[ptr Adjustment00](self.impl), upper)

proc gtk_adjustment_set_value(self: ptr Adjustment00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: Adjustment; value: cdouble) =
  gtk_adjustment_set_value(cast[ptr Adjustment00](self.impl), value)

proc `value=`*(self: Adjustment; value: cdouble) =
  gtk_adjustment_set_value(cast[ptr Adjustment00](self.impl), value)

proc gtk_adjustment_value_changed(self: ptr Adjustment00) {.
    importc, libprag.}

proc valueChanged*(self: Adjustment) =
  gtk_adjustment_value_changed(cast[ptr Adjustment00](self.impl))

proc gtk_container_get_focus_hadjustment(self: ptr Container00): ptr Adjustment00 {.
    importc, libprag.}

proc getFocusHadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_hadjustment(cast[ptr Container00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusHadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_hadjustment(cast[ptr Container00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_get_focus_vadjustment(self: ptr Container00): ptr Adjustment00 {.
    importc, libprag.}

proc getFocusVadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_vadjustment(cast[ptr Container00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusVadjustment*(self: Container): Adjustment =
  let gobj = gtk_container_get_focus_vadjustment(cast[ptr Container00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_set_focus_hadjustment(self: ptr Container00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setFocusHadjustment*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_hadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `focusHadjustment=`*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_hadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_container_set_focus_vadjustment(self: ptr Container00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setFocusVadjustment*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_vadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `focusVadjustment=`*(self: Container; adjustment: Adjustment) =
  gtk_container_set_focus_vadjustment(cast[ptr Container00](self.impl), cast[ptr Adjustment00](adjustment.impl))

type
  ResizeMode* {.size: sizeof(cint), pure.} = enum
    parent = 0
    queue = 1
    immediate = 2

proc gtk_container_get_resize_mode(self: ptr Container00): ResizeMode {.
    importc, libprag.}

proc getResizeMode*(self: Container): ResizeMode =
  gtk_container_get_resize_mode(cast[ptr Container00](self.impl))

proc resizeMode*(self: Container): ResizeMode =
  gtk_container_get_resize_mode(cast[ptr Container00](self.impl))

proc gtk_container_set_resize_mode(self: ptr Container00; resizeMode: ResizeMode) {.
    importc, libprag.}

proc setResizeMode*(self: Container; resizeMode: ResizeMode) =
  gtk_container_set_resize_mode(cast[ptr Container00](self.impl), resizeMode)

proc `resizeMode=`*(self: Container; resizeMode: ResizeMode) =
  gtk_container_set_resize_mode(cast[ptr Container00](self.impl), resizeMode)

type
  TextIter* {.pure, byRef.} = object
    dummy1*: pointer
    dummy2*: pointer
    dummy3*: int32
    dummy4*: int32
    dummy5*: int32
    dummy6*: int32
    dummy7*: int32
    dummy8*: int32
    dummy9*: pointer
    dummy10*: pointer
    dummy11*: int32
    dummy12*: int32
    dummy13*: int32
    dummy14*: pointer

proc gtk_text_iter_get_type*(): GType {.importc, libprag.}

proc gtk_text_iter_free(self: TextIter) {.
    importc, libprag.}

proc free*(self: TextIter) =
  gtk_text_iter_free(self)

proc gtk_text_iter_backward_char(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardChar*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_char(self))

proc gtk_text_iter_backward_chars(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardChars*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_chars(self, int32(count)))

proc gtk_text_iter_backward_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_cursor_position(self))

proc gtk_text_iter_backward_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_cursor_positions(self, int32(count)))

proc gtk_text_iter_backward_line(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardLine*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_line(self))

proc gtk_text_iter_backward_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_lines(self, int32(count)))

proc gtk_text_iter_backward_sentence_start(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardSentenceStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_sentence_start(self))

proc gtk_text_iter_backward_sentence_starts(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardSentenceStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_sentence_starts(self, int32(count)))

proc gtk_text_iter_backward_visible_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardVisibleCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_cursor_position(self))

proc gtk_text_iter_backward_visible_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardVisibleCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_cursor_positions(self, int32(count)))

proc gtk_text_iter_backward_visible_line(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardVisibleLine*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_line(self))

proc gtk_text_iter_backward_visible_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardVisibleLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_lines(self, int32(count)))

proc gtk_text_iter_backward_visible_word_start(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardVisibleWordStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_visible_word_start(self))

proc gtk_text_iter_backward_visible_word_starts(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardVisibleWordStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_visible_word_starts(self, int32(count)))

proc gtk_text_iter_backward_word_start(self: TextIter): gboolean {.
    importc, libprag.}

proc backwardWordStart*(self: TextIter): bool =
  toBool(gtk_text_iter_backward_word_start(self))

proc gtk_text_iter_backward_word_starts(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc backwardWordStarts*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_backward_word_starts(self, int32(count)))

proc gtk_text_iter_can_insert(self: TextIter; defaultEditability: gboolean): gboolean {.
    importc, libprag.}

proc canInsert*(self: TextIter; defaultEditability: bool): bool =
  toBool(gtk_text_iter_can_insert(self, gboolean(defaultEditability)))

proc gtk_text_iter_compare(self: TextIter; rhs: TextIter): int32 {.
    importc, libprag.}

proc compare*(self: TextIter; rhs: TextIter): int =
  int(gtk_text_iter_compare(self, rhs))

proc gtk_text_iter_editable(self: TextIter; defaultSetting: gboolean): gboolean {.
    importc, libprag.}

proc editable*(self: TextIter; defaultSetting: bool): bool =
  toBool(gtk_text_iter_editable(self, gboolean(defaultSetting)))

proc gtk_text_iter_ends_line(self: TextIter): gboolean {.
    importc, libprag.}

proc endsLine*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_line(self))

proc gtk_text_iter_ends_sentence(self: TextIter): gboolean {.
    importc, libprag.}

proc endsSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_sentence(self))

proc gtk_text_iter_ends_word(self: TextIter): gboolean {.
    importc, libprag.}

proc endsWord*(self: TextIter): bool =
  toBool(gtk_text_iter_ends_word(self))

proc gtk_text_iter_equal(self: TextIter; rhs: TextIter): gboolean {.
    importc, libprag.}

proc equal*(self: TextIter; rhs: TextIter): bool =
  toBool(gtk_text_iter_equal(self, rhs))

proc gtk_text_iter_forward_char(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardChar*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_char(self))

proc gtk_text_iter_forward_chars(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardChars*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_chars(self, int32(count)))

proc gtk_text_iter_forward_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_cursor_position(self))

proc gtk_text_iter_forward_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_cursor_positions(self, int32(count)))

proc gtk_text_iter_forward_line(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardLine*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_line(self))

proc gtk_text_iter_forward_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_lines(self, int32(count)))

proc gtk_text_iter_forward_sentence_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardSentenceEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_sentence_end(self))

proc gtk_text_iter_forward_sentence_ends(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardSentenceEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_sentence_ends(self, int32(count)))

proc gtk_text_iter_forward_to_end(self: TextIter) {.
    importc, libprag.}

proc forwardToEnd*(self: TextIter) =
  gtk_text_iter_forward_to_end(self)

proc gtk_text_iter_forward_to_line_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardToLineEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_to_line_end(self))

proc gtk_text_iter_forward_visible_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardVisibleCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_cursor_position(self))

proc gtk_text_iter_forward_visible_cursor_positions(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardVisibleCursorPositions*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_cursor_positions(self, int32(count)))

proc gtk_text_iter_forward_visible_line(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardVisibleLine*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_line(self))

proc gtk_text_iter_forward_visible_lines(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardVisibleLines*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_lines(self, int32(count)))

proc gtk_text_iter_forward_visible_word_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardVisibleWordEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_visible_word_end(self))

proc gtk_text_iter_forward_visible_word_ends(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardVisibleWordEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_visible_word_ends(self, int32(count)))

proc gtk_text_iter_forward_word_end(self: TextIter): gboolean {.
    importc, libprag.}

proc forwardWordEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_forward_word_end(self))

proc gtk_text_iter_forward_word_ends(self: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc forwardWordEnds*(self: TextIter; count: int): bool =
  toBool(gtk_text_iter_forward_word_ends(self, int32(count)))

proc gtk_text_iter_assign(self: TextIter; other: TextIter) {.
    importc, libprag.}

proc assign*(self: TextIter; other: TextIter) =
  gtk_text_iter_assign(self, other)

proc gtk_text_iter_get_bytes_in_line(self: TextIter): int32 {.
    importc, libprag.}

proc getBytesInLine*(self: TextIter): int =
  int(gtk_text_iter_get_bytes_in_line(self))

proc bytesInLine*(self: TextIter): int =
  int(gtk_text_iter_get_bytes_in_line(self))

proc gtk_text_iter_get_char(self: TextIter): gunichar {.
    importc, libprag.}

proc getChar*(self: TextIter): gunichar =
  gtk_text_iter_get_char(self)

proc gtk_text_iter_get_chars_in_line(self: TextIter): int32 {.
    importc, libprag.}

proc getCharsInLine*(self: TextIter): int =
  int(gtk_text_iter_get_chars_in_line(self))

proc charsInLine*(self: TextIter): int =
  int(gtk_text_iter_get_chars_in_line(self))

proc gtk_text_iter_get_language(self: TextIter): ptr pango.Language00 {.
    importc, libprag.}

proc getLanguage*(self: TextIter): pango.Language =
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = gtk_text_iter_get_language(self)

proc language*(self: TextIter): pango.Language =
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = gtk_text_iter_get_language(self)

proc gtk_text_iter_get_line(self: TextIter): int32 {.
    importc, libprag.}

proc getLine*(self: TextIter): int =
  int(gtk_text_iter_get_line(self))

proc line*(self: TextIter): int =
  int(gtk_text_iter_get_line(self))

proc gtk_text_iter_get_line_index(self: TextIter): int32 {.
    importc, libprag.}

proc getLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_line_index(self))

proc lineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_line_index(self))

proc gtk_text_iter_get_line_offset(self: TextIter): int32 {.
    importc, libprag.}

proc getLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_line_offset(self))

proc lineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_line_offset(self))

proc gtk_text_iter_get_offset(self: TextIter): int32 {.
    importc, libprag.}

proc getOffset*(self: TextIter): int =
  int(gtk_text_iter_get_offset(self))

proc offset*(self: TextIter): int =
  int(gtk_text_iter_get_offset(self))

proc gtk_text_iter_get_pixbuf(self: TextIter): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPixbuf*(self: TextIter): gdkpixbuf.Pixbuf =
  let gobj = gtk_text_iter_get_pixbuf(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: TextIter): gdkpixbuf.Pixbuf =
  let gobj = gtk_text_iter_get_pixbuf(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_iter_get_slice(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getSlice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_slice(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_text(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getText*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_text(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_visible_line_index(self: TextIter): int32 {.
    importc, libprag.}

proc getVisibleLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_index(self))

proc visibleLineIndex*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_index(self))

proc gtk_text_iter_get_visible_line_offset(self: TextIter): int32 {.
    importc, libprag.}

proc getVisibleLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_offset(self))

proc visibleLineOffset*(self: TextIter): int =
  int(gtk_text_iter_get_visible_line_offset(self))

proc gtk_text_iter_get_visible_slice(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getVisibleSlice*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_slice(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_get_visible_text(self: TextIter; `end`: TextIter): cstring {.
    importc, libprag.}

proc getVisibleText*(self: TextIter; `end`: TextIter): string =
  let resul0 = gtk_text_iter_get_visible_text(self, `end`)
  result = $resul0
  cogfree(resul0)

proc gtk_text_iter_in_range(self: TextIter; start: TextIter; `end`: TextIter): gboolean {.
    importc, libprag.}

proc inRange*(self: TextIter; start: TextIter; `end`: TextIter): bool =
  toBool(gtk_text_iter_in_range(self, start, `end`))

proc gtk_text_iter_inside_sentence(self: TextIter): gboolean {.
    importc, libprag.}

proc insideSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_inside_sentence(self))

proc gtk_text_iter_inside_word(self: TextIter): gboolean {.
    importc, libprag.}

proc insideWord*(self: TextIter): bool =
  toBool(gtk_text_iter_inside_word(self))

proc gtk_text_iter_is_cursor_position(self: TextIter): gboolean {.
    importc, libprag.}

proc isCursorPosition*(self: TextIter): bool =
  toBool(gtk_text_iter_is_cursor_position(self))

proc gtk_text_iter_is_end(self: TextIter): gboolean {.
    importc, libprag.}

proc isEnd*(self: TextIter): bool =
  toBool(gtk_text_iter_is_end(self))

proc gtk_text_iter_is_start(self: TextIter): gboolean {.
    importc, libprag.}

proc isStart*(self: TextIter): bool =
  toBool(gtk_text_iter_is_start(self))

proc gtk_text_iter_order(self: TextIter; second: TextIter) {.
    importc, libprag.}

proc order*(self: TextIter; second: TextIter) =
  gtk_text_iter_order(self, second)

proc gtk_text_iter_set_line(self: TextIter; lineNumber: int32) {.
    importc, libprag.}

proc setLine*(self: TextIter; lineNumber: int) =
  gtk_text_iter_set_line(self, int32(lineNumber))

proc `line=`*(self: TextIter; lineNumber: int) =
  gtk_text_iter_set_line(self, int32(lineNumber))

proc gtk_text_iter_set_line_index(self: TextIter; byteOnLine: int32) {.
    importc, libprag.}

proc setLineIndex*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_line_index(self, int32(byteOnLine))

proc `lineIndex=`*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_line_index(self, int32(byteOnLine))

proc gtk_text_iter_set_line_offset(self: TextIter; charOnLine: int32) {.
    importc, libprag.}

proc setLineOffset*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_line_offset(self, int32(charOnLine))

proc `lineOffset=`*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_line_offset(self, int32(charOnLine))

proc gtk_text_iter_set_offset(self: TextIter; charOffset: int32) {.
    importc, libprag.}

proc setOffset*(self: TextIter; charOffset: int) =
  gtk_text_iter_set_offset(self, int32(charOffset))

proc `offset=`*(self: TextIter; charOffset: int) =
  gtk_text_iter_set_offset(self, int32(charOffset))

proc gtk_text_iter_set_visible_line_index(self: TextIter; byteOnLine: int32) {.
    importc, libprag.}

proc setVisibleLineIndex*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_visible_line_index(self, int32(byteOnLine))

proc `visibleLineIndex=`*(self: TextIter; byteOnLine: int) =
  gtk_text_iter_set_visible_line_index(self, int32(byteOnLine))

proc gtk_text_iter_set_visible_line_offset(self: TextIter; charOnLine: int32) {.
    importc, libprag.}

proc setVisibleLineOffset*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_visible_line_offset(self, int32(charOnLine))

proc `visibleLineOffset=`*(self: TextIter; charOnLine: int) =
  gtk_text_iter_set_visible_line_offset(self, int32(charOnLine))

proc gtk_text_iter_starts_line(self: TextIter): gboolean {.
    importc, libprag.}

proc startsLine*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_line(self))

proc gtk_text_iter_starts_sentence(self: TextIter): gboolean {.
    importc, libprag.}

proc startsSentence*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_sentence(self))

proc gtk_text_iter_starts_word(self: TextIter): gboolean {.
    importc, libprag.}

proc startsWord*(self: TextIter): bool =
  toBool(gtk_text_iter_starts_word(self))

type
  TextTag* = ref object of gobject.Object
  TextTag00* = object of gobject.Object00

proc gtk_text_tag_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextTag()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEvent*(self: TextTag;  p: proc (self: ptr TextTag00; `object`: ptr gobject.Object00; event: ptr gdk.Event00; iter: TextIter; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "event", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_tag_new(name: cstring): ptr TextTag00 {.
    importc, libprag.}

proc newTextTag*(name: cstring = nil): TextTag =
  let gobj = gtk_text_tag_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextTag*(tdesc: typedesc; name: cstring = nil): tdesc =
  assert(result is TextTag)
  let gobj = gtk_text_tag_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextTag*[T](result: var T; name: cstring = nil) {.deprecated.} =
  assert(result is TextTag)
  let gobj = gtk_text_tag_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_changed(self: ptr TextTag00; sizeChanged: gboolean) {.
    importc, libprag.}

proc changed*(self: TextTag; sizeChanged: bool) =
  gtk_text_tag_changed(cast[ptr TextTag00](self.impl), gboolean(sizeChanged))

proc gtk_text_tag_event(self: ptr TextTag00; eventObject: ptr gobject.Object00;
    event: ptr gdk.Event00; iter: TextIter): gboolean {.
    importc, libprag.}

proc event*(self: TextTag; eventObject: gobject.Object; event: gdk.Event;
    iter: TextIter): bool =
  toBool(gtk_text_tag_event(cast[ptr TextTag00](self.impl), cast[ptr gobject.Object00](eventObject.impl), cast[ptr gdk.Event00](event.impl), iter))

proc gtk_text_tag_get_priority(self: ptr TextTag00): int32 {.
    importc, libprag.}

proc getPriority*(self: TextTag): int =
  int(gtk_text_tag_get_priority(cast[ptr TextTag00](self.impl)))

proc priority*(self: TextTag): int =
  int(gtk_text_tag_get_priority(cast[ptr TextTag00](self.impl)))

proc gtk_text_tag_set_priority(self: ptr TextTag00; priority: int32) {.
    importc, libprag.}

proc setPriority*(self: TextTag; priority: int) =
  gtk_text_tag_set_priority(cast[ptr TextTag00](self.impl), int32(priority))

proc `priority=`*(self: TextTag; priority: int) =
  gtk_text_tag_set_priority(cast[ptr TextTag00](self.impl), int32(priority))

proc gtk_text_iter_backward_to_tag_toggle(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc backwardToTagToggle*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_backward_to_tag_toggle(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_begins_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc beginsTag*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_begins_tag(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_ends_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc endsTag*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_ends_tag(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_forward_to_tag_toggle(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc forwardToTagToggle*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_forward_to_tag_toggle(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_get_tags(self: TextIter): ptr glib.SList {.
    importc, libprag.}

proc getTags*(self: TextIter): seq[TextTag] =
  let resul0 = gtk_text_iter_get_tags(self)
  result = gslistObjects2seq(TextTag, resul0, false)
  g_slist_free(resul0)

proc tags*(self: TextIter): seq[TextTag] =
  let resul0 = gtk_text_iter_get_tags(self)
  result = gslistObjects2seq(TextTag, resul0, false)
  g_slist_free(resul0)

proc gtk_text_iter_get_toggled_tags(self: TextIter; toggledOn: gboolean): ptr glib.SList {.
    importc, libprag.}

proc getToggledTags*(self: TextIter; toggledOn: bool): seq[TextTag] =
  let resul0 = gtk_text_iter_get_toggled_tags(self, gboolean(toggledOn))
  result = gslistObjects2seq(TextTag, resul0, false)
  g_slist_free(resul0)

proc gtk_text_iter_has_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc hasTag*(self: TextIter; tag: TextTag): bool =
  toBool(gtk_text_iter_has_tag(self, cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_starts_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc startsTag*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_starts_tag(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

proc gtk_text_iter_toggles_tag(self: TextIter; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc togglesTag*(self: TextIter; tag: TextTag = nil): bool =
  toBool(gtk_text_iter_toggles_tag(self, if tag.isNil: nil else: cast[ptr TextTag00](tag.impl)))

type
  TextSearchFlag* {.size: sizeof(cint), pure.} = enum
    visibleOnly = 0
    textOnly = 1
    caseInsensitive = 2

  TextSearchFlags* {.size: sizeof(cint).} = set[TextSearchFlag]

proc gtk_text_iter_backward_search(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter; matchEnd: var TextIter; limit: TextIter): gboolean {.
    importc, libprag.}

proc backwardSearch*(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter = cast[var TextIter](nil); matchEnd: var TextIter = cast[var TextIter](nil);
    limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_backward_search(self, str, flags, matchStart, matchEnd, limit))

proc gtk_text_iter_forward_search(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter; matchEnd: var TextIter; limit: TextIter): gboolean {.
    importc, libprag.}

proc forwardSearch*(self: TextIter; str: cstring; flags: TextSearchFlags;
    matchStart: var TextIter = cast[var TextIter](nil); matchEnd: var TextIter = cast[var TextIter](nil);
    limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_forward_search(self, str, flags, matchStart, matchEnd, limit))

type
  TextAttributes00* {.pure.} = object
  TextAttributes* = ref object
    impl*: ptr TextAttributes00
    ignoreFinalizer*: bool

proc gtk_text_attributes_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkTextAttributes*(self: TextAttributes) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_text_attributes_get_type(), cast[ptr TextAttributes00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextAttributes()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_text_attributes_get_type(), cast[ptr TextAttributes00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var TextAttributes) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkTextAttributes)

proc gtk_text_attributes_unref(self: ptr TextAttributes00) {.
    importc, libprag.}

proc unref*(self: TextAttributes) =
  gtk_text_attributes_unref(cast[ptr TextAttributes00](self.impl))

proc finalizerunref*(self: TextAttributes) =
  if not self.ignoreFinalizer:
    gtk_text_attributes_unref(cast[ptr TextAttributes00](self.impl))

proc gtk_text_attributes_copy(self: ptr TextAttributes00): ptr TextAttributes00 {.
    importc, libprag.}

proc copy*(self: TextAttributes): TextAttributes =
  fnew(result, gBoxedFreeGtkTextAttributes)
  result.impl = gtk_text_attributes_copy(cast[ptr TextAttributes00](self.impl))

proc gtk_text_attributes_copy_values(self: ptr TextAttributes00; dest: ptr TextAttributes00) {.
    importc, libprag.}

proc copyValues*(self: TextAttributes; dest: TextAttributes) =
  gtk_text_attributes_copy_values(cast[ptr TextAttributes00](self.impl), cast[ptr TextAttributes00](dest.impl))

proc gtk_text_attributes_ref(self: ptr TextAttributes00): ptr TextAttributes00 {.
    importc, libprag.}

proc `ref`*(self: TextAttributes): TextAttributes =
  fnew(result, gBoxedFreeGtkTextAttributes)
  result.impl = gtk_text_attributes_ref(cast[ptr TextAttributes00](self.impl))

proc gtk_text_attributes_new(): ptr TextAttributes00 {.
    importc, libprag.}

proc newTextAttributes*(): TextAttributes =
  fnew(result, gBoxedFreeGtkTextAttributes)
  result.impl = gtk_text_attributes_new()

proc newTextAttributes*(tdesc: typedesc): tdesc =
  assert(result is TextAttributes)
  fnew(result, gBoxedFreeGtkTextAttributes)
  result.impl = gtk_text_attributes_new()

proc initTextAttributes*[T](result: var T) {.deprecated.} =
  assert(result is TextAttributes)
  fnew(result, gBoxedFreeGtkTextAttributes)
  result.impl = gtk_text_attributes_new()

proc gtk_text_iter_get_attributes(self: TextIter; values: var TextAttributes00): gboolean {.
    importc, libprag.}

proc getAttributes*(self: TextIter; values: var TextAttributes00): bool =
  toBool(gtk_text_iter_get_attributes(self, values))

type
  TextChildAnchor* = ref object of gobject.Object
  TextChildAnchor00* = object of gobject.Object00

proc gtk_text_child_anchor_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextChildAnchor()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_text_child_anchor_new(): ptr TextChildAnchor00 {.
    importc, libprag.}

proc newTextChildAnchor*(): TextChildAnchor =
  let gobj = gtk_text_child_anchor_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextChildAnchor*(tdesc: typedesc): tdesc =
  assert(result is TextChildAnchor)
  let gobj = gtk_text_child_anchor_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextChildAnchor*[T](result: var T) {.deprecated.} =
  assert(result is TextChildAnchor)
  let gobj = gtk_text_child_anchor_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_child_anchor_get_deleted(self: ptr TextChildAnchor00): gboolean {.
    importc, libprag.}

proc getDeleted*(self: TextChildAnchor): bool =
  toBool(gtk_text_child_anchor_get_deleted(cast[ptr TextChildAnchor00](self.impl)))

proc deleted*(self: TextChildAnchor): bool =
  toBool(gtk_text_child_anchor_get_deleted(cast[ptr TextChildAnchor00](self.impl)))

proc gtk_text_child_anchor_get_widgets(self: ptr TextChildAnchor00): ptr glib.List {.
    importc, libprag.}

proc getWidgets*(self: TextChildAnchor): seq[Widget] =
  let resul0 = gtk_text_child_anchor_get_widgets(cast[ptr TextChildAnchor00](self.impl))
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc widgets*(self: TextChildAnchor): seq[Widget] =
  let resul0 = gtk_text_child_anchor_get_widgets(cast[ptr TextChildAnchor00](self.impl))
  result = glistObjects2seq(Widget, resul0, false)
  g_list_free(resul0)

proc gtk_text_iter_get_child_anchor(self: TextIter): ptr TextChildAnchor00 {.
    importc, libprag.}

proc getChildAnchor*(self: TextIter): TextChildAnchor =
  let gobj = gtk_text_iter_get_child_anchor(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc childAnchor*(self: TextIter): TextChildAnchor =
  let gobj = gtk_text_iter_get_child_anchor(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TextMark* = ref object of gobject.Object
  TextMark00* = object of gobject.Object00

proc gtk_text_mark_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextMark()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_text_mark_new(name: cstring; leftGravity: gboolean): ptr TextMark00 {.
    importc, libprag.}

proc newTextMark*(name: cstring = nil; leftGravity: bool): TextMark =
  let gobj = gtk_text_mark_new(name, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextMark*(tdesc: typedesc; name: cstring = nil; leftGravity: bool): tdesc =
  assert(result is TextMark)
  let gobj = gtk_text_mark_new(name, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextMark*[T](result: var T; name: cstring = nil; leftGravity: bool) {.deprecated.} =
  assert(result is TextMark)
  let gobj = gtk_text_mark_new(name, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_mark_get_deleted(self: ptr TextMark00): gboolean {.
    importc, libprag.}

proc getDeleted*(self: TextMark): bool =
  toBool(gtk_text_mark_get_deleted(cast[ptr TextMark00](self.impl)))

proc deleted*(self: TextMark): bool =
  toBool(gtk_text_mark_get_deleted(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_get_left_gravity(self: ptr TextMark00): gboolean {.
    importc, libprag.}

proc getLeftGravity*(self: TextMark): bool =
  toBool(gtk_text_mark_get_left_gravity(cast[ptr TextMark00](self.impl)))

proc leftGravity*(self: TextMark): bool =
  toBool(gtk_text_mark_get_left_gravity(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_get_name(self: ptr TextMark00): cstring {.
    importc, libprag.}

proc getName*(self: TextMark): string =
  let resul0 = gtk_text_mark_get_name(cast[ptr TextMark00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: TextMark): string =
  let resul0 = gtk_text_mark_get_name(cast[ptr TextMark00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_text_mark_get_visible(self: ptr TextMark00): gboolean {.
    importc, libprag.}

proc getVisible*(self: TextMark): bool =
  toBool(gtk_text_mark_get_visible(cast[ptr TextMark00](self.impl)))

proc visible*(self: TextMark): bool =
  toBool(gtk_text_mark_get_visible(cast[ptr TextMark00](self.impl)))

proc gtk_text_mark_set_visible(self: ptr TextMark00; setting: gboolean) {.
    importc, libprag.}

proc setVisible*(self: TextMark; setting: bool = true) =
  gtk_text_mark_set_visible(cast[ptr TextMark00](self.impl), gboolean(setting))

proc `visible=`*(self: TextMark; setting: bool) =
  gtk_text_mark_set_visible(cast[ptr TextMark00](self.impl), gboolean(setting))

type
  TextBuffer* = ref object of gobject.Object
  TextBuffer00* = object of gobject.Object00

proc gtk_text_buffer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextBuffer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scApplyTag*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; tag: ptr TextTag00; start: TextIter; `end`: TextIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "apply-tag", cast[GCallback](p), xdata, nil, cf)

proc scBeginUserAction*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "begin-user-action", cast[GCallback](p), xdata, nil, cf)

proc scChanged*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scDeleteRange*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; start: TextIter; `end`: TextIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-range", cast[GCallback](p), xdata, nil, cf)

proc scEndUserAction*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "end-user-action", cast[GCallback](p), xdata, nil, cf)

proc scInsertChildAnchor*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; anchor: ptr TextChildAnchor00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-child-anchor", cast[GCallback](p), xdata, nil, cf)

proc scInsertPixbuf*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; pixbuf: ptr gdkpixbuf.Pixbuf00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-pixbuf", cast[GCallback](p), xdata, nil, cf)

proc scInsertText*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; text: cstring; len: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-text", cast[GCallback](p), xdata, nil, cf)

proc scMarkDeleted*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; mark: ptr TextMark00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "mark-deleted", cast[GCallback](p), xdata, nil, cf)

proc scMarkSet*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; location: TextIter; mark: ptr TextMark00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "mark-set", cast[GCallback](p), xdata, nil, cf)

proc scModifiedChanged*(self: TextBuffer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "modified-changed", cast[GCallback](p), xdata, nil, cf)

proc scPasteDone*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; clipboard: ptr Clipboard00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paste-done", cast[GCallback](p), xdata, nil, cf)

proc scRemoveTag*(self: TextBuffer;  p: proc (self: ptr TextBuffer00; tag: ptr TextTag00; start: TextIter; `end`: TextIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "remove-tag", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_buffer_add_mark(self: ptr TextBuffer00; mark: ptr TextMark00;
    where: TextIter) {.
    importc, libprag.}

proc addMark*(self: TextBuffer; mark: TextMark; where: TextIter) =
  gtk_text_buffer_add_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl), where)

proc gtk_text_buffer_add_selection_clipboard(self: ptr TextBuffer00; clipboard: ptr Clipboard00) {.
    importc, libprag.}

proc addSelectionClipboard*(self: TextBuffer; clipboard: Clipboard) =
  gtk_text_buffer_add_selection_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl))

proc gtk_text_buffer_apply_tag(self: ptr TextBuffer00; tag: ptr TextTag00;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc applyTag*(self: TextBuffer; tag: TextTag; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_apply_tag(cast[ptr TextBuffer00](self.impl), cast[ptr TextTag00](tag.impl), start, `end`)

proc gtk_text_buffer_apply_tag_by_name(self: ptr TextBuffer00; name: cstring;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc applyTagByName*(self: TextBuffer; name: cstring; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_apply_tag_by_name(cast[ptr TextBuffer00](self.impl), name, start, `end`)

proc gtk_text_buffer_backspace(self: ptr TextBuffer00; iter: TextIter; interactive: gboolean;
    defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc backspace*(self: TextBuffer; iter: TextIter; interactive: bool;
    defaultEditable: bool): bool =
  toBool(gtk_text_buffer_backspace(cast[ptr TextBuffer00](self.impl), iter, gboolean(interactive), gboolean(defaultEditable)))

proc gtk_text_buffer_begin_user_action(self: ptr TextBuffer00) {.
    importc, libprag.}

proc beginUserAction*(self: TextBuffer) =
  gtk_text_buffer_begin_user_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_copy_clipboard(self: ptr TextBuffer00; clipboard: ptr Clipboard00) {.
    importc, libprag.}

proc copyClipboard*(self: TextBuffer; clipboard: Clipboard) =
  gtk_text_buffer_copy_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl))

proc gtk_text_buffer_create_child_anchor(self: ptr TextBuffer00; iter: TextIter): ptr TextChildAnchor00 {.
    importc, libprag.}

proc createChildAnchor*(self: TextBuffer; iter: TextIter): TextChildAnchor =
  let gobj = gtk_text_buffer_create_child_anchor(cast[ptr TextBuffer00](self.impl), iter)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_create_mark(self: ptr TextBuffer00; markName: cstring;
    where: TextIter; leftGravity: gboolean): ptr TextMark00 {.
    importc, libprag.}

proc createMark*(self: TextBuffer; markName: cstring = nil;
    where: TextIter; leftGravity: bool): TextMark =
  let gobj = gtk_text_buffer_create_mark(cast[ptr TextBuffer00](self.impl), markName, where, gboolean(leftGravity))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_cut_clipboard(self: ptr TextBuffer00; clipboard: ptr Clipboard00;
    defaultEditable: gboolean) {.
    importc, libprag.}

proc cutClipboard*(self: TextBuffer; clipboard: Clipboard;
    defaultEditable: bool) =
  gtk_text_buffer_cut_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl), gboolean(defaultEditable))

proc gtk_text_buffer_delete(self: ptr TextBuffer00; start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc delete*(self: TextBuffer; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_delete(cast[ptr TextBuffer00](self.impl), start, `end`)

proc gtk_text_buffer_delete_interactive(self: ptr TextBuffer00; startIter: TextIter;
    endIter: TextIter; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc deleteInteractive*(self: TextBuffer; startIter: TextIter;
    endIter: TextIter; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_delete_interactive(cast[ptr TextBuffer00](self.impl), startIter, endIter, gboolean(defaultEditable)))

proc gtk_text_buffer_delete_mark(self: ptr TextBuffer00; mark: ptr TextMark00) {.
    importc, libprag.}

proc deleteMark*(self: TextBuffer; mark: TextMark) =
  gtk_text_buffer_delete_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl))

proc gtk_text_buffer_delete_mark_by_name(self: ptr TextBuffer00; name: cstring) {.
    importc, libprag.}

proc deleteMarkByName*(self: TextBuffer; name: cstring) =
  gtk_text_buffer_delete_mark_by_name(cast[ptr TextBuffer00](self.impl), name)

proc gtk_text_buffer_delete_selection(self: ptr TextBuffer00; interactive: gboolean;
    defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc deleteSelection*(self: TextBuffer; interactive: bool;
    defaultEditable: bool): bool =
  toBool(gtk_text_buffer_delete_selection(cast[ptr TextBuffer00](self.impl), gboolean(interactive), gboolean(defaultEditable)))

proc gtk_text_buffer_deserialize(self: ptr TextBuffer00; contentBuffer: ptr TextBuffer00;
    format: ptr gdk.Atom00; iter: TextIter; data: ptr uint8; length: uint64;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc deserialize*(self: TextBuffer; contentBuffer: TextBuffer;
    format: gdk.Atom; iter: TextIter; data: seq[uint8] | string): bool =
  let length = uint64(data.len)
  var gerror: ptr glib.Error
  let resul0 = gtk_text_buffer_deserialize(cast[ptr TextBuffer00](self.impl), cast[ptr TextBuffer00](contentBuffer.impl), cast[ptr gdk.Atom00](format.impl), iter, cast[ptr uint8](unsafeaddr(data[0])), length, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_text_buffer_deserialize_get_can_create_tags(self: ptr TextBuffer00;
    format: ptr gdk.Atom00): gboolean {.
    importc, libprag.}

proc deserializeGetCanCreateTags*(self: TextBuffer; format: gdk.Atom): bool =
  toBool(gtk_text_buffer_deserialize_get_can_create_tags(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl)))

proc gtk_text_buffer_deserialize_set_can_create_tags(self: ptr TextBuffer00;
    format: ptr gdk.Atom00; canCreateTags: gboolean) {.
    importc, libprag.}

proc deserializeSetCanCreateTags*(self: TextBuffer; format: gdk.Atom;
    canCreateTags: bool) =
  gtk_text_buffer_deserialize_set_can_create_tags(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl), gboolean(canCreateTags))

proc gtk_text_buffer_end_user_action(self: ptr TextBuffer00) {.
    importc, libprag.}

proc endUserAction*(self: TextBuffer) =
  gtk_text_buffer_end_user_action(cast[ptr TextBuffer00](self.impl))

proc gtk_text_buffer_get_bounds(self: ptr TextBuffer00; start: var TextIter;
    `end`: var TextIter) {.
    importc, libprag.}

proc getBounds*(self: TextBuffer; start: var TextIter; `end`: var TextIter) =
  gtk_text_buffer_get_bounds(cast[ptr TextBuffer00](self.impl), start, `end`)

proc gtk_text_buffer_get_char_count(self: ptr TextBuffer00): int32 {.
    importc, libprag.}

proc getCharCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_char_count(cast[ptr TextBuffer00](self.impl)))

proc charCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_char_count(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_copy_target_list(self: ptr TextBuffer00): ptr TargetList00 {.
    importc, libprag.}

proc getCopyTargetList*(self: TextBuffer): TargetList =
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_text_buffer_get_copy_target_list(cast[ptr TextBuffer00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_list_get_type(), result.impl))

proc copyTargetList*(self: TextBuffer): TargetList =
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_text_buffer_get_copy_target_list(cast[ptr TextBuffer00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_list_get_type(), result.impl))

proc gtk_text_buffer_get_deserialize_formats(self: ptr TextBuffer00; nFormats: var int32): ptr ptr gdk.Atom00 {.
    importc, libprag.}

proc getDeserializeFormats*(self: TextBuffer; nFormats: var int): ptr ptr gdk.Atom00 =
  var nFormats_00: int32
  result = gtk_text_buffer_get_deserialize_formats(cast[ptr TextBuffer00](self.impl), nFormats_00)
  if nFormats.addr != nil:
    nFormats = int(nFormats_00)

proc gtk_text_buffer_get_end_iter(self: ptr TextBuffer00; iter: var TextIter) {.
    importc, libprag.}

proc getEndIter*(self: TextBuffer; iter: var TextIter) =
  gtk_text_buffer_get_end_iter(cast[ptr TextBuffer00](self.impl), iter)

proc getEndIter*(self: TextBuffer): TextIter =
  gtk_text_buffer_get_end_iter(cast[ptr TextBuffer00](self.impl), result)

proc gtk_text_buffer_get_has_selection(self: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc getHasSelection*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_has_selection(cast[ptr TextBuffer00](self.impl)))

proc hasSelection*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_has_selection(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_insert(self: ptr TextBuffer00): ptr TextMark00 {.
    importc, libprag.}

proc getInsert*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_insert(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc insert*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_insert(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_iter_at_child_anchor(self: ptr TextBuffer00; iter: var TextIter;
    anchor: ptr TextChildAnchor00) {.
    importc, libprag.}

proc getIterAtChildAnchor*(self: TextBuffer; iter: var TextIter;
    anchor: TextChildAnchor) =
  gtk_text_buffer_get_iter_at_child_anchor(cast[ptr TextBuffer00](self.impl), iter, cast[ptr TextChildAnchor00](anchor.impl))

proc gtk_text_buffer_get_iter_at_line(self: ptr TextBuffer00; iter: var TextIter;
    lineNumber: int32) {.
    importc, libprag.}

proc getIterAtLine*(self: TextBuffer; iter: var TextIter;
    lineNumber: int) =
  gtk_text_buffer_get_iter_at_line(cast[ptr TextBuffer00](self.impl), iter, int32(lineNumber))

proc gtk_text_buffer_get_iter_at_line_index(self: ptr TextBuffer00; iter: var TextIter;
    lineNumber: int32; byteIndex: int32) {.
    importc, libprag.}

proc getIterAtLineIndex*(self: TextBuffer; iter: var TextIter;
    lineNumber: int; byteIndex: int) =
  gtk_text_buffer_get_iter_at_line_index(cast[ptr TextBuffer00](self.impl), iter, int32(lineNumber), int32(byteIndex))

proc gtk_text_buffer_get_iter_at_line_offset(self: ptr TextBuffer00; iter: var TextIter;
    lineNumber: int32; charOffset: int32) {.
    importc, libprag.}

proc getIterAtLineOffset*(self: TextBuffer; iter: var TextIter;
    lineNumber: int; charOffset: int) =
  gtk_text_buffer_get_iter_at_line_offset(cast[ptr TextBuffer00](self.impl), iter, int32(lineNumber), int32(charOffset))

proc gtk_text_buffer_get_iter_at_mark(self: ptr TextBuffer00; iter: var TextIter;
    mark: ptr TextMark00) {.
    importc, libprag.}

proc getIterAtMark*(self: TextBuffer; iter: var TextIter;
    mark: TextMark) =
  gtk_text_buffer_get_iter_at_mark(cast[ptr TextBuffer00](self.impl), iter, cast[ptr TextMark00](mark.impl))

proc gtk_text_buffer_get_iter_at_offset(self: ptr TextBuffer00; iter: var TextIter;
    charOffset: int32) {.
    importc, libprag.}

proc getIterAtOffset*(self: TextBuffer; iter: var TextIter;
    charOffset: int) =
  gtk_text_buffer_get_iter_at_offset(cast[ptr TextBuffer00](self.impl), iter, int32(charOffset))

proc gtk_text_buffer_get_line_count(self: ptr TextBuffer00): int32 {.
    importc, libprag.}

proc getLineCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_line_count(cast[ptr TextBuffer00](self.impl)))

proc lineCount*(self: TextBuffer): int =
  int(gtk_text_buffer_get_line_count(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_mark(self: ptr TextBuffer00; name: cstring): ptr TextMark00 {.
    importc, libprag.}

proc getMark*(self: TextBuffer; name: cstring): TextMark =
  let gobj = gtk_text_buffer_get_mark(cast[ptr TextBuffer00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_modified(self: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc getModified*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_modified(cast[ptr TextBuffer00](self.impl)))

proc modified*(self: TextBuffer): bool =
  toBool(gtk_text_buffer_get_modified(cast[ptr TextBuffer00](self.impl)))

proc gtk_text_buffer_get_paste_target_list(self: ptr TextBuffer00): ptr TargetList00 {.
    importc, libprag.}

proc getPasteTargetList*(self: TextBuffer): TargetList =
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_text_buffer_get_paste_target_list(cast[ptr TextBuffer00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_list_get_type(), result.impl))

proc pasteTargetList*(self: TextBuffer): TargetList =
  fnew(result, gBoxedFreeGtkTargetList)
  result.impl = gtk_text_buffer_get_paste_target_list(cast[ptr TextBuffer00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_list_get_type(), result.impl))

proc gtk_text_buffer_get_selection_bound(self: ptr TextBuffer00): ptr TextMark00 {.
    importc, libprag.}

proc getSelectionBound*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_selection_bound(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectionBound*(self: TextBuffer): TextMark =
  let gobj = gtk_text_buffer_get_selection_bound(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_selection_bounds(self: ptr TextBuffer00; start: var TextIter;
    `end`: var TextIter): gboolean {.
    importc, libprag.}

proc getSelectionBounds*(self: TextBuffer; start: var TextIter;
    `end`: var TextIter): bool =
  toBool(gtk_text_buffer_get_selection_bounds(cast[ptr TextBuffer00](self.impl), start, `end`))

proc gtk_text_buffer_get_serialize_formats(self: ptr TextBuffer00; nFormats: var int32): ptr ptr gdk.Atom00 {.
    importc, libprag.}

proc getSerializeFormats*(self: TextBuffer; nFormats: var int): ptr ptr gdk.Atom00 =
  var nFormats_00: int32
  result = gtk_text_buffer_get_serialize_formats(cast[ptr TextBuffer00](self.impl), nFormats_00)
  if nFormats.addr != nil:
    nFormats = int(nFormats_00)

proc gtk_text_buffer_get_slice(self: ptr TextBuffer00; start: TextIter; `end`: TextIter;
    includeHiddenChars: gboolean): cstring {.
    importc, libprag.}

proc getSlice*(self: TextBuffer; start: TextIter; `end`: TextIter;
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_slice(cast[ptr TextBuffer00](self.impl), start, `end`, gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc gtk_text_buffer_get_start_iter(self: ptr TextBuffer00; iter: var TextIter) {.
    importc, libprag.}

proc getStartIter*(self: TextBuffer; iter: var TextIter) =
  gtk_text_buffer_get_start_iter(cast[ptr TextBuffer00](self.impl), iter)

proc getStartIter*(self: TextBuffer): TextIter =
  gtk_text_buffer_get_start_iter(cast[ptr TextBuffer00](self.impl), result)

proc gtk_text_buffer_get_text(self: ptr TextBuffer00; start: TextIter; `end`: TextIter;
    includeHiddenChars: gboolean): cstring {.
    importc, libprag.}

proc getText*(self: TextBuffer; start: TextIter; `end`: TextIter;
    includeHiddenChars: bool): string =
  let resul0 = gtk_text_buffer_get_text(cast[ptr TextBuffer00](self.impl), start, `end`, gboolean(includeHiddenChars))
  result = $resul0
  cogfree(resul0)

proc gtk_text_buffer_insert(self: ptr TextBuffer00; iter: TextIter; text: cstring;
    len: int32) {.
    importc, libprag.}

proc insert*(self: TextBuffer; iter: TextIter; text: cstring;
    len: int) =
  gtk_text_buffer_insert(cast[ptr TextBuffer00](self.impl), iter, text, int32(len))

proc gtk_text_buffer_insert_at_cursor(self: ptr TextBuffer00; text: cstring;
    len: int32) {.
    importc, libprag.}

proc insertAtCursor*(self: TextBuffer; text: cstring; len: int) =
  gtk_text_buffer_insert_at_cursor(cast[ptr TextBuffer00](self.impl), text, int32(len))

proc gtk_text_buffer_insert_child_anchor(self: ptr TextBuffer00; iter: TextIter;
    anchor: ptr TextChildAnchor00) {.
    importc, libprag.}

proc insertChildAnchor*(self: TextBuffer; iter: TextIter;
    anchor: TextChildAnchor) =
  gtk_text_buffer_insert_child_anchor(cast[ptr TextBuffer00](self.impl), iter, cast[ptr TextChildAnchor00](anchor.impl))

proc gtk_text_buffer_insert_interactive(self: ptr TextBuffer00; iter: TextIter;
    text: cstring; len: int32; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc insertInteractive*(self: TextBuffer; iter: TextIter;
    text: cstring; len: int; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_interactive(cast[ptr TextBuffer00](self.impl), iter, text, int32(len), gboolean(defaultEditable)))

proc gtk_text_buffer_insert_interactive_at_cursor(self: ptr TextBuffer00;
    text: cstring; len: int32; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc insertInteractiveAtCursor*(self: TextBuffer; text: cstring;
    len: int; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_interactive_at_cursor(cast[ptr TextBuffer00](self.impl), text, int32(len), gboolean(defaultEditable)))

proc gtk_text_buffer_insert_markup(self: ptr TextBuffer00; iter: TextIter;
    markup: cstring; len: int32) {.
    importc, libprag.}

proc insertMarkup*(self: TextBuffer; iter: TextIter; markup: cstring;
    len: int) =
  gtk_text_buffer_insert_markup(cast[ptr TextBuffer00](self.impl), iter, markup, int32(len))

proc gtk_text_buffer_insert_pixbuf(self: ptr TextBuffer00; iter: TextIter;
    pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc insertPixbuf*(self: TextBuffer; iter: TextIter; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_text_buffer_insert_pixbuf(cast[ptr TextBuffer00](self.impl), iter, cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_text_buffer_insert_range(self: ptr TextBuffer00; iter: TextIter;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc insertRange*(self: TextBuffer; iter: TextIter; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_insert_range(cast[ptr TextBuffer00](self.impl), iter, start, `end`)

proc gtk_text_buffer_insert_range_interactive(self: ptr TextBuffer00; iter: TextIter;
    start: TextIter; `end`: TextIter; defaultEditable: gboolean): gboolean {.
    importc, libprag.}

proc insertRangeInteractive*(self: TextBuffer; iter: TextIter;
    start: TextIter; `end`: TextIter; defaultEditable: bool): bool =
  toBool(gtk_text_buffer_insert_range_interactive(cast[ptr TextBuffer00](self.impl), iter, start, `end`, gboolean(defaultEditable)))

proc gtk_text_buffer_move_mark(self: ptr TextBuffer00; mark: ptr TextMark00;
    where: TextIter) {.
    importc, libprag.}

proc moveMark*(self: TextBuffer; mark: TextMark; where: TextIter) =
  gtk_text_buffer_move_mark(cast[ptr TextBuffer00](self.impl), cast[ptr TextMark00](mark.impl), where)

proc gtk_text_buffer_move_mark_by_name(self: ptr TextBuffer00; name: cstring;
    where: TextIter) {.
    importc, libprag.}

proc moveMarkByName*(self: TextBuffer; name: cstring; where: TextIter) =
  gtk_text_buffer_move_mark_by_name(cast[ptr TextBuffer00](self.impl), name, where)

proc gtk_text_buffer_paste_clipboard(self: ptr TextBuffer00; clipboard: ptr Clipboard00;
    overrideLocation: TextIter; defaultEditable: gboolean) {.
    importc, libprag.}

proc pasteClipboard*(self: TextBuffer; clipboard: Clipboard;
    overrideLocation: TextIter = cast[var TextIter](nil); defaultEditable: bool) =
  gtk_text_buffer_paste_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl), overrideLocation, gboolean(defaultEditable))

proc gtk_text_buffer_place_cursor(self: ptr TextBuffer00; where: TextIter) {.
    importc, libprag.}

proc placeCursor*(self: TextBuffer; where: TextIter) =
  gtk_text_buffer_place_cursor(cast[ptr TextBuffer00](self.impl), where)

proc gtk_text_buffer_register_deserialize_tagset(self: ptr TextBuffer00;
    tagsetName: cstring): ptr gdk.Atom00 {.
    importc, libprag.}

proc registerDeserializeTagset*(self: TextBuffer; tagsetName: cstring = nil): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_deserialize_tagset(cast[ptr TextBuffer00](self.impl), tagsetName)
  result.ignoreFinalizer = true

proc gtk_text_buffer_register_serialize_tagset(self: ptr TextBuffer00; tagsetName: cstring): ptr gdk.Atom00 {.
    importc, libprag.}

proc registerSerializeTagset*(self: TextBuffer; tagsetName: cstring = nil): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_serialize_tagset(cast[ptr TextBuffer00](self.impl), tagsetName)
  result.ignoreFinalizer = true

proc gtk_text_buffer_remove_all_tags(self: ptr TextBuffer00; start: TextIter;
    `end`: TextIter) {.
    importc, libprag.}

proc removeAllTags*(self: TextBuffer; start: TextIter; `end`: TextIter) =
  gtk_text_buffer_remove_all_tags(cast[ptr TextBuffer00](self.impl), start, `end`)

proc gtk_text_buffer_remove_selection_clipboard(self: ptr TextBuffer00; clipboard: ptr Clipboard00) {.
    importc, libprag.}

proc removeSelectionClipboard*(self: TextBuffer; clipboard: Clipboard) =
  gtk_text_buffer_remove_selection_clipboard(cast[ptr TextBuffer00](self.impl), cast[ptr Clipboard00](clipboard.impl))

proc gtk_text_buffer_remove_tag(self: ptr TextBuffer00; tag: ptr TextTag00;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc removeTag*(self: TextBuffer; tag: TextTag; start: TextIter;
    `end`: TextIter) =
  gtk_text_buffer_remove_tag(cast[ptr TextBuffer00](self.impl), cast[ptr TextTag00](tag.impl), start, `end`)

proc gtk_text_buffer_remove_tag_by_name(self: ptr TextBuffer00; name: cstring;
    start: TextIter; `end`: TextIter) {.
    importc, libprag.}

proc removeTagByName*(self: TextBuffer; name: cstring;
    start: TextIter; `end`: TextIter) =
  gtk_text_buffer_remove_tag_by_name(cast[ptr TextBuffer00](self.impl), name, start, `end`)

proc gtk_text_buffer_select_range(self: ptr TextBuffer00; ins: TextIter;
    bound: TextIter) {.
    importc, libprag.}

proc selectRange*(self: TextBuffer; ins: TextIter; bound: TextIter) =
  gtk_text_buffer_select_range(cast[ptr TextBuffer00](self.impl), ins, bound)

proc gtk_text_buffer_serialize(self: ptr TextBuffer00; contentBuffer: ptr TextBuffer00;
    format: ptr gdk.Atom00; start: TextIter; `end`: TextIter; length: var uint64): ptr uint8 {.
    importc, libprag.}

proc serialize*(self: TextBuffer; contentBuffer: TextBuffer;
    format: gdk.Atom; start: TextIter; `end`: TextIter; length: var uint64): seq[uint8] =
  let resul0 = gtk_text_buffer_serialize(cast[ptr TextBuffer00](self.impl), cast[ptr TextBuffer00](contentBuffer.impl), cast[ptr gdk.Atom00](format.impl), start, `end`, length)
  result = uint8ArrayToSeq(resul0, length.int)
  cogfree(resul0)

proc gtk_text_buffer_set_modified(self: ptr TextBuffer00; setting: gboolean) {.
    importc, libprag.}

proc setModified*(self: TextBuffer; setting: bool = true) =
  gtk_text_buffer_set_modified(cast[ptr TextBuffer00](self.impl), gboolean(setting))

proc `modified=`*(self: TextBuffer; setting: bool) =
  gtk_text_buffer_set_modified(cast[ptr TextBuffer00](self.impl), gboolean(setting))

proc gtk_text_buffer_set_text(self: ptr TextBuffer00; text: cstring; len: int32) {.
    importc, libprag.}

proc setText*(self: TextBuffer; text: cstring; len: int) =
  gtk_text_buffer_set_text(cast[ptr TextBuffer00](self.impl), text, int32(len))

proc gtk_text_buffer_unregister_deserialize_format(self: ptr TextBuffer00;
    format: ptr gdk.Atom00) {.
    importc, libprag.}

proc unregisterDeserializeFormat*(self: TextBuffer; format: gdk.Atom) =
  gtk_text_buffer_unregister_deserialize_format(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl))

proc gtk_text_buffer_unregister_serialize_format(self: ptr TextBuffer00;
    format: ptr gdk.Atom00) {.
    importc, libprag.}

proc unregisterSerializeFormat*(self: TextBuffer; format: gdk.Atom) =
  gtk_text_buffer_unregister_serialize_format(cast[ptr TextBuffer00](self.impl), cast[ptr gdk.Atom00](format.impl))

proc gtk_selection_data_targets_include_rich_text(self: ptr SelectionData00;
    buffer: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc targetsIncludeRichText*(self: SelectionData; buffer: TextBuffer): bool =
  toBool(gtk_selection_data_targets_include_rich_text(cast[ptr SelectionData00](self.impl), cast[ptr TextBuffer00](buffer.impl)))

proc gtk_target_list_add_rich_text_targets(self: ptr TargetList00; info: uint32;
    deserializable: gboolean; buffer: ptr TextBuffer00) {.
    importc, libprag.}

proc addRichTextTargets*(self: TargetList; info: int; deserializable: bool;
    buffer: TextBuffer) =
  gtk_target_list_add_rich_text_targets(cast[ptr TargetList00](self.impl), uint32(info), gboolean(deserializable), cast[ptr TextBuffer00](buffer.impl))

proc gtk_clipboard_wait_for_rich_text(self: ptr Clipboard00; buffer: ptr TextBuffer00;
    format: var ptr gdk.Atom00; length: var uint64): ptr uint8 {.
    importc, libprag.}

proc waitForRichText*(self: Clipboard; buffer: TextBuffer;
    format: var ptr gdk.Atom00; length: var uint64): seq[uint8] =
  let resul0 = gtk_clipboard_wait_for_rich_text(cast[ptr Clipboard00](self.impl), cast[ptr TextBuffer00](buffer.impl), format, length)
  if resul0.isNil:
    return
  result = uint8ArrayToSeq(resul0, length.int)
  cogfree(resul0)

proc gtk_clipboard_wait_is_rich_text_available(self: ptr Clipboard00; buffer: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc waitIsRichTextAvailable*(self: Clipboard; buffer: TextBuffer): bool =
  toBool(gtk_clipboard_wait_is_rich_text_available(cast[ptr Clipboard00](self.impl), cast[ptr TextBuffer00](buffer.impl)))

proc gtk_text_iter_get_buffer(self: TextIter): ptr TextBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: TextIter): TextBuffer =
  let gobj = gtk_text_iter_get_buffer(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextIter): TextBuffer =
  let gobj = gtk_text_iter_get_buffer(self)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_iter_get_marks(self: TextIter): ptr glib.SList {.
    importc, libprag.}

proc getMarks*(self: TextIter): seq[TextMark] =
  let resul0 = gtk_text_iter_get_marks(self)
  result = gslistObjects2seq(TextMark, resul0, false)
  g_slist_free(resul0)

proc marks*(self: TextIter): seq[TextMark] =
  let resul0 = gtk_text_iter_get_marks(self)
  result = gslistObjects2seq(TextMark, resul0, false)
  g_slist_free(resul0)

proc gtk_text_mark_get_buffer(self: ptr TextMark00): ptr TextBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: TextMark): TextBuffer =
  let gobj = gtk_text_mark_get_buffer(cast[ptr TextMark00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextMark): TextBuffer =
  let gobj = gtk_text_mark_get_buffer(cast[ptr TextMark00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TextTagTable* = ref object of gobject.Object
  TextTagTable00* = object of gobject.Object00

proc gtk_text_tag_table_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextTagTable()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scTagAdded*(self: TextTagTable;  p: proc (self: ptr TextTagTable00; tag: ptr TextTag00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "tag-added", cast[GCallback](p), xdata, nil, cf)

proc scTagChanged*(self: TextTagTable;  p: proc (self: ptr TextTagTable00; tag: ptr TextTag00; sizeChanged: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "tag-changed", cast[GCallback](p), xdata, nil, cf)

proc scTagRemoved*(self: TextTagTable;  p: proc (self: ptr TextTagTable00; tag: ptr TextTag00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "tag-removed", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_tag_table_new(): ptr TextTagTable00 {.
    importc, libprag.}

proc newTextTagTable*(): TextTagTable =
  let gobj = gtk_text_tag_table_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextTagTable*(tdesc: typedesc): tdesc =
  assert(result is TextTagTable)
  let gobj = gtk_text_tag_table_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextTagTable*[T](result: var T) {.deprecated.} =
  assert(result is TextTagTable)
  let gobj = gtk_text_tag_table_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_table_add(self: ptr TextTagTable00; tag: ptr TextTag00): gboolean {.
    importc, libprag.}

proc add*(self: TextTagTable; tag: TextTag): bool =
  toBool(gtk_text_tag_table_add(cast[ptr TextTagTable00](self.impl), cast[ptr TextTag00](tag.impl)))

proc gtk_text_tag_table_get_size(self: ptr TextTagTable00): int32 {.
    importc, libprag.}

proc getSize*(self: TextTagTable): int =
  int(gtk_text_tag_table_get_size(cast[ptr TextTagTable00](self.impl)))

proc size*(self: TextTagTable): int =
  int(gtk_text_tag_table_get_size(cast[ptr TextTagTable00](self.impl)))

proc gtk_text_tag_table_lookup(self: ptr TextTagTable00; name: cstring): ptr TextTag00 {.
    importc, libprag.}

proc lookup*(self: TextTagTable; name: cstring): TextTag =
  let gobj = gtk_text_tag_table_lookup(cast[ptr TextTagTable00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_tag_table_remove(self: ptr TextTagTable00; tag: ptr TextTag00) {.
    importc, libprag.}

proc remove*(self: TextTagTable; tag: TextTag) =
  gtk_text_tag_table_remove(cast[ptr TextTagTable00](self.impl), cast[ptr TextTag00](tag.impl))

proc gtk_text_buffer_new(table: ptr TextTagTable00): ptr TextBuffer00 {.
    importc, libprag.}

proc newTextBuffer*(table: TextTagTable = nil): TextBuffer =
  let gobj = gtk_text_buffer_new(if table.isNil: nil else: cast[ptr TextTagTable00](table.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextBuffer*(tdesc: typedesc; table: TextTagTable = nil): tdesc =
  assert(result is TextBuffer)
  let gobj = gtk_text_buffer_new(if table.isNil: nil else: cast[ptr TextTagTable00](table.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextBuffer*[T](result: var T; table: TextTagTable = nil) {.deprecated.} =
  assert(result is TextBuffer)
  let gobj = gtk_text_buffer_new(if table.isNil: nil else: cast[ptr TextTagTable00](table.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_buffer_get_tag_table(self: ptr TextBuffer00): ptr TextTagTable00 {.
    importc, libprag.}

proc getTagTable*(self: TextBuffer): TextTagTable =
  let gobj = gtk_text_buffer_get_tag_table(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc tagTable*(self: TextBuffer): TextTagTable =
  let gobj = gtk_text_buffer_get_tag_table(cast[ptr TextBuffer00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  AccelGroupActivate* = proc (accelGroup: ptr AccelGroup00; acceleratable: ptr gobject.Object00;
    keyval: uint32; modifier: gdk.ModifierType): gboolean {.cdecl.}

type
  AccelKey* {.pure, byRef.} = object
    accelKey*: uint32
    accelMods*: gdk.ModifierType
    accelFlags*: uint32

type
  AccelGroupFindFunc* = proc (key: AccelKey; closure: ptr gobject.Closure00; data: pointer): gboolean {.cdecl.}

proc gtk_accel_group_find(self: ptr AccelGroup00; findFunc: AccelGroupFindFunc;
    data: pointer): ptr AccelKey {.
    importc, libprag.}

proc findAccelGroup*(self: AccelGroup; findFunc: AccelGroupFindFunc;
    data: pointer): ptr AccelKey =
  gtk_accel_group_find(cast[ptr AccelGroup00](self.impl), findFunc, data)

type
  Misc* = ref object of Widget
  Misc00* = object of Widget00

proc gtk_misc_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Misc()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_misc_get_alignment(self: ptr Misc00; xalign: var cfloat; yalign: var cfloat) {.
    importc, libprag.}

proc getAlignment*(self: Misc; xalign: var cfloat = cast[var cfloat](nil);
    yalign: var cfloat = cast[var cfloat](nil)) =
  gtk_misc_get_alignment(cast[ptr Misc00](self.impl), xalign, yalign)

proc gtk_misc_get_padding(self: ptr Misc00; xpad: var int32; ypad: var int32) {.
    importc, libprag.}

proc getPadding*(self: Misc; xpad: var int = cast[var int](nil);
    ypad: var int = cast[var int](nil)) =
  var ypad_00: int32
  var xpad_00: int32
  gtk_misc_get_padding(cast[ptr Misc00](self.impl), xpad_00, ypad_00)
  if ypad.addr != nil:
    ypad = int(ypad_00)
  if xpad.addr != nil:
    xpad = int(xpad_00)

proc gtk_misc_set_alignment(self: ptr Misc00; xalign: cfloat; yalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: Misc; xalign: cfloat; yalign: cfloat) =
  gtk_misc_set_alignment(cast[ptr Misc00](self.impl), xalign, yalign)

proc gtk_misc_set_padding(self: ptr Misc00; xpad: int32; ypad: int32) {.
    importc, libprag.}

proc setPadding*(self: Misc; xpad: int; ypad: int) =
  gtk_misc_set_padding(cast[ptr Misc00](self.impl), int32(xpad), int32(ypad))

type
  MovementStep* {.size: sizeof(cint), pure.} = enum
    logicalPositions = 0
    visualPositions = 1
    words = 2
    displayLines = 3
    displayLineEnds = 4
    paragraphs = 5
    paragraphEnds = 6
    pages = 7
    bufferEnds = 8
    horizontalPages = 9

type
  MenuDirectionType* {.size: sizeof(cint), pure.} = enum
    parent = 0
    child = 1
    next = 2
    prev = 3

type
  MenuShell* = ref object of Container
  MenuShell00* = object of Container00

proc gtk_menu_shell_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuShell()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCurrent*(self: MenuShell;  p: proc (self: ptr MenuShell00; forceHide: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-current", cast[GCallback](p), xdata, nil, cf)

proc scCancel*(self: MenuShell;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cf)

proc scCycleFocus*(self: MenuShell;  p: proc (self: ptr MenuShell00; direction: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cycle-focus", cast[GCallback](p), xdata, nil, cf)

proc scDeactivate*(self: MenuShell;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "deactivate", cast[GCallback](p), xdata, nil, cf)

proc scInsert*(self: MenuShell;  p: proc (self: ptr MenuShell00; child: ptr Widget00; position: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert", cast[GCallback](p), xdata, nil, cf)

proc scMoveCurrent*(self: MenuShell;  p: proc (self: ptr MenuShell00; direction: MenuDirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-current", cast[GCallback](p), xdata, nil, cf)

proc scMoveSelected*(self: MenuShell;  p: proc (self: ptr MenuShell00; distance: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-selected", cast[GCallback](p), xdata, nil, cf)

proc scSelectionDone*(self: MenuShell;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-done", cast[GCallback](p), xdata, nil, cf)

proc gtk_menu_shell_activate_item(self: ptr MenuShell00; menuItem: ptr Widget00;
    forceDeactivate: gboolean) {.
    importc, libprag.}

proc activateItem*(self: MenuShell; menuItem: Widget; forceDeactivate: bool) =
  gtk_menu_shell_activate_item(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](menuItem.impl), gboolean(forceDeactivate))

proc gtk_menu_shell_bind_model(self: ptr MenuShell00; model: ptr gio.MenuModel00;
    actionNamespace: cstring; withSeparators: gboolean) {.
    importc, libprag.}

proc bindModel*(self: MenuShell; model: gio.MenuModel = nil;
    actionNamespace: cstring = nil; withSeparators: bool) =
  gtk_menu_shell_bind_model(cast[ptr MenuShell00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl), actionNamespace, gboolean(withSeparators))

proc gtk_menu_shell_cancel(self: ptr MenuShell00) {.
    importc, libprag.}

proc cancel*(self: MenuShell) =
  gtk_menu_shell_cancel(cast[ptr MenuShell00](self.impl))

proc gtk_menu_shell_deactivate(self: ptr MenuShell00) {.
    importc, libprag.}

proc deactivate*(self: MenuShell) =
  gtk_menu_shell_deactivate(cast[ptr MenuShell00](self.impl))

proc gtk_menu_shell_deselect(self: ptr MenuShell00) {.
    importc, libprag.}

proc deselect*(self: MenuShell) =
  gtk_menu_shell_deselect(cast[ptr MenuShell00](self.impl))

proc gtk_menu_shell_get_parent_shell(self: ptr MenuShell00): ptr Widget00 {.
    importc, libprag.}

proc getParentShell*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_parent_shell(cast[ptr MenuShell00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parentShell*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_parent_shell(cast[ptr MenuShell00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_shell_get_selected_item(self: ptr MenuShell00): ptr Widget00 {.
    importc, libprag.}

proc getSelectedItem*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_selected_item(cast[ptr MenuShell00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedItem*(self: MenuShell): Widget =
  let gobj = gtk_menu_shell_get_selected_item(cast[ptr MenuShell00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_shell_get_take_focus(self: ptr MenuShell00): gboolean {.
    importc, libprag.}

proc getTakeFocus*(self: MenuShell): bool =
  toBool(gtk_menu_shell_get_take_focus(cast[ptr MenuShell00](self.impl)))

proc takeFocus*(self: MenuShell): bool =
  toBool(gtk_menu_shell_get_take_focus(cast[ptr MenuShell00](self.impl)))

proc gtk_menu_shell_insert(self: ptr MenuShell00; child: ptr Widget00; position: int32) {.
    importc, libprag.}

proc insert*(self: MenuShell; child: Widget; position: int) =
  gtk_menu_shell_insert(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_menu_shell_prepend(self: ptr MenuShell00; child: ptr Widget00) {.
    importc, libprag.}

proc prepend*(self: MenuShell; child: Widget) =
  gtk_menu_shell_prepend(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_menu_shell_select_first(self: ptr MenuShell00; searchSensitive: gboolean) {.
    importc, libprag.}

proc selectFirst*(self: MenuShell; searchSensitive: bool) =
  gtk_menu_shell_select_first(cast[ptr MenuShell00](self.impl), gboolean(searchSensitive))

proc gtk_menu_shell_select_item(self: ptr MenuShell00; menuItem: ptr Widget00) {.
    importc, libprag.}

proc selectItem*(self: MenuShell; menuItem: Widget) =
  gtk_menu_shell_select_item(cast[ptr MenuShell00](self.impl), cast[ptr Widget00](menuItem.impl))

proc gtk_menu_shell_set_take_focus(self: ptr MenuShell00; takeFocus: gboolean) {.
    importc, libprag.}

proc setTakeFocus*(self: MenuShell; takeFocus: bool = true) =
  gtk_menu_shell_set_take_focus(cast[ptr MenuShell00](self.impl), gboolean(takeFocus))

proc `takeFocus=`*(self: MenuShell; takeFocus: bool) =
  gtk_menu_shell_set_take_focus(cast[ptr MenuShell00](self.impl), gboolean(takeFocus))

type
  ScrollType* {.size: sizeof(cint), pure.} = enum
    none = 0
    jump = 1
    stepBackward = 2
    stepForward = 3
    pageBackward = 4
    pageForward = 5
    stepUp = 6
    stepDown = 7
    pageUp = 8
    pageDown = 9
    stepLeft = 10
    stepRight = 11
    pageLeft = 12
    pageRight = 13
    start = 14
    `end` = 15

type
  Menu* = ref object of MenuShell
  Menu00* = object of MenuShell00

proc gtk_menu_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Menu()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scMoveScroll*(self: Menu;  p: proc (self: ptr Menu00; scrollType: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-scroll", cast[GCallback](p), xdata, nil, cf)

proc scPoppedUp*(self: Menu;  p: proc (self: ptr Menu00; flippedRect: pointer; finalRect: pointer; flippedX: gboolean; flippedY: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popped-up", cast[GCallback](p), xdata, nil, cf)

proc gtk_menu_new(): ptr Menu00 {.
    importc, libprag.}

proc newMenu*(): Menu =
  let gobj = gtk_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenu*(tdesc: typedesc): tdesc =
  assert(result is Menu)
  let gobj = gtk_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenu*[T](result: var T) {.deprecated.} =
  assert(result is Menu)
  let gobj = gtk_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_new_from_model(model: ptr gio.MenuModel00): ptr Menu00 {.
    importc, libprag.}

proc newMenuFromModel*(model: gio.MenuModel): Menu =
  let gobj = gtk_menu_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuFromModel*(tdesc: typedesc; model: gio.MenuModel): tdesc =
  assert(result is Menu)
  let gobj = gtk_menu_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuFromModel*[T](result: var T; model: gio.MenuModel) {.deprecated.} =
  assert(result is Menu)
  let gobj = gtk_menu_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_for_attach_widget(widget: ptr Widget00): ptr glib.List {.
    importc, libprag.}

proc getForAttachWidget*(widget: Widget): seq[Widget] =
  result = glistObjects2seq(Widget, gtk_menu_get_for_attach_widget(cast[ptr Widget00](widget.impl)), false)

proc forAttachWidget*(widget: Widget): seq[Widget] =
  result = glistObjects2seq(Widget, gtk_menu_get_for_attach_widget(cast[ptr Widget00](widget.impl)), false)

proc gtk_menu_attach(self: ptr Menu00; child: ptr Widget00; leftAttach: uint32;
    rightAttach: uint32; topAttach: uint32; bottomAttach: uint32) {.
    importc, libprag.}

proc attach*(self: Menu; child: Widget; leftAttach: int; rightAttach: int;
    topAttach: int; bottomAttach: int) =
  gtk_menu_attach(cast[ptr Menu00](self.impl), cast[ptr Widget00](child.impl), uint32(leftAttach), uint32(rightAttach), uint32(topAttach), uint32(bottomAttach))

proc gtk_menu_detach(self: ptr Menu00) {.
    importc, libprag.}

proc detach*(self: Menu) =
  gtk_menu_detach(cast[ptr Menu00](self.impl))

proc gtk_menu_get_accel_group(self: ptr Menu00): ptr AccelGroup00 {.
    importc, libprag.}

proc getAccelGroup*(self: Menu): AccelGroup =
  let gobj = gtk_menu_get_accel_group(cast[ptr Menu00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelGroup*(self: Menu): AccelGroup =
  let gobj = gtk_menu_get_accel_group(cast[ptr Menu00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_accel_path(self: ptr Menu00): cstring {.
    importc, libprag.}

proc getAccelPath*(self: Menu): string =
  result = $gtk_menu_get_accel_path(cast[ptr Menu00](self.impl))

proc accelPath*(self: Menu): string =
  result = $gtk_menu_get_accel_path(cast[ptr Menu00](self.impl))

proc gtk_menu_get_active(self: ptr Menu00): ptr Widget00 {.
    importc, libprag.}

proc getActive*(self: Menu): Widget =
  let gobj = gtk_menu_get_active(cast[ptr Menu00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc active*(self: Menu): Widget =
  let gobj = gtk_menu_get_active(cast[ptr Menu00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_attach_widget(self: ptr Menu00): ptr Widget00 {.
    importc, libprag.}

proc getAttachWidget*(self: Menu): Widget =
  let gobj = gtk_menu_get_attach_widget(cast[ptr Menu00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc attachWidget*(self: Menu): Widget =
  let gobj = gtk_menu_get_attach_widget(cast[ptr Menu00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_get_monitor(self: ptr Menu00): int32 {.
    importc, libprag.}

proc getMonitor*(self: Menu): int =
  int(gtk_menu_get_monitor(cast[ptr Menu00](self.impl)))

proc monitor*(self: Menu): int =
  int(gtk_menu_get_monitor(cast[ptr Menu00](self.impl)))

proc gtk_menu_get_reserve_toggle_size(self: ptr Menu00): gboolean {.
    importc, libprag.}

proc getReserveToggleSize*(self: Menu): bool =
  toBool(gtk_menu_get_reserve_toggle_size(cast[ptr Menu00](self.impl)))

proc reserveToggleSize*(self: Menu): bool =
  toBool(gtk_menu_get_reserve_toggle_size(cast[ptr Menu00](self.impl)))

proc gtk_menu_get_tearoff_state(self: ptr Menu00): gboolean {.
    importc, libprag.}

proc getTearoffState*(self: Menu): bool =
  toBool(gtk_menu_get_tearoff_state(cast[ptr Menu00](self.impl)))

proc tearoffState*(self: Menu): bool =
  toBool(gtk_menu_get_tearoff_state(cast[ptr Menu00](self.impl)))

proc gtk_menu_get_title(self: ptr Menu00): cstring {.
    importc, libprag.}

proc getTitle*(self: Menu): string =
  result = $gtk_menu_get_title(cast[ptr Menu00](self.impl))

proc title*(self: Menu): string =
  result = $gtk_menu_get_title(cast[ptr Menu00](self.impl))

proc gtk_menu_place_on_monitor(self: ptr Menu00; monitor: ptr gdk.Monitor00) {.
    importc, libprag.}

proc placeOnMonitor*(self: Menu; monitor: gdk.Monitor) =
  gtk_menu_place_on_monitor(cast[ptr Menu00](self.impl), cast[ptr gdk.Monitor00](monitor.impl))

proc gtk_menu_popdown(self: ptr Menu00) {.
    importc, libprag.}

proc popdown*(self: Menu) =
  gtk_menu_popdown(cast[ptr Menu00](self.impl))

proc gtk_menu_popup_at_pointer(self: ptr Menu00; triggerEvent: ptr gdk.Event00) {.
    importc, libprag.}

proc popupAtPointer*(self: Menu; triggerEvent: gdk.Event = nil) =
  gtk_menu_popup_at_pointer(cast[ptr Menu00](self.impl), if triggerEvent.isNil: nil else: cast[ptr gdk.Event00](triggerEvent.impl))

proc gtk_menu_popup_at_rect(self: ptr Menu00; rectWindow: ptr gdk.Window00;
    rect: gdk.Rectangle; rectAnchor: gdk.Gravity; menuAnchor: gdk.Gravity;
    triggerEvent: ptr gdk.Event00) {.
    importc, libprag.}

proc popupAtRect*(self: Menu; rectWindow: gdk.Window; rect: gdk.Rectangle;
    rectAnchor: gdk.Gravity; menuAnchor: gdk.Gravity; triggerEvent: gdk.Event = nil) =
  gtk_menu_popup_at_rect(cast[ptr Menu00](self.impl), cast[ptr gdk.Window00](rectWindow.impl), rect, rectAnchor, menuAnchor, if triggerEvent.isNil: nil else: cast[ptr gdk.Event00](triggerEvent.impl))

proc gtk_menu_popup_at_widget(self: ptr Menu00; widget: ptr Widget00; widgetAnchor: gdk.Gravity;
    menuAnchor: gdk.Gravity; triggerEvent: ptr gdk.Event00) {.
    importc, libprag.}

proc popupAtWidget*(self: Menu; widget: Widget; widgetAnchor: gdk.Gravity;
    menuAnchor: gdk.Gravity; triggerEvent: gdk.Event = nil) =
  gtk_menu_popup_at_widget(cast[ptr Menu00](self.impl), cast[ptr Widget00](widget.impl), widgetAnchor, menuAnchor, if triggerEvent.isNil: nil else: cast[ptr gdk.Event00](triggerEvent.impl))

proc gtk_menu_reorder_child(self: ptr Menu00; child: ptr Widget00; position: int32) {.
    importc, libprag.}

proc reorderChild*(self: Menu; child: Widget; position: int) =
  gtk_menu_reorder_child(cast[ptr Menu00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_menu_reposition(self: ptr Menu00) {.
    importc, libprag.}

proc reposition*(self: Menu) =
  gtk_menu_reposition(cast[ptr Menu00](self.impl))

proc gtk_menu_set_accel_group(self: ptr Menu00; accelGroup: ptr AccelGroup00) {.
    importc, libprag.}

proc setAccelGroup*(self: Menu; accelGroup: AccelGroup = nil) =
  gtk_menu_set_accel_group(cast[ptr Menu00](self.impl), if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: Menu; accelGroup: AccelGroup = nil) =
  gtk_menu_set_accel_group(cast[ptr Menu00](self.impl), if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_menu_set_accel_path(self: ptr Menu00; accelPath: cstring) {.
    importc, libprag.}

proc setAccelPath*(self: Menu; accelPath: cstring = nil) =
  gtk_menu_set_accel_path(cast[ptr Menu00](self.impl), accelPath)

proc `accelPath=`*(self: Menu; accelPath: cstring = nil) =
  gtk_menu_set_accel_path(cast[ptr Menu00](self.impl), accelPath)

proc gtk_menu_set_active(self: ptr Menu00; index: uint32) {.
    importc, libprag.}

proc setActive*(self: Menu; index: int) =
  gtk_menu_set_active(cast[ptr Menu00](self.impl), uint32(index))

proc `active=`*(self: Menu; index: int) =
  gtk_menu_set_active(cast[ptr Menu00](self.impl), uint32(index))

proc gtk_menu_set_monitor(self: ptr Menu00; monitorNum: int32) {.
    importc, libprag.}

proc setMonitor*(self: Menu; monitorNum: int) =
  gtk_menu_set_monitor(cast[ptr Menu00](self.impl), int32(monitorNum))

proc `monitor=`*(self: Menu; monitorNum: int) =
  gtk_menu_set_monitor(cast[ptr Menu00](self.impl), int32(monitorNum))

proc gtk_menu_set_reserve_toggle_size(self: ptr Menu00; reserveToggleSize: gboolean) {.
    importc, libprag.}

proc setReserveToggleSize*(self: Menu; reserveToggleSize: bool = true) =
  gtk_menu_set_reserve_toggle_size(cast[ptr Menu00](self.impl), gboolean(reserveToggleSize))

proc `reserveToggleSize=`*(self: Menu; reserveToggleSize: bool) =
  gtk_menu_set_reserve_toggle_size(cast[ptr Menu00](self.impl), gboolean(reserveToggleSize))

proc gtk_menu_set_screen(self: ptr Menu00; screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc setScreen*(self: Menu; screen: gdk.Screen = nil) =
  gtk_menu_set_screen(cast[ptr Menu00](self.impl), if screen.isNil: nil else: cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: Menu; screen: gdk.Screen = nil) =
  gtk_menu_set_screen(cast[ptr Menu00](self.impl), if screen.isNil: nil else: cast[ptr gdk.Screen00](screen.impl))

proc gtk_menu_set_tearoff_state(self: ptr Menu00; tornOff: gboolean) {.
    importc, libprag.}

proc setTearoffState*(self: Menu; tornOff: bool = true) =
  gtk_menu_set_tearoff_state(cast[ptr Menu00](self.impl), gboolean(tornOff))

proc `tearoffState=`*(self: Menu; tornOff: bool) =
  gtk_menu_set_tearoff_state(cast[ptr Menu00](self.impl), gboolean(tornOff))

proc gtk_menu_set_title(self: ptr Menu00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: Menu; title: cstring = nil) =
  gtk_menu_set_title(cast[ptr Menu00](self.impl), title)

proc `title=`*(self: Menu; title: cstring = nil) =
  gtk_menu_set_title(cast[ptr Menu00](self.impl), title)

type
  Label* = ref object of Misc
  Label00* = object of Misc00

proc gtk_label_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Label()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCurrentLink*(self: Label;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-current-link", cast[GCallback](p), xdata, nil, cf)

proc scActivateLink*(self: Label;  p: proc (self: ptr Label00; uri: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cf)

proc scCopyClipboard*(self: Label;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: Label;  p: proc (self: ptr Label00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scPopulatePopup*(self: Label;  p: proc (self: ptr Label00; menu: ptr Menu00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cf)

proc gtk_label_new(str: cstring): ptr Label00 {.
    importc, libprag.}

proc newLabel*(str: cstring = nil): Label =
  let gobj = gtk_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLabel*(tdesc: typedesc; str: cstring = nil): tdesc =
  assert(result is Label)
  let gobj = gtk_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLabel*[T](result: var T; str: cstring = nil) {.deprecated.} =
  assert(result is Label)
  let gobj = gtk_label_new(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_new_with_mnemonic(str: cstring): ptr Label00 {.
    importc, libprag.}

proc newLabelWithMnemonic*(str: cstring = nil): Label =
  let gobj = gtk_label_new_with_mnemonic(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLabelWithMnemonic*(tdesc: typedesc; str: cstring = nil): tdesc =
  assert(result is Label)
  let gobj = gtk_label_new_with_mnemonic(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLabelWithMnemonic*[T](result: var T; str: cstring = nil) {.deprecated.} =
  assert(result is Label)
  let gobj = gtk_label_new_with_mnemonic(str)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_angle(self: ptr Label00): cdouble {.
    importc, libprag.}

proc getAngle*(self: Label): cdouble =
  gtk_label_get_angle(cast[ptr Label00](self.impl))

proc angle*(self: Label): cdouble =
  gtk_label_get_angle(cast[ptr Label00](self.impl))

proc gtk_label_get_attributes(self: ptr Label00): ptr pango.AttrList00 {.
    importc, libprag.}

proc getAttributes*(self: Label): pango.AttrList =
  let impl0 = gtk_label_get_attributes(cast[ptr Label00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc attributes*(self: Label): pango.AttrList =
  let impl0 = gtk_label_get_attributes(cast[ptr Label00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc gtk_label_get_current_uri(self: ptr Label00): cstring {.
    importc, libprag.}

proc getCurrentUri*(self: Label): string =
  result = $gtk_label_get_current_uri(cast[ptr Label00](self.impl))

proc currentUri*(self: Label): string =
  result = $gtk_label_get_current_uri(cast[ptr Label00](self.impl))

proc gtk_label_get_ellipsize(self: ptr Label00): pango.EllipsizeMode {.
    importc, libprag.}

proc getEllipsize*(self: Label): pango.EllipsizeMode =
  gtk_label_get_ellipsize(cast[ptr Label00](self.impl))

proc ellipsize*(self: Label): pango.EllipsizeMode =
  gtk_label_get_ellipsize(cast[ptr Label00](self.impl))

proc gtk_label_get_label(self: ptr Label00): cstring {.
    importc, libprag.}

proc getLabel*(self: Label): string =
  result = $gtk_label_get_label(cast[ptr Label00](self.impl))

proc label*(self: Label): string =
  result = $gtk_label_get_label(cast[ptr Label00](self.impl))

proc gtk_label_get_layout(self: ptr Label00): ptr pango.Layout00 {.
    importc, libprag.}

proc getLayout*(self: Label): pango.Layout =
  let gobj = gtk_label_get_layout(cast[ptr Label00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Label): pango.Layout =
  let gobj = gtk_label_get_layout(cast[ptr Label00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_layout_offsets(self: ptr Label00; x: var int32; y: var int32) {.
    importc, libprag.}

proc getLayoutOffsets*(self: Label; x: var int = cast[var int](nil);
    y: var int = cast[var int](nil)) =
  var y_00: int32
  var x_00: int32
  gtk_label_get_layout_offsets(cast[ptr Label00](self.impl), x_00, y_00)
  if y.addr != nil:
    y = int(y_00)
  if x.addr != nil:
    x = int(x_00)

proc gtk_label_get_line_wrap(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getLineWrap*(self: Label): bool =
  toBool(gtk_label_get_line_wrap(cast[ptr Label00](self.impl)))

proc lineWrap*(self: Label): bool =
  toBool(gtk_label_get_line_wrap(cast[ptr Label00](self.impl)))

proc gtk_label_get_line_wrap_mode(self: ptr Label00): pango.WrapMode {.
    importc, libprag.}

proc getLineWrapMode*(self: Label): pango.WrapMode =
  gtk_label_get_line_wrap_mode(cast[ptr Label00](self.impl))

proc lineWrapMode*(self: Label): pango.WrapMode =
  gtk_label_get_line_wrap_mode(cast[ptr Label00](self.impl))

proc gtk_label_get_lines(self: ptr Label00): int32 {.
    importc, libprag.}

proc getLines*(self: Label): int =
  int(gtk_label_get_lines(cast[ptr Label00](self.impl)))

proc lines*(self: Label): int =
  int(gtk_label_get_lines(cast[ptr Label00](self.impl)))

proc gtk_label_get_max_width_chars(self: ptr Label00): int32 {.
    importc, libprag.}

proc getMaxWidthChars*(self: Label): int =
  int(gtk_label_get_max_width_chars(cast[ptr Label00](self.impl)))

proc maxWidthChars*(self: Label): int =
  int(gtk_label_get_max_width_chars(cast[ptr Label00](self.impl)))

proc gtk_label_get_mnemonic_keyval(self: ptr Label00): uint32 {.
    importc, libprag.}

proc getMnemonicKeyval*(self: Label): int =
  int(gtk_label_get_mnemonic_keyval(cast[ptr Label00](self.impl)))

proc mnemonicKeyval*(self: Label): int =
  int(gtk_label_get_mnemonic_keyval(cast[ptr Label00](self.impl)))

proc gtk_label_get_mnemonic_widget(self: ptr Label00): ptr Widget00 {.
    importc, libprag.}

proc getMnemonicWidget*(self: Label): Widget =
  let gobj = gtk_label_get_mnemonic_widget(cast[ptr Label00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc mnemonicWidget*(self: Label): Widget =
  let gobj = gtk_label_get_mnemonic_widget(cast[ptr Label00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_label_get_selectable(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getSelectable*(self: Label): bool =
  toBool(gtk_label_get_selectable(cast[ptr Label00](self.impl)))

proc selectable*(self: Label): bool =
  toBool(gtk_label_get_selectable(cast[ptr Label00](self.impl)))

proc gtk_label_get_selection_bounds(self: ptr Label00; start: var int32;
    `end`: var int32): gboolean {.
    importc, libprag.}

proc getSelectionBounds*(self: Label; start: var int; `end`: var int): bool =
  var start_00: int32
  var end_00: int32
  result = toBool(gtk_label_get_selection_bounds(cast[ptr Label00](self.impl), start_00, end_00))
  if start.addr != nil:
    start = int(start_00)
  if `end`.addr != nil:
    `end` = int(end_00)

proc gtk_label_get_single_line_mode(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getSingleLineMode*(self: Label): bool =
  toBool(gtk_label_get_single_line_mode(cast[ptr Label00](self.impl)))

proc singleLineMode*(self: Label): bool =
  toBool(gtk_label_get_single_line_mode(cast[ptr Label00](self.impl)))

proc gtk_label_get_text(self: ptr Label00): cstring {.
    importc, libprag.}

proc getText*(self: Label): string =
  result = $gtk_label_get_text(cast[ptr Label00](self.impl))

proc text*(self: Label): string =
  result = $gtk_label_get_text(cast[ptr Label00](self.impl))

proc gtk_label_get_track_visited_links(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getTrackVisitedLinks*(self: Label): bool =
  toBool(gtk_label_get_track_visited_links(cast[ptr Label00](self.impl)))

proc trackVisitedLinks*(self: Label): bool =
  toBool(gtk_label_get_track_visited_links(cast[ptr Label00](self.impl)))

proc gtk_label_get_use_markup(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getUseMarkup*(self: Label): bool =
  toBool(gtk_label_get_use_markup(cast[ptr Label00](self.impl)))

proc useMarkup*(self: Label): bool =
  toBool(gtk_label_get_use_markup(cast[ptr Label00](self.impl)))

proc gtk_label_get_use_underline(self: ptr Label00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: Label): bool =
  toBool(gtk_label_get_use_underline(cast[ptr Label00](self.impl)))

proc useUnderline*(self: Label): bool =
  toBool(gtk_label_get_use_underline(cast[ptr Label00](self.impl)))

proc gtk_label_get_width_chars(self: ptr Label00): int32 {.
    importc, libprag.}

proc getWidthChars*(self: Label): int =
  int(gtk_label_get_width_chars(cast[ptr Label00](self.impl)))

proc widthChars*(self: Label): int =
  int(gtk_label_get_width_chars(cast[ptr Label00](self.impl)))

proc gtk_label_get_xalign(self: ptr Label00): cfloat {.
    importc, libprag.}

proc getXalign*(self: Label): cfloat =
  gtk_label_get_xalign(cast[ptr Label00](self.impl))

proc xalign*(self: Label): cfloat =
  gtk_label_get_xalign(cast[ptr Label00](self.impl))

proc gtk_label_get_yalign(self: ptr Label00): cfloat {.
    importc, libprag.}

proc getYalign*(self: Label): cfloat =
  gtk_label_get_yalign(cast[ptr Label00](self.impl))

proc yalign*(self: Label): cfloat =
  gtk_label_get_yalign(cast[ptr Label00](self.impl))

proc gtk_label_select_region(self: ptr Label00; startOffset: int32; endOffset: int32) {.
    importc, libprag.}

proc selectRegion*(self: Label; startOffset: int; endOffset: int) =
  gtk_label_select_region(cast[ptr Label00](self.impl), int32(startOffset), int32(endOffset))

proc gtk_label_set_angle(self: ptr Label00; angle: cdouble) {.
    importc, libprag.}

proc setAngle*(self: Label; angle: cdouble) =
  gtk_label_set_angle(cast[ptr Label00](self.impl), angle)

proc `angle=`*(self: Label; angle: cdouble) =
  gtk_label_set_angle(cast[ptr Label00](self.impl), angle)

proc gtk_label_set_attributes(self: ptr Label00; attrs: ptr pango.AttrList00) {.
    importc, libprag.}

proc setAttributes*(self: Label; attrs: pango.AttrList = nil) =
  gtk_label_set_attributes(cast[ptr Label00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Label; attrs: pango.AttrList = nil) =
  gtk_label_set_attributes(cast[ptr Label00](self.impl), if attrs.isNil: nil else: cast[ptr pango.AttrList00](attrs.impl))

proc gtk_label_set_ellipsize(self: ptr Label00; mode: pango.EllipsizeMode) {.
    importc, libprag.}

proc setEllipsize*(self: Label; mode: pango.EllipsizeMode) =
  gtk_label_set_ellipsize(cast[ptr Label00](self.impl), mode)

proc `ellipsize=`*(self: Label; mode: pango.EllipsizeMode) =
  gtk_label_set_ellipsize(cast[ptr Label00](self.impl), mode)

proc gtk_label_set_label(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setLabel*(self: Label; str: cstring) =
  gtk_label_set_label(cast[ptr Label00](self.impl), str)

proc `label=`*(self: Label; str: cstring) =
  gtk_label_set_label(cast[ptr Label00](self.impl), str)

proc gtk_label_set_line_wrap(self: ptr Label00; wrap: gboolean) {.
    importc, libprag.}

proc setLineWrap*(self: Label; wrap: bool = true) =
  gtk_label_set_line_wrap(cast[ptr Label00](self.impl), gboolean(wrap))

proc `lineWrap=`*(self: Label; wrap: bool) =
  gtk_label_set_line_wrap(cast[ptr Label00](self.impl), gboolean(wrap))

proc gtk_label_set_line_wrap_mode(self: ptr Label00; wrapMode: pango.WrapMode) {.
    importc, libprag.}

proc setLineWrapMode*(self: Label; wrapMode: pango.WrapMode) =
  gtk_label_set_line_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

proc `lineWrapMode=`*(self: Label; wrapMode: pango.WrapMode) =
  gtk_label_set_line_wrap_mode(cast[ptr Label00](self.impl), wrapMode)

proc gtk_label_set_lines(self: ptr Label00; lines: int32) {.
    importc, libprag.}

proc setLines*(self: Label; lines: int) =
  gtk_label_set_lines(cast[ptr Label00](self.impl), int32(lines))

proc `lines=`*(self: Label; lines: int) =
  gtk_label_set_lines(cast[ptr Label00](self.impl), int32(lines))

proc gtk_label_set_markup(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setMarkup*(self: Label; str: cstring) =
  gtk_label_set_markup(cast[ptr Label00](self.impl), str)

proc `markup=`*(self: Label; str: cstring) =
  gtk_label_set_markup(cast[ptr Label00](self.impl), str)

proc gtk_label_set_markup_with_mnemonic(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setMarkupWithMnemonic*(self: Label; str: cstring) =
  gtk_label_set_markup_with_mnemonic(cast[ptr Label00](self.impl), str)

proc `markupWithMnemonic=`*(self: Label; str: cstring) =
  gtk_label_set_markup_with_mnemonic(cast[ptr Label00](self.impl), str)

proc gtk_label_set_max_width_chars(self: ptr Label00; nChars: int32) {.
    importc, libprag.}

proc setMaxWidthChars*(self: Label; nChars: int) =
  gtk_label_set_max_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc `maxWidthChars=`*(self: Label; nChars: int) =
  gtk_label_set_max_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc gtk_label_set_mnemonic_widget(self: ptr Label00; widget: ptr Widget00) {.
    importc, libprag.}

proc setMnemonicWidget*(self: Label; widget: Widget = nil) =
  gtk_label_set_mnemonic_widget(cast[ptr Label00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `mnemonicWidget=`*(self: Label; widget: Widget = nil) =
  gtk_label_set_mnemonic_widget(cast[ptr Label00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_label_set_pattern(self: ptr Label00; pattern: cstring) {.
    importc, libprag.}

proc setPattern*(self: Label; pattern: cstring) =
  gtk_label_set_pattern(cast[ptr Label00](self.impl), pattern)

proc `pattern=`*(self: Label; pattern: cstring) =
  gtk_label_set_pattern(cast[ptr Label00](self.impl), pattern)

proc gtk_label_set_selectable(self: ptr Label00; setting: gboolean) {.
    importc, libprag.}

proc setSelectable*(self: Label; setting: bool = true) =
  gtk_label_set_selectable(cast[ptr Label00](self.impl), gboolean(setting))

proc `selectable=`*(self: Label; setting: bool) =
  gtk_label_set_selectable(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_single_line_mode(self: ptr Label00; singleLineMode: gboolean) {.
    importc, libprag.}

proc setSingleLineMode*(self: Label; singleLineMode: bool = true) =
  gtk_label_set_single_line_mode(cast[ptr Label00](self.impl), gboolean(singleLineMode))

proc `singleLineMode=`*(self: Label; singleLineMode: bool) =
  gtk_label_set_single_line_mode(cast[ptr Label00](self.impl), gboolean(singleLineMode))

proc gtk_label_set_text(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setText*(self: Label; str: cstring) =
  gtk_label_set_text(cast[ptr Label00](self.impl), str)

proc `text=`*(self: Label; str: cstring) =
  gtk_label_set_text(cast[ptr Label00](self.impl), str)

proc gtk_label_set_text_with_mnemonic(self: ptr Label00; str: cstring) {.
    importc, libprag.}

proc setTextWithMnemonic*(self: Label; str: cstring) =
  gtk_label_set_text_with_mnemonic(cast[ptr Label00](self.impl), str)

proc `textWithMnemonic=`*(self: Label; str: cstring) =
  gtk_label_set_text_with_mnemonic(cast[ptr Label00](self.impl), str)

proc gtk_label_set_track_visited_links(self: ptr Label00; trackLinks: gboolean) {.
    importc, libprag.}

proc setTrackVisitedLinks*(self: Label; trackLinks: bool = true) =
  gtk_label_set_track_visited_links(cast[ptr Label00](self.impl), gboolean(trackLinks))

proc `trackVisitedLinks=`*(self: Label; trackLinks: bool) =
  gtk_label_set_track_visited_links(cast[ptr Label00](self.impl), gboolean(trackLinks))

proc gtk_label_set_use_markup(self: ptr Label00; setting: gboolean) {.
    importc, libprag.}

proc setUseMarkup*(self: Label; setting: bool = true) =
  gtk_label_set_use_markup(cast[ptr Label00](self.impl), gboolean(setting))

proc `useMarkup=`*(self: Label; setting: bool) =
  gtk_label_set_use_markup(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_use_underline(self: ptr Label00; setting: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: Label; setting: bool = true) =
  gtk_label_set_use_underline(cast[ptr Label00](self.impl), gboolean(setting))

proc `useUnderline=`*(self: Label; setting: bool) =
  gtk_label_set_use_underline(cast[ptr Label00](self.impl), gboolean(setting))

proc gtk_label_set_width_chars(self: ptr Label00; nChars: int32) {.
    importc, libprag.}

proc setWidthChars*(self: Label; nChars: int) =
  gtk_label_set_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc `widthChars=`*(self: Label; nChars: int) =
  gtk_label_set_width_chars(cast[ptr Label00](self.impl), int32(nChars))

proc gtk_label_set_xalign(self: ptr Label00; xalign: cfloat) {.
    importc, libprag.}

proc setXalign*(self: Label; xalign: cfloat) =
  gtk_label_set_xalign(cast[ptr Label00](self.impl), xalign)

proc `xalign=`*(self: Label; xalign: cfloat) =
  gtk_label_set_xalign(cast[ptr Label00](self.impl), xalign)

proc gtk_label_set_yalign(self: ptr Label00; yalign: cfloat) {.
    importc, libprag.}

proc setYalign*(self: Label; yalign: cfloat) =
  gtk_label_set_yalign(cast[ptr Label00](self.impl), yalign)

proc `yalign=`*(self: Label; yalign: cfloat) =
  gtk_label_set_yalign(cast[ptr Label00](self.impl), yalign)

type
  AccelLabel* = ref object of Label
  AccelLabel00* = object of Label00

proc gtk_accel_label_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AccelLabel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_accel_label_new(string: cstring): ptr AccelLabel00 {.
    importc, libprag.}

proc newAccelLabel*(string: cstring): AccelLabel =
  let gobj = gtk_accel_label_new(string)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAccelLabel*(tdesc: typedesc; string: cstring): tdesc =
  assert(result is AccelLabel)
  let gobj = gtk_accel_label_new(string)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAccelLabel*[T](result: var T; string: cstring) {.deprecated.} =
  assert(result is AccelLabel)
  let gobj = gtk_accel_label_new(string)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_label_get_accel(self: ptr AccelLabel00; acceleratorKey: var uint32;
    acceleratorMods: var gdk.ModifierType) {.
    importc, libprag.}

proc getAccel*(self: AccelLabel; acceleratorKey: var int;
    acceleratorMods: var gdk.ModifierType) =
  var acceleratorKey_00: uint32
  gtk_accel_label_get_accel(cast[ptr AccelLabel00](self.impl), acceleratorKey_00, acceleratorMods)
  if acceleratorKey.addr != nil:
    acceleratorKey = int(acceleratorKey_00)

proc gtk_accel_label_get_accel_widget(self: ptr AccelLabel00): ptr Widget00 {.
    importc, libprag.}

proc getAccelWidget*(self: AccelLabel): Widget =
  let gobj = gtk_accel_label_get_accel_widget(cast[ptr AccelLabel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelWidget*(self: AccelLabel): Widget =
  let gobj = gtk_accel_label_get_accel_widget(cast[ptr AccelLabel00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_accel_label_get_accel_width(self: ptr AccelLabel00): uint32 {.
    importc, libprag.}

proc getAccelWidth*(self: AccelLabel): int =
  int(gtk_accel_label_get_accel_width(cast[ptr AccelLabel00](self.impl)))

proc accelWidth*(self: AccelLabel): int =
  int(gtk_accel_label_get_accel_width(cast[ptr AccelLabel00](self.impl)))

proc gtk_accel_label_refetch(self: ptr AccelLabel00): gboolean {.
    importc, libprag.}

proc refetch*(self: AccelLabel): bool =
  toBool(gtk_accel_label_refetch(cast[ptr AccelLabel00](self.impl)))

proc gtk_accel_label_set_accel(self: ptr AccelLabel00; acceleratorKey: uint32;
    acceleratorMods: gdk.ModifierType) {.
    importc, libprag.}

proc setAccel*(self: AccelLabel; acceleratorKey: int; acceleratorMods: gdk.ModifierType) =
  gtk_accel_label_set_accel(cast[ptr AccelLabel00](self.impl), uint32(acceleratorKey), acceleratorMods)

proc gtk_accel_label_set_accel_closure(self: ptr AccelLabel00; accelClosure: ptr gobject.Closure00) {.
    importc, libprag.}

proc setAccelClosure*(self: AccelLabel; accelClosure: gobject.Closure = nil) =
  gtk_accel_label_set_accel_closure(cast[ptr AccelLabel00](self.impl), if accelClosure.isNil: nil else: cast[ptr gobject.Closure00](accelClosure.impl))

proc `accelClosure=`*(self: AccelLabel; accelClosure: gobject.Closure = nil) =
  gtk_accel_label_set_accel_closure(cast[ptr AccelLabel00](self.impl), if accelClosure.isNil: nil else: cast[ptr gobject.Closure00](accelClosure.impl))

proc gtk_accel_label_set_accel_widget(self: ptr AccelLabel00; accelWidget: ptr Widget00) {.
    importc, libprag.}

proc setAccelWidget*(self: AccelLabel; accelWidget: Widget = nil) =
  gtk_accel_label_set_accel_widget(cast[ptr AccelLabel00](self.impl), if accelWidget.isNil: nil else: cast[ptr Widget00](accelWidget.impl))

proc `accelWidget=`*(self: AccelLabel; accelWidget: Widget = nil) =
  gtk_accel_label_set_accel_widget(cast[ptr AccelLabel00](self.impl), if accelWidget.isNil: nil else: cast[ptr Widget00](accelWidget.impl))

type
  Justification* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    center = 2
    fill = 3

proc gtk_label_get_justify(self: ptr Label00): Justification {.
    importc, libprag.}

proc getJustify*(self: Label): Justification =
  gtk_label_get_justify(cast[ptr Label00](self.impl))

proc justify*(self: Label): Justification =
  gtk_label_get_justify(cast[ptr Label00](self.impl))

proc gtk_label_set_justify(self: ptr Label00; jtype: Justification) {.
    importc, libprag.}

proc setJustify*(self: Label; jtype: Justification) =
  gtk_label_set_justify(cast[ptr Label00](self.impl), jtype)

proc `justify=`*(self: Label; jtype: Justification) =
  gtk_label_set_justify(cast[ptr Label00](self.impl), jtype)

type
  MenuItem* = ref object of Bin
  MenuItem00* = object of Bin00

proc gtk_menu_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scActivateItem*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-item", cast[GCallback](p), xdata, nil, cf)

proc scDeselect*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "deselect", cast[GCallback](p), xdata, nil, cf)

proc scSelect*(self: MenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select", cast[GCallback](p), xdata, nil, cf)

proc scToggleSizeAllocate*(self: MenuItem;  p: proc (self: ptr MenuItem00; `object`: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-size-allocate", cast[GCallback](p), xdata, nil, cf)

proc scToggleSizeRequest*(self: MenuItem;  p: proc (self: ptr MenuItem00; `object`: pointer; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-size-request", cast[GCallback](p), xdata, nil, cf)

proc gtk_menu_item_new(): ptr MenuItem00 {.
    importc, libprag.}

proc newMenuItem*(): MenuItem =
  let gobj = gtk_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuItem*(tdesc: typedesc): tdesc =
  assert(result is MenuItem)
  let gobj = gtk_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuItem*[T](result: var T) {.deprecated.} =
  assert(result is MenuItem)
  let gobj = gtk_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_new_with_label(label: cstring): ptr MenuItem00 {.
    importc, libprag.}

proc newMenuItemWithLabel*(label: cstring): MenuItem =
  let gobj = gtk_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuItemWithLabel*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is MenuItem)
  let gobj = gtk_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuItemWithLabel*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is MenuItem)
  let gobj = gtk_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_new_with_mnemonic(label: cstring): ptr MenuItem00 {.
    importc, libprag.}

proc newMenuItemWithMnemonic*(label: cstring): MenuItem =
  let gobj = gtk_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuItemWithMnemonic*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is MenuItem)
  let gobj = gtk_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuItemWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is MenuItem)
  let gobj = gtk_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_activate(self: ptr MenuItem00) {.
    importc, libprag.}

proc activate*(self: MenuItem) =
  gtk_menu_item_activate(cast[ptr MenuItem00](self.impl))

proc gtk_menu_item_deselect(self: ptr MenuItem00) {.
    importc, libprag.}

proc deselect*(self: MenuItem) =
  gtk_menu_item_deselect(cast[ptr MenuItem00](self.impl))

proc gtk_menu_item_get_accel_path(self: ptr MenuItem00): cstring {.
    importc, libprag.}

proc getAccelPath*(self: MenuItem): string =
  let resul0 = gtk_menu_item_get_accel_path(cast[ptr MenuItem00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc accelPath*(self: MenuItem): string =
  let resul0 = gtk_menu_item_get_accel_path(cast[ptr MenuItem00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_menu_item_get_label(self: ptr MenuItem00): cstring {.
    importc, libprag.}

proc getLabel*(self: MenuItem): string =
  result = $gtk_menu_item_get_label(cast[ptr MenuItem00](self.impl))

proc label*(self: MenuItem): string =
  result = $gtk_menu_item_get_label(cast[ptr MenuItem00](self.impl))

proc gtk_menu_item_get_reserve_indicator(self: ptr MenuItem00): gboolean {.
    importc, libprag.}

proc getReserveIndicator*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_reserve_indicator(cast[ptr MenuItem00](self.impl)))

proc reserveIndicator*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_reserve_indicator(cast[ptr MenuItem00](self.impl)))

proc gtk_menu_item_get_right_justified(self: ptr MenuItem00): gboolean {.
    importc, libprag.}

proc getRightJustified*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_right_justified(cast[ptr MenuItem00](self.impl)))

proc rightJustified*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_right_justified(cast[ptr MenuItem00](self.impl)))

proc gtk_menu_item_get_submenu(self: ptr MenuItem00): ptr Widget00 {.
    importc, libprag.}

proc getSubmenu*(self: MenuItem): Widget =
  let gobj = gtk_menu_item_get_submenu(cast[ptr MenuItem00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc submenu*(self: MenuItem): Widget =
  let gobj = gtk_menu_item_get_submenu(cast[ptr MenuItem00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_item_get_use_underline(self: ptr MenuItem00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_use_underline(cast[ptr MenuItem00](self.impl)))

proc useUnderline*(self: MenuItem): bool =
  toBool(gtk_menu_item_get_use_underline(cast[ptr MenuItem00](self.impl)))

proc gtk_menu_item_select(self: ptr MenuItem00) {.
    importc, libprag.}

proc select*(self: MenuItem) =
  gtk_menu_item_select(cast[ptr MenuItem00](self.impl))

proc gtk_menu_item_set_accel_path(self: ptr MenuItem00; accelPath: cstring) {.
    importc, libprag.}

proc setAccelPath*(self: MenuItem; accelPath: cstring = nil) =
  gtk_menu_item_set_accel_path(cast[ptr MenuItem00](self.impl), accelPath)

proc `accelPath=`*(self: MenuItem; accelPath: cstring = nil) =
  gtk_menu_item_set_accel_path(cast[ptr MenuItem00](self.impl), accelPath)

proc gtk_menu_item_set_label(self: ptr MenuItem00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: MenuItem; label: cstring) =
  gtk_menu_item_set_label(cast[ptr MenuItem00](self.impl), label)

proc `label=`*(self: MenuItem; label: cstring) =
  gtk_menu_item_set_label(cast[ptr MenuItem00](self.impl), label)

proc gtk_menu_item_set_reserve_indicator(self: ptr MenuItem00; reserve: gboolean) {.
    importc, libprag.}

proc setReserveIndicator*(self: MenuItem; reserve: bool = true) =
  gtk_menu_item_set_reserve_indicator(cast[ptr MenuItem00](self.impl), gboolean(reserve))

proc `reserveIndicator=`*(self: MenuItem; reserve: bool) =
  gtk_menu_item_set_reserve_indicator(cast[ptr MenuItem00](self.impl), gboolean(reserve))

proc gtk_menu_item_set_right_justified(self: ptr MenuItem00; rightJustified: gboolean) {.
    importc, libprag.}

proc setRightJustified*(self: MenuItem; rightJustified: bool = true) =
  gtk_menu_item_set_right_justified(cast[ptr MenuItem00](self.impl), gboolean(rightJustified))

proc `rightJustified=`*(self: MenuItem; rightJustified: bool) =
  gtk_menu_item_set_right_justified(cast[ptr MenuItem00](self.impl), gboolean(rightJustified))

proc gtk_menu_item_set_submenu(self: ptr MenuItem00; submenu: ptr Menu00) {.
    importc, libprag.}

proc setSubmenu*(self: MenuItem; submenu: Menu = nil) =
  gtk_menu_item_set_submenu(cast[ptr MenuItem00](self.impl), if submenu.isNil: nil else: cast[ptr Menu00](submenu.impl))

proc `submenu=`*(self: MenuItem; submenu: Menu = nil) =
  gtk_menu_item_set_submenu(cast[ptr MenuItem00](self.impl), if submenu.isNil: nil else: cast[ptr Menu00](submenu.impl))

proc gtk_menu_item_set_use_underline(self: ptr MenuItem00; setting: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: MenuItem; setting: bool = true) =
  gtk_menu_item_set_use_underline(cast[ptr MenuItem00](self.impl), gboolean(setting))

proc `useUnderline=`*(self: MenuItem; setting: bool) =
  gtk_menu_item_set_use_underline(cast[ptr MenuItem00](self.impl), gboolean(setting))

proc gtk_menu_item_toggle_size_allocate(self: ptr MenuItem00; allocation: int32) {.
    importc, libprag.}

proc toggleSizeAllocate*(self: MenuItem; allocation: int) =
  gtk_menu_item_toggle_size_allocate(cast[ptr MenuItem00](self.impl), int32(allocation))

proc gtk_menu_item_toggle_size_request(self: ptr MenuItem00; requisition: var int32) {.
    importc, libprag.}

proc toggleSizeRequest*(self: MenuItem; requisition: var int) =
  var requisition_00 = int32(requisition)
  gtk_menu_item_toggle_size_request(cast[ptr MenuItem00](self.impl), requisition_00)
  requisition = int(requisition_00)

proc gtk_menu_shell_append(self: ptr MenuShell00; child: ptr MenuItem00) {.
    importc, libprag.}

proc append*(self: MenuShell; child: MenuItem) =
  gtk_menu_shell_append(cast[ptr MenuShell00](self.impl), cast[ptr MenuItem00](child.impl))

type
  AccelMap* = ref object of gobject.Object
  AccelMap00* = object of gobject.Object00

proc gtk_accel_map_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AccelMap()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: AccelMap;  p: proc (self: ptr AccelMap00; accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_accel_map_add_entry(accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType) {.
    importc, libprag.}

proc addEntry*(accelPath: cstring; accelKey: int; accelMods: gdk.ModifierType) =
  gtk_accel_map_add_entry(accelPath, uint32(accelKey), accelMods)

proc addFilter*(filterPattern: cstring) {.
    importc: "gtk_accel_map_add_filter", libprag.}

proc gtk_accel_map_change_entry(accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType;
    replace: gboolean): gboolean {.
    importc, libprag.}

proc changeEntry*(accelPath: cstring; accelKey: int; accelMods: gdk.ModifierType;
    replace: bool): bool =
  toBool(gtk_accel_map_change_entry(accelPath, uint32(accelKey), accelMods, gboolean(replace)))

proc gtk_accel_map_get(): ptr AccelMap00 {.
    importc, libprag.}

proc getAccelMap*(): AccelMap =
  let gobj = gtk_accel_map_get()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc load*(fileName: cstring) {.
    importc: "gtk_accel_map_load", libprag.}

proc gtk_accel_map_load_fd(fd: int32) {.
    importc, libprag.}

proc loadFd*(fd: int) =
  gtk_accel_map_load_fd(int32(fd))

proc gtk_accel_map_load_scanner(scanner: ptr glib.Scanner00) {.
    importc, libprag.}

proc loadScanner*(scanner: glib.Scanner) =
  gtk_accel_map_load_scanner(cast[ptr glib.Scanner00](scanner.impl))

proc lockPath*(accelPath: cstring) {.
    importc: "gtk_accel_map_lock_path", libprag.}

proc gtk_accel_map_lookup_entry(accelPath: cstring; key: var AccelKey): gboolean {.
    importc, libprag.}

proc lookupEntry*(accelPath: cstring; key: var AccelKey = cast[var AccelKey](nil)): bool =
  toBool(gtk_accel_map_lookup_entry(accelPath, key))

proc save*(fileName: cstring) {.
    importc: "gtk_accel_map_save", libprag.}

proc gtk_accel_map_save_fd(fd: int32) {.
    importc, libprag.}

proc saveFd*(fd: int) =
  gtk_accel_map_save_fd(int32(fd))

proc unlockPath*(accelPath: cstring) {.
    importc: "gtk_accel_map_unlock_path", libprag.}

type
  AccelMapForeach* = proc (data: pointer; accelPath: cstring; accelKey: uint32; accelMods: gdk.ModifierType;
    changed: gboolean) {.cdecl.}

proc foreach*(data: pointer; foreachFunc: AccelMapForeach) {.
    importc: "gtk_accel_map_foreach", libprag.}

proc foreachUnfiltered*(data: pointer; foreachFunc: AccelMapForeach) {.
    importc: "gtk_accel_map_foreach_unfiltered", libprag.}

type
  ExpanderAccessible* = ref object of ContainerAccessible
  ExpanderAccessible00* = object of ContainerAccessible00

proc gtk_expander_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ExpanderAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  CellAccessible* = ref object of Accessible
  CellAccessible00* = object of Accessible00

proc gtk_cell_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ContainerCellAccessible* = ref object of CellAccessible
  ContainerCellAccessible00* = object of CellAccessible00

proc gtk_container_cell_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ContainerCellAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_container_cell_accessible_new(): ptr ContainerCellAccessible00 {.
    importc, libprag.}

proc newContainerCellAccessible*(): ContainerCellAccessible =
  let gobj = gtk_container_cell_accessible_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newContainerCellAccessible*(tdesc: typedesc): tdesc =
  assert(result is ContainerCellAccessible)
  let gobj = gtk_container_cell_accessible_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initContainerCellAccessible*[T](result: var T) {.deprecated.} =
  assert(result is ContainerCellAccessible)
  let gobj = gtk_container_cell_accessible_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_container_cell_accessible_add_child(self: ptr ContainerCellAccessible00;
    child: ptr CellAccessible00) {.
    importc, libprag.}

proc addChild*(self: ContainerCellAccessible;
    child: CellAccessible) =
  gtk_container_cell_accessible_add_child(cast[ptr ContainerCellAccessible00](self.impl), cast[ptr CellAccessible00](child.impl))

proc gtk_container_cell_accessible_get_children(self: ptr ContainerCellAccessible00): ptr glib.List {.
    importc, libprag.}

proc getChildren*(self: ContainerCellAccessible): seq[CellAccessible] =
  result = glistObjects2seq(CellAccessible, gtk_container_cell_accessible_get_children(cast[ptr ContainerCellAccessible00](self.impl)), false)

proc children*(self: ContainerCellAccessible): seq[CellAccessible] =
  result = glistObjects2seq(CellAccessible, gtk_container_cell_accessible_get_children(cast[ptr ContainerCellAccessible00](self.impl)), false)

proc gtk_container_cell_accessible_remove_child(self: ptr ContainerCellAccessible00;
    child: ptr CellAccessible00) {.
    importc, libprag.}

proc removeChild*(self: ContainerCellAccessible;
    child: CellAccessible) =
  gtk_container_cell_accessible_remove_child(cast[ptr ContainerCellAccessible00](self.impl), cast[ptr CellAccessible00](child.impl))

type
  ButtonAccessible* = ref object of ContainerAccessible
  ButtonAccessible00* = object of ContainerAccessible00

proc gtk_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  LockButtonAccessible* = ref object of ButtonAccessible
  LockButtonAccessible00* = object of ButtonAccessible00

proc gtk_lock_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LockButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  SwitchAccessible* = ref object of WidgetAccessible
  SwitchAccessible00* = object of WidgetAccessible00

proc gtk_switch_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SwitchAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  MenuItemAccessible* = ref object of ContainerAccessible
  MenuItemAccessible00* = object of ContainerAccessible00

proc gtk_menu_item_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuItemAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  CheckMenuItemAccessible* = ref object of MenuItemAccessible
  CheckMenuItemAccessible00* = object of MenuItemAccessible00

proc gtk_check_menu_item_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CheckMenuItemAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ToggleButtonAccessible* = ref object of ButtonAccessible
  ToggleButtonAccessible00* = object of ButtonAccessible00

proc gtk_toggle_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToggleButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  RadioButtonAccessible* = ref object of ToggleButtonAccessible
  RadioButtonAccessible00* = object of ToggleButtonAccessible00

proc gtk_radio_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RadioButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  LinkButtonAccessible* = ref object of ButtonAccessible
  LinkButtonAccessible00* = object of ButtonAccessible00

proc gtk_link_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LinkButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  RendererCellAccessible* = ref object of CellAccessible
  RendererCellAccessible00* = object of CellAccessible00

proc gtk_renderer_cell_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RendererCellAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ImageCellAccessible* = ref object of RendererCellAccessible
  ImageCellAccessible00* = object of RendererCellAccessible00

proc gtk_image_cell_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ImageCellAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  EntryAccessible* = ref object of WidgetAccessible
  EntryAccessible00* = object of WidgetAccessible00

proc gtk_entry_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EntryAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  SpinButtonAccessible* = ref object of EntryAccessible
  SpinButtonAccessible00* = object of EntryAccessible00

proc gtk_spin_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SpinButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  MenuButtonAccessible* = ref object of ToggleButtonAccessible
  MenuButtonAccessible00* = object of ToggleButtonAccessible00

proc gtk_menu_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ComboBoxAccessible* = ref object of ContainerAccessible
  ComboBoxAccessible00* = object of ContainerAccessible00

proc gtk_combo_box_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ComboBoxAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  RadioMenuItemAccessible* = ref object of CheckMenuItemAccessible
  RadioMenuItemAccessible00* = object of CheckMenuItemAccessible00

proc gtk_radio_menu_item_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RadioMenuItemAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ScaleButtonAccessible* = ref object of ButtonAccessible
  ScaleButtonAccessible00* = object of ButtonAccessible00

proc gtk_scale_button_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScaleButtonAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  BooleanCellAccessible* = ref object of RendererCellAccessible
  BooleanCellAccessible00* = object of RendererCellAccessible00

proc gtk_boolean_cell_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(BooleanCellAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  TextCellAccessible* = ref object of RendererCellAccessible
  TextCellAccessible00* = object of RendererCellAccessible00

proc gtk_text_cell_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextCellAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  EntryIconAccessible* = ref object of atk.Object
  EntryIconAccessible00* = object of atk.Object00

proc gtk_entry_icon_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EntryIconAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  Action* = ref object of gobject.Object
  Action00* = object of gobject.Object00

proc gtk_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Action()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_action_new(name: cstring; label: cstring; tooltip: cstring; stockId: cstring): ptr Action00 {.
    importc, libprag.}

proc newAction*(name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil): Action {.deprecated.}  =
  let gobj = gtk_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAction*(tdesc: typedesc; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil): tdesc {.deprecated.}  =
  assert(result is Action)
  let gobj = gtk_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAction*[T](result: var T; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil) {.deprecated.} =
  assert(result is Action)
  let gobj = gtk_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_activate(self: ptr Action00) {.
    importc, libprag.}

proc activate*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible) =
  gtk_action_activate(cast[ptr Action00](self.impl))

proc gtk_action_block_activate(self: ptr Action00) {.
    importc, libprag.}

proc blockActivate*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible) =
  gtk_action_block_activate(cast[ptr Action00](self.impl))

proc gtk_action_connect_accelerator(self: ptr Action00) {.
    importc, libprag.}

proc connectAccelerator*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible) =
  gtk_action_connect_accelerator(cast[ptr Action00](self.impl))

proc gtk_action_create_icon(self: ptr Action00; iconSize: int32): ptr Widget00 {.
    importc, libprag.}

proc createIcon*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    iconSize: int): Widget =
  let gobj = gtk_action_create_icon(cast[ptr Action00](self.impl), int32(iconSize))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_create_menu(self: ptr Action00): ptr Widget00 {.
    importc, libprag.}

proc createMenu*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): Widget =
  let gobj = gtk_action_create_menu(cast[ptr Action00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_create_menu_item(self: ptr Action00): ptr Widget00 {.
    importc, libprag.}

proc createMenuItem*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): Widget =
  let gobj = gtk_action_create_menu_item(cast[ptr Action00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_create_tool_item(self: ptr Action00): ptr Widget00 {.
    importc, libprag.}

proc createToolItem*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): Widget =
  let gobj = gtk_action_create_tool_item(cast[ptr Action00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_disconnect_accelerator(self: ptr Action00) {.
    importc, libprag.}

proc disconnectAccelerator*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible) =
  gtk_action_disconnect_accelerator(cast[ptr Action00](self.impl))

proc gtk_action_get_accel_closure(self: ptr Action00): ptr gobject.Closure00 {.
    importc, libprag.}

proc getAccelClosure*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): gobject.Closure =
  fnew(result, gBoxedFreeGClosure)
  result.impl = gtk_action_get_accel_closure(cast[ptr Action00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_closure_get_type(), result.impl))

proc accelClosure*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): gobject.Closure =
  fnew(result, gBoxedFreeGClosure)
  result.impl = gtk_action_get_accel_closure(cast[ptr Action00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(g_closure_get_type(), result.impl))

proc gtk_action_get_accel_path(self: ptr Action00): cstring {.
    importc, libprag.}

proc getAccelPath*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_accel_path(cast[ptr Action00](self.impl))

proc accelPath*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_accel_path(cast[ptr Action00](self.impl))

proc gtk_action_get_always_show_image(self: ptr Action00): gboolean {.
    importc, libprag.}

proc getAlwaysShowImage*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_always_show_image(cast[ptr Action00](self.impl)))

proc alwaysShowImage*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_always_show_image(cast[ptr Action00](self.impl)))

proc gtk_action_get_gicon(self: ptr Action00): ptr gio.Icon00 {.
    importc, libprag.}

proc getGicon*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): gio.Icon =
  let gobj = gtk_action_get_gicon(cast[ptr Action00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gicon*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): gio.Icon =
  let gobj = gtk_action_get_gicon(cast[ptr Action00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_get_icon_name(self: ptr Action00): cstring {.
    importc, libprag.}

proc getIconName*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_icon_name(cast[ptr Action00](self.impl))

proc iconName*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_icon_name(cast[ptr Action00](self.impl))

proc gtk_action_get_is_important(self: ptr Action00): gboolean {.
    importc, libprag.}

proc getIsImportant*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_is_important(cast[ptr Action00](self.impl)))

proc isImportant*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_is_important(cast[ptr Action00](self.impl)))

proc gtk_action_get_label(self: ptr Action00): cstring {.
    importc, libprag.}

proc getLabel*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_label(cast[ptr Action00](self.impl))

proc label*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_label(cast[ptr Action00](self.impl))

proc gtk_action_get_name(self: ptr Action00): cstring {.
    importc, libprag.}

proc getName*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_name(cast[ptr Action00](self.impl))

proc name*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_name(cast[ptr Action00](self.impl))

proc gtk_action_get_proxies(self: ptr Action00): ptr glib.SList {.
    importc, libprag.}

proc getProxies*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): seq[Widget] =
  result = gslistObjects2seq(Widget, gtk_action_get_proxies(cast[ptr Action00](self.impl)), false)

proc proxies*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): seq[Widget] =
  result = gslistObjects2seq(Widget, gtk_action_get_proxies(cast[ptr Action00](self.impl)), false)

proc gtk_action_get_sensitive(self: ptr Action00): gboolean {.
    importc, libprag.}

proc getSensitive*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_sensitive(cast[ptr Action00](self.impl)))

proc sensitive*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_sensitive(cast[ptr Action00](self.impl)))

proc gtk_action_get_short_label(self: ptr Action00): cstring {.
    importc, libprag.}

proc getShortLabel*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_short_label(cast[ptr Action00](self.impl))

proc shortLabel*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_short_label(cast[ptr Action00](self.impl))

proc gtk_action_get_stock_id(self: ptr Action00): cstring {.
    importc, libprag.}

proc getStockId*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_stock_id(cast[ptr Action00](self.impl))

proc stockId*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_stock_id(cast[ptr Action00](self.impl))

proc gtk_action_get_tooltip(self: ptr Action00): cstring {.
    importc, libprag.}

proc getTooltip*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_tooltip(cast[ptr Action00](self.impl))

proc tooltip*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): string =
  result = $gtk_action_get_tooltip(cast[ptr Action00](self.impl))

proc gtk_action_get_visible(self: ptr Action00): gboolean {.
    importc, libprag.}

proc getVisible*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_visible(cast[ptr Action00](self.impl)))

proc visible*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_visible(cast[ptr Action00](self.impl)))

proc gtk_action_get_visible_horizontal(self: ptr Action00): gboolean {.
    importc, libprag.}

proc getVisibleHorizontal*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_visible_horizontal(cast[ptr Action00](self.impl)))

proc visibleHorizontal*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_visible_horizontal(cast[ptr Action00](self.impl)))

proc gtk_action_get_visible_vertical(self: ptr Action00): gboolean {.
    importc, libprag.}

proc getVisibleVertical*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_visible_vertical(cast[ptr Action00](self.impl)))

proc visibleVertical*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_get_visible_vertical(cast[ptr Action00](self.impl)))

proc gtk_action_is_sensitive(self: ptr Action00): gboolean {.
    importc, libprag.}

proc isSensitive*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_is_sensitive(cast[ptr Action00](self.impl)))

proc gtk_action_is_visible(self: ptr Action00): gboolean {.
    importc, libprag.}

proc isVisible*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible): bool =
  toBool(gtk_action_is_visible(cast[ptr Action00](self.impl)))

proc gtk_action_set_accel_group(self: ptr Action00; accelGroup: ptr AccelGroup00) {.
    importc, libprag.}

proc setAccelGroup*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    accelGroup: AccelGroup = nil) =
  gtk_action_set_accel_group(cast[ptr Action00](self.impl), if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    accelGroup: AccelGroup = nil) =
  gtk_action_set_accel_group(cast[ptr Action00](self.impl), if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_action_set_accel_path(self: ptr Action00; accelPath: cstring) {.
    importc, libprag.}

proc setAccelPath*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    accelPath: cstring) =
  gtk_action_set_accel_path(cast[ptr Action00](self.impl), accelPath)

proc `accelPath=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    accelPath: cstring) =
  gtk_action_set_accel_path(cast[ptr Action00](self.impl), accelPath)

proc gtk_action_set_always_show_image(self: ptr Action00; alwaysShow: gboolean) {.
    importc, libprag.}

proc setAlwaysShowImage*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    alwaysShow: bool = true) =
  gtk_action_set_always_show_image(cast[ptr Action00](self.impl), gboolean(alwaysShow))

proc `alwaysShowImage=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    alwaysShow: bool) =
  gtk_action_set_always_show_image(cast[ptr Action00](self.impl), gboolean(alwaysShow))

proc gtk_action_set_gicon(self: ptr Action00; icon: ptr gio.Icon00) {.
    importc, libprag.}

proc setGicon*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    icon: gio.Icon) =
  gtk_action_set_gicon(cast[ptr Action00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc `gicon=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    icon: gio.Icon) =
  gtk_action_set_gicon(cast[ptr Action00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_action_set_icon_name(self: ptr Action00; iconName: cstring) {.
    importc, libprag.}

proc setIconName*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    iconName: cstring) =
  gtk_action_set_icon_name(cast[ptr Action00](self.impl), iconName)

proc `iconName=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    iconName: cstring) =
  gtk_action_set_icon_name(cast[ptr Action00](self.impl), iconName)

proc gtk_action_set_is_important(self: ptr Action00; isImportant: gboolean) {.
    importc, libprag.}

proc setIsImportant*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    isImportant: bool = true) =
  gtk_action_set_is_important(cast[ptr Action00](self.impl), gboolean(isImportant))

proc `isImportant=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    isImportant: bool) =
  gtk_action_set_is_important(cast[ptr Action00](self.impl), gboolean(isImportant))

proc gtk_action_set_label(self: ptr Action00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    label: cstring) =
  gtk_action_set_label(cast[ptr Action00](self.impl), label)

proc `label=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    label: cstring) =
  gtk_action_set_label(cast[ptr Action00](self.impl), label)

proc gtk_action_set_sensitive(self: ptr Action00; sensitive: gboolean) {.
    importc, libprag.}

proc setSensitive*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    sensitive: bool = true) =
  gtk_action_set_sensitive(cast[ptr Action00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    sensitive: bool) =
  gtk_action_set_sensitive(cast[ptr Action00](self.impl), gboolean(sensitive))

proc gtk_action_set_short_label(self: ptr Action00; shortLabel: cstring) {.
    importc, libprag.}

proc setShortLabel*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    shortLabel: cstring) =
  gtk_action_set_short_label(cast[ptr Action00](self.impl), shortLabel)

proc `shortLabel=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    shortLabel: cstring) =
  gtk_action_set_short_label(cast[ptr Action00](self.impl), shortLabel)

proc gtk_action_set_stock_id(self: ptr Action00; stockId: cstring) {.
    importc, libprag.}

proc setStockId*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    stockId: cstring) =
  gtk_action_set_stock_id(cast[ptr Action00](self.impl), stockId)

proc `stockId=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    stockId: cstring) =
  gtk_action_set_stock_id(cast[ptr Action00](self.impl), stockId)

proc gtk_action_set_tooltip(self: ptr Action00; tooltip: cstring) {.
    importc, libprag.}

proc setTooltip*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    tooltip: cstring) =
  gtk_action_set_tooltip(cast[ptr Action00](self.impl), tooltip)

proc `tooltip=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    tooltip: cstring) =
  gtk_action_set_tooltip(cast[ptr Action00](self.impl), tooltip)

proc gtk_action_set_visible(self: ptr Action00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    visible: bool = true) =
  gtk_action_set_visible(cast[ptr Action00](self.impl), gboolean(visible))

proc `visible=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    visible: bool) =
  gtk_action_set_visible(cast[ptr Action00](self.impl), gboolean(visible))

proc gtk_action_set_visible_horizontal(self: ptr Action00; visibleHorizontal: gboolean) {.
    importc, libprag.}

proc setVisibleHorizontal*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    visibleHorizontal: bool = true) =
  gtk_action_set_visible_horizontal(cast[ptr Action00](self.impl), gboolean(visibleHorizontal))

proc `visibleHorizontal=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    visibleHorizontal: bool) =
  gtk_action_set_visible_horizontal(cast[ptr Action00](self.impl), gboolean(visibleHorizontal))

proc gtk_action_set_visible_vertical(self: ptr Action00; visibleVertical: gboolean) {.
    importc, libprag.}

proc setVisibleVertical*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    visibleVertical: bool = true) =
  gtk_action_set_visible_vertical(cast[ptr Action00](self.impl), gboolean(visibleVertical))

proc `visibleVertical=`*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible;
    visibleVertical: bool) =
  gtk_action_set_visible_vertical(cast[ptr Action00](self.impl), gboolean(visibleVertical))

proc gtk_action_unblock_activate(self: ptr Action00) {.
    importc, libprag.}

proc unblockActivate*(self: Action | ExpanderAccessible | ContainerCellAccessible | LockButtonAccessible | SwitchAccessible | CheckMenuItemAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | SpinButtonAccessible | MenuButtonAccessible | ComboBoxAccessible | ToggleButtonAccessible | MenuItemAccessible | RendererCellAccessible | RadioMenuItemAccessible | ScaleButtonAccessible | BooleanCellAccessible | ButtonAccessible | TextCellAccessible | EntryIconAccessible | CellAccessible | EntryAccessible) =
  gtk_action_unblock_activate(cast[ptr Action00](self.impl))

type
  ComboBox* = ref object of Bin
  ComboBox00* = object of Bin00

proc gtk_combo_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ComboBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scFormatEntryText*(self: ComboBox;  p: proc (self: ptr ComboBox00; path: cstring; xdata: pointer): cstring {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "format-entry-text", cast[GCallback](p), xdata, nil, cf)

proc scMoveActive*(self: ComboBox;  p: proc (self: ptr ComboBox00; scrollType: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-active", cast[GCallback](p), xdata, nil, cf)

proc scPopdown*(self: ComboBox;  p: proc (self: ptr ComboBox00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popdown", cast[GCallback](p), xdata, nil, cf)

proc scPopup*(self: ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popup", cast[GCallback](p), xdata, nil, cf)

proc gtk_combo_box_new(): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBox*(): ComboBox =
  let gobj = gtk_combo_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBox*(tdesc: typedesc): tdesc =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBox*[T](result: var T) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_entry(): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithEntry*(): ComboBox =
  let gobj = gtk_combo_box_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithEntry*(tdesc: typedesc): tdesc =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithEntry*[T](result: var T) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_active(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getActive*(self: ComboBox): int =
  int(gtk_combo_box_get_active(cast[ptr ComboBox00](self.impl)))

proc active*(self: ComboBox): int =
  int(gtk_combo_box_get_active(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_active_id(self: ptr ComboBox00): cstring {.
    importc, libprag.}

proc getActiveId*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_active_id(cast[ptr ComboBox00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc activeId*(self: ComboBox): string =
  let resul0 = gtk_combo_box_get_active_id(cast[ptr ComboBox00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_combo_box_get_add_tearoffs(self: ptr ComboBox00): gboolean {.
    importc, libprag.}

proc getAddTearoffs*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_add_tearoffs(cast[ptr ComboBox00](self.impl)))

proc addTearoffs*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_add_tearoffs(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_column_span_column(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getColumnSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_column_span_column(cast[ptr ComboBox00](self.impl)))

proc columnSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_column_span_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_entry_text_column(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getEntryTextColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_entry_text_column(cast[ptr ComboBox00](self.impl)))

proc entryTextColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_entry_text_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_focus_on_click(self: ptr ComboBox00): gboolean {.
    importc, libprag.}

proc getFocusOnClick*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_focus_on_click(cast[ptr ComboBox00](self.impl)))

proc focusOnClick*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_focus_on_click(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_has_entry(self: ptr ComboBox00): gboolean {.
    importc, libprag.}

proc getHasEntry*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_has_entry(cast[ptr ComboBox00](self.impl)))

proc hasEntry*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_has_entry(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_id_column(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getIdColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_id_column(cast[ptr ComboBox00](self.impl)))

proc idColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_id_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_popup_accessible(self: ptr ComboBox00): ptr atk.Object00 {.
    importc, libprag.}

proc getPopupAccessible*(self: ComboBox): atk.Object =
  let gobj = gtk_combo_box_get_popup_accessible(cast[ptr ComboBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, atk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popupAccessible*(self: ComboBox): atk.Object =
  let gobj = gtk_combo_box_get_popup_accessible(cast[ptr ComboBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, atk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_popup_fixed_width(self: ptr ComboBox00): gboolean {.
    importc, libprag.}

proc getPopupFixedWidth*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_popup_fixed_width(cast[ptr ComboBox00](self.impl)))

proc popupFixedWidth*(self: ComboBox): bool =
  toBool(gtk_combo_box_get_popup_fixed_width(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_row_span_column(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getRowSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_row_span_column(cast[ptr ComboBox00](self.impl)))

proc rowSpanColumn*(self: ComboBox): int =
  int(gtk_combo_box_get_row_span_column(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_get_title(self: ptr ComboBox00): cstring {.
    importc, libprag.}

proc getTitle*(self: ComboBox): string =
  result = $gtk_combo_box_get_title(cast[ptr ComboBox00](self.impl))

proc title*(self: ComboBox): string =
  result = $gtk_combo_box_get_title(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_get_wrap_width(self: ptr ComboBox00): int32 {.
    importc, libprag.}

proc getWrapWidth*(self: ComboBox): int =
  int(gtk_combo_box_get_wrap_width(cast[ptr ComboBox00](self.impl)))

proc wrapWidth*(self: ComboBox): int =
  int(gtk_combo_box_get_wrap_width(cast[ptr ComboBox00](self.impl)))

proc gtk_combo_box_popdown(self: ptr ComboBox00) {.
    importc, libprag.}

proc popdown*(self: ComboBox) =
  gtk_combo_box_popdown(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_popup(self: ptr ComboBox00) {.
    importc, libprag.}

proc popup*(self: ComboBox) =
  gtk_combo_box_popup(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_popup_for_device(self: ptr ComboBox00; device: ptr gdk.Device00) {.
    importc, libprag.}

proc popupForDevice*(self: ComboBox; device: gdk.Device) =
  gtk_combo_box_popup_for_device(cast[ptr ComboBox00](self.impl), cast[ptr gdk.Device00](device.impl))

proc gtk_combo_box_set_active(self: ptr ComboBox00; index: int32) {.
    importc, libprag.}

proc setActive*(self: ComboBox; index: int) =
  gtk_combo_box_set_active(cast[ptr ComboBox00](self.impl), int32(index))

proc `active=`*(self: ComboBox; index: int) =
  gtk_combo_box_set_active(cast[ptr ComboBox00](self.impl), int32(index))

proc gtk_combo_box_set_active_id(self: ptr ComboBox00; activeId: cstring): gboolean {.
    importc, libprag.}

proc setActiveId*(self: ComboBox; activeId: cstring = nil): bool =
  toBool(gtk_combo_box_set_active_id(cast[ptr ComboBox00](self.impl), activeId))

proc gtk_combo_box_set_add_tearoffs(self: ptr ComboBox00; addTearoffs: gboolean) {.
    importc, libprag.}

proc setAddTearoffs*(self: ComboBox; addTearoffs: bool = true) =
  gtk_combo_box_set_add_tearoffs(cast[ptr ComboBox00](self.impl), gboolean(addTearoffs))

proc `addTearoffs=`*(self: ComboBox; addTearoffs: bool) =
  gtk_combo_box_set_add_tearoffs(cast[ptr ComboBox00](self.impl), gboolean(addTearoffs))

proc gtk_combo_box_set_column_span_column(self: ptr ComboBox00; columnSpan: int32) {.
    importc, libprag.}

proc setColumnSpanColumn*(self: ComboBox; columnSpan: int) =
  gtk_combo_box_set_column_span_column(cast[ptr ComboBox00](self.impl), int32(columnSpan))

proc `columnSpanColumn=`*(self: ComboBox; columnSpan: int) =
  gtk_combo_box_set_column_span_column(cast[ptr ComboBox00](self.impl), int32(columnSpan))

proc gtk_combo_box_set_entry_text_column(self: ptr ComboBox00; textColumn: int32) {.
    importc, libprag.}

proc setEntryTextColumn*(self: ComboBox; textColumn: int) =
  gtk_combo_box_set_entry_text_column(cast[ptr ComboBox00](self.impl), int32(textColumn))

proc `entryTextColumn=`*(self: ComboBox; textColumn: int) =
  gtk_combo_box_set_entry_text_column(cast[ptr ComboBox00](self.impl), int32(textColumn))

proc gtk_combo_box_set_focus_on_click(self: ptr ComboBox00; focusOnClick: gboolean) {.
    importc, libprag.}

proc setFocusOnClick*(self: ComboBox; focusOnClick: bool = true) =
  gtk_combo_box_set_focus_on_click(cast[ptr ComboBox00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: ComboBox; focusOnClick: bool) =
  gtk_combo_box_set_focus_on_click(cast[ptr ComboBox00](self.impl), gboolean(focusOnClick))

proc gtk_combo_box_set_id_column(self: ptr ComboBox00; idColumn: int32) {.
    importc, libprag.}

proc setIdColumn*(self: ComboBox; idColumn: int) =
  gtk_combo_box_set_id_column(cast[ptr ComboBox00](self.impl), int32(idColumn))

proc `idColumn=`*(self: ComboBox; idColumn: int) =
  gtk_combo_box_set_id_column(cast[ptr ComboBox00](self.impl), int32(idColumn))

proc gtk_combo_box_set_popup_fixed_width(self: ptr ComboBox00; fixed: gboolean) {.
    importc, libprag.}

proc setPopupFixedWidth*(self: ComboBox; fixed: bool = true) =
  gtk_combo_box_set_popup_fixed_width(cast[ptr ComboBox00](self.impl), gboolean(fixed))

proc `popupFixedWidth=`*(self: ComboBox; fixed: bool) =
  gtk_combo_box_set_popup_fixed_width(cast[ptr ComboBox00](self.impl), gboolean(fixed))

proc gtk_combo_box_set_row_span_column(self: ptr ComboBox00; rowSpan: int32) {.
    importc, libprag.}

proc setRowSpanColumn*(self: ComboBox; rowSpan: int) =
  gtk_combo_box_set_row_span_column(cast[ptr ComboBox00](self.impl), int32(rowSpan))

proc `rowSpanColumn=`*(self: ComboBox; rowSpan: int) =
  gtk_combo_box_set_row_span_column(cast[ptr ComboBox00](self.impl), int32(rowSpan))

proc gtk_combo_box_set_title(self: ptr ComboBox00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: ComboBox; title: cstring) =
  gtk_combo_box_set_title(cast[ptr ComboBox00](self.impl), title)

proc `title=`*(self: ComboBox; title: cstring) =
  gtk_combo_box_set_title(cast[ptr ComboBox00](self.impl), title)

proc gtk_combo_box_set_wrap_width(self: ptr ComboBox00; width: int32) {.
    importc, libprag.}

proc setWrapWidth*(self: ComboBox; width: int) =
  gtk_combo_box_set_wrap_width(cast[ptr ComboBox00](self.impl), int32(width))

proc `wrapWidth=`*(self: ComboBox; width: int) =
  gtk_combo_box_set_wrap_width(cast[ptr ComboBox00](self.impl), int32(width))

type
  ComboBoxText* = ref object of ComboBox
  ComboBoxText00* = object of ComboBox00

proc gtk_combo_box_text_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ComboBoxText()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_combo_box_text_new(): ptr ComboBoxText00 {.
    importc, libprag.}

proc newComboBoxText*(): ComboBoxText =
  let gobj = gtk_combo_box_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxText*(tdesc: typedesc): tdesc =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxText*[T](result: var T) {.deprecated.} =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_text_new_with_entry(): ptr ComboBoxText00 {.
    importc, libprag.}

proc newComboBoxTextWithEntry*(): ComboBoxText =
  let gobj = gtk_combo_box_text_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxTextWithEntry*(tdesc: typedesc): tdesc =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxTextWithEntry*[T](result: var T) {.deprecated.} =
  assert(result is ComboBoxText)
  let gobj = gtk_combo_box_text_new_with_entry()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_text_append(self: ptr ComboBoxText00; id: cstring; text: cstring) {.
    importc, libprag.}

proc append*(self: ComboBoxText; id: cstring = nil; text: cstring) =
  gtk_combo_box_text_append(cast[ptr ComboBoxText00](self.impl), id, text)

proc gtk_combo_box_text_append_text(self: ptr ComboBoxText00; text: cstring) {.
    importc, libprag.}

proc appendText*(self: ComboBoxText; text: cstring) =
  gtk_combo_box_text_append_text(cast[ptr ComboBoxText00](self.impl), text)

proc gtk_combo_box_text_get_active_text(self: ptr ComboBoxText00): cstring {.
    importc, libprag.}

proc getActiveText*(self: ComboBoxText): string =
  let resul0 = gtk_combo_box_text_get_active_text(cast[ptr ComboBoxText00](self.impl))
  result = $resul0
  cogfree(resul0)

proc activeText*(self: ComboBoxText): string =
  let resul0 = gtk_combo_box_text_get_active_text(cast[ptr ComboBoxText00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_combo_box_text_insert(self: ptr ComboBoxText00; position: int32;
    id: cstring; text: cstring) {.
    importc, libprag.}

proc insert*(self: ComboBoxText; position: int; id: cstring = nil;
    text: cstring) =
  gtk_combo_box_text_insert(cast[ptr ComboBoxText00](self.impl), int32(position), id, text)

proc gtk_combo_box_text_insert_text(self: ptr ComboBoxText00; position: int32;
    text: cstring) {.
    importc, libprag.}

proc insertText*(self: ComboBoxText; position: int; text: cstring) =
  gtk_combo_box_text_insert_text(cast[ptr ComboBoxText00](self.impl), int32(position), text)

proc gtk_combo_box_text_prepend(self: ptr ComboBoxText00; id: cstring; text: cstring) {.
    importc, libprag.}

proc prepend*(self: ComboBoxText; id: cstring = nil; text: cstring) =
  gtk_combo_box_text_prepend(cast[ptr ComboBoxText00](self.impl), id, text)

proc gtk_combo_box_text_prepend_text(self: ptr ComboBoxText00; text: cstring) {.
    importc, libprag.}

proc prependText*(self: ComboBoxText; text: cstring) =
  gtk_combo_box_text_prepend_text(cast[ptr ComboBoxText00](self.impl), text)

proc gtk_combo_box_text_remove(self: ptr ComboBoxText00; position: int32) {.
    importc, libprag.}

proc remove*(self: ComboBoxText; position: int) =
  gtk_combo_box_text_remove(cast[ptr ComboBoxText00](self.impl), int32(position))

proc gtk_combo_box_text_remove_all(self: ptr ComboBoxText00) {.
    importc, libprag.}

proc removeAll*(self: ComboBoxText) =
  gtk_combo_box_text_remove_all(cast[ptr ComboBoxText00](self.impl))

type
  DeleteType* {.size: sizeof(cint), pure.} = enum
    chars = 0
    wordEnds = 1
    words = 2
    displayLines = 3
    displayLineEnds = 4
    paragraphEnds = 5
    paragraphs = 6
    whitespace = 7

type
  EntryIconPosition* {.size: sizeof(cint), pure.} = enum
    primary = 0
    secondary = 1

type
  Entry* = ref object of Widget
  Entry00* = object of Widget00

proc gtk_entry_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Entry()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scBackspace*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "backspace", cast[GCallback](p), xdata, nil, cf)

proc scCopyClipboard*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scCutClipboard*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cut-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scDeleteFromCursor*(self: Entry;  p: proc (self: ptr Entry00; `type`: DeleteType; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-from-cursor", cast[GCallback](p), xdata, nil, cf)

proc scIconPress*(self: Entry;  p: proc (self: ptr Entry00; iconPos: EntryIconPosition; event: ptr gdk.Event00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "icon-press", cast[GCallback](p), xdata, nil, cf)

proc scIconRelease*(self: Entry;  p: proc (self: ptr Entry00; iconPos: EntryIconPosition; event: ptr gdk.Event00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "icon-release", cast[GCallback](p), xdata, nil, cf)

proc scInsertAtCursor*(self: Entry;  p: proc (self: ptr Entry00; string: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-at-cursor", cast[GCallback](p), xdata, nil, cf)

proc scInsertEmoji*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-emoji", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: Entry;  p: proc (self: ptr Entry00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scPasteClipboard*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paste-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scPopulatePopup*(self: Entry;  p: proc (self: ptr Entry00; widget: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cf)

proc scPreeditChanged*(self: Entry;  p: proc (self: ptr Entry00; preedit: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleOverwrite*(self: Entry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-overwrite", cast[GCallback](p), xdata, nil, cf)

proc gtk_entry_new(): ptr Entry00 {.
    importc, libprag.}

proc newEntry*(): Entry =
  let gobj = gtk_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntry*(tdesc: typedesc): tdesc =
  assert(result is Entry)
  let gobj = gtk_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntry*[T](result: var T) {.deprecated.} =
  assert(result is Entry)
  let gobj = gtk_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_activates_default(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getActivatesDefault*(self: Entry): bool =
  toBool(gtk_entry_get_activates_default(cast[ptr Entry00](self.impl)))

proc activatesDefault*(self: Entry): bool =
  toBool(gtk_entry_get_activates_default(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_alignment(self: ptr Entry00): cfloat {.
    importc, libprag.}

proc getAlignment*(self: Entry): cfloat =
  gtk_entry_get_alignment(cast[ptr Entry00](self.impl))

proc alignment*(self: Entry): cfloat =
  gtk_entry_get_alignment(cast[ptr Entry00](self.impl))

proc gtk_entry_get_attributes(self: ptr Entry00): ptr pango.AttrList00 {.
    importc, libprag.}

proc getAttributes*(self: Entry): pango.AttrList =
  let impl0 = gtk_entry_get_attributes(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc attributes*(self: Entry): pango.AttrList =
  let impl0 = gtk_entry_get_attributes(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoAttrList)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_attr_list_get_type(), impl0))

proc gtk_entry_get_current_icon_drag_source(self: ptr Entry00): int32 {.
    importc, libprag.}

proc getCurrentIconDragSource*(self: Entry): int =
  int(gtk_entry_get_current_icon_drag_source(cast[ptr Entry00](self.impl)))

proc currentIconDragSource*(self: Entry): int =
  int(gtk_entry_get_current_icon_drag_source(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_cursor_hadjustment(self: ptr Entry00): ptr Adjustment00 {.
    importc, libprag.}

proc getCursorHadjustment*(self: Entry): Adjustment =
  let gobj = gtk_entry_get_cursor_hadjustment(cast[ptr Entry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc cursorHadjustment*(self: Entry): Adjustment =
  let gobj = gtk_entry_get_cursor_hadjustment(cast[ptr Entry00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_has_frame(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getHasFrame*(self: Entry): bool =
  toBool(gtk_entry_get_has_frame(cast[ptr Entry00](self.impl)))

proc hasFrame*(self: Entry): bool =
  toBool(gtk_entry_get_has_frame(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_icon_activatable(self: ptr Entry00; iconPos: EntryIconPosition): gboolean {.
    importc, libprag.}

proc getIconActivatable*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_activatable(cast[ptr Entry00](self.impl), iconPos))

proc gtk_entry_get_icon_area(self: ptr Entry00; iconPos: EntryIconPosition;
    iconArea: var gdk.Rectangle) {.
    importc, libprag.}

proc getIconArea*(self: Entry; iconPos: EntryIconPosition; iconArea: var gdk.Rectangle) =
  gtk_entry_get_icon_area(cast[ptr Entry00](self.impl), iconPos, iconArea)

proc gtk_entry_get_icon_at_pos(self: ptr Entry00; x: int32; y: int32): int32 {.
    importc, libprag.}

proc getIconAtPos*(self: Entry; x: int; y: int): int =
  int(gtk_entry_get_icon_at_pos(cast[ptr Entry00](self.impl), int32(x), int32(y)))

proc gtk_entry_get_icon_gicon(self: ptr Entry00; iconPos: EntryIconPosition): ptr gio.Icon00 {.
    importc, libprag.}

proc getIconGicon*(self: Entry; iconPos: EntryIconPosition): gio.Icon =
  let gobj = gtk_entry_get_icon_gicon(cast[ptr Entry00](self.impl), iconPos)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_icon_name(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc, libprag.}

proc getIconName*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_name(cast[ptr Entry00](self.impl), iconPos)
  if resul0.isNil:
    return
  result = $resul0

proc gtk_entry_get_icon_pixbuf(self: ptr Entry00; iconPos: EntryIconPosition): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getIconPixbuf*(self: Entry; iconPos: EntryIconPosition): gdkpixbuf.Pixbuf =
  let gobj = gtk_entry_get_icon_pixbuf(cast[ptr Entry00](self.impl), iconPos)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_icon_sensitive(self: ptr Entry00; iconPos: EntryIconPosition): gboolean {.
    importc, libprag.}

proc getIconSensitive*(self: Entry; iconPos: EntryIconPosition): bool =
  toBool(gtk_entry_get_icon_sensitive(cast[ptr Entry00](self.impl), iconPos))

proc gtk_entry_get_icon_stock(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc, libprag.}

proc getIconStock*(self: Entry; iconPos: EntryIconPosition): string =
  result = $gtk_entry_get_icon_stock(cast[ptr Entry00](self.impl), iconPos)

proc gtk_entry_get_icon_tooltip_markup(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc, libprag.}

proc getIconTooltipMarkup*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_markup(cast[ptr Entry00](self.impl), iconPos)
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_entry_get_icon_tooltip_text(self: ptr Entry00; iconPos: EntryIconPosition): cstring {.
    importc, libprag.}

proc getIconTooltipText*(self: Entry; iconPos: EntryIconPosition): string =
  let resul0 = gtk_entry_get_icon_tooltip_text(cast[ptr Entry00](self.impl), iconPos)
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_entry_get_inner_border(self: ptr Entry00): ptr Border {.
    importc, libprag.}

proc getInnerBorder*(self: Entry): ptr Border =
  gtk_entry_get_inner_border(cast[ptr Entry00](self.impl))

proc innerBorder*(self: Entry): ptr Border =
  gtk_entry_get_inner_border(cast[ptr Entry00](self.impl))

proc gtk_entry_get_invisible_char(self: ptr Entry00): gunichar {.
    importc, libprag.}

proc getInvisibleChar*(self: Entry): gunichar =
  gtk_entry_get_invisible_char(cast[ptr Entry00](self.impl))

proc invisibleChar*(self: Entry): gunichar =
  gtk_entry_get_invisible_char(cast[ptr Entry00](self.impl))

proc gtk_entry_get_layout(self: ptr Entry00): ptr pango.Layout00 {.
    importc, libprag.}

proc getLayout*(self: Entry): pango.Layout =
  let gobj = gtk_entry_get_layout(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Entry): pango.Layout =
  let gobj = gtk_entry_get_layout(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_layout_offsets(self: ptr Entry00; x: var int32; y: var int32) {.
    importc, libprag.}

proc getLayoutOffsets*(self: Entry; x: var int = cast[var int](nil);
    y: var int = cast[var int](nil)) =
  var y_00: int32
  var x_00: int32
  gtk_entry_get_layout_offsets(cast[ptr Entry00](self.impl), x_00, y_00)
  if y.addr != nil:
    y = int(y_00)
  if x.addr != nil:
    x = int(x_00)

proc gtk_entry_get_max_length(self: ptr Entry00): int32 {.
    importc, libprag.}

proc getMaxLength*(self: Entry): int =
  int(gtk_entry_get_max_length(cast[ptr Entry00](self.impl)))

proc maxLength*(self: Entry): int =
  int(gtk_entry_get_max_length(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_max_width_chars(self: ptr Entry00): int32 {.
    importc, libprag.}

proc getMaxWidthChars*(self: Entry): int =
  int(gtk_entry_get_max_width_chars(cast[ptr Entry00](self.impl)))

proc maxWidthChars*(self: Entry): int =
  int(gtk_entry_get_max_width_chars(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_overwrite_mode(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getOverwriteMode*(self: Entry): bool =
  toBool(gtk_entry_get_overwrite_mode(cast[ptr Entry00](self.impl)))

proc overwriteMode*(self: Entry): bool =
  toBool(gtk_entry_get_overwrite_mode(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_placeholder_text(self: ptr Entry00): cstring {.
    importc, libprag.}

proc getPlaceholderText*(self: Entry): string =
  result = $gtk_entry_get_placeholder_text(cast[ptr Entry00](self.impl))

proc placeholderText*(self: Entry): string =
  result = $gtk_entry_get_placeholder_text(cast[ptr Entry00](self.impl))

proc gtk_entry_get_progress_fraction(self: ptr Entry00): cdouble {.
    importc, libprag.}

proc getProgressFraction*(self: Entry): cdouble =
  gtk_entry_get_progress_fraction(cast[ptr Entry00](self.impl))

proc progressFraction*(self: Entry): cdouble =
  gtk_entry_get_progress_fraction(cast[ptr Entry00](self.impl))

proc gtk_entry_get_progress_pulse_step(self: ptr Entry00): cdouble {.
    importc, libprag.}

proc getProgressPulseStep*(self: Entry): cdouble =
  gtk_entry_get_progress_pulse_step(cast[ptr Entry00](self.impl))

proc progressPulseStep*(self: Entry): cdouble =
  gtk_entry_get_progress_pulse_step(cast[ptr Entry00](self.impl))

proc gtk_entry_get_tabs(self: ptr Entry00): ptr pango.TabArray00 {.
    importc, libprag.}

proc getTabs*(self: Entry): pango.TabArray =
  let impl0 = gtk_entry_get_tabs(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_tab_array_get_type(), impl0))

proc tabs*(self: Entry): pango.TabArray =
  let impl0 = gtk_entry_get_tabs(cast[ptr Entry00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_tab_array_get_type(), impl0))

proc gtk_entry_get_text(self: ptr Entry00): cstring {.
    importc, libprag.}

proc getText*(self: Entry): string =
  result = $gtk_entry_get_text(cast[ptr Entry00](self.impl))

proc text*(self: Entry): string =
  result = $gtk_entry_get_text(cast[ptr Entry00](self.impl))

proc gtk_entry_get_text_area(self: ptr Entry00; textArea: var gdk.Rectangle) {.
    importc, libprag.}

proc getTextArea*(self: Entry; textArea: var gdk.Rectangle) =
  gtk_entry_get_text_area(cast[ptr Entry00](self.impl), textArea)

proc getTextArea*(self: Entry): gdk.Rectangle =
  gtk_entry_get_text_area(cast[ptr Entry00](self.impl), result)

proc gtk_entry_get_text_length(self: ptr Entry00): uint16 {.
    importc, libprag.}

proc getTextLength*(self: Entry): uint16 =
  gtk_entry_get_text_length(cast[ptr Entry00](self.impl))

proc textLength*(self: Entry): uint16 =
  gtk_entry_get_text_length(cast[ptr Entry00](self.impl))

proc gtk_entry_get_visibility(self: ptr Entry00): gboolean {.
    importc, libprag.}

proc getVisibility*(self: Entry): bool =
  toBool(gtk_entry_get_visibility(cast[ptr Entry00](self.impl)))

proc visibility*(self: Entry): bool =
  toBool(gtk_entry_get_visibility(cast[ptr Entry00](self.impl)))

proc gtk_entry_get_width_chars(self: ptr Entry00): int32 {.
    importc, libprag.}

proc getWidthChars*(self: Entry): int =
  int(gtk_entry_get_width_chars(cast[ptr Entry00](self.impl)))

proc widthChars*(self: Entry): int =
  int(gtk_entry_get_width_chars(cast[ptr Entry00](self.impl)))

proc gtk_entry_grab_focus_without_selecting(self: ptr Entry00) {.
    importc, libprag.}

proc grabFocusWithoutSelecting*(self: Entry) =
  gtk_entry_grab_focus_without_selecting(cast[ptr Entry00](self.impl))

proc gtk_entry_im_context_filter_keypress(self: ptr Entry00; event: ptr gdk.EventKey00): gboolean {.
    importc, libprag.}

proc imContextFilterKeypress*(self: Entry; event: gdk.EventKey): bool =
  toBool(gtk_entry_im_context_filter_keypress(cast[ptr Entry00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_entry_layout_index_to_text_index(self: ptr Entry00; layoutIndex: int32): int32 {.
    importc, libprag.}

proc layoutIndexToTextIndex*(self: Entry; layoutIndex: int): int =
  int(gtk_entry_layout_index_to_text_index(cast[ptr Entry00](self.impl), int32(layoutIndex)))

proc gtk_entry_progress_pulse(self: ptr Entry00) {.
    importc, libprag.}

proc progressPulse*(self: Entry) =
  gtk_entry_progress_pulse(cast[ptr Entry00](self.impl))

proc gtk_entry_reset_im_context(self: ptr Entry00) {.
    importc, libprag.}

proc resetImContext*(self: Entry) =
  gtk_entry_reset_im_context(cast[ptr Entry00](self.impl))

proc gtk_entry_set_activates_default(self: ptr Entry00; setting: gboolean) {.
    importc, libprag.}

proc setActivatesDefault*(self: Entry; setting: bool = true) =
  gtk_entry_set_activates_default(cast[ptr Entry00](self.impl), gboolean(setting))

proc `activatesDefault=`*(self: Entry; setting: bool) =
  gtk_entry_set_activates_default(cast[ptr Entry00](self.impl), gboolean(setting))

proc gtk_entry_set_alignment(self: ptr Entry00; xalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: Entry; xalign: cfloat) =
  gtk_entry_set_alignment(cast[ptr Entry00](self.impl), xalign)

proc `alignment=`*(self: Entry; xalign: cfloat) =
  gtk_entry_set_alignment(cast[ptr Entry00](self.impl), xalign)

proc gtk_entry_set_attributes(self: ptr Entry00; attrs: ptr pango.AttrList00) {.
    importc, libprag.}

proc setAttributes*(self: Entry; attrs: pango.AttrList) =
  gtk_entry_set_attributes(cast[ptr Entry00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc `attributes=`*(self: Entry; attrs: pango.AttrList) =
  gtk_entry_set_attributes(cast[ptr Entry00](self.impl), cast[ptr pango.AttrList00](attrs.impl))

proc gtk_entry_set_cursor_hadjustment(self: ptr Entry00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setCursorHadjustment*(self: Entry; adjustment: Adjustment = nil) =
  gtk_entry_set_cursor_hadjustment(cast[ptr Entry00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `cursorHadjustment=`*(self: Entry; adjustment: Adjustment = nil) =
  gtk_entry_set_cursor_hadjustment(cast[ptr Entry00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_entry_set_has_frame(self: ptr Entry00; setting: gboolean) {.
    importc, libprag.}

proc setHasFrame*(self: Entry; setting: bool = true) =
  gtk_entry_set_has_frame(cast[ptr Entry00](self.impl), gboolean(setting))

proc `hasFrame=`*(self: Entry; setting: bool) =
  gtk_entry_set_has_frame(cast[ptr Entry00](self.impl), gboolean(setting))

proc gtk_entry_set_icon_activatable(self: ptr Entry00; iconPos: EntryIconPosition;
    activatable: gboolean) {.
    importc, libprag.}

proc setIconActivatable*(self: Entry; iconPos: EntryIconPosition;
    activatable: bool) =
  gtk_entry_set_icon_activatable(cast[ptr Entry00](self.impl), iconPos, gboolean(activatable))

proc gtk_entry_set_icon_drag_source(self: ptr Entry00; iconPos: EntryIconPosition;
    targetList: ptr TargetList00; actions: gdk.DragAction) {.
    importc, libprag.}

proc setIconDragSource*(self: Entry; iconPos: EntryIconPosition;
    targetList: TargetList; actions: gdk.DragAction) =
  gtk_entry_set_icon_drag_source(cast[ptr Entry00](self.impl), iconPos, cast[ptr TargetList00](targetList.impl), actions)

proc gtk_entry_set_icon_from_gicon(self: ptr Entry00; iconPos: EntryIconPosition;
    icon: ptr gio.Icon00) {.
    importc, libprag.}

proc setIconFromGicon*(self: Entry; iconPos: EntryIconPosition;
    icon: gio.Icon = nil) =
  gtk_entry_set_icon_from_gicon(cast[ptr Entry00](self.impl), iconPos, if icon.isNil: nil else: cast[ptr gio.Icon00](icon.impl))

proc gtk_entry_set_icon_from_icon_name(self: ptr Entry00; iconPos: EntryIconPosition;
    iconName: cstring) {.
    importc, libprag.}

proc setIconFromIconName*(self: Entry; iconPos: EntryIconPosition;
    iconName: cstring = nil) =
  gtk_entry_set_icon_from_icon_name(cast[ptr Entry00](self.impl), iconPos, iconName)

proc gtk_entry_set_icon_from_pixbuf(self: ptr Entry00; iconPos: EntryIconPosition;
    pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setIconFromPixbuf*(self: Entry; iconPos: EntryIconPosition;
    pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_entry_set_icon_from_pixbuf(cast[ptr Entry00](self.impl), iconPos, if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_entry_set_icon_from_stock(self: ptr Entry00; iconPos: EntryIconPosition;
    stockId: cstring) {.
    importc, libprag.}

proc setIconFromStock*(self: Entry; iconPos: EntryIconPosition;
    stockId: cstring = nil) =
  gtk_entry_set_icon_from_stock(cast[ptr Entry00](self.impl), iconPos, stockId)

proc gtk_entry_set_icon_sensitive(self: ptr Entry00; iconPos: EntryIconPosition;
    sensitive: gboolean) {.
    importc, libprag.}

proc setIconSensitive*(self: Entry; iconPos: EntryIconPosition;
    sensitive: bool) =
  gtk_entry_set_icon_sensitive(cast[ptr Entry00](self.impl), iconPos, gboolean(sensitive))

proc gtk_entry_set_icon_tooltip_markup(self: ptr Entry00; iconPos: EntryIconPosition;
    tooltip: cstring) {.
    importc, libprag.}

proc setIconTooltipMarkup*(self: Entry; iconPos: EntryIconPosition;
    tooltip: cstring = nil) =
  gtk_entry_set_icon_tooltip_markup(cast[ptr Entry00](self.impl), iconPos, tooltip)

proc gtk_entry_set_icon_tooltip_text(self: ptr Entry00; iconPos: EntryIconPosition;
    tooltip: cstring) {.
    importc, libprag.}

proc setIconTooltipText*(self: Entry; iconPos: EntryIconPosition;
    tooltip: cstring = nil) =
  gtk_entry_set_icon_tooltip_text(cast[ptr Entry00](self.impl), iconPos, tooltip)

proc gtk_entry_set_inner_border(self: ptr Entry00; border: Border) {.
    importc, libprag.}

proc setInnerBorder*(self: Entry; border: Border = cast[var Border](nil)) =
  gtk_entry_set_inner_border(cast[ptr Entry00](self.impl), border)

proc `innerBorder=`*(self: Entry; border: Border = cast[var Border](nil)) =
  gtk_entry_set_inner_border(cast[ptr Entry00](self.impl), border)

proc gtk_entry_set_invisible_char(self: ptr Entry00; ch: gunichar) {.
    importc, libprag.}

proc setInvisibleChar*(self: Entry; ch: gunichar) =
  gtk_entry_set_invisible_char(cast[ptr Entry00](self.impl), ch)

proc `invisibleChar=`*(self: Entry; ch: gunichar) =
  gtk_entry_set_invisible_char(cast[ptr Entry00](self.impl), ch)

proc gtk_entry_set_max_length(self: ptr Entry00; max: int32) {.
    importc, libprag.}

proc setMaxLength*(self: Entry; max: int) =
  gtk_entry_set_max_length(cast[ptr Entry00](self.impl), int32(max))

proc `maxLength=`*(self: Entry; max: int) =
  gtk_entry_set_max_length(cast[ptr Entry00](self.impl), int32(max))

proc gtk_entry_set_max_width_chars(self: ptr Entry00; nChars: int32) {.
    importc, libprag.}

proc setMaxWidthChars*(self: Entry; nChars: int) =
  gtk_entry_set_max_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc `maxWidthChars=`*(self: Entry; nChars: int) =
  gtk_entry_set_max_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc gtk_entry_set_overwrite_mode(self: ptr Entry00; overwrite: gboolean) {.
    importc, libprag.}

proc setOverwriteMode*(self: Entry; overwrite: bool = true) =
  gtk_entry_set_overwrite_mode(cast[ptr Entry00](self.impl), gboolean(overwrite))

proc `overwriteMode=`*(self: Entry; overwrite: bool) =
  gtk_entry_set_overwrite_mode(cast[ptr Entry00](self.impl), gboolean(overwrite))

proc gtk_entry_set_placeholder_text(self: ptr Entry00; text: cstring) {.
    importc, libprag.}

proc setPlaceholderText*(self: Entry; text: cstring = nil) =
  gtk_entry_set_placeholder_text(cast[ptr Entry00](self.impl), text)

proc `placeholderText=`*(self: Entry; text: cstring = nil) =
  gtk_entry_set_placeholder_text(cast[ptr Entry00](self.impl), text)

proc gtk_entry_set_progress_fraction(self: ptr Entry00; fraction: cdouble) {.
    importc, libprag.}

proc setProgressFraction*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_fraction(cast[ptr Entry00](self.impl), fraction)

proc `progressFraction=`*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_fraction(cast[ptr Entry00](self.impl), fraction)

proc gtk_entry_set_progress_pulse_step(self: ptr Entry00; fraction: cdouble) {.
    importc, libprag.}

proc setProgressPulseStep*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_pulse_step(cast[ptr Entry00](self.impl), fraction)

proc `progressPulseStep=`*(self: Entry; fraction: cdouble) =
  gtk_entry_set_progress_pulse_step(cast[ptr Entry00](self.impl), fraction)

proc gtk_entry_set_tabs(self: ptr Entry00; tabs: ptr pango.TabArray00) {.
    importc, libprag.}

proc setTabs*(self: Entry; tabs: pango.TabArray) =
  gtk_entry_set_tabs(cast[ptr Entry00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: Entry; tabs: pango.TabArray) =
  gtk_entry_set_tabs(cast[ptr Entry00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc gtk_entry_set_text(self: ptr Entry00; text: cstring) {.
    importc, libprag.}

proc setText*(self: Entry; text: cstring) =
  gtk_entry_set_text(cast[ptr Entry00](self.impl), text)

proc `text=`*(self: Entry; text: cstring) =
  gtk_entry_set_text(cast[ptr Entry00](self.impl), text)

proc gtk_entry_set_visibility(self: ptr Entry00; visible: gboolean) {.
    importc, libprag.}

proc setVisibility*(self: Entry; visible: bool = true) =
  gtk_entry_set_visibility(cast[ptr Entry00](self.impl), gboolean(visible))

proc `visibility=`*(self: Entry; visible: bool) =
  gtk_entry_set_visibility(cast[ptr Entry00](self.impl), gboolean(visible))

proc gtk_entry_set_width_chars(self: ptr Entry00; nChars: int32) {.
    importc, libprag.}

proc setWidthChars*(self: Entry; nChars: int) =
  gtk_entry_set_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc `widthChars=`*(self: Entry; nChars: int) =
  gtk_entry_set_width_chars(cast[ptr Entry00](self.impl), int32(nChars))

proc gtk_entry_text_index_to_layout_index(self: ptr Entry00; textIndex: int32): int32 {.
    importc, libprag.}

proc textIndexToLayoutIndex*(self: Entry; textIndex: int): int =
  int(gtk_entry_text_index_to_layout_index(cast[ptr Entry00](self.impl), int32(textIndex)))

proc gtk_entry_unset_invisible_char(self: ptr Entry00) {.
    importc, libprag.}

proc unsetInvisibleChar*(self: Entry) =
  gtk_entry_unset_invisible_char(cast[ptr Entry00](self.impl))

type
  SpinButton* = ref object of Entry
  SpinButton00* = object of Entry00

proc gtk_spin_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SpinButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChangeValue*(self: SpinButton;  p: proc (self: ptr SpinButton00; scroll: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-value", cast[GCallback](p), xdata, nil, cf)

proc scInput*(self: SpinButton;  p: proc (self: ptr SpinButton00; newValue: var cdouble; xdata: pointer): int32 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "input", cast[GCallback](p), xdata, nil, cf)

proc scOutput*(self: SpinButton;  p: proc (self: ptr SpinButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "output", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc scWrapped*(self: SpinButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "wrapped", cast[GCallback](p), xdata, nil, cf)

proc gtk_spin_button_new(adjustment: ptr Adjustment00; climbRate: cdouble;
    digits: uint32): ptr SpinButton00 {.
    importc, libprag.}

proc newSpinButton*(adjustment: Adjustment = nil; climbRate: cdouble;
    digits: int): SpinButton =
  let gobj = gtk_spin_button_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSpinButton*(tdesc: typedesc; adjustment: Adjustment = nil; climbRate: cdouble;
    digits: int): tdesc =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinButton*[T](result: var T; adjustment: Adjustment = nil; climbRate: cdouble;
    digits: int) {.deprecated.} =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_new_with_range(min: cdouble; max: cdouble; step: cdouble): ptr SpinButton00 {.
    importc, libprag.}

proc newSpinButtonWithRange*(min: cdouble; max: cdouble; step: cdouble): SpinButton =
  let gobj = gtk_spin_button_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSpinButtonWithRange*(tdesc: typedesc; min: cdouble; max: cdouble; step: cdouble): tdesc =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinButtonWithRange*[T](result: var T; min: cdouble; max: cdouble; step: cdouble) {.deprecated.} =
  assert(result is SpinButton)
  let gobj = gtk_spin_button_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_configure(self: ptr SpinButton00; adjustment: ptr Adjustment00;
    climbRate: cdouble; digits: uint32) {.
    importc, libprag.}

proc configure*(self: SpinButton; adjustment: Adjustment = nil;
    climbRate: cdouble; digits: int) =
  gtk_spin_button_configure(cast[ptr SpinButton00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl), climbRate, uint32(digits))

proc gtk_spin_button_get_adjustment(self: ptr SpinButton00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: SpinButton): Adjustment =
  let gobj = gtk_spin_button_get_adjustment(cast[ptr SpinButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: SpinButton): Adjustment =
  let gobj = gtk_spin_button_get_adjustment(cast[ptr SpinButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spin_button_get_digits(self: ptr SpinButton00): uint32 {.
    importc, libprag.}

proc getDigits*(self: SpinButton): int =
  int(gtk_spin_button_get_digits(cast[ptr SpinButton00](self.impl)))

proc digits*(self: SpinButton): int =
  int(gtk_spin_button_get_digits(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_increments(self: ptr SpinButton00; step: var cdouble;
    page: var cdouble) {.
    importc, libprag.}

proc getIncrements*(self: SpinButton; step: var cdouble = cast[var cdouble](nil);
    page: var cdouble = cast[var cdouble](nil)) =
  gtk_spin_button_get_increments(cast[ptr SpinButton00](self.impl), step, page)

proc gtk_spin_button_get_numeric(self: ptr SpinButton00): gboolean {.
    importc, libprag.}

proc getNumeric*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_numeric(cast[ptr SpinButton00](self.impl)))

proc numeric*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_numeric(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_range(self: ptr SpinButton00; min: var cdouble;
    max: var cdouble) {.
    importc, libprag.}

proc getRange*(self: SpinButton; min: var cdouble = cast[var cdouble](nil);
    max: var cdouble = cast[var cdouble](nil)) =
  gtk_spin_button_get_range(cast[ptr SpinButton00](self.impl), min, max)

proc gtk_spin_button_get_snap_to_ticks(self: ptr SpinButton00): gboolean {.
    importc, libprag.}

proc getSnapToTicks*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_snap_to_ticks(cast[ptr SpinButton00](self.impl)))

proc snapToTicks*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_snap_to_ticks(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_value(self: ptr SpinButton00): cdouble {.
    importc, libprag.}

proc getValue*(self: SpinButton): cdouble =
  gtk_spin_button_get_value(cast[ptr SpinButton00](self.impl))

proc value*(self: SpinButton): cdouble =
  gtk_spin_button_get_value(cast[ptr SpinButton00](self.impl))

proc gtk_spin_button_get_value_as_int(self: ptr SpinButton00): int32 {.
    importc, libprag.}

proc getValueAsInt*(self: SpinButton): int =
  int(gtk_spin_button_get_value_as_int(cast[ptr SpinButton00](self.impl)))

proc valueAsInt*(self: SpinButton): int =
  int(gtk_spin_button_get_value_as_int(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_get_wrap(self: ptr SpinButton00): gboolean {.
    importc, libprag.}

proc getWrap*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_wrap(cast[ptr SpinButton00](self.impl)))

proc wrap*(self: SpinButton): bool =
  toBool(gtk_spin_button_get_wrap(cast[ptr SpinButton00](self.impl)))

proc gtk_spin_button_set_adjustment(self: ptr SpinButton00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: SpinButton; adjustment: Adjustment) =
  gtk_spin_button_set_adjustment(cast[ptr SpinButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: SpinButton; adjustment: Adjustment) =
  gtk_spin_button_set_adjustment(cast[ptr SpinButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_spin_button_set_digits(self: ptr SpinButton00; digits: uint32) {.
    importc, libprag.}

proc setDigits*(self: SpinButton; digits: int) =
  gtk_spin_button_set_digits(cast[ptr SpinButton00](self.impl), uint32(digits))

proc `digits=`*(self: SpinButton; digits: int) =
  gtk_spin_button_set_digits(cast[ptr SpinButton00](self.impl), uint32(digits))

proc gtk_spin_button_set_increments(self: ptr SpinButton00; step: cdouble;
    page: cdouble) {.
    importc, libprag.}

proc setIncrements*(self: SpinButton; step: cdouble; page: cdouble) =
  gtk_spin_button_set_increments(cast[ptr SpinButton00](self.impl), step, page)

proc gtk_spin_button_set_numeric(self: ptr SpinButton00; numeric: gboolean) {.
    importc, libprag.}

proc setNumeric*(self: SpinButton; numeric: bool = true) =
  gtk_spin_button_set_numeric(cast[ptr SpinButton00](self.impl), gboolean(numeric))

proc `numeric=`*(self: SpinButton; numeric: bool) =
  gtk_spin_button_set_numeric(cast[ptr SpinButton00](self.impl), gboolean(numeric))

proc gtk_spin_button_set_range(self: ptr SpinButton00; min: cdouble; max: cdouble) {.
    importc, libprag.}

proc setRange*(self: SpinButton; min: cdouble; max: cdouble) =
  gtk_spin_button_set_range(cast[ptr SpinButton00](self.impl), min, max)

proc gtk_spin_button_set_snap_to_ticks(self: ptr SpinButton00; snapToTicks: gboolean) {.
    importc, libprag.}

proc setSnapToTicks*(self: SpinButton; snapToTicks: bool = true) =
  gtk_spin_button_set_snap_to_ticks(cast[ptr SpinButton00](self.impl), gboolean(snapToTicks))

proc `snapToTicks=`*(self: SpinButton; snapToTicks: bool) =
  gtk_spin_button_set_snap_to_ticks(cast[ptr SpinButton00](self.impl), gboolean(snapToTicks))

proc gtk_spin_button_set_value(self: ptr SpinButton00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: SpinButton; value: cdouble) =
  gtk_spin_button_set_value(cast[ptr SpinButton00](self.impl), value)

proc `value=`*(self: SpinButton; value: cdouble) =
  gtk_spin_button_set_value(cast[ptr SpinButton00](self.impl), value)

proc gtk_spin_button_set_wrap(self: ptr SpinButton00; wrap: gboolean) {.
    importc, libprag.}

proc setWrap*(self: SpinButton; wrap: bool = true) =
  gtk_spin_button_set_wrap(cast[ptr SpinButton00](self.impl), gboolean(wrap))

proc `wrap=`*(self: SpinButton; wrap: bool) =
  gtk_spin_button_set_wrap(cast[ptr SpinButton00](self.impl), gboolean(wrap))

proc gtk_spin_button_update(self: ptr SpinButton00) {.
    importc, libprag.}

proc update*(self: SpinButton) =
  gtk_spin_button_update(cast[ptr SpinButton00](self.impl))

type
  AppChooserButton* = ref object of ComboBox
  AppChooserButton00* = object of ComboBox00

proc gtk_app_chooser_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AppChooserButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCustomItemActivated*(self: AppChooserButton;  p: proc (self: ptr AppChooserButton00; itemName: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "custom-item-activated", cast[GCallback](p), xdata, nil, cf)

proc gtk_app_chooser_button_new(contentType: cstring): ptr AppChooserButton00 {.
    importc, libprag.}

proc newAppChooserButton*(contentType: cstring): AppChooserButton =
  let gobj = gtk_app_chooser_button_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserButton*(tdesc: typedesc; contentType: cstring): tdesc =
  assert(result is AppChooserButton)
  let gobj = gtk_app_chooser_button_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserButton*[T](result: var T; contentType: cstring) {.deprecated.} =
  assert(result is AppChooserButton)
  let gobj = gtk_app_chooser_button_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_button_append_custom_item(self: ptr AppChooserButton00;
    name: cstring; label: cstring; icon: ptr gio.Icon00) {.
    importc, libprag.}

proc appendCustomItem*(self: AppChooserButton; name: cstring;
    label: cstring; icon: gio.Icon) =
  gtk_app_chooser_button_append_custom_item(cast[ptr AppChooserButton00](self.impl), name, label, cast[ptr gio.Icon00](icon.impl))

proc gtk_app_chooser_button_append_separator(self: ptr AppChooserButton00) {.
    importc, libprag.}

proc appendSeparator*(self: AppChooserButton) =
  gtk_app_chooser_button_append_separator(cast[ptr AppChooserButton00](self.impl))

proc gtk_app_chooser_button_get_heading(self: ptr AppChooserButton00): cstring {.
    importc, libprag.}

proc getHeading*(self: AppChooserButton): string =
  let resul0 = gtk_app_chooser_button_get_heading(cast[ptr AppChooserButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc heading*(self: AppChooserButton): string =
  let resul0 = gtk_app_chooser_button_get_heading(cast[ptr AppChooserButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_app_chooser_button_get_show_default_item(self: ptr AppChooserButton00): gboolean {.
    importc, libprag.}

proc getShowDefaultItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_default_item(cast[ptr AppChooserButton00](self.impl)))

proc showDefaultItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_default_item(cast[ptr AppChooserButton00](self.impl)))

proc gtk_app_chooser_button_get_show_dialog_item(self: ptr AppChooserButton00): gboolean {.
    importc, libprag.}

proc getShowDialogItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_dialog_item(cast[ptr AppChooserButton00](self.impl)))

proc showDialogItem*(self: AppChooserButton): bool =
  toBool(gtk_app_chooser_button_get_show_dialog_item(cast[ptr AppChooserButton00](self.impl)))

proc gtk_app_chooser_button_set_active_custom_item(self: ptr AppChooserButton00;
    name: cstring) {.
    importc, libprag.}

proc setActiveCustomItem*(self: AppChooserButton;
    name: cstring) =
  gtk_app_chooser_button_set_active_custom_item(cast[ptr AppChooserButton00](self.impl), name)

proc `activeCustomItem=`*(self: AppChooserButton;
    name: cstring) =
  gtk_app_chooser_button_set_active_custom_item(cast[ptr AppChooserButton00](self.impl), name)

proc gtk_app_chooser_button_set_heading(self: ptr AppChooserButton00; heading: cstring) {.
    importc, libprag.}

proc setHeading*(self: AppChooserButton; heading: cstring) =
  gtk_app_chooser_button_set_heading(cast[ptr AppChooserButton00](self.impl), heading)

proc `heading=`*(self: AppChooserButton; heading: cstring) =
  gtk_app_chooser_button_set_heading(cast[ptr AppChooserButton00](self.impl), heading)

proc gtk_app_chooser_button_set_show_default_item(self: ptr AppChooserButton00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowDefaultItem*(self: AppChooserButton;
    setting: bool = true) =
  gtk_app_chooser_button_set_show_default_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc `showDefaultItem=`*(self: AppChooserButton;
    setting: bool) =
  gtk_app_chooser_button_set_show_default_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc gtk_app_chooser_button_set_show_dialog_item(self: ptr AppChooserButton00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowDialogItem*(self: AppChooserButton;
    setting: bool = true) =
  gtk_app_chooser_button_set_show_dialog_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

proc `showDialogItem=`*(self: AppChooserButton;
    setting: bool) =
  gtk_app_chooser_button_set_show_dialog_item(cast[ptr AppChooserButton00](self.impl), gboolean(setting))

type
  SearchEntry* = ref object of Entry
  SearchEntry00* = object of Entry00

proc gtk_search_entry_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SearchEntry()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scNextMatch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "next-match", cast[GCallback](p), xdata, nil, cf)

proc scPreviousMatch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "previous-match", cast[GCallback](p), xdata, nil, cf)

proc scSearchChanged*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "search-changed", cast[GCallback](p), xdata, nil, cf)

proc scStopSearch*(self: SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "stop-search", cast[GCallback](p), xdata, nil, cf)

proc gtk_search_entry_new(): ptr SearchEntry00 {.
    importc, libprag.}

proc newSearchEntry*(): SearchEntry =
  let gobj = gtk_search_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSearchEntry*(tdesc: typedesc): tdesc =
  assert(result is SearchEntry)
  let gobj = gtk_search_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSearchEntry*[T](result: var T) {.deprecated.} =
  assert(result is SearchEntry)
  let gobj = gtk_search_entry_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_entry_handle_event(self: ptr SearchEntry00; event: ptr gdk.Event00): gboolean {.
    importc, libprag.}

proc handleEvent*(self: SearchEntry; event: gdk.Event): bool =
  toBool(gtk_search_entry_handle_event(cast[ptr SearchEntry00](self.impl), cast[ptr gdk.Event00](event.impl)))

type
  CellEditable00* = object of gobject.Object00
  CellEditable* = ref object of gobject.Object

proc scEditingDone*(self: CellEditable | ComboBoxText | SpinButton | AppChooserButton | Entry | SearchEntry | ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "editing-done", cast[GCallback](p), xdata, nil, cf)

proc scRemoveWidget*(self: CellEditable | ComboBoxText | SpinButton | AppChooserButton | Entry | SearchEntry | ComboBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "remove-widget", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_editable_editing_done(self: ptr CellEditable00) {.
    importc, libprag.}

proc editingDone*(self: CellEditable | ComboBoxText | SpinButton | AppChooserButton | Entry | SearchEntry | ComboBox) =
  gtk_cell_editable_editing_done(cast[ptr CellEditable00](self.impl))

proc gtk_cell_editable_remove_widget(self: ptr CellEditable00) {.
    importc, libprag.}

proc removeWidget*(self: CellEditable | ComboBoxText | SpinButton | AppChooserButton | Entry | SearchEntry | ComboBox) =
  gtk_cell_editable_remove_widget(cast[ptr CellEditable00](self.impl))

proc gtk_cell_editable_start_editing(self: ptr CellEditable00; event: ptr gdk.Event00) {.
    importc, libprag.}

proc startEditing*(self: CellEditable | ComboBoxText | SpinButton | AppChooserButton | Entry | SearchEntry | ComboBox;
    event: gdk.Event = nil) =
  gtk_cell_editable_start_editing(cast[ptr CellEditable00](self.impl), if event.isNil: nil else: cast[ptr gdk.Event00](event.impl))

type
  CellRenderer* = ref object of gobject.InitiallyUnowned
  CellRenderer00* = object of gobject.InitiallyUnowned00

proc gtk_cell_renderer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRenderer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEditingCanceled*(self: CellRenderer;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "editing-canceled", cast[GCallback](p), xdata, nil, cf)

proc scEditingStarted*(self: CellRenderer;  p: proc (self: ptr CellRenderer00; editable: ptr CellEditable00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "editing-started", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_get_alignment(self: ptr CellRenderer00; xalign: var cfloat;
    yalign: var cfloat) {.
    importc, libprag.}

proc getAlignment*(self: CellRenderer; xalign: var cfloat = cast[var cfloat](nil);
    yalign: var cfloat = cast[var cfloat](nil)) =
  gtk_cell_renderer_get_alignment(cast[ptr CellRenderer00](self.impl), xalign, yalign)

proc gtk_cell_renderer_get_fixed_size(self: ptr CellRenderer00; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getFixedSize*(self: CellRenderer; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var width_00: int32
  var height_00: int32
  gtk_cell_renderer_get_fixed_size(cast[ptr CellRenderer00](self.impl), width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_cell_renderer_get_padding(self: ptr CellRenderer00; xpad: var int32;
    ypad: var int32) {.
    importc, libprag.}

proc getPadding*(self: CellRenderer; xpad: var int = cast[var int](nil);
    ypad: var int = cast[var int](nil)) =
  var ypad_00: int32
  var xpad_00: int32
  gtk_cell_renderer_get_padding(cast[ptr CellRenderer00](self.impl), xpad_00, ypad_00)
  if ypad.addr != nil:
    ypad = int(ypad_00)
  if xpad.addr != nil:
    xpad = int(xpad_00)

proc gtk_cell_renderer_get_preferred_height(self: ptr CellRenderer00; widget: ptr Widget00;
    minimumSize: var int32; naturalSize: var int32) {.
    importc, libprag.}

proc getPreferredHeight*(self: CellRenderer; widget: Widget;
    minimumSize: var int = cast[var int](nil); naturalSize: var int = cast[var int](nil)) =
  var minimumSize_00: int32
  var naturalSize_00: int32
  gtk_cell_renderer_get_preferred_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  if minimumSize.addr != nil:
    minimumSize = int(minimumSize_00)
  if naturalSize.addr != nil:
    naturalSize = int(naturalSize_00)

proc gtk_cell_renderer_get_preferred_height_for_width(self: ptr CellRenderer00;
    widget: ptr Widget00; width: int32; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeightForWidth*(self: CellRenderer;
    widget: Widget; width: int; minimumHeight: var int = cast[var int](nil);
    naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_renderer_get_preferred_height_for_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_renderer_get_preferred_size(self: ptr CellRenderer00; widget: ptr Widget00;
    minimumSize: var Requisition; naturalSize: var Requisition) {.
    importc, libprag.}

proc getPreferredSize*(self: CellRenderer; widget: Widget;
    minimumSize: var Requisition = cast[var Requisition](nil); naturalSize: var Requisition = cast[var Requisition](nil)) =
  gtk_cell_renderer_get_preferred_size(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize, naturalSize)

proc gtk_cell_renderer_get_preferred_width(self: ptr CellRenderer00; widget: ptr Widget00;
    minimumSize: var int32; naturalSize: var int32) {.
    importc, libprag.}

proc getPreferredWidth*(self: CellRenderer; widget: Widget;
    minimumSize: var int = cast[var int](nil); naturalSize: var int = cast[var int](nil)) =
  var minimumSize_00: int32
  var naturalSize_00: int32
  gtk_cell_renderer_get_preferred_width(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), minimumSize_00, naturalSize_00)
  if minimumSize.addr != nil:
    minimumSize = int(minimumSize_00)
  if naturalSize.addr != nil:
    naturalSize = int(naturalSize_00)

proc gtk_cell_renderer_get_preferred_width_for_height(self: ptr CellRenderer00;
    widget: ptr Widget00; height: int32; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidthForHeight*(self: CellRenderer;
    widget: Widget; height: int; minimumWidth: var int = cast[var int](nil);
    naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_renderer_get_preferred_width_for_height(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_renderer_get_request_mode(self: ptr CellRenderer00): SizeRequestMode {.
    importc, libprag.}

proc getRequestMode*(self: CellRenderer): SizeRequestMode =
  gtk_cell_renderer_get_request_mode(cast[ptr CellRenderer00](self.impl))

proc requestMode*(self: CellRenderer): SizeRequestMode =
  gtk_cell_renderer_get_request_mode(cast[ptr CellRenderer00](self.impl))

proc gtk_cell_renderer_get_sensitive(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getSensitive*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_sensitive(cast[ptr CellRenderer00](self.impl)))

proc sensitive*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_sensitive(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_get_size(self: ptr CellRenderer00; widget: ptr Widget00;
    cellArea: gdk.Rectangle; xOffset: var int32; yOffset: var int32; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getSize*(self: CellRenderer; widget: Widget; cellArea: gdk.Rectangle = cast[var gdk.Rectangle](nil);
    xOffset: var int = cast[var int](nil); yOffset: var int = cast[var int](nil);
    width: var int = cast[var int](nil); height: var int = cast[var int](nil)) =
  var width_00: int32
  var yOffset_00: int32
  var xOffset_00: int32
  var height_00: int32
  gtk_cell_renderer_get_size(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), cellArea, xOffset_00, yOffset_00, width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if yOffset.addr != nil:
    yOffset = int(yOffset_00)
  if xOffset.addr != nil:
    xOffset = int(xOffset_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_cell_renderer_get_visible(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getVisible*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_visible(cast[ptr CellRenderer00](self.impl)))

proc visible*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_get_visible(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_is_activatable(self: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc isActivatable*(self: CellRenderer): bool =
  toBool(gtk_cell_renderer_is_activatable(cast[ptr CellRenderer00](self.impl)))

proc gtk_cell_renderer_set_alignment(self: ptr CellRenderer00; xalign: cfloat;
    yalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: CellRenderer; xalign: cfloat;
    yalign: cfloat) =
  gtk_cell_renderer_set_alignment(cast[ptr CellRenderer00](self.impl), xalign, yalign)

proc gtk_cell_renderer_set_fixed_size(self: ptr CellRenderer00; width: int32;
    height: int32) {.
    importc, libprag.}

proc setFixedSize*(self: CellRenderer; width: int; height: int) =
  gtk_cell_renderer_set_fixed_size(cast[ptr CellRenderer00](self.impl), int32(width), int32(height))

proc gtk_cell_renderer_set_padding(self: ptr CellRenderer00; xpad: int32;
    ypad: int32) {.
    importc, libprag.}

proc setPadding*(self: CellRenderer; xpad: int; ypad: int) =
  gtk_cell_renderer_set_padding(cast[ptr CellRenderer00](self.impl), int32(xpad), int32(ypad))

proc gtk_cell_renderer_set_sensitive(self: ptr CellRenderer00; sensitive: gboolean) {.
    importc, libprag.}

proc setSensitive*(self: CellRenderer; sensitive: bool = true) =
  gtk_cell_renderer_set_sensitive(cast[ptr CellRenderer00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: CellRenderer; sensitive: bool) =
  gtk_cell_renderer_set_sensitive(cast[ptr CellRenderer00](self.impl), gboolean(sensitive))

proc gtk_cell_renderer_set_visible(self: ptr CellRenderer00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: CellRenderer; visible: bool = true) =
  gtk_cell_renderer_set_visible(cast[ptr CellRenderer00](self.impl), gboolean(visible))

proc `visible=`*(self: CellRenderer; visible: bool) =
  gtk_cell_renderer_set_visible(cast[ptr CellRenderer00](self.impl), gboolean(visible))

proc gtk_cell_renderer_stop_editing(self: ptr CellRenderer00; canceled: gboolean) {.
    importc, libprag.}

proc stopEditing*(self: CellRenderer; canceled: bool) =
  gtk_cell_renderer_stop_editing(cast[ptr CellRenderer00](self.impl), gboolean(canceled))

proc gtk_renderer_cell_accessible_new(renderer: ptr CellRenderer00): ptr RendererCellAccessible00 {.
    importc, libprag.}

proc newRendererCellAccessible*(renderer: CellRenderer): RendererCellAccessible =
  let gobj = gtk_renderer_cell_accessible_new(cast[ptr CellRenderer00](renderer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRendererCellAccessible*(tdesc: typedesc; renderer: CellRenderer): tdesc =
  assert(result is RendererCellAccessible)
  let gobj = gtk_renderer_cell_accessible_new(cast[ptr CellRenderer00](renderer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRendererCellAccessible*[T](result: var T; renderer: CellRenderer) {.deprecated.} =
  assert(result is RendererCellAccessible)
  let gobj = gtk_renderer_cell_accessible_new(cast[ptr CellRenderer00](renderer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererState* {.size: sizeof(cint), pure.} = enum
    selected = 1
    prelit = 2
    insensitive = 4
    sorted = 8
    focused = 16
    expandable = 32
    expanded = 64

proc gtk_cell_renderer_activate(self: ptr CellRenderer00; event: ptr gdk.Event00;
    widget: ptr Widget00; path: cstring; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle;
    flags: CellRendererState): gboolean {.
    importc, libprag.}

proc activate*(self: CellRenderer; event: gdk.Event; widget: Widget;
    path: cstring; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle;
    flags: CellRendererState): bool =
  toBool(gtk_cell_renderer_activate(cast[ptr CellRenderer00](self.impl), cast[ptr gdk.Event00](event.impl), cast[ptr Widget00](widget.impl), path, backgroundArea, cellArea, flags))

proc gtk_cell_renderer_get_aligned_area(self: ptr CellRenderer00; widget: ptr Widget00;
    flags: CellRendererState; cellArea: gdk.Rectangle; alignedArea: var gdk.Rectangle) {.
    importc, libprag.}

proc getAlignedArea*(self: CellRenderer; widget: Widget;
    flags: CellRendererState; cellArea: gdk.Rectangle; alignedArea: var gdk.Rectangle) =
  gtk_cell_renderer_get_aligned_area(cast[ptr CellRenderer00](self.impl), cast[ptr Widget00](widget.impl), flags, cellArea, alignedArea)

proc gtk_cell_renderer_get_state(self: ptr CellRenderer00; widget: ptr Widget00;
    cellState: CellRendererState): StateFlags {.
    importc, libprag.}

proc getState*(self: CellRenderer; widget: Widget = nil;
    cellState: CellRendererState): StateFlags =
  gtk_cell_renderer_get_state(cast[ptr CellRenderer00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl), cellState)

proc gtk_cell_renderer_render(self: ptr CellRenderer00; cr: ptr cairo.Context00;
    widget: ptr Widget00; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle;
    flags: CellRendererState) {.
    importc, libprag.}

proc render*(self: CellRenderer; cr: cairo.Context; widget: Widget;
    backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle; flags: CellRendererState) =
  gtk_cell_renderer_render(cast[ptr CellRenderer00](self.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr Widget00](widget.impl), backgroundArea, cellArea, flags)

proc gtk_cell_renderer_start_editing(self: ptr CellRenderer00; event: ptr gdk.Event00;
    widget: ptr Widget00; path: cstring; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle;
    flags: CellRendererState): ptr CellEditable00 {.
    importc, libprag.}

proc startEditing*(self: CellRenderer; event: gdk.Event = nil;
    widget: Widget; path: cstring; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle;
    flags: CellRendererState): CellEditable =
  let gobj = gtk_cell_renderer_start_editing(cast[ptr CellRenderer00](self.impl), if event.isNil: nil else: cast[ptr gdk.Event00](event.impl), cast[ptr Widget00](widget.impl), path, backgroundArea, cellArea, flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ImageType* {.size: sizeof(cint), pure.} = enum
    empty = 0
    pixbuf = 1
    stock = 2
    iconSet = 3
    animation = 4
    iconName = 5
    gicon = 6
    surface = 7

proc gtk_entry_get_icon_storage_type(self: ptr Entry00; iconPos: EntryIconPosition): ImageType {.
    importc, libprag.}

proc getIconStorageType*(self: Entry; iconPos: EntryIconPosition): ImageType =
  gtk_entry_get_icon_storage_type(cast[ptr Entry00](self.impl), iconPos)

type
  EntryBuffer* = ref object of gobject.Object
  EntryBuffer00* = object of gobject.Object00

proc gtk_entry_buffer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EntryBuffer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDeletedText*(self: EntryBuffer;  p: proc (self: ptr EntryBuffer00; position: uint32; nChars: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "deleted-text", cast[GCallback](p), xdata, nil, cf)

proc scInsertedText*(self: EntryBuffer;  p: proc (self: ptr EntryBuffer00; position: uint32; chars: cstring; nChars: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "inserted-text", cast[GCallback](p), xdata, nil, cf)

proc gtk_entry_buffer_new(initialChars: cstring; nInitialChars: int32): ptr EntryBuffer00 {.
    importc, libprag.}

proc newEntryBuffer*(initialChars: cstring = nil; nInitialChars: int): EntryBuffer =
  let gobj = gtk_entry_buffer_new(initialChars, int32(nInitialChars))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryBuffer*(tdesc: typedesc; initialChars: cstring = nil; nInitialChars: int): tdesc =
  assert(result is EntryBuffer)
  let gobj = gtk_entry_buffer_new(initialChars, int32(nInitialChars))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryBuffer*[T](result: var T; initialChars: cstring = nil; nInitialChars: int) {.deprecated.} =
  assert(result is EntryBuffer)
  let gobj = gtk_entry_buffer_new(initialChars, int32(nInitialChars))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_buffer_delete_text(self: ptr EntryBuffer00; position: uint32;
    nChars: int32): uint32 {.
    importc, libprag.}

proc deleteText*(self: EntryBuffer; position: int; nChars: int): int =
  int(gtk_entry_buffer_delete_text(cast[ptr EntryBuffer00](self.impl), uint32(position), int32(nChars)))

proc gtk_entry_buffer_emit_deleted_text(self: ptr EntryBuffer00; position: uint32;
    nChars: uint32) {.
    importc, libprag.}

proc emitDeletedText*(self: EntryBuffer; position: int;
    nChars: int) =
  gtk_entry_buffer_emit_deleted_text(cast[ptr EntryBuffer00](self.impl), uint32(position), uint32(nChars))

proc gtk_entry_buffer_emit_inserted_text(self: ptr EntryBuffer00; position: uint32;
    chars: cstring; nChars: uint32) {.
    importc, libprag.}

proc emitInsertedText*(self: EntryBuffer; position: int;
    chars: cstring; nChars: int) =
  gtk_entry_buffer_emit_inserted_text(cast[ptr EntryBuffer00](self.impl), uint32(position), chars, uint32(nChars))

proc gtk_entry_buffer_get_bytes(self: ptr EntryBuffer00): uint64 {.
    importc, libprag.}

proc getBytes*(self: EntryBuffer): uint64 =
  gtk_entry_buffer_get_bytes(cast[ptr EntryBuffer00](self.impl))

proc bytes*(self: EntryBuffer): uint64 =
  gtk_entry_buffer_get_bytes(cast[ptr EntryBuffer00](self.impl))

proc gtk_entry_buffer_get_length(self: ptr EntryBuffer00): uint32 {.
    importc, libprag.}

proc getLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_length(cast[ptr EntryBuffer00](self.impl)))

proc length*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_length(cast[ptr EntryBuffer00](self.impl)))

proc gtk_entry_buffer_get_max_length(self: ptr EntryBuffer00): int32 {.
    importc, libprag.}

proc getMaxLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_max_length(cast[ptr EntryBuffer00](self.impl)))

proc maxLength*(self: EntryBuffer): int =
  int(gtk_entry_buffer_get_max_length(cast[ptr EntryBuffer00](self.impl)))

proc gtk_entry_buffer_get_text(self: ptr EntryBuffer00): cstring {.
    importc, libprag.}

proc getText*(self: EntryBuffer): string =
  result = $gtk_entry_buffer_get_text(cast[ptr EntryBuffer00](self.impl))

proc text*(self: EntryBuffer): string =
  result = $gtk_entry_buffer_get_text(cast[ptr EntryBuffer00](self.impl))

proc gtk_entry_buffer_insert_text(self: ptr EntryBuffer00; position: uint32;
    chars: cstring; nChars: int32): uint32 {.
    importc, libprag.}

proc insertText*(self: EntryBuffer; position: int; chars: cstring;
    nChars: int): int =
  int(gtk_entry_buffer_insert_text(cast[ptr EntryBuffer00](self.impl), uint32(position), chars, int32(nChars)))

proc gtk_entry_buffer_set_max_length(self: ptr EntryBuffer00; maxLength: int32) {.
    importc, libprag.}

proc setMaxLength*(self: EntryBuffer; maxLength: int) =
  gtk_entry_buffer_set_max_length(cast[ptr EntryBuffer00](self.impl), int32(maxLength))

proc `maxLength=`*(self: EntryBuffer; maxLength: int) =
  gtk_entry_buffer_set_max_length(cast[ptr EntryBuffer00](self.impl), int32(maxLength))

proc gtk_entry_buffer_set_text(self: ptr EntryBuffer00; chars: cstring; nChars: int32) {.
    importc, libprag.}

proc setText*(self: EntryBuffer; chars: cstring; nChars: int) =
  gtk_entry_buffer_set_text(cast[ptr EntryBuffer00](self.impl), chars, int32(nChars))

proc gtk_entry_new_with_buffer(buffer: ptr EntryBuffer00): ptr Entry00 {.
    importc, libprag.}

proc newEntryWithBuffer*(buffer: EntryBuffer): Entry =
  let gobj = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryWithBuffer*(tdesc: typedesc; buffer: EntryBuffer): tdesc =
  assert(result is Entry)
  let gobj = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryWithBuffer*[T](result: var T; buffer: EntryBuffer) {.deprecated.} =
  assert(result is Entry)
  let gobj = gtk_entry_new_with_buffer(cast[ptr EntryBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_get_buffer(self: ptr Entry00): ptr EntryBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: Entry): EntryBuffer =
  let gobj = gtk_entry_get_buffer(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: Entry): EntryBuffer =
  let gobj = gtk_entry_get_buffer(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_set_buffer(self: ptr Entry00; buffer: ptr EntryBuffer00) {.
    importc, libprag.}

proc setBuffer*(self: Entry; buffer: EntryBuffer) =
  gtk_entry_set_buffer(cast[ptr Entry00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

proc `buffer=`*(self: Entry; buffer: EntryBuffer) =
  gtk_entry_set_buffer(cast[ptr Entry00](self.impl), cast[ptr EntryBuffer00](buffer.impl))

type
  InputHints* {.size: sizeof(cint), pure.} = enum
    none = 0
    spellcheck = 1
    noSpellcheck = 2
    wordCompletion = 4
    lowercase = 8
    uppercaseChars = 16
    uppercaseWords = 32
    uppercaseSentences = 64
    inhibitOsk = 128
    verticalWriting = 256
    emoji = 512
    noEmoji = 1024

proc gtk_entry_get_input_hints(self: ptr Entry00): InputHints {.
    importc, libprag.}

proc getInputHints*(self: Entry): InputHints =
  gtk_entry_get_input_hints(cast[ptr Entry00](self.impl))

proc inputHints*(self: Entry): InputHints =
  gtk_entry_get_input_hints(cast[ptr Entry00](self.impl))

proc gtk_entry_set_input_hints(self: ptr Entry00; hints: InputHints) {.
    importc, libprag.}

proc setInputHints*(self: Entry; hints: InputHints) =
  gtk_entry_set_input_hints(cast[ptr Entry00](self.impl), hints)

proc `inputHints=`*(self: Entry; hints: InputHints) =
  gtk_entry_set_input_hints(cast[ptr Entry00](self.impl), hints)

type
  InputPurpose* {.size: sizeof(cint), pure.} = enum
    freeForm = 0
    alpha = 1
    digits = 2
    number = 3
    phone = 4
    url = 5
    email = 6
    name = 7
    password = 8
    pin = 9
    terminal = 10

proc gtk_entry_get_input_purpose(self: ptr Entry00): InputPurpose {.
    importc, libprag.}

proc getInputPurpose*(self: Entry): InputPurpose =
  gtk_entry_get_input_purpose(cast[ptr Entry00](self.impl))

proc inputPurpose*(self: Entry): InputPurpose =
  gtk_entry_get_input_purpose(cast[ptr Entry00](self.impl))

proc gtk_entry_set_input_purpose(self: ptr Entry00; purpose: InputPurpose) {.
    importc, libprag.}

proc setInputPurpose*(self: Entry; purpose: InputPurpose) =
  gtk_entry_set_input_purpose(cast[ptr Entry00](self.impl), purpose)

proc `inputPurpose=`*(self: Entry; purpose: InputPurpose) =
  gtk_entry_set_input_purpose(cast[ptr Entry00](self.impl), purpose)

type
  SpinButtonUpdatePolicy* {.size: sizeof(cint), pure.} = enum
    always = 0
    ifValid = 1

proc gtk_spin_button_get_update_policy(self: ptr SpinButton00): SpinButtonUpdatePolicy {.
    importc, libprag.}

proc getUpdatePolicy*(self: SpinButton): SpinButtonUpdatePolicy =
  gtk_spin_button_get_update_policy(cast[ptr SpinButton00](self.impl))

proc updatePolicy*(self: SpinButton): SpinButtonUpdatePolicy =
  gtk_spin_button_get_update_policy(cast[ptr SpinButton00](self.impl))

proc gtk_spin_button_set_update_policy(self: ptr SpinButton00; policy: SpinButtonUpdatePolicy) {.
    importc, libprag.}

proc setUpdatePolicy*(self: SpinButton; policy: SpinButtonUpdatePolicy) =
  gtk_spin_button_set_update_policy(cast[ptr SpinButton00](self.impl), policy)

proc `updatePolicy=`*(self: SpinButton; policy: SpinButtonUpdatePolicy) =
  gtk_spin_button_set_update_policy(cast[ptr SpinButton00](self.impl), policy)

type
  SpinType* {.size: sizeof(cint), pure.} = enum
    stepForward = 0
    stepBackward = 1
    pageForward = 2
    pageBackward = 3
    home = 4
    `end` = 5
    userDefined = 6

proc gtk_spin_button_spin(self: ptr SpinButton00; direction: SpinType; increment: cdouble) {.
    importc, libprag.}

proc spin*(self: SpinButton; direction: SpinType; increment: cdouble) =
  gtk_spin_button_spin(cast[ptr SpinButton00](self.impl), direction, increment)

type
  TreeIter* {.pure, byRef.} = object
    stamp*: int32
    userData*: pointer
    userData2*: pointer
    userData3*: pointer

proc gtk_tree_iter_get_type*(): GType {.importc, libprag.}

proc gtk_tree_iter_free(self: TreeIter) {.
    importc, libprag.}

proc free*(self: TreeIter) =
  gtk_tree_iter_free(self)

proc gtk_tree_iter_copy(self: TreeIter): ptr TreeIter {.
    importc, libprag.}

proc copy*(self: TreeIter): ptr TreeIter =
  gtk_tree_iter_copy(self)

proc gtk_combo_box_get_active_iter(self: ptr ComboBox00; iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getActiveIter*(self: ComboBox; iter: var TreeIter): bool =
  toBool(gtk_combo_box_get_active_iter(cast[ptr ComboBox00](self.impl), iter))

proc gtk_combo_box_set_active_iter(self: ptr ComboBox00; iter: TreeIter) {.
    importc, libprag.}

proc setActiveIter*(self: ComboBox; iter: TreeIter = cast[var TreeIter](nil)) =
  gtk_combo_box_set_active_iter(cast[ptr ComboBox00](self.impl), iter)

proc `activeIter=`*(self: ComboBox; iter: TreeIter = cast[var TreeIter](nil)) =
  gtk_combo_box_set_active_iter(cast[ptr ComboBox00](self.impl), iter)

type
  SensitivityType* {.size: sizeof(cint), pure.} = enum
    auto = 0
    on = 1
    off = 2

proc gtk_combo_box_get_button_sensitivity(self: ptr ComboBox00): SensitivityType {.
    importc, libprag.}

proc getButtonSensitivity*(self: ComboBox): SensitivityType =
  gtk_combo_box_get_button_sensitivity(cast[ptr ComboBox00](self.impl))

proc buttonSensitivity*(self: ComboBox): SensitivityType =
  gtk_combo_box_get_button_sensitivity(cast[ptr ComboBox00](self.impl))

proc gtk_combo_box_set_button_sensitivity(self: ptr ComboBox00; sensitivity: SensitivityType) {.
    importc, libprag.}

proc setButtonSensitivity*(self: ComboBox; sensitivity: SensitivityType) =
  gtk_combo_box_set_button_sensitivity(cast[ptr ComboBox00](self.impl), sensitivity)

proc `buttonSensitivity=`*(self: ComboBox; sensitivity: SensitivityType) =
  gtk_combo_box_set_button_sensitivity(cast[ptr ComboBox00](self.impl), sensitivity)

type
  TreePath00* {.pure.} = object
  TreePath* = ref object
    impl*: ptr TreePath00
    ignoreFinalizer*: bool

proc gtk_tree_path_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkTreePath*(self: TreePath) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_tree_path_get_type(), cast[ptr TreePath00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreePath()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_tree_path_get_type(), cast[ptr TreePath00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var TreePath) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkTreePath)

proc gtk_tree_path_free(self: ptr TreePath00) {.
    importc, libprag.}

proc free*(self: TreePath) =
  gtk_tree_path_free(cast[ptr TreePath00](self.impl))

proc finalizerfree*(self: TreePath) =
  if not self.ignoreFinalizer:
    gtk_tree_path_free(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_new_first(): ptr TreePath00 {.
    importc, libprag.}

proc newTreePathFirst*(): TreePath =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_first()

proc newTreePathFirst*(tdesc: typedesc): tdesc =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_first()

proc initTreePathFirst*[T](result: var T) {.deprecated.} =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_first()

proc gtk_tree_path_new_from_indicesv(indices: ptr int32; length: uint64): ptr TreePath00 {.
    importc, libprag.}

proc newTreePathFromIndices*(indices: seq[int32]): TreePath =
  let length = uint64(indices.len)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_indicesv(cast[ptr int32](unsafeaddr(indices[0])), length)

proc newTreePathFromIndices*(tdesc: typedesc; indices: seq[int32]): tdesc =
  let length = uint64(indices.len)
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_indicesv(cast[ptr int32](unsafeaddr(indices[0])), length)

proc initTreePathFromIndices*[T](result: var T; indices: seq[int32]) {.deprecated.} =
  let length = uint64(indices.len)
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_indicesv(cast[ptr int32](unsafeaddr(indices[0])), length)

proc gtk_tree_path_new_from_string(path: cstring): ptr TreePath00 {.
    importc, libprag.}

proc newTreePathFromString*(path: cstring): TreePath =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_string(path)

proc newTreePathFromString*(tdesc: typedesc; path: cstring): tdesc =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_string(path)

proc initTreePathFromString*[T](result: var T; path: cstring) {.deprecated.} =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new_from_string(path)

proc gtk_tree_path_append_index(self: ptr TreePath00; index: int32) {.
    importc, libprag.}

proc appendIndex*(self: TreePath; index: int) =
  gtk_tree_path_append_index(cast[ptr TreePath00](self.impl), int32(index))

proc gtk_tree_path_compare(self: ptr TreePath00; b: ptr TreePath00): int32 {.
    importc, libprag.}

proc compare*(self: TreePath; b: TreePath): int =
  int(gtk_tree_path_compare(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](b.impl)))

proc gtk_tree_path_copy(self: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc copy*(self: TreePath): TreePath =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_copy(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_down(self: ptr TreePath00) {.
    importc, libprag.}

proc down*(self: TreePath) =
  gtk_tree_path_down(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_new(): ptr TreePath00 {.
    importc, libprag.}

proc newTreePath*(): TreePath =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new()

proc newTreePath*(tdesc: typedesc): tdesc =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new()

proc initTreePath*[T](result: var T) {.deprecated.} =
  assert(result is TreePath)
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_path_new()

proc gtk_tree_path_get_depth(self: ptr TreePath00): int32 {.
    importc, libprag.}

proc getDepth*(self: TreePath): int =
  int(gtk_tree_path_get_depth(cast[ptr TreePath00](self.impl)))

proc depth*(self: TreePath): int =
  int(gtk_tree_path_get_depth(cast[ptr TreePath00](self.impl)))

proc gtk_tree_path_get_indices_with_depth(self: ptr TreePath00; depth: var int32): ptr int32 {.
    importc, libprag.}

proc getIndices*(self: TreePath; depth: var int = cast[var int](nil)): seq[int32] =
  var depth_00: int32
  result = int32ArrayToSeq(gtk_tree_path_get_indices_with_depth(cast[ptr TreePath00](self.impl), depth_00), depth.int)
  if depth.addr != nil:
    depth = int(depth_00)

proc gtk_tree_path_is_ancestor(self: ptr TreePath00; descendant: ptr TreePath00): gboolean {.
    importc, libprag.}

proc isAncestor*(self: TreePath; descendant: TreePath): bool =
  toBool(gtk_tree_path_is_ancestor(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](descendant.impl)))

proc gtk_tree_path_is_descendant(self: ptr TreePath00; ancestor: ptr TreePath00): gboolean {.
    importc, libprag.}

proc isDescendant*(self: TreePath; ancestor: TreePath): bool =
  toBool(gtk_tree_path_is_descendant(cast[ptr TreePath00](self.impl), cast[ptr TreePath00](ancestor.impl)))

proc gtk_tree_path_next(self: ptr TreePath00) {.
    importc, libprag.}

proc next*(self: TreePath) =
  gtk_tree_path_next(cast[ptr TreePath00](self.impl))

proc gtk_tree_path_prepend_index(self: ptr TreePath00; index: int32) {.
    importc, libprag.}

proc prependIndex*(self: TreePath; index: int) =
  gtk_tree_path_prepend_index(cast[ptr TreePath00](self.impl), int32(index))

proc gtk_tree_path_prev(self: ptr TreePath00): gboolean {.
    importc, libprag.}

proc prev*(self: TreePath): bool =
  toBool(gtk_tree_path_prev(cast[ptr TreePath00](self.impl)))

proc gtk_tree_path_to_string(self: ptr TreePath00): cstring {.
    importc, libprag.}

proc toString*(self: TreePath): string =
  let resul0 = gtk_tree_path_to_string(cast[ptr TreePath00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_tree_path_up(self: ptr TreePath00): gboolean {.
    importc, libprag.}

proc up*(self: TreePath): bool =
  toBool(gtk_tree_path_up(cast[ptr TreePath00](self.impl)))

type
  TreeModelSort* = ref object of gobject.Object
  TreeModelSort00* = object of gobject.Object00

proc gtk_tree_model_sort_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeModelSort()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_model_sort_clear_cache(self: ptr TreeModelSort00) {.
    importc, libprag.}

proc clearCache*(self: TreeModelSort) =
  gtk_tree_model_sort_clear_cache(cast[ptr TreeModelSort00](self.impl))

proc gtk_tree_model_sort_convert_child_iter_to_iter(self: ptr TreeModelSort00;
    sortIter: var TreeIter; childIter: TreeIter): gboolean {.
    importc, libprag.}

proc convertChildIterToIter*(self: TreeModelSort;
    sortIter: var TreeIter; childIter: TreeIter): bool =
  toBool(gtk_tree_model_sort_convert_child_iter_to_iter(cast[ptr TreeModelSort00](self.impl), sortIter, childIter))

proc gtk_tree_model_sort_convert_child_path_to_path(self: ptr TreeModelSort00;
    childPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertChildPathToPath*(self: TreeModelSort;
    childPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_sort_convert_child_path_to_path(cast[ptr TreeModelSort00](self.impl), cast[ptr TreePath00](childPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_sort_convert_iter_to_child_iter(self: ptr TreeModelSort00;
    childIter: var TreeIter; sortedIter: TreeIter) {.
    importc, libprag.}

proc convertIterToChildIter*(self: TreeModelSort;
    childIter: var TreeIter; sortedIter: TreeIter) =
  gtk_tree_model_sort_convert_iter_to_child_iter(cast[ptr TreeModelSort00](self.impl), childIter, sortedIter)

proc gtk_tree_model_sort_convert_path_to_child_path(self: ptr TreeModelSort00;
    sortedPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertPathToChildPath*(self: TreeModelSort;
    sortedPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_sort_convert_path_to_child_path(cast[ptr TreeModelSort00](self.impl), cast[ptr TreePath00](sortedPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_sort_iter_is_valid(self: ptr TreeModelSort00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsValid*(self: TreeModelSort; iter: TreeIter): bool =
  toBool(gtk_tree_model_sort_iter_is_valid(cast[ptr TreeModelSort00](self.impl), iter))

proc gtk_tree_model_sort_reset_default_sort_func(self: ptr TreeModelSort00) {.
    importc, libprag.}

proc resetDefaultSortFunc*(self: TreeModelSort) =
  gtk_tree_model_sort_reset_default_sort_func(cast[ptr TreeModelSort00](self.impl))

type
  ListStore* = ref object of gobject.Object
  ListStore00* = object of gobject.Object00

proc gtk_list_store_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListStore()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_list_store_newv(nColumns: int32; types: ptr GType): ptr ListStore00 {.
    importc, libprag.}

proc newListStore*(nColumns: int; types: ptr GType): ListStore =
  let gobj = gtk_list_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newListStore*(tdesc: typedesc; nColumns: int; types: ptr GType): tdesc =
  assert(result is ListStore)
  let gobj = gtk_list_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListStore*[T](result: var T; nColumns: int; types: ptr GType) {.deprecated.} =
  assert(result is ListStore)
  let gobj = gtk_list_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_store_append(self: ptr ListStore00; iter: var TreeIter) {.
    importc, libprag.}

proc append*(self: ListStore; iter: var TreeIter) =
  gtk_list_store_append(cast[ptr ListStore00](self.impl), iter)

proc append*(self: ListStore): TreeIter =
  gtk_list_store_append(cast[ptr ListStore00](self.impl), result)

proc gtk_list_store_clear(self: ptr ListStore00) {.
    importc, libprag.}

proc clear*(self: ListStore) =
  gtk_list_store_clear(cast[ptr ListStore00](self.impl))

proc gtk_list_store_insert(self: ptr ListStore00; iter: var TreeIter; position: int32) {.
    importc, libprag.}

proc insert*(self: ListStore; iter: var TreeIter; position: int) =
  gtk_list_store_insert(cast[ptr ListStore00](self.impl), iter, int32(position))

proc gtk_list_store_insert_after(self: ptr ListStore00; iter: var TreeIter;
    sibling: TreeIter) {.
    importc, libprag.}

proc insertAfter*(self: ListStore; iter: var TreeIter; sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_insert_after(cast[ptr ListStore00](self.impl), iter, sibling)

proc gtk_list_store_insert_before(self: ptr ListStore00; iter: var TreeIter;
    sibling: TreeIter) {.
    importc, libprag.}

proc insertBefore*(self: ListStore; iter: var TreeIter; sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_insert_before(cast[ptr ListStore00](self.impl), iter, sibling)

proc gtk_list_store_iter_is_valid(self: ptr ListStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsValid*(self: ListStore; iter: TreeIter): bool =
  toBool(gtk_list_store_iter_is_valid(cast[ptr ListStore00](self.impl), iter))

proc gtk_list_store_move_after(self: ptr ListStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveAfter*(self: ListStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_move_after(cast[ptr ListStore00](self.impl), iter, position)

proc gtk_list_store_move_before(self: ptr ListStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveBefore*(self: ListStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_list_store_move_before(cast[ptr ListStore00](self.impl), iter, position)

proc gtk_list_store_prepend(self: ptr ListStore00; iter: var TreeIter) {.
    importc, libprag.}

proc prepend*(self: ListStore; iter: var TreeIter) =
  gtk_list_store_prepend(cast[ptr ListStore00](self.impl), iter)

proc prepend*(self: ListStore): TreeIter =
  gtk_list_store_prepend(cast[ptr ListStore00](self.impl), result)

proc gtk_list_store_remove(self: ptr ListStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc remove*(self: ListStore; iter: TreeIter): bool =
  toBool(gtk_list_store_remove(cast[ptr ListStore00](self.impl), iter))

proc gtk_list_store_reorder(self: ptr ListStore00; newOrder: ptr int32) {.
    importc, libprag.}

proc reorder*(self: ListStore; newOrder: seq[int32]) =
  gtk_list_store_reorder(cast[ptr ListStore00](self.impl), cast[ptr int32](unsafeaddr(newOrder[0])))

proc gtk_list_store_set_column_types(self: ptr ListStore00; nColumns: int32;
    types: ptr GType) {.
    importc, libprag.}

proc setColumnTypes*(self: ListStore; nColumns: int; types: ptr GType) =
  gtk_list_store_set_column_types(cast[ptr ListStore00](self.impl), int32(nColumns), types)

proc gtk_list_store_set_value(self: ptr ListStore00; iter: TreeIter; column: int32;
    value: gobject.Value) {.
    importc, libprag.}

proc setValue*(self: ListStore; iter: TreeIter; column: int;
    value: gobject.Value) =
  gtk_list_store_set_value(cast[ptr ListStore00](self.impl), iter, int32(column), value)

proc gtk_list_store_swap(self: ptr ListStore00; a: TreeIter; b: TreeIter) {.
    importc, libprag.}

proc swap*(self: ListStore; a: TreeIter; b: TreeIter) =
  gtk_list_store_swap(cast[ptr ListStore00](self.impl), a, b)

type
  TreeModelFilter* = ref object of gobject.Object
  TreeModelFilter00* = object of gobject.Object00

proc gtk_tree_model_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeModelFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_model_filter_clear_cache(self: ptr TreeModelFilter00) {.
    importc, libprag.}

proc clearCache*(self: TreeModelFilter) =
  gtk_tree_model_filter_clear_cache(cast[ptr TreeModelFilter00](self.impl))

proc gtk_tree_model_filter_convert_child_iter_to_iter(self: ptr TreeModelFilter00;
    filterIter: var TreeIter; childIter: TreeIter): gboolean {.
    importc, libprag.}

proc convertChildIterToIter*(self: TreeModelFilter;
    filterIter: var TreeIter; childIter: TreeIter): bool =
  toBool(gtk_tree_model_filter_convert_child_iter_to_iter(cast[ptr TreeModelFilter00](self.impl), filterIter, childIter))

proc gtk_tree_model_filter_convert_child_path_to_path(self: ptr TreeModelFilter00;
    childPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertChildPathToPath*(self: TreeModelFilter;
    childPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_filter_convert_child_path_to_path(cast[ptr TreeModelFilter00](self.impl), cast[ptr TreePath00](childPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_filter_convert_iter_to_child_iter(self: ptr TreeModelFilter00;
    childIter: var TreeIter; filterIter: TreeIter) {.
    importc, libprag.}

proc convertIterToChildIter*(self: TreeModelFilter;
    childIter: var TreeIter; filterIter: TreeIter) =
  gtk_tree_model_filter_convert_iter_to_child_iter(cast[ptr TreeModelFilter00](self.impl), childIter, filterIter)

proc gtk_tree_model_filter_convert_path_to_child_path(self: ptr TreeModelFilter00;
    filterPath: ptr TreePath00): ptr TreePath00 {.
    importc, libprag.}

proc convertPathToChildPath*(self: TreeModelFilter;
    filterPath: TreePath): TreePath =
  let impl0 = gtk_tree_model_filter_convert_path_to_child_path(cast[ptr TreeModelFilter00](self.impl), cast[ptr TreePath00](filterPath.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_model_filter_refilter(self: ptr TreeModelFilter00) {.
    importc, libprag.}

proc refilter*(self: TreeModelFilter) =
  gtk_tree_model_filter_refilter(cast[ptr TreeModelFilter00](self.impl))

proc gtk_tree_model_filter_set_visible_column(self: ptr TreeModelFilter00;
    column: int32) {.
    importc, libprag.}

proc setVisibleColumn*(self: TreeModelFilter; column: int) =
  gtk_tree_model_filter_set_visible_column(cast[ptr TreeModelFilter00](self.impl), int32(column))

proc `visibleColumn=`*(self: TreeModelFilter; column: int) =
  gtk_tree_model_filter_set_visible_column(cast[ptr TreeModelFilter00](self.impl), int32(column))

type
  TreeStore* = ref object of gobject.Object
  TreeStore00* = object of gobject.Object00

proc gtk_tree_store_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeStore()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tree_store_newv(nColumns: int32; types: ptr GType): ptr TreeStore00 {.
    importc, libprag.}

proc newTreeStore*(nColumns: int; types: ptr GType): TreeStore =
  let gobj = gtk_tree_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeStore*(tdesc: typedesc; nColumns: int; types: ptr GType): tdesc =
  assert(result is TreeStore)
  let gobj = gtk_tree_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeStore*[T](result: var T; nColumns: int; types: ptr GType) {.deprecated.} =
  assert(result is TreeStore)
  let gobj = gtk_tree_store_newv(int32(nColumns), types)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_store_append(self: ptr TreeStore00; iter: var TreeIter; parent: TreeIter) {.
    importc, libprag.}

proc append*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_append(cast[ptr TreeStore00](self.impl), iter, parent)

proc gtk_tree_store_clear(self: ptr TreeStore00) {.
    importc, libprag.}

proc clear*(self: TreeStore) =
  gtk_tree_store_clear(cast[ptr TreeStore00](self.impl))

proc gtk_tree_store_insert(self: ptr TreeStore00; iter: var TreeIter; parent: TreeIter;
    position: int32) {.
    importc, libprag.}

proc insert*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil);
    position: int) =
  gtk_tree_store_insert(cast[ptr TreeStore00](self.impl), iter, parent, int32(position))

proc gtk_tree_store_insert_after(self: ptr TreeStore00; iter: var TreeIter;
    parent: TreeIter; sibling: TreeIter) {.
    importc, libprag.}

proc insertAfter*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil);
    sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_insert_after(cast[ptr TreeStore00](self.impl), iter, parent, sibling)

proc gtk_tree_store_insert_before(self: ptr TreeStore00; iter: var TreeIter;
    parent: TreeIter; sibling: TreeIter) {.
    importc, libprag.}

proc insertBefore*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil);
    sibling: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_insert_before(cast[ptr TreeStore00](self.impl), iter, parent, sibling)

proc gtk_tree_store_is_ancestor(self: ptr TreeStore00; iter: TreeIter; descendant: TreeIter): gboolean {.
    importc, libprag.}

proc isAncestor*(self: TreeStore; iter: TreeIter; descendant: TreeIter): bool =
  toBool(gtk_tree_store_is_ancestor(cast[ptr TreeStore00](self.impl), iter, descendant))

proc gtk_tree_store_iter_depth(self: ptr TreeStore00; iter: TreeIter): int32 {.
    importc, libprag.}

proc iterDepth*(self: TreeStore; iter: TreeIter): int =
  int(gtk_tree_store_iter_depth(cast[ptr TreeStore00](self.impl), iter))

proc gtk_tree_store_iter_is_valid(self: ptr TreeStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsValid*(self: TreeStore; iter: TreeIter): bool =
  toBool(gtk_tree_store_iter_is_valid(cast[ptr TreeStore00](self.impl), iter))

proc gtk_tree_store_move_after(self: ptr TreeStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveAfter*(self: TreeStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_move_after(cast[ptr TreeStore00](self.impl), iter, position)

proc gtk_tree_store_move_before(self: ptr TreeStore00; iter: TreeIter; position: TreeIter) {.
    importc, libprag.}

proc moveBefore*(self: TreeStore; iter: TreeIter; position: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_move_before(cast[ptr TreeStore00](self.impl), iter, position)

proc gtk_tree_store_prepend(self: ptr TreeStore00; iter: var TreeIter; parent: TreeIter) {.
    importc, libprag.}

proc prepend*(self: TreeStore; iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil)) =
  gtk_tree_store_prepend(cast[ptr TreeStore00](self.impl), iter, parent)

proc gtk_tree_store_remove(self: ptr TreeStore00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc remove*(self: TreeStore; iter: TreeIter): bool =
  toBool(gtk_tree_store_remove(cast[ptr TreeStore00](self.impl), iter))

proc gtk_tree_store_set_column_types(self: ptr TreeStore00; nColumns: int32;
    types: ptr GType) {.
    importc, libprag.}

proc setColumnTypes*(self: TreeStore; nColumns: int; types: ptr GType) =
  gtk_tree_store_set_column_types(cast[ptr TreeStore00](self.impl), int32(nColumns), types)

proc gtk_tree_store_set_value(self: ptr TreeStore00; iter: TreeIter; column: int32;
    value: gobject.Value) {.
    importc, libprag.}

proc setValue*(self: TreeStore; iter: TreeIter; column: int;
    value: gobject.Value) =
  gtk_tree_store_set_value(cast[ptr TreeStore00](self.impl), iter, int32(column), value)

proc gtk_tree_store_swap(self: ptr TreeStore00; a: TreeIter; b: TreeIter) {.
    importc, libprag.}

proc swap*(self: TreeStore; a: TreeIter; b: TreeIter) =
  gtk_tree_store_swap(cast[ptr TreeStore00](self.impl), a, b)

type
  TreeModel00* = object of gobject.Object00
  TreeModel* = ref object of gobject.Object

proc scRowChanged*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-changed", cast[GCallback](p), xdata, nil, cf)

proc scRowDeleted*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-deleted", cast[GCallback](p), xdata, nil, cf)

proc scRowHasChildToggled*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-has-child-toggled", cast[GCallback](p), xdata, nil, cf)

proc scRowInserted*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;  p: proc (self: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-inserted", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_model_filter_new(self: ptr TreeModel00; root: ptr TreePath00): ptr TreeModel00 {.
    importc, libprag.}

proc filterNew*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    root: TreePath = nil): TreeModel =
  let gobj = gtk_tree_model_filter_new(cast[ptr TreeModel00](self.impl), if root.isNil: nil else: cast[ptr TreePath00](root.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_model_get_column_type(self: ptr TreeModel00; index: int32): GType {.
    importc, libprag.}

proc getColumnType*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    index: int): GType =
  gtk_tree_model_get_column_type(cast[ptr TreeModel00](self.impl), int32(index))

proc gtk_tree_model_get_iter(self: ptr TreeModel00; iter: var TreeIter; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc getIter*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: var TreeIter; path: TreePath): bool =
  toBool(gtk_tree_model_get_iter(cast[ptr TreeModel00](self.impl), iter, cast[ptr TreePath00](path.impl)))

proc gtk_tree_model_get_iter_first(self: ptr TreeModel00; iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getIterFirst*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: var TreeIter): bool =
  toBool(gtk_tree_model_get_iter_first(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_get_iter_from_string(self: ptr TreeModel00; iter: var TreeIter;
    pathString: cstring): gboolean {.
    importc, libprag.}

proc getIterFromString*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: var TreeIter; pathString: cstring): bool =
  toBool(gtk_tree_model_get_iter_from_string(cast[ptr TreeModel00](self.impl), iter, pathString))

proc gtk_tree_model_get_n_columns(self: ptr TreeModel00): int32 {.
    importc, libprag.}

proc getNColumns*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): int =
  int(gtk_tree_model_get_n_columns(cast[ptr TreeModel00](self.impl)))

proc nColumns*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): int =
  int(gtk_tree_model_get_n_columns(cast[ptr TreeModel00](self.impl)))

proc gtk_tree_model_get_path(self: ptr TreeModel00; iter: TreeIter): ptr TreePath00 {.
    importc, libprag.}

proc getPath*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter): TreePath =
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = gtk_tree_model_get_path(cast[ptr TreeModel00](self.impl), iter)

proc gtk_tree_model_get_string_from_iter(self: ptr TreeModel00; iter: TreeIter): cstring {.
    importc, libprag.}

proc getStringFromIter*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter): string =
  let resul0 = gtk_tree_model_get_string_from_iter(cast[ptr TreeModel00](self.impl), iter)
  result = $resul0
  cogfree(resul0)

proc gtk_tree_model_get_value(self: ptr TreeModel00; iter: TreeIter; column: int32;
    value: var gobject.Value) {.
    importc, libprag.}

proc getValue*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter; column: int; value: var gobject.Value) =
  gtk_tree_model_get_value(cast[ptr TreeModel00](self.impl), iter, int32(column), value)

proc gtk_tree_model_iter_children(self: ptr TreeModel00; iter: var TreeIter;
    parent: TreeIter): gboolean {.
    importc, libprag.}

proc iterChildren*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil)): bool =
  toBool(gtk_tree_model_iter_children(cast[ptr TreeModel00](self.impl), iter, parent))

proc gtk_tree_model_iter_has_child(self: ptr TreeModel00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterHasChild*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_has_child(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_iter_n_children(self: ptr TreeModel00; iter: TreeIter): int32 {.
    importc, libprag.}

proc iterNChildren*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter = cast[var TreeIter](nil)): int =
  int(gtk_tree_model_iter_n_children(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_iter_next(self: ptr TreeModel00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterNext*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_next(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_iter_nth_child(self: ptr TreeModel00; iter: var TreeIter;
    parent: TreeIter; n: int32): gboolean {.
    importc, libprag.}

proc iterNthChild*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: var TreeIter; parent: TreeIter = cast[var TreeIter](nil); n: int): bool =
  toBool(gtk_tree_model_iter_nth_child(cast[ptr TreeModel00](self.impl), iter, parent, int32(n)))

proc gtk_tree_model_iter_parent(self: ptr TreeModel00; iter: var TreeIter;
    child: TreeIter): gboolean {.
    importc, libprag.}

proc iterParent*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: var TreeIter; child: TreeIter): bool =
  toBool(gtk_tree_model_iter_parent(cast[ptr TreeModel00](self.impl), iter, child))

proc gtk_tree_model_iter_previous(self: ptr TreeModel00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterPrevious*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter): bool =
  toBool(gtk_tree_model_iter_previous(cast[ptr TreeModel00](self.impl), iter))

proc gtk_tree_model_ref_node(self: ptr TreeModel00; iter: TreeIter) {.
    importc, libprag.}

proc refNode*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter) =
  gtk_tree_model_ref_node(cast[ptr TreeModel00](self.impl), iter)

proc gtk_tree_model_row_changed(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter) {.
    importc, libprag.}

proc rowChanged*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_changed(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter)

proc gtk_tree_model_row_deleted(self: ptr TreeModel00; path: ptr TreePath00) {.
    importc, libprag.}

proc rowDeleted*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath) =
  gtk_tree_model_row_deleted(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_model_row_has_child_toggled(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter) {.
    importc, libprag.}

proc rowHasChildToggled*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_has_child_toggled(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter)

proc gtk_tree_model_row_inserted(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter) {.
    importc, libprag.}

proc rowInserted*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath; iter: TreeIter) =
  gtk_tree_model_row_inserted(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter)

proc gtk_tree_model_rows_reordered_with_length(self: ptr TreeModel00; path: ptr TreePath00;
    iter: TreeIter; newOrder: ptr int32; length: int32) {.
    importc, libprag.}

proc rowsReordered*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath; iter: TreeIter = cast[var TreeIter](nil); newOrder: seq[int32]) =
  let length = int(newOrder.len)
  gtk_tree_model_rows_reordered_with_length(cast[ptr TreeModel00](self.impl), cast[ptr TreePath00](path.impl), iter, cast[ptr int32](unsafeaddr(newOrder[0])), int32(length))

proc gtk_tree_model_unref_node(self: ptr TreeModel00; iter: TreeIter) {.
    importc, libprag.}

proc unrefNode*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter) =
  gtk_tree_model_unref_node(cast[ptr TreeModel00](self.impl), iter)

type
  CellArea* = ref object of gobject.InitiallyUnowned
  CellArea00* = object of gobject.InitiallyUnowned00

proc gtk_cell_area_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellArea()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAddEditable*(self: CellArea;  p: proc (self: ptr CellArea00; renderer: ptr CellRenderer00; editable: ptr CellEditable00; cellArea: gdk.Rectangle;
    path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "add-editable", cast[GCallback](p), xdata, nil, cf)

proc scApplyAttributes*(self: CellArea;  p: proc (self: ptr CellArea00; model: ptr TreeModel00; iter: TreeIter; isExpander: gboolean; isExpanded: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "apply-attributes", cast[GCallback](p), xdata, nil, cf)

proc scFocusChanged*(self: CellArea;  p: proc (self: ptr CellArea00; renderer: ptr CellRenderer00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-changed", cast[GCallback](p), xdata, nil, cf)

proc scRemoveEditable*(self: CellArea;  p: proc (self: ptr CellArea00; renderer: ptr CellRenderer00; editable: ptr CellEditable00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "remove-editable", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_area_activate_cell(self: ptr CellArea00; widget: ptr Widget00;
    renderer: ptr CellRenderer00; event: ptr gdk.Event00; cellArea: gdk.Rectangle;
    flags: CellRendererState): gboolean {.
    importc, libprag.}

proc activateCell*(self: CellArea; widget: Widget; renderer: CellRenderer;
    event: gdk.Event; cellArea: gdk.Rectangle; flags: CellRendererState): bool =
  toBool(gtk_cell_area_activate_cell(cast[ptr CellArea00](self.impl), cast[ptr Widget00](widget.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr gdk.Event00](event.impl), cellArea, flags))

proc gtk_cell_area_add(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc, libprag.}

proc add*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_add(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_add_focus_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00;
    sibling: ptr CellRenderer00) {.
    importc, libprag.}

proc addFocusSibling*(self: CellArea; renderer: CellRenderer;
    sibling: CellRenderer) =
  gtk_cell_area_add_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl))

proc gtk_cell_area_apply_attributes(self: ptr CellArea00; treeModel: ptr TreeModel00;
    iter: TreeIter; isExpander: gboolean; isExpanded: gboolean) {.
    importc, libprag.}

proc applyAttributes*(self: CellArea; treeModel: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter; isExpander: bool; isExpanded: bool) =
  gtk_cell_area_apply_attributes(cast[ptr CellArea00](self.impl), cast[ptr TreeModel00](treeModel.impl), iter, gboolean(isExpander), gboolean(isExpanded))

proc gtk_cell_area_attribute_connect(self: ptr CellArea00; renderer: ptr CellRenderer00;
    attribute: cstring; column: int32) {.
    importc, libprag.}

proc attributeConnect*(self: CellArea; renderer: CellRenderer;
    attribute: cstring; column: int) =
  gtk_cell_area_attribute_connect(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), attribute, int32(column))

proc gtk_cell_area_attribute_disconnect(self: ptr CellArea00; renderer: ptr CellRenderer00;
    attribute: cstring) {.
    importc, libprag.}

proc attributeDisconnect*(self: CellArea; renderer: CellRenderer;
    attribute: cstring) =
  gtk_cell_area_attribute_disconnect(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), attribute)

proc gtk_cell_area_attribute_get_column(self: ptr CellArea00; renderer: ptr CellRenderer00;
    attribute: cstring): int32 {.
    importc, libprag.}

proc attributeGetColumn*(self: CellArea; renderer: CellRenderer;
    attribute: cstring): int =
  int(gtk_cell_area_attribute_get_column(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), attribute))

proc gtk_cell_area_cell_get_property(self: ptr CellArea00; renderer: ptr CellRenderer00;
    propertyName: cstring; value: gobject.Value) {.
    importc, libprag.}

proc cellGetProperty*(self: CellArea; renderer: CellRenderer;
    propertyName: cstring; value: gobject.Value) =
  gtk_cell_area_cell_get_property(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), propertyName, value)

proc gtk_cell_area_cell_set_property(self: ptr CellArea00; renderer: ptr CellRenderer00;
    propertyName: cstring; value: gobject.Value) {.
    importc, libprag.}

proc cellSetProperty*(self: CellArea; renderer: CellRenderer;
    propertyName: cstring; value: gobject.Value) =
  gtk_cell_area_cell_set_property(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), propertyName, value)

proc gtk_cell_area_focus(self: ptr CellArea00; direction: DirectionType): gboolean {.
    importc, libprag.}

proc focus*(self: CellArea; direction: DirectionType): bool =
  toBool(gtk_cell_area_focus(cast[ptr CellArea00](self.impl), direction))

proc gtk_cell_area_get_current_path_string(self: ptr CellArea00): cstring {.
    importc, libprag.}

proc getCurrentPathString*(self: CellArea): string =
  result = $gtk_cell_area_get_current_path_string(cast[ptr CellArea00](self.impl))

proc currentPathString*(self: CellArea): string =
  result = $gtk_cell_area_get_current_path_string(cast[ptr CellArea00](self.impl))

proc gtk_cell_area_get_edit_widget(self: ptr CellArea00): ptr CellEditable00 {.
    importc, libprag.}

proc getEditWidget*(self: CellArea): CellEditable =
  let gobj = gtk_cell_area_get_edit_widget(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc editWidget*(self: CellArea): CellEditable =
  let gobj = gtk_cell_area_get_edit_widget(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_edited_cell(self: ptr CellArea00): ptr CellRenderer00 {.
    importc, libprag.}

proc getEditedCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_edited_cell(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc editedCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_edited_cell(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_cell(self: ptr CellArea00): ptr CellRenderer00 {.
    importc, libprag.}

proc getFocusCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_focus_cell(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc focusCell*(self: CellArea): CellRenderer =
  let gobj = gtk_cell_area_get_focus_cell(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_from_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00): ptr CellRenderer00 {.
    importc, libprag.}

proc getFocusFromSibling*(self: CellArea; renderer: CellRenderer): CellRenderer =
  let gobj = gtk_cell_area_get_focus_from_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_focus_siblings(self: ptr CellArea00; renderer: ptr CellRenderer00): ptr glib.List {.
    importc, libprag.}

proc getFocusSiblings*(self: CellArea; renderer: CellRenderer): seq[CellRenderer] =
  result = glistObjects2seq(CellRenderer, gtk_cell_area_get_focus_siblings(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl)), false)

proc gtk_cell_area_get_request_mode(self: ptr CellArea00): SizeRequestMode {.
    importc, libprag.}

proc getRequestMode*(self: CellArea): SizeRequestMode =
  gtk_cell_area_get_request_mode(cast[ptr CellArea00](self.impl))

proc requestMode*(self: CellArea): SizeRequestMode =
  gtk_cell_area_get_request_mode(cast[ptr CellArea00](self.impl))

proc gtk_cell_area_has_renderer(self: ptr CellArea00; renderer: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc hasRenderer*(self: CellArea; renderer: CellRenderer): bool =
  toBool(gtk_cell_area_has_renderer(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl)))

proc gtk_cell_area_inner_cell_area(self: ptr CellArea00; widget: ptr Widget00;
    cellArea: gdk.Rectangle; innerArea: var gdk.Rectangle) {.
    importc, libprag.}

proc innerCellArea*(self: CellArea; widget: Widget; cellArea: gdk.Rectangle;
    innerArea: var gdk.Rectangle) =
  gtk_cell_area_inner_cell_area(cast[ptr CellArea00](self.impl), cast[ptr Widget00](widget.impl), cellArea, innerArea)

proc gtk_cell_area_is_activatable(self: ptr CellArea00): gboolean {.
    importc, libprag.}

proc isActivatable*(self: CellArea): bool =
  toBool(gtk_cell_area_is_activatable(cast[ptr CellArea00](self.impl)))

proc gtk_cell_area_is_focus_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00;
    sibling: ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc isFocusSibling*(self: CellArea; renderer: CellRenderer;
    sibling: CellRenderer): bool =
  toBool(gtk_cell_area_is_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl)))

proc gtk_cell_area_remove(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc, libprag.}

proc remove*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_remove(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_remove_focus_sibling(self: ptr CellArea00; renderer: ptr CellRenderer00;
    sibling: ptr CellRenderer00) {.
    importc, libprag.}

proc removeFocusSibling*(self: CellArea; renderer: CellRenderer;
    sibling: CellRenderer) =
  gtk_cell_area_remove_focus_sibling(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), cast[ptr CellRenderer00](sibling.impl))

proc gtk_cell_area_request_renderer(self: ptr CellArea00; renderer: ptr CellRenderer00;
    orientation: Orientation; widget: ptr Widget00; forSize: int32; minimumSize: var int32;
    naturalSize: var int32) {.
    importc, libprag.}

proc requestRenderer*(self: CellArea; renderer: CellRenderer;
    orientation: Orientation; widget: Widget; forSize: int; minimumSize: var int = cast[var int](nil);
    naturalSize: var int = cast[var int](nil)) =
  var minimumSize_00: int32
  var naturalSize_00: int32
  gtk_cell_area_request_renderer(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl), orientation, cast[ptr Widget00](widget.impl), int32(forSize), minimumSize_00, naturalSize_00)
  if minimumSize.addr != nil:
    minimumSize = int(minimumSize_00)
  if naturalSize.addr != nil:
    naturalSize = int(naturalSize_00)

proc gtk_cell_area_set_focus_cell(self: ptr CellArea00; renderer: ptr CellRenderer00) {.
    importc, libprag.}

proc setFocusCell*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_set_focus_cell(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc `focusCell=`*(self: CellArea; renderer: CellRenderer) =
  gtk_cell_area_set_focus_cell(cast[ptr CellArea00](self.impl), cast[ptr CellRenderer00](renderer.impl))

proc gtk_cell_area_stop_editing(self: ptr CellArea00; canceled: gboolean) {.
    importc, libprag.}

proc stopEditing*(self: CellArea; canceled: bool) =
  gtk_cell_area_stop_editing(cast[ptr CellArea00](self.impl), gboolean(canceled))

type
  EntryCompletion* = ref object of gobject.Object
  EntryCompletion00* = object of gobject.Object00

proc gtk_entry_completion_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EntryCompletion()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActionActivated*(self: EntryCompletion;  p: proc (self: ptr EntryCompletion00; index: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "action-activated", cast[GCallback](p), xdata, nil, cf)

proc scCursorOnMatch*(self: EntryCompletion;  p: proc (self: ptr EntryCompletion00; model: ptr TreeModel00; iter: TreeIter; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cursor-on-match", cast[GCallback](p), xdata, nil, cf)

proc scInsertPrefix*(self: EntryCompletion;  p: proc (self: ptr EntryCompletion00; prefix: cstring; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-prefix", cast[GCallback](p), xdata, nil, cf)

proc scMatchSelected*(self: EntryCompletion;  p: proc (self: ptr EntryCompletion00; model: ptr TreeModel00; iter: TreeIter; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "match-selected", cast[GCallback](p), xdata, nil, cf)

proc scNoMatches*(self: EntryCompletion;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "no-matches", cast[GCallback](p), xdata, nil, cf)

proc gtk_entry_completion_new(): ptr EntryCompletion00 {.
    importc, libprag.}

proc newEntryCompletion*(): EntryCompletion =
  let gobj = gtk_entry_completion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryCompletion*(tdesc: typedesc): tdesc =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryCompletion*[T](result: var T) {.deprecated.} =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_new_with_area(area: ptr CellArea00): ptr EntryCompletion00 {.
    importc, libprag.}

proc newEntryCompletionWithArea*(area: CellArea): EntryCompletion =
  let gobj = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEntryCompletionWithArea*(tdesc: typedesc; area: CellArea): tdesc =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEntryCompletionWithArea*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is EntryCompletion)
  let gobj = gtk_entry_completion_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_complete(self: ptr EntryCompletion00) {.
    importc, libprag.}

proc complete*(self: EntryCompletion) =
  gtk_entry_completion_complete(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_compute_prefix(self: ptr EntryCompletion00; key: cstring): cstring {.
    importc, libprag.}

proc computePrefix*(self: EntryCompletion; key: cstring): string =
  let resul0 = gtk_entry_completion_compute_prefix(cast[ptr EntryCompletion00](self.impl), key)
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_entry_completion_delete_action(self: ptr EntryCompletion00; index: int32) {.
    importc, libprag.}

proc deleteAction*(self: EntryCompletion; index: int) =
  gtk_entry_completion_delete_action(cast[ptr EntryCompletion00](self.impl), int32(index))

proc gtk_entry_completion_get_completion_prefix(self: ptr EntryCompletion00): cstring {.
    importc, libprag.}

proc getCompletionPrefix*(self: EntryCompletion): string =
  result = $gtk_entry_completion_get_completion_prefix(cast[ptr EntryCompletion00](self.impl))

proc completionPrefix*(self: EntryCompletion): string =
  result = $gtk_entry_completion_get_completion_prefix(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_get_entry(self: ptr EntryCompletion00): ptr Widget00 {.
    importc, libprag.}

proc getEntry*(self: EntryCompletion): Widget =
  let gobj = gtk_entry_completion_get_entry(cast[ptr EntryCompletion00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc entry*(self: EntryCompletion): Widget =
  let gobj = gtk_entry_completion_get_entry(cast[ptr EntryCompletion00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_get_inline_completion(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getInlineCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_completion(cast[ptr EntryCompletion00](self.impl)))

proc inlineCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_completion(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_inline_selection(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getInlineSelection*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_selection(cast[ptr EntryCompletion00](self.impl)))

proc inlineSelection*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_inline_selection(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_minimum_key_length(self: ptr EntryCompletion00): int32 {.
    importc, libprag.}

proc getMinimumKeyLength*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_minimum_key_length(cast[ptr EntryCompletion00](self.impl)))

proc minimumKeyLength*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_minimum_key_length(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_model(self: ptr EntryCompletion00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: EntryCompletion): TreeModel =
  let gobj = gtk_entry_completion_get_model(cast[ptr EntryCompletion00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: EntryCompletion): TreeModel =
  let gobj = gtk_entry_completion_get_model(cast[ptr EntryCompletion00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_completion_get_popup_completion(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getPopupCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_completion(cast[ptr EntryCompletion00](self.impl)))

proc popupCompletion*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_completion(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_popup_set_width(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getPopupSetWidth*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_set_width(cast[ptr EntryCompletion00](self.impl)))

proc popupSetWidth*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_set_width(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_popup_single_match(self: ptr EntryCompletion00): gboolean {.
    importc, libprag.}

proc getPopupSingleMatch*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_single_match(cast[ptr EntryCompletion00](self.impl)))

proc popupSingleMatch*(self: EntryCompletion): bool =
  toBool(gtk_entry_completion_get_popup_single_match(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_get_text_column(self: ptr EntryCompletion00): int32 {.
    importc, libprag.}

proc getTextColumn*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_text_column(cast[ptr EntryCompletion00](self.impl)))

proc textColumn*(self: EntryCompletion): int =
  int(gtk_entry_completion_get_text_column(cast[ptr EntryCompletion00](self.impl)))

proc gtk_entry_completion_insert_action_markup(self: ptr EntryCompletion00;
    index: int32; markup: cstring) {.
    importc, libprag.}

proc insertActionMarkup*(self: EntryCompletion; index: int;
    markup: cstring) =
  gtk_entry_completion_insert_action_markup(cast[ptr EntryCompletion00](self.impl), int32(index), markup)

proc gtk_entry_completion_insert_action_text(self: ptr EntryCompletion00;
    index: int32; text: cstring) {.
    importc, libprag.}

proc insertActionText*(self: EntryCompletion; index: int;
    text: cstring) =
  gtk_entry_completion_insert_action_text(cast[ptr EntryCompletion00](self.impl), int32(index), text)

proc gtk_entry_completion_insert_prefix(self: ptr EntryCompletion00) {.
    importc, libprag.}

proc insertPrefix*(self: EntryCompletion) =
  gtk_entry_completion_insert_prefix(cast[ptr EntryCompletion00](self.impl))

proc gtk_entry_completion_set_inline_completion(self: ptr EntryCompletion00;
    inlineCompletion: gboolean) {.
    importc, libprag.}

proc setInlineCompletion*(self: EntryCompletion; inlineCompletion: bool = true) =
  gtk_entry_completion_set_inline_completion(cast[ptr EntryCompletion00](self.impl), gboolean(inlineCompletion))

proc `inlineCompletion=`*(self: EntryCompletion; inlineCompletion: bool) =
  gtk_entry_completion_set_inline_completion(cast[ptr EntryCompletion00](self.impl), gboolean(inlineCompletion))

proc gtk_entry_completion_set_inline_selection(self: ptr EntryCompletion00;
    inlineSelection: gboolean) {.
    importc, libprag.}

proc setInlineSelection*(self: EntryCompletion; inlineSelection: bool = true) =
  gtk_entry_completion_set_inline_selection(cast[ptr EntryCompletion00](self.impl), gboolean(inlineSelection))

proc `inlineSelection=`*(self: EntryCompletion; inlineSelection: bool) =
  gtk_entry_completion_set_inline_selection(cast[ptr EntryCompletion00](self.impl), gboolean(inlineSelection))

proc gtk_entry_completion_set_minimum_key_length(self: ptr EntryCompletion00;
    length: int32) {.
    importc, libprag.}

proc setMinimumKeyLength*(self: EntryCompletion; length: int) =
  gtk_entry_completion_set_minimum_key_length(cast[ptr EntryCompletion00](self.impl), int32(length))

proc `minimumKeyLength=`*(self: EntryCompletion; length: int) =
  gtk_entry_completion_set_minimum_key_length(cast[ptr EntryCompletion00](self.impl), int32(length))

proc gtk_entry_completion_set_model(self: ptr EntryCompletion00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: EntryCompletion; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_entry_completion_set_model(cast[ptr EntryCompletion00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: EntryCompletion; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_entry_completion_set_model(cast[ptr EntryCompletion00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_entry_completion_set_popup_completion(self: ptr EntryCompletion00;
    popupCompletion: gboolean) {.
    importc, libprag.}

proc setPopupCompletion*(self: EntryCompletion; popupCompletion: bool = true) =
  gtk_entry_completion_set_popup_completion(cast[ptr EntryCompletion00](self.impl), gboolean(popupCompletion))

proc `popupCompletion=`*(self: EntryCompletion; popupCompletion: bool) =
  gtk_entry_completion_set_popup_completion(cast[ptr EntryCompletion00](self.impl), gboolean(popupCompletion))

proc gtk_entry_completion_set_popup_set_width(self: ptr EntryCompletion00;
    popupSetWidth: gboolean) {.
    importc, libprag.}

proc setPopupSetWidth*(self: EntryCompletion; popupSetWidth: bool = true) =
  gtk_entry_completion_set_popup_set_width(cast[ptr EntryCompletion00](self.impl), gboolean(popupSetWidth))

proc `popupSetWidth=`*(self: EntryCompletion; popupSetWidth: bool) =
  gtk_entry_completion_set_popup_set_width(cast[ptr EntryCompletion00](self.impl), gboolean(popupSetWidth))

proc gtk_entry_completion_set_popup_single_match(self: ptr EntryCompletion00;
    popupSingleMatch: gboolean) {.
    importc, libprag.}

proc setPopupSingleMatch*(self: EntryCompletion; popupSingleMatch: bool = true) =
  gtk_entry_completion_set_popup_single_match(cast[ptr EntryCompletion00](self.impl), gboolean(popupSingleMatch))

proc `popupSingleMatch=`*(self: EntryCompletion; popupSingleMatch: bool) =
  gtk_entry_completion_set_popup_single_match(cast[ptr EntryCompletion00](self.impl), gboolean(popupSingleMatch))

proc gtk_entry_completion_set_text_column(self: ptr EntryCompletion00; column: int32) {.
    importc, libprag.}

proc setTextColumn*(self: EntryCompletion; column: int) =
  gtk_entry_completion_set_text_column(cast[ptr EntryCompletion00](self.impl), int32(column))

proc `textColumn=`*(self: EntryCompletion; column: int) =
  gtk_entry_completion_set_text_column(cast[ptr EntryCompletion00](self.impl), int32(column))

proc gtk_combo_box_new_with_area(area: ptr CellArea00): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithArea*(area: CellArea): ComboBox =
  let gobj = gtk_combo_box_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithArea*(tdesc: typedesc; area: CellArea): tdesc =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithArea*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_area_and_entry(area: ptr CellArea00): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithAreaAndEntry*(area: CellArea): ComboBox =
  let gobj = gtk_combo_box_new_with_area_and_entry(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithAreaAndEntry*(tdesc: typedesc; area: CellArea): tdesc =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_area_and_entry(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithAreaAndEntry*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_area_and_entry(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_model(model: ptr TreeModel00): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithModel*(model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): ComboBox =
  let gobj = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithModel*(tdesc: typedesc; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): tdesc =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithModel*[T](result: var T; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_new_with_model_and_entry(model: ptr TreeModel00): ptr ComboBox00 {.
    importc, libprag.}

proc newComboBoxWithModelAndEntry*(model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): ComboBox =
  let gobj = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newComboBoxWithModelAndEntry*(tdesc: typedesc; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): tdesc =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initComboBoxWithModelAndEntry*[T](result: var T; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) {.deprecated.} =
  assert(result is ComboBox)
  let gobj = gtk_combo_box_new_with_model_and_entry(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_get_model(self: ptr ComboBox00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: ComboBox): TreeModel =
  let gobj = gtk_combo_box_get_model(cast[ptr ComboBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: ComboBox): TreeModel =
  let gobj = gtk_combo_box_get_model(cast[ptr ComboBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_combo_box_set_model(self: ptr ComboBox00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: ComboBox; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_combo_box_set_model(cast[ptr ComboBox00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: ComboBox; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_combo_box_set_model(cast[ptr ComboBox00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_entry_get_completion(self: ptr Entry00): ptr EntryCompletion00 {.
    importc, libprag.}

proc getCompletion*(self: Entry): EntryCompletion =
  let gobj = gtk_entry_get_completion(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc completion*(self: Entry): EntryCompletion =
  let gobj = gtk_entry_get_completion(cast[ptr Entry00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_entry_set_completion(self: ptr Entry00; completion: ptr EntryCompletion00) {.
    importc, libprag.}

proc setCompletion*(self: Entry; completion: EntryCompletion = nil) =
  gtk_entry_set_completion(cast[ptr Entry00](self.impl), if completion.isNil: nil else: cast[ptr EntryCompletion00](completion.impl))

proc `completion=`*(self: Entry; completion: EntryCompletion = nil) =
  gtk_entry_set_completion(cast[ptr Entry00](self.impl), if completion.isNil: nil else: cast[ptr EntryCompletion00](completion.impl))

proc gtk_tree_model_sort_new_with_model(childModel: ptr TreeModel00): ptr TreeModelSort00 {.
    importc, libprag.}

proc newTreeModelSortWithModel*(childModel: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): TreeModelSort =
  let gobj = gtk_tree_model_sort_new_with_model(cast[ptr TreeModel00](childModel.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeModelSortWithModel*(tdesc: typedesc; childModel: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): tdesc =
  assert(result is TreeModelSort)
  let gobj = gtk_tree_model_sort_new_with_model(cast[ptr TreeModel00](childModel.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeModelSortWithModel*[T](result: var T; childModel: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) {.deprecated.} =
  assert(result is TreeModelSort)
  let gobj = gtk_tree_model_sort_new_with_model(cast[ptr TreeModel00](childModel.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_model_sort_get_model(self: ptr TreeModelSort00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeModelSort): TreeModel =
  let gobj = gtk_tree_model_sort_get_model(cast[ptr TreeModelSort00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeModelSort): TreeModel =
  let gobj = gtk_tree_model_sort_get_model(cast[ptr TreeModelSort00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_model_filter_get_model(self: ptr TreeModelFilter00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeModelFilter): TreeModel =
  let gobj = gtk_tree_model_filter_get_model(cast[ptr TreeModelFilter00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeModelFilter): TreeModel =
  let gobj = gtk_tree_model_filter_get_model(cast[ptr TreeModelFilter00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TreeModelFlag* {.size: sizeof(cint), pure.} = enum
    itersPersist = 0
    listOnly = 1

  TreeModelFlags* {.size: sizeof(cint).} = set[TreeModelFlag]

proc gtk_tree_model_get_flags(self: ptr TreeModel00): TreeModelFlags {.
    importc, libprag.}

proc getFlags*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): TreeModelFlags =
  gtk_tree_model_get_flags(cast[ptr TreeModel00](self.impl))

proc flags*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): TreeModelFlags =
  gtk_tree_model_get_flags(cast[ptr TreeModel00](self.impl))

type
  CellAreaContext* = ref object of gobject.Object
  CellAreaContext00* = object of gobject.Object00

proc gtk_cell_area_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellAreaContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_area_context_allocate(self: ptr CellAreaContext00; width: int32;
    height: int32) {.
    importc, libprag.}

proc allocate*(self: CellAreaContext; width: int; height: int) =
  gtk_cell_area_context_allocate(cast[ptr CellAreaContext00](self.impl), int32(width), int32(height))

proc gtk_cell_area_context_get_allocation(self: ptr CellAreaContext00; width: var int32;
    height: var int32) {.
    importc, libprag.}

proc getAllocation*(self: CellAreaContext; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var width_00: int32
  var height_00: int32
  gtk_cell_area_context_get_allocation(cast[ptr CellAreaContext00](self.impl), width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_cell_area_context_get_area(self: ptr CellAreaContext00): ptr CellArea00 {.
    importc, libprag.}

proc getArea*(self: CellAreaContext): CellArea =
  let gobj = gtk_cell_area_context_get_area(cast[ptr CellAreaContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc area*(self: CellAreaContext): CellArea =
  let gobj = gtk_cell_area_context_get_area(cast[ptr CellAreaContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_context_get_preferred_height(self: ptr CellAreaContext00;
    minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeight*(self: CellAreaContext; minimumHeight: var int = cast[var int](nil);
    naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_context_get_preferred_height(cast[ptr CellAreaContext00](self.impl), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_context_get_preferred_height_for_width(self: ptr CellAreaContext00;
    width: int32; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeightForWidth*(self: CellAreaContext;
    width: int; minimumHeight: var int = cast[var int](nil); naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_context_get_preferred_height_for_width(cast[ptr CellAreaContext00](self.impl), int32(width), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_context_get_preferred_width(self: ptr CellAreaContext00;
    minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidth*(self: CellAreaContext; minimumWidth: var int = cast[var int](nil);
    naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_context_get_preferred_width(cast[ptr CellAreaContext00](self.impl), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_context_get_preferred_width_for_height(self: ptr CellAreaContext00;
    height: int32; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidthForHeight*(self: CellAreaContext;
    height: int; minimumWidth: var int = cast[var int](nil); naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_context_get_preferred_width_for_height(cast[ptr CellAreaContext00](self.impl), int32(height), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_context_push_preferred_height(self: ptr CellAreaContext00;
    minimumHeight: int32; naturalHeight: int32) {.
    importc, libprag.}

proc pushPreferredHeight*(self: CellAreaContext; minimumHeight: int;
    naturalHeight: int) =
  gtk_cell_area_context_push_preferred_height(cast[ptr CellAreaContext00](self.impl), int32(minimumHeight), int32(naturalHeight))

proc gtk_cell_area_context_push_preferred_width(self: ptr CellAreaContext00;
    minimumWidth: int32; naturalWidth: int32) {.
    importc, libprag.}

proc pushPreferredWidth*(self: CellAreaContext; minimumWidth: int;
    naturalWidth: int) =
  gtk_cell_area_context_push_preferred_width(cast[ptr CellAreaContext00](self.impl), int32(minimumWidth), int32(naturalWidth))

proc gtk_cell_area_context_reset(self: ptr CellAreaContext00) {.
    importc, libprag.}

proc reset*(self: CellAreaContext) =
  gtk_cell_area_context_reset(cast[ptr CellAreaContext00](self.impl))

proc gtk_cell_area_activate(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; cellArea: gdk.Rectangle; flags: CellRendererState;
    editOnly: gboolean): gboolean {.
    importc, libprag.}

proc activate*(self: CellArea; context: CellAreaContext; widget: Widget;
    cellArea: gdk.Rectangle; flags: CellRendererState; editOnly: bool): bool =
  toBool(gtk_cell_area_activate(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cellArea, flags, gboolean(editOnly)))

proc gtk_cell_area_copy_context(self: ptr CellArea00; context: ptr CellAreaContext00): ptr CellAreaContext00 {.
    importc, libprag.}

proc copyContext*(self: CellArea; context: CellAreaContext): CellAreaContext =
  let gobj = gtk_cell_area_copy_context(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_create_context(self: ptr CellArea00): ptr CellAreaContext00 {.
    importc, libprag.}

proc createContext*(self: CellArea): CellAreaContext =
  let gobj = gtk_cell_area_create_context(cast[ptr CellArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_event(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; event: ptr gdk.Event00; cellArea: gdk.Rectangle;
    flags: CellRendererState): int32 {.
    importc, libprag.}

proc event*(self: CellArea; context: CellAreaContext; widget: Widget;
    event: gdk.Event; cellArea: gdk.Rectangle; flags: CellRendererState): int =
  int(gtk_cell_area_event(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Event00](event.impl), cellArea, flags))

proc gtk_cell_area_get_cell_allocation(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; renderer: ptr CellRenderer00; cellArea: gdk.Rectangle;
    allocation: var gdk.Rectangle) {.
    importc, libprag.}

proc getCellAllocation*(self: CellArea; context: CellAreaContext;
    widget: Widget; renderer: CellRenderer; cellArea: gdk.Rectangle; allocation: var gdk.Rectangle) =
  gtk_cell_area_get_cell_allocation(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr CellRenderer00](renderer.impl), cellArea, allocation)

proc gtk_cell_area_get_cell_at_position(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; cellArea: gdk.Rectangle; x: int32; y: int32; allocArea: var gdk.Rectangle): ptr CellRenderer00 {.
    importc, libprag.}

proc getCellAtPosition*(self: CellArea; context: CellAreaContext;
    widget: Widget; cellArea: gdk.Rectangle; x: int; y: int; allocArea: var gdk.Rectangle = cast[var gdk.Rectangle](nil)): CellRenderer =
  let gobj = gtk_cell_area_get_cell_at_position(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cellArea, int32(x), int32(y), allocArea)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_get_preferred_height(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeight*(self: CellArea; context: CellAreaContext;
    widget: Widget; minimumHeight: var int = cast[var int](nil); naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_get_preferred_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_get_preferred_height_for_width(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; width: int32; minimumHeight: var int32; naturalHeight: var int32) {.
    importc, libprag.}

proc getPreferredHeightForWidth*(self: CellArea; context: CellAreaContext;
    widget: Widget; width: int; minimumHeight: var int = cast[var int](nil);
    naturalHeight: var int = cast[var int](nil)) =
  var naturalHeight_00: int32
  var minimumHeight_00: int32
  gtk_cell_area_get_preferred_height_for_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(width), minimumHeight_00, naturalHeight_00)
  if naturalHeight.addr != nil:
    naturalHeight = int(naturalHeight_00)
  if minimumHeight.addr != nil:
    minimumHeight = int(minimumHeight_00)

proc gtk_cell_area_get_preferred_width(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidth*(self: CellArea; context: CellAreaContext;
    widget: Widget; minimumWidth: var int = cast[var int](nil); naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_get_preferred_width(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_get_preferred_width_for_height(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; height: int32; minimumWidth: var int32; naturalWidth: var int32) {.
    importc, libprag.}

proc getPreferredWidthForHeight*(self: CellArea; context: CellAreaContext;
    widget: Widget; height: int; minimumWidth: var int = cast[var int](nil);
    naturalWidth: var int = cast[var int](nil)) =
  var minimumWidth_00: int32
  var naturalWidth_00: int32
  gtk_cell_area_get_preferred_width_for_height(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), int32(height), minimumWidth_00, naturalWidth_00)
  if minimumWidth.addr != nil:
    minimumWidth = int(minimumWidth_00)
  if naturalWidth.addr != nil:
    naturalWidth = int(naturalWidth_00)

proc gtk_cell_area_render(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; cr: ptr cairo.Context00; backgroundArea: gdk.Rectangle;
    cellArea: gdk.Rectangle; flags: CellRendererState; paintFocus: gboolean) {.
    importc, libprag.}

proc render*(self: CellArea; context: CellAreaContext; widget: Widget;
    cr: cairo.Context; backgroundArea: gdk.Rectangle; cellArea: gdk.Rectangle;
    flags: CellRendererState; paintFocus: bool) =
  gtk_cell_area_render(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cast[ptr cairo.Context00](cr.impl), backgroundArea, cellArea, flags, gboolean(paintFocus))

type
  ActionBar* = ref object of Bin
  ActionBar00* = object of Bin00

proc gtk_action_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ActionBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_action_bar_new(): ptr ActionBar00 {.
    importc, libprag.}

proc newActionBar*(): ActionBar =
  let gobj = gtk_action_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newActionBar*(tdesc: typedesc): tdesc =
  assert(result is ActionBar)
  let gobj = gtk_action_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initActionBar*[T](result: var T) {.deprecated.} =
  assert(result is ActionBar)
  let gobj = gtk_action_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_bar_get_center_widget(self: ptr ActionBar00): ptr Widget00 {.
    importc, libprag.}

proc getCenterWidget*(self: ActionBar): Widget =
  let gobj = gtk_action_bar_get_center_widget(cast[ptr ActionBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc centerWidget*(self: ActionBar): Widget =
  let gobj = gtk_action_bar_get_center_widget(cast[ptr ActionBar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_bar_pack_end(self: ptr ActionBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packEnd*(self: ActionBar; child: Widget) =
  gtk_action_bar_pack_end(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_action_bar_pack_start(self: ptr ActionBar00; child: ptr Widget00) {.
    importc, libprag.}

proc packStart*(self: ActionBar; child: Widget) =
  gtk_action_bar_pack_start(cast[ptr ActionBar00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_action_bar_set_center_widget(self: ptr ActionBar00; centerWidget: ptr Widget00) {.
    importc, libprag.}

proc setCenterWidget*(self: ActionBar; centerWidget: Widget = nil) =
  gtk_action_bar_set_center_widget(cast[ptr ActionBar00](self.impl), if centerWidget.isNil: nil else: cast[ptr Widget00](centerWidget.impl))

proc `centerWidget=`*(self: ActionBar; centerWidget: Widget = nil) =
  gtk_action_bar_set_center_widget(cast[ptr ActionBar00](self.impl), if centerWidget.isNil: nil else: cast[ptr Widget00](centerWidget.impl))

type
  ActionEntry00* {.pure.} = object
  ActionEntry* = ref object
    impl*: ptr ActionEntry00
    ignoreFinalizer*: bool

type
  ApplicationWindow* = ref object of Window
  ApplicationWindow00* = object of Window00

proc gtk_application_window_get_type*(): GType {.importc, libprag.}

proc gtk_application_window_new(application: ptr Application00): ptr ApplicationWindow00 {.
    importc, libprag.}

proc newApplicationWindow*(application: Application): ApplicationWindow =
  let gobj = gtk_application_window_new(cast[ptr Application00](application.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newApplicationWindow*(tdesc: typedesc; application: Application): tdesc =
  assert(result is ApplicationWindow)
  let gobj = gtk_application_window_new(cast[ptr Application00](application.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initApplicationWindow*[T](result: var T; application: Application) {.deprecated.} =
  assert(result is ApplicationWindow)
  let gobj = gtk_application_window_new(cast[ptr Application00](application.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    GC_ref(result)
    result.ignoreFinalizer = true
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_window_get_id(self: ptr ApplicationWindow00): uint32 {.
    importc, libprag.}

proc getId*(self: ApplicationWindow): int =
  int(gtk_application_window_get_id(cast[ptr ApplicationWindow00](self.impl)))

proc id*(self: ApplicationWindow): int =
  int(gtk_application_window_get_id(cast[ptr ApplicationWindow00](self.impl)))

proc gtk_application_window_get_show_menubar(self: ptr ApplicationWindow00): gboolean {.
    importc, libprag.}

proc getShowMenubar*(self: ApplicationWindow): bool =
  toBool(gtk_application_window_get_show_menubar(cast[ptr ApplicationWindow00](self.impl)))

proc showMenubar*(self: ApplicationWindow): bool =
  toBool(gtk_application_window_get_show_menubar(cast[ptr ApplicationWindow00](self.impl)))

proc gtk_application_window_set_show_menubar(self: ptr ApplicationWindow00;
    showMenubar: gboolean) {.
    importc, libprag.}

proc setShowMenubar*(self: ApplicationWindow; showMenubar: bool = true) =
  gtk_application_window_set_show_menubar(cast[ptr ApplicationWindow00](self.impl), gboolean(showMenubar))

proc `showMenubar=`*(self: ApplicationWindow; showMenubar: bool) =
  gtk_application_window_set_show_menubar(cast[ptr ApplicationWindow00](self.impl), gboolean(showMenubar))

type
  ActionGroup* = ref object of gobject.Object
  ActionGroup00* = object of gobject.Object00

proc gtk_action_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ActionGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scConnectProxy*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;  p: proc (self: ptr ActionGroup00; action: ptr Action00; proxy: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "connect-proxy", cast[GCallback](p), xdata, nil, cf)

proc scDisconnectProxy*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;  p: proc (self: ptr ActionGroup00; action: ptr Action00; proxy: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "disconnect-proxy", cast[GCallback](p), xdata, nil, cf)

proc scPostActivate*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;  p: proc (self: ptr ActionGroup00; action: ptr Action00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "post-activate", cast[GCallback](p), xdata, nil, cf)

proc scPreActivate*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;  p: proc (self: ptr ActionGroup00; action: ptr Action00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pre-activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_action_group_new(name: cstring): ptr ActionGroup00 {.
    importc, libprag.}

proc newActionGroup*(name: cstring): ActionGroup {.deprecated.}  =
  let gobj = gtk_action_group_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newActionGroup*(tdesc: typedesc; name: cstring): tdesc {.deprecated.}  =
  assert(result is ActionGroup)
  let gobj = gtk_action_group_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initActionGroup*[T](result: var T; name: cstring) {.deprecated.} =
  assert(result is ActionGroup)
  let gobj = gtk_action_group_new(name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_group_add_action(self: ptr ActionGroup00; action: ptr Action00) {.
    importc, libprag.}

proc addAction*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    action: Action) =
  gtk_action_group_add_action(cast[ptr ActionGroup00](self.impl), cast[ptr Action00](action.impl))

proc gtk_action_group_add_action_with_accel(self: ptr ActionGroup00; action: ptr Action00;
    accelerator: cstring) {.
    importc, libprag.}

proc addActionWithAccel*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    action: Action; accelerator: cstring = nil) =
  gtk_action_group_add_action_with_accel(cast[ptr ActionGroup00](self.impl), cast[ptr Action00](action.impl), accelerator)

proc gtk_action_group_get_accel_group(self: ptr ActionGroup00): ptr AccelGroup00 {.
    importc, libprag.}

proc getAccelGroup*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): AccelGroup =
  let gobj = gtk_action_group_get_accel_group(cast[ptr ActionGroup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelGroup*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): AccelGroup =
  let gobj = gtk_action_group_get_accel_group(cast[ptr ActionGroup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_group_get_action(self: ptr ActionGroup00; actionName: cstring): ptr Action00 {.
    importc, libprag.}

proc getAction*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    actionName: cstring): Action =
  let gobj = gtk_action_group_get_action(cast[ptr ActionGroup00](self.impl), actionName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_action_group_get_name(self: ptr ActionGroup00): cstring {.
    importc, libprag.}

proc getName*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): string =
  result = $gtk_action_group_get_name(cast[ptr ActionGroup00](self.impl))

proc name*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): string =
  result = $gtk_action_group_get_name(cast[ptr ActionGroup00](self.impl))

proc gtk_action_group_get_sensitive(self: ptr ActionGroup00): gboolean {.
    importc, libprag.}

proc getSensitive*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): bool =
  toBool(gtk_action_group_get_sensitive(cast[ptr ActionGroup00](self.impl)))

proc sensitive*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): bool =
  toBool(gtk_action_group_get_sensitive(cast[ptr ActionGroup00](self.impl)))

proc gtk_action_group_get_visible(self: ptr ActionGroup00): gboolean {.
    importc, libprag.}

proc getVisible*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): bool =
  toBool(gtk_action_group_get_visible(cast[ptr ActionGroup00](self.impl)))

proc visible*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): bool =
  toBool(gtk_action_group_get_visible(cast[ptr ActionGroup00](self.impl)))

proc gtk_action_group_list_actions(self: ptr ActionGroup00): ptr glib.List {.
    importc, libprag.}

proc listActions*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow): seq[Action] =
  let resul0 = gtk_action_group_list_actions(cast[ptr ActionGroup00](self.impl))
  result = glistObjects2seq(Action, resul0, false)
  g_list_free(resul0)

proc gtk_action_group_remove_action(self: ptr ActionGroup00; action: ptr Action00) {.
    importc, libprag.}

proc removeAction*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    action: Action) =
  gtk_action_group_remove_action(cast[ptr ActionGroup00](self.impl), cast[ptr Action00](action.impl))

proc gtk_action_group_set_accel_group(self: ptr ActionGroup00; accelGroup: ptr AccelGroup00) {.
    importc, libprag.}

proc setAccelGroup*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    accelGroup: AccelGroup = nil) =
  gtk_action_group_set_accel_group(cast[ptr ActionGroup00](self.impl), if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    accelGroup: AccelGroup = nil) =
  gtk_action_group_set_accel_group(cast[ptr ActionGroup00](self.impl), if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_action_group_set_sensitive(self: ptr ActionGroup00; sensitive: gboolean) {.
    importc, libprag.}

proc setSensitive*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    sensitive: bool = true) =
  gtk_action_group_set_sensitive(cast[ptr ActionGroup00](self.impl), gboolean(sensitive))

proc `sensitive=`*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    sensitive: bool) =
  gtk_action_group_set_sensitive(cast[ptr ActionGroup00](self.impl), gboolean(sensitive))

proc gtk_action_group_set_translation_domain(self: ptr ActionGroup00; domain: cstring) {.
    importc, libprag.}

proc setTranslationDomain*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    domain: cstring = nil) =
  gtk_action_group_set_translation_domain(cast[ptr ActionGroup00](self.impl), domain)

proc `translationDomain=`*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    domain: cstring = nil) =
  gtk_action_group_set_translation_domain(cast[ptr ActionGroup00](self.impl), domain)

proc gtk_action_group_set_visible(self: ptr ActionGroup00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    visible: bool = true) =
  gtk_action_group_set_visible(cast[ptr ActionGroup00](self.impl), gboolean(visible))

proc `visible=`*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    visible: bool) =
  gtk_action_group_set_visible(cast[ptr ActionGroup00](self.impl), gboolean(visible))

proc gtk_action_group_translate_string(self: ptr ActionGroup00; string: cstring): cstring {.
    importc, libprag.}

proc translateString*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    string: cstring): string =
  result = $gtk_action_group_translate_string(cast[ptr ActionGroup00](self.impl), string)

type
  ShortcutsWindow* = ref object of Window
  ShortcutsWindow00* = object of Window00

proc gtk_shortcuts_window_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsWindow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClose*(self: ShortcutsWindow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scSearch*(self: ShortcutsWindow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "search", cast[GCallback](p), xdata, nil, cf)

proc gtk_application_window_get_help_overlay(self: ptr ApplicationWindow00): ptr ShortcutsWindow00 {.
    importc, libprag.}

proc getHelpOverlay*(self: ApplicationWindow): ShortcutsWindow =
  let gobj = gtk_application_window_get_help_overlay(cast[ptr ApplicationWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc helpOverlay*(self: ApplicationWindow): ShortcutsWindow =
  let gobj = gtk_application_window_get_help_overlay(cast[ptr ApplicationWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_application_window_set_help_overlay(self: ptr ApplicationWindow00;
    helpOverlay: ptr ShortcutsWindow00) {.
    importc, libprag.}

proc setHelpOverlay*(self: ApplicationWindow; helpOverlay: ShortcutsWindow = nil) =
  gtk_application_window_set_help_overlay(cast[ptr ApplicationWindow00](self.impl), if helpOverlay.isNil: nil else: cast[ptr ShortcutsWindow00](helpOverlay.impl))

proc `helpOverlay=`*(self: ApplicationWindow; helpOverlay: ShortcutsWindow = nil) =
  gtk_application_window_set_help_overlay(cast[ptr ApplicationWindow00](self.impl), if helpOverlay.isNil: nil else: cast[ptr ShortcutsWindow00](helpOverlay.impl))

type
  Actionable00* = object of gobject.Object00
  Actionable* = ref object of gobject.Object

type
  TearoffMenuItem* = ref object of MenuItem
  TearoffMenuItem00* = object of MenuItem00

proc gtk_tearoff_menu_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TearoffMenuItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tearoff_menu_item_new(): ptr TearoffMenuItem00 {.
    importc, libprag.}

proc newTearoffMenuItem*(): TearoffMenuItem {.deprecated.}  =
  let gobj = gtk_tearoff_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTearoffMenuItem*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is TearoffMenuItem)
  let gobj = gtk_tearoff_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTearoffMenuItem*[T](result: var T) {.deprecated.} =
  assert(result is TearoffMenuItem)
  let gobj = gtk_tearoff_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Button* = ref object of Bin
  Button00* = object of Bin00

proc gtk_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Button()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scClicked*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cf)

proc scEnter*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enter", cast[GCallback](p), xdata, nil, cf)

proc scLeave*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "leave", cast[GCallback](p), xdata, nil, cf)

proc scPressed*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cf)

proc scReleased*(self: Button;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "released", cast[GCallback](p), xdata, nil, cf)

proc gtk_button_new(): ptr Button00 {.
    importc, libprag.}

proc newButton*(): Button =
  let gobj = gtk_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButton*(tdesc: typedesc): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButton*[T](result: var T) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_from_icon_name(iconName: cstring; size: int32): ptr Button00 {.
    importc, libprag.}

proc newButtonFromIconName*(iconName: cstring = nil; size: int): Button =
  let gobj = gtk_button_new_from_icon_name(iconName, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButtonFromIconName*(tdesc: typedesc; iconName: cstring = nil; size: int): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new_from_icon_name(iconName, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonFromIconName*[T](result: var T; iconName: cstring = nil; size: int) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new_from_icon_name(iconName, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_from_stock(stockId: cstring): ptr Button00 {.
    importc, libprag.}

proc newButtonFromStock*(stockId: cstring): Button {.deprecated.}  =
  let gobj = gtk_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButtonFromStock*(tdesc: typedesc; stockId: cstring): tdesc {.deprecated.}  =
  assert(result is Button)
  let gobj = gtk_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonFromStock*[T](result: var T; stockId: cstring) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_with_label(label: cstring): ptr Button00 {.
    importc, libprag.}

proc newButton*(label: cstring): Button =
  let gobj = gtk_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButton*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButton*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_new_with_mnemonic(label: cstring): ptr Button00 {.
    importc, libprag.}

proc newButtonWithMnemonic*(label: cstring): Button =
  let gobj = gtk_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButtonWithMnemonic*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is Button)
  let gobj = gtk_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is Button)
  let gobj = gtk_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_clicked(self: ptr Button00) {.
    importc, libprag.}

proc clicked*(self: Button) =
  gtk_button_clicked(cast[ptr Button00](self.impl))

proc gtk_button_enter(self: ptr Button00) {.
    importc, libprag.}

proc enter*(self: Button) =
  gtk_button_enter(cast[ptr Button00](self.impl))

proc gtk_button_get_alignment(self: ptr Button00; xalign: var cfloat; yalign: var cfloat) {.
    importc, libprag.}

proc getAlignment*(self: Button; xalign: var cfloat; yalign: var cfloat) =
  gtk_button_get_alignment(cast[ptr Button00](self.impl), xalign, yalign)

proc gtk_button_get_always_show_image(self: ptr Button00): gboolean {.
    importc, libprag.}

proc getAlwaysShowImage*(self: Button): bool =
  toBool(gtk_button_get_always_show_image(cast[ptr Button00](self.impl)))

proc alwaysShowImage*(self: Button): bool =
  toBool(gtk_button_get_always_show_image(cast[ptr Button00](self.impl)))

proc gtk_button_get_event_window(self: ptr Button00): ptr gdk.Window00 {.
    importc, libprag.}

proc getEventWindow*(self: Button): gdk.Window =
  let gobj = gtk_button_get_event_window(cast[ptr Button00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc eventWindow*(self: Button): gdk.Window =
  let gobj = gtk_button_get_event_window(cast[ptr Button00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_get_focus_on_click(self: ptr Button00): gboolean {.
    importc, libprag.}

proc getFocusOnClick*(self: Button): bool =
  toBool(gtk_button_get_focus_on_click(cast[ptr Button00](self.impl)))

proc focusOnClick*(self: Button): bool =
  toBool(gtk_button_get_focus_on_click(cast[ptr Button00](self.impl)))

proc gtk_button_get_image(self: ptr Button00): ptr Widget00 {.
    importc, libprag.}

proc getImage*(self: Button): Widget =
  let gobj = gtk_button_get_image(cast[ptr Button00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc image*(self: Button): Widget =
  let gobj = gtk_button_get_image(cast[ptr Button00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_get_label(self: ptr Button00): cstring {.
    importc, libprag.}

proc getLabel*(self: Button): string =
  result = $gtk_button_get_label(cast[ptr Button00](self.impl))

proc label*(self: Button): string =
  result = $gtk_button_get_label(cast[ptr Button00](self.impl))

proc gtk_button_get_use_stock(self: ptr Button00): gboolean {.
    importc, libprag.}

proc getUseStock*(self: Button): bool =
  toBool(gtk_button_get_use_stock(cast[ptr Button00](self.impl)))

proc useStock*(self: Button): bool =
  toBool(gtk_button_get_use_stock(cast[ptr Button00](self.impl)))

proc gtk_button_get_use_underline(self: ptr Button00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: Button): bool =
  toBool(gtk_button_get_use_underline(cast[ptr Button00](self.impl)))

proc useUnderline*(self: Button): bool =
  toBool(gtk_button_get_use_underline(cast[ptr Button00](self.impl)))

proc gtk_button_leave(self: ptr Button00) {.
    importc, libprag.}

proc leave*(self: Button) =
  gtk_button_leave(cast[ptr Button00](self.impl))

proc gtk_button_pressed(self: ptr Button00) {.
    importc, libprag.}

proc pressed*(self: Button) =
  gtk_button_pressed(cast[ptr Button00](self.impl))

proc gtk_button_released(self: ptr Button00) {.
    importc, libprag.}

proc released*(self: Button) =
  gtk_button_released(cast[ptr Button00](self.impl))

proc gtk_button_set_alignment(self: ptr Button00; xalign: cfloat; yalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: Button; xalign: cfloat; yalign: cfloat) =
  gtk_button_set_alignment(cast[ptr Button00](self.impl), xalign, yalign)

proc gtk_button_set_always_show_image(self: ptr Button00; alwaysShow: gboolean) {.
    importc, libprag.}

proc setAlwaysShowImage*(self: Button; alwaysShow: bool = true) =
  gtk_button_set_always_show_image(cast[ptr Button00](self.impl), gboolean(alwaysShow))

proc `alwaysShowImage=`*(self: Button; alwaysShow: bool) =
  gtk_button_set_always_show_image(cast[ptr Button00](self.impl), gboolean(alwaysShow))

proc gtk_button_set_focus_on_click(self: ptr Button00; focusOnClick: gboolean) {.
    importc, libprag.}

proc setFocusOnClick*(self: Button; focusOnClick: bool = true) =
  gtk_button_set_focus_on_click(cast[ptr Button00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: Button; focusOnClick: bool) =
  gtk_button_set_focus_on_click(cast[ptr Button00](self.impl), gboolean(focusOnClick))

proc gtk_button_set_image(self: ptr Button00; image: ptr Widget00) {.
    importc, libprag.}

proc setImage*(self: Button; image: Widget = nil) =
  gtk_button_set_image(cast[ptr Button00](self.impl), if image.isNil: nil else: cast[ptr Widget00](image.impl))

proc `image=`*(self: Button; image: Widget = nil) =
  gtk_button_set_image(cast[ptr Button00](self.impl), if image.isNil: nil else: cast[ptr Widget00](image.impl))

proc gtk_button_set_label(self: ptr Button00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: Button; label: cstring) =
  gtk_button_set_label(cast[ptr Button00](self.impl), label)

proc `label=`*(self: Button; label: cstring) =
  gtk_button_set_label(cast[ptr Button00](self.impl), label)

proc gtk_button_set_use_stock(self: ptr Button00; useStock: gboolean) {.
    importc, libprag.}

proc setUseStock*(self: Button; useStock: bool = true) =
  gtk_button_set_use_stock(cast[ptr Button00](self.impl), gboolean(useStock))

proc `useStock=`*(self: Button; useStock: bool) =
  gtk_button_set_use_stock(cast[ptr Button00](self.impl), gboolean(useStock))

proc gtk_button_set_use_underline(self: ptr Button00; useUnderline: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: Button; useUnderline: bool = true) =
  gtk_button_set_use_underline(cast[ptr Button00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: Button; useUnderline: bool) =
  gtk_button_set_use_underline(cast[ptr Button00](self.impl), gboolean(useUnderline))

type
  ToggleButton* = ref object of Button
  ToggleButton00* = object of Button00

proc gtk_toggle_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToggleButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scToggled*(self: ToggleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_toggle_button_new(): ptr ToggleButton00 {.
    importc, libprag.}

proc newToggleButton*(): ToggleButton =
  let gobj = gtk_toggle_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleButton*(tdesc: typedesc): tdesc =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButton*[T](result: var T) {.deprecated.} =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_new_with_label(label: cstring): ptr ToggleButton00 {.
    importc, libprag.}

proc newToggleButton*(label: cstring): ToggleButton =
  let gobj = gtk_toggle_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleButton*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButton*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_new_with_mnemonic(label: cstring): ptr ToggleButton00 {.
    importc, libprag.}

proc newToggleButtonWithMnemonic*(label: cstring): ToggleButton =
  let gobj = gtk_toggle_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleButtonWithMnemonic*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleButtonWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is ToggleButton)
  let gobj = gtk_toggle_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_button_get_active(self: ptr ToggleButton00): gboolean {.
    importc, libprag.}

proc getActive*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_active(cast[ptr ToggleButton00](self.impl)))

proc active*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_active(cast[ptr ToggleButton00](self.impl)))

proc gtk_toggle_button_get_inconsistent(self: ptr ToggleButton00): gboolean {.
    importc, libprag.}

proc getInconsistent*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_inconsistent(cast[ptr ToggleButton00](self.impl)))

proc inconsistent*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_inconsistent(cast[ptr ToggleButton00](self.impl)))

proc gtk_toggle_button_get_mode(self: ptr ToggleButton00): gboolean {.
    importc, libprag.}

proc getMode*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_mode(cast[ptr ToggleButton00](self.impl)))

proc mode*(self: ToggleButton): bool =
  toBool(gtk_toggle_button_get_mode(cast[ptr ToggleButton00](self.impl)))

proc gtk_toggle_button_set_active(self: ptr ToggleButton00; isActive: gboolean) {.
    importc, libprag.}

proc setActive*(self: ToggleButton; isActive: bool = true) =
  gtk_toggle_button_set_active(cast[ptr ToggleButton00](self.impl), gboolean(isActive))

proc `active=`*(self: ToggleButton; isActive: bool) =
  gtk_toggle_button_set_active(cast[ptr ToggleButton00](self.impl), gboolean(isActive))

proc gtk_toggle_button_set_inconsistent(self: ptr ToggleButton00; setting: gboolean) {.
    importc, libprag.}

proc setInconsistent*(self: ToggleButton; setting: bool = true) =
  gtk_toggle_button_set_inconsistent(cast[ptr ToggleButton00](self.impl), gboolean(setting))

proc `inconsistent=`*(self: ToggleButton; setting: bool) =
  gtk_toggle_button_set_inconsistent(cast[ptr ToggleButton00](self.impl), gboolean(setting))

proc gtk_toggle_button_set_mode(self: ptr ToggleButton00; drawIndicator: gboolean) {.
    importc, libprag.}

proc setMode*(self: ToggleButton; drawIndicator: bool = true) =
  gtk_toggle_button_set_mode(cast[ptr ToggleButton00](self.impl), gboolean(drawIndicator))

proc `mode=`*(self: ToggleButton; drawIndicator: bool) =
  gtk_toggle_button_set_mode(cast[ptr ToggleButton00](self.impl), gboolean(drawIndicator))

proc gtk_toggle_button_toggled(self: ptr ToggleButton00) {.
    importc, libprag.}

proc toggled*(self: ToggleButton) =
  gtk_toggle_button_toggled(cast[ptr ToggleButton00](self.impl))

type
  CheckButton* = ref object of ToggleButton
  CheckButton00* = object of ToggleButton00

proc gtk_check_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CheckButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_check_button_new(): ptr CheckButton00 {.
    importc, libprag.}

proc newCheckButton*(): CheckButton =
  let gobj = gtk_check_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckButton*(tdesc: typedesc): tdesc =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButton*[T](result: var T) {.deprecated.} =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_new_with_label(label: cstring): ptr CheckButton00 {.
    importc, libprag.}

proc newCheckButton*(label: cstring): CheckButton =
  let gobj = gtk_check_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckButton*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButton*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_button_new_with_mnemonic(label: cstring): ptr CheckButton00 {.
    importc, libprag.}

proc newCheckButtonWithMnemonic*(label: cstring): CheckButton =
  let gobj = gtk_check_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckButtonWithMnemonic*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckButtonWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is CheckButton)
  let gobj = gtk_check_button_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ToolItem* = ref object of Bin
  ToolItem00* = object of Bin00

proc gtk_tool_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToolItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCreateMenuProxy*(self: ToolItem;  p: proc (self: ptr ToolItem00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "create-menu-proxy", cast[GCallback](p), xdata, nil, cf)

proc scToolbarReconfigured*(self: ToolItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toolbar-reconfigured", cast[GCallback](p), xdata, nil, cf)

proc gtk_tool_item_new(): ptr ToolItem00 {.
    importc, libprag.}

proc newToolItem*(): ToolItem =
  let gobj = gtk_tool_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToolItem*(tdesc: typedesc): tdesc =
  assert(result is ToolItem)
  let gobj = gtk_tool_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolItem*[T](result: var T) {.deprecated.} =
  assert(result is ToolItem)
  let gobj = gtk_tool_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_get_ellipsize_mode(self: ptr ToolItem00): pango.EllipsizeMode {.
    importc, libprag.}

proc getEllipsizeMode*(self: ToolItem): pango.EllipsizeMode =
  gtk_tool_item_get_ellipsize_mode(cast[ptr ToolItem00](self.impl))

proc ellipsizeMode*(self: ToolItem): pango.EllipsizeMode =
  gtk_tool_item_get_ellipsize_mode(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_expand(self: ptr ToolItem00): gboolean {.
    importc, libprag.}

proc getExpand*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_expand(cast[ptr ToolItem00](self.impl)))

proc expand*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_expand(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_homogeneous(self: ptr ToolItem00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_homogeneous(cast[ptr ToolItem00](self.impl)))

proc homogeneous*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_homogeneous(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_icon_size(self: ptr ToolItem00): int32 {.
    importc, libprag.}

proc getIconSize*(self: ToolItem): int =
  int(gtk_tool_item_get_icon_size(cast[ptr ToolItem00](self.impl)))

proc iconSize*(self: ToolItem): int =
  int(gtk_tool_item_get_icon_size(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_is_important(self: ptr ToolItem00): gboolean {.
    importc, libprag.}

proc getIsImportant*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_is_important(cast[ptr ToolItem00](self.impl)))

proc isImportant*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_is_important(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_orientation(self: ptr ToolItem00): Orientation {.
    importc, libprag.}

proc getOrientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_orientation(cast[ptr ToolItem00](self.impl))

proc orientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_orientation(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_proxy_menu_item(self: ptr ToolItem00; menuItemId: cstring): ptr Widget00 {.
    importc, libprag.}

proc getProxyMenuItem*(self: ToolItem; menuItemId: cstring): Widget =
  let gobj = gtk_tool_item_get_proxy_menu_item(cast[ptr ToolItem00](self.impl), menuItemId)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_get_text_alignment(self: ptr ToolItem00): cfloat {.
    importc, libprag.}

proc getTextAlignment*(self: ToolItem): cfloat =
  gtk_tool_item_get_text_alignment(cast[ptr ToolItem00](self.impl))

proc textAlignment*(self: ToolItem): cfloat =
  gtk_tool_item_get_text_alignment(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_text_orientation(self: ptr ToolItem00): Orientation {.
    importc, libprag.}

proc getTextOrientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_text_orientation(cast[ptr ToolItem00](self.impl))

proc textOrientation*(self: ToolItem): Orientation =
  gtk_tool_item_get_text_orientation(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_get_use_drag_window(self: ptr ToolItem00): gboolean {.
    importc, libprag.}

proc getUseDragWindow*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_use_drag_window(cast[ptr ToolItem00](self.impl)))

proc useDragWindow*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_use_drag_window(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_visible_horizontal(self: ptr ToolItem00): gboolean {.
    importc, libprag.}

proc getVisibleHorizontal*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_horizontal(cast[ptr ToolItem00](self.impl)))

proc visibleHorizontal*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_horizontal(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_get_visible_vertical(self: ptr ToolItem00): gboolean {.
    importc, libprag.}

proc getVisibleVertical*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_vertical(cast[ptr ToolItem00](self.impl)))

proc visibleVertical*(self: ToolItem): bool =
  toBool(gtk_tool_item_get_visible_vertical(cast[ptr ToolItem00](self.impl)))

proc gtk_tool_item_rebuild_menu(self: ptr ToolItem00) {.
    importc, libprag.}

proc rebuildMenu*(self: ToolItem) =
  gtk_tool_item_rebuild_menu(cast[ptr ToolItem00](self.impl))

proc gtk_tool_item_retrieve_proxy_menu_item(self: ptr ToolItem00): ptr Widget00 {.
    importc, libprag.}

proc retrieveProxyMenuItem*(self: ToolItem): Widget =
  let gobj = gtk_tool_item_retrieve_proxy_menu_item(cast[ptr ToolItem00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_set_expand(self: ptr ToolItem00; expand: gboolean) {.
    importc, libprag.}

proc setExpand*(self: ToolItem; expand: bool = true) =
  gtk_tool_item_set_expand(cast[ptr ToolItem00](self.impl), gboolean(expand))

proc `expand=`*(self: ToolItem; expand: bool) =
  gtk_tool_item_set_expand(cast[ptr ToolItem00](self.impl), gboolean(expand))

proc gtk_tool_item_set_homogeneous(self: ptr ToolItem00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: ToolItem; homogeneous: bool = true) =
  gtk_tool_item_set_homogeneous(cast[ptr ToolItem00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: ToolItem; homogeneous: bool) =
  gtk_tool_item_set_homogeneous(cast[ptr ToolItem00](self.impl), gboolean(homogeneous))

proc gtk_tool_item_set_is_important(self: ptr ToolItem00; isImportant: gboolean) {.
    importc, libprag.}

proc setIsImportant*(self: ToolItem; isImportant: bool = true) =
  gtk_tool_item_set_is_important(cast[ptr ToolItem00](self.impl), gboolean(isImportant))

proc `isImportant=`*(self: ToolItem; isImportant: bool) =
  gtk_tool_item_set_is_important(cast[ptr ToolItem00](self.impl), gboolean(isImportant))

proc gtk_tool_item_set_proxy_menu_item(self: ptr ToolItem00; menuItemId: cstring;
    menuItem: ptr Widget00) {.
    importc, libprag.}

proc setProxyMenuItem*(self: ToolItem; menuItemId: cstring;
    menuItem: Widget = nil) =
  gtk_tool_item_set_proxy_menu_item(cast[ptr ToolItem00](self.impl), menuItemId, if menuItem.isNil: nil else: cast[ptr Widget00](menuItem.impl))

proc gtk_tool_item_set_tooltip_markup(self: ptr ToolItem00; markup: cstring) {.
    importc, libprag.}

proc setTooltipMarkup*(self: ToolItem; markup: cstring) =
  gtk_tool_item_set_tooltip_markup(cast[ptr ToolItem00](self.impl), markup)

proc `tooltipMarkup=`*(self: ToolItem; markup: cstring) =
  gtk_tool_item_set_tooltip_markup(cast[ptr ToolItem00](self.impl), markup)

proc gtk_tool_item_set_tooltip_text(self: ptr ToolItem00; text: cstring) {.
    importc, libprag.}

proc setTooltipText*(self: ToolItem; text: cstring) =
  gtk_tool_item_set_tooltip_text(cast[ptr ToolItem00](self.impl), text)

proc `tooltipText=`*(self: ToolItem; text: cstring) =
  gtk_tool_item_set_tooltip_text(cast[ptr ToolItem00](self.impl), text)

proc gtk_tool_item_set_use_drag_window(self: ptr ToolItem00; useDragWindow: gboolean) {.
    importc, libprag.}

proc setUseDragWindow*(self: ToolItem; useDragWindow: bool = true) =
  gtk_tool_item_set_use_drag_window(cast[ptr ToolItem00](self.impl), gboolean(useDragWindow))

proc `useDragWindow=`*(self: ToolItem; useDragWindow: bool) =
  gtk_tool_item_set_use_drag_window(cast[ptr ToolItem00](self.impl), gboolean(useDragWindow))

proc gtk_tool_item_set_visible_horizontal(self: ptr ToolItem00; visibleHorizontal: gboolean) {.
    importc, libprag.}

proc setVisibleHorizontal*(self: ToolItem; visibleHorizontal: bool = true) =
  gtk_tool_item_set_visible_horizontal(cast[ptr ToolItem00](self.impl), gboolean(visibleHorizontal))

proc `visibleHorizontal=`*(self: ToolItem; visibleHorizontal: bool) =
  gtk_tool_item_set_visible_horizontal(cast[ptr ToolItem00](self.impl), gboolean(visibleHorizontal))

proc gtk_tool_item_set_visible_vertical(self: ptr ToolItem00; visibleVertical: gboolean) {.
    importc, libprag.}

proc setVisibleVertical*(self: ToolItem; visibleVertical: bool = true) =
  gtk_tool_item_set_visible_vertical(cast[ptr ToolItem00](self.impl), gboolean(visibleVertical))

proc `visibleVertical=`*(self: ToolItem; visibleVertical: bool) =
  gtk_tool_item_set_visible_vertical(cast[ptr ToolItem00](self.impl), gboolean(visibleVertical))

proc gtk_tool_item_toolbar_reconfigured(self: ptr ToolItem00) {.
    importc, libprag.}

proc toolbarReconfigured*(self: ToolItem) =
  gtk_tool_item_toolbar_reconfigured(cast[ptr ToolItem00](self.impl))

type
  ToolButton* = ref object of ToolItem
  ToolButton00* = object of ToolItem00

proc gtk_tool_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToolButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClicked*(self: ToolButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cf)

proc gtk_tool_button_new(iconWidget: ptr Widget00; label: cstring): ptr ToolButton00 {.
    importc, libprag.}

proc newToolButton*(iconWidget: Widget = nil; label: cstring = nil): ToolButton =
  let gobj = gtk_tool_button_new(if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToolButton*(tdesc: typedesc; iconWidget: Widget = nil; label: cstring = nil): tdesc =
  assert(result is ToolButton)
  let gobj = gtk_tool_button_new(if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolButton*[T](result: var T; iconWidget: Widget = nil; label: cstring = nil) {.deprecated.} =
  assert(result is ToolButton)
  let gobj = gtk_tool_button_new(if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_new_from_stock(stockId: cstring): ptr ToolButton00 {.
    importc, libprag.}

proc newToolButtonFromStock*(stockId: cstring): ToolButton {.deprecated.}  =
  let gobj = gtk_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToolButtonFromStock*(tdesc: typedesc; stockId: cstring): tdesc {.deprecated.}  =
  assert(result is ToolButton)
  let gobj = gtk_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolButtonFromStock*[T](result: var T; stockId: cstring) {.deprecated.} =
  assert(result is ToolButton)
  let gobj = gtk_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_get_icon_name(self: ptr ToolButton00): cstring {.
    importc, libprag.}

proc getIconName*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_icon_name(cast[ptr ToolButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_icon_name(cast[ptr ToolButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_tool_button_get_icon_widget(self: ptr ToolButton00): ptr Widget00 {.
    importc, libprag.}

proc getIconWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_icon_widget(cast[ptr ToolButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc iconWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_icon_widget(cast[ptr ToolButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_get_label(self: ptr ToolButton00): cstring {.
    importc, libprag.}

proc getLabel*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_label(cast[ptr ToolButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: ToolButton): string =
  let resul0 = gtk_tool_button_get_label(cast[ptr ToolButton00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_tool_button_get_label_widget(self: ptr ToolButton00): ptr Widget00 {.
    importc, libprag.}

proc getLabelWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_label_widget(cast[ptr ToolButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: ToolButton): Widget =
  let gobj = gtk_tool_button_get_label_widget(cast[ptr ToolButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_button_get_stock_id(self: ptr ToolButton00): cstring {.
    importc, libprag.}

proc getStockId*(self: ToolButton): string =
  result = $gtk_tool_button_get_stock_id(cast[ptr ToolButton00](self.impl))

proc stockId*(self: ToolButton): string =
  result = $gtk_tool_button_get_stock_id(cast[ptr ToolButton00](self.impl))

proc gtk_tool_button_get_use_underline(self: ptr ToolButton00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: ToolButton): bool =
  toBool(gtk_tool_button_get_use_underline(cast[ptr ToolButton00](self.impl)))

proc useUnderline*(self: ToolButton): bool =
  toBool(gtk_tool_button_get_use_underline(cast[ptr ToolButton00](self.impl)))

proc gtk_tool_button_set_icon_name(self: ptr ToolButton00; iconName: cstring) {.
    importc, libprag.}

proc setIconName*(self: ToolButton; iconName: cstring = nil) =
  gtk_tool_button_set_icon_name(cast[ptr ToolButton00](self.impl), iconName)

proc `iconName=`*(self: ToolButton; iconName: cstring = nil) =
  gtk_tool_button_set_icon_name(cast[ptr ToolButton00](self.impl), iconName)

proc gtk_tool_button_set_icon_widget(self: ptr ToolButton00; iconWidget: ptr Widget00) {.
    importc, libprag.}

proc setIconWidget*(self: ToolButton; iconWidget: Widget = nil) =
  gtk_tool_button_set_icon_widget(cast[ptr ToolButton00](self.impl), if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl))

proc `iconWidget=`*(self: ToolButton; iconWidget: Widget = nil) =
  gtk_tool_button_set_icon_widget(cast[ptr ToolButton00](self.impl), if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl))

proc gtk_tool_button_set_label(self: ptr ToolButton00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: ToolButton; label: cstring = nil) =
  gtk_tool_button_set_label(cast[ptr ToolButton00](self.impl), label)

proc `label=`*(self: ToolButton; label: cstring = nil) =
  gtk_tool_button_set_label(cast[ptr ToolButton00](self.impl), label)

proc gtk_tool_button_set_label_widget(self: ptr ToolButton00; labelWidget: ptr Widget00) {.
    importc, libprag.}

proc setLabelWidget*(self: ToolButton; labelWidget: Widget = nil) =
  gtk_tool_button_set_label_widget(cast[ptr ToolButton00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: ToolButton; labelWidget: Widget = nil) =
  gtk_tool_button_set_label_widget(cast[ptr ToolButton00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc gtk_tool_button_set_stock_id(self: ptr ToolButton00; stockId: cstring) {.
    importc, libprag.}

proc setStockId*(self: ToolButton; stockId: cstring = nil) =
  gtk_tool_button_set_stock_id(cast[ptr ToolButton00](self.impl), stockId)

proc `stockId=`*(self: ToolButton; stockId: cstring = nil) =
  gtk_tool_button_set_stock_id(cast[ptr ToolButton00](self.impl), stockId)

proc gtk_tool_button_set_use_underline(self: ptr ToolButton00; useUnderline: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: ToolButton; useUnderline: bool = true) =
  gtk_tool_button_set_use_underline(cast[ptr ToolButton00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: ToolButton; useUnderline: bool) =
  gtk_tool_button_set_use_underline(cast[ptr ToolButton00](self.impl), gboolean(useUnderline))

type
  ToggleToolButton* = ref object of ToolButton
  ToggleToolButton00* = object of ToolButton00

proc gtk_toggle_tool_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToggleToolButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scToggled*(self: ToggleToolButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_toggle_tool_button_new(): ptr ToggleToolButton00 {.
    importc, libprag.}

proc newToggleToolButton*(): ToggleToolButton =
  let gobj = gtk_toggle_tool_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleToolButton*(tdesc: typedesc): tdesc =
  assert(result is ToggleToolButton)
  let gobj = gtk_toggle_tool_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleToolButton*[T](result: var T) {.deprecated.} =
  assert(result is ToggleToolButton)
  let gobj = gtk_toggle_tool_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_tool_button_new_from_stock(stockId: cstring): ptr ToggleToolButton00 {.
    importc, libprag.}

proc newToggleToolButtonFromStock*(stockId: cstring): ToggleToolButton {.deprecated.}  =
  let gobj = gtk_toggle_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleToolButtonFromStock*(tdesc: typedesc; stockId: cstring): tdesc {.deprecated.}  =
  assert(result is ToggleToolButton)
  let gobj = gtk_toggle_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleToolButtonFromStock*[T](result: var T; stockId: cstring) {.deprecated.} =
  assert(result is ToggleToolButton)
  let gobj = gtk_toggle_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_tool_button_get_active(self: ptr ToggleToolButton00): gboolean {.
    importc, libprag.}

proc getActive*(self: ToggleToolButton): bool =
  toBool(gtk_toggle_tool_button_get_active(cast[ptr ToggleToolButton00](self.impl)))

proc active*(self: ToggleToolButton): bool =
  toBool(gtk_toggle_tool_button_get_active(cast[ptr ToggleToolButton00](self.impl)))

proc gtk_toggle_tool_button_set_active(self: ptr ToggleToolButton00; isActive: gboolean) {.
    importc, libprag.}

proc setActive*(self: ToggleToolButton; isActive: bool = true) =
  gtk_toggle_tool_button_set_active(cast[ptr ToggleToolButton00](self.impl), gboolean(isActive))

proc `active=`*(self: ToggleToolButton; isActive: bool) =
  gtk_toggle_tool_button_set_active(cast[ptr ToggleToolButton00](self.impl), gboolean(isActive))

type
  ModelButton* = ref object of Button
  ModelButton00* = object of Button00

proc gtk_model_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ModelButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_model_button_new(): ptr ModelButton00 {.
    importc, libprag.}

proc newModelButton*(): ModelButton =
  let gobj = gtk_model_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newModelButton*(tdesc: typedesc): tdesc =
  assert(result is ModelButton)
  let gobj = gtk_model_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initModelButton*[T](result: var T) {.deprecated.} =
  assert(result is ModelButton)
  let gobj = gtk_model_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ScaleButton* = ref object of Button
  ScaleButton00* = object of Button00

proc gtk_scale_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScaleButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scPopdown*(self: ScaleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popdown", cast[GCallback](p), xdata, nil, cf)

proc scPopup*(self: ScaleButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popup", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: ScaleButton;  p: proc (self: ptr ScaleButton00; value: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_scale_button_new(size: int32; min: cdouble; max: cdouble; step: cdouble;
    icons: ptr cstring): ptr ScaleButton00 {.
    importc, libprag.}

proc newScaleButton*(size: int; min: cdouble; max: cdouble; step: cdouble;
    icons: varargs[string, `$`]): ScaleButton =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  let gobj = gtk_scale_button_new(int32(size), min, max, step, seq2CstringArray(icons, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScaleButton*(tdesc: typedesc; size: int; min: cdouble; max: cdouble; step: cdouble;
    icons: varargs[string, `$`]): tdesc =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is ScaleButton)
  let gobj = gtk_scale_button_new(int32(size), min, max, step, seq2CstringArray(icons, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScaleButton*[T](result: var T; size: int; min: cdouble; max: cdouble; step: cdouble;
    icons: varargs[string, `$`]) {.deprecated.} =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  assert(result is ScaleButton)
  let gobj = gtk_scale_button_new(int32(size), min, max, step, seq2CstringArray(icons, fs469n23))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_adjustment(self: ptr ScaleButton00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: ScaleButton): Adjustment =
  let gobj = gtk_scale_button_get_adjustment(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: ScaleButton): Adjustment =
  let gobj = gtk_scale_button_get_adjustment(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_minus_button(self: ptr ScaleButton00): ptr Button00 {.
    importc, libprag.}

proc getMinusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_minus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc minusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_minus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_plus_button(self: ptr ScaleButton00): ptr Button00 {.
    importc, libprag.}

proc getPlusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_plus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc plusButton*(self: ScaleButton): Button =
  let gobj = gtk_scale_button_get_plus_button(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_popup(self: ptr ScaleButton00): ptr Widget00 {.
    importc, libprag.}

proc getPopup*(self: ScaleButton): Widget =
  let gobj = gtk_scale_button_get_popup(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popup*(self: ScaleButton): Widget =
  let gobj = gtk_scale_button_get_popup(cast[ptr ScaleButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_button_get_value(self: ptr ScaleButton00): cdouble {.
    importc, libprag.}

proc getValue*(self: ScaleButton): cdouble =
  gtk_scale_button_get_value(cast[ptr ScaleButton00](self.impl))

proc value*(self: ScaleButton): cdouble =
  gtk_scale_button_get_value(cast[ptr ScaleButton00](self.impl))

proc gtk_scale_button_set_adjustment(self: ptr ScaleButton00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: ScaleButton; adjustment: Adjustment) =
  gtk_scale_button_set_adjustment(cast[ptr ScaleButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: ScaleButton; adjustment: Adjustment) =
  gtk_scale_button_set_adjustment(cast[ptr ScaleButton00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_scale_button_set_icons(self: ptr ScaleButton00; icons: ptr cstring) {.
    importc, libprag.}

proc setIcons*(self: ScaleButton; icons: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_scale_button_set_icons(cast[ptr ScaleButton00](self.impl), seq2CstringArray(icons, fs469n23))

proc `icons=`*(self: ScaleButton; icons: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_scale_button_set_icons(cast[ptr ScaleButton00](self.impl), seq2CstringArray(icons, fs469n23))

proc gtk_scale_button_set_value(self: ptr ScaleButton00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: ScaleButton; value: cdouble) =
  gtk_scale_button_set_value(cast[ptr ScaleButton00](self.impl), value)

proc `value=`*(self: ScaleButton; value: cdouble) =
  gtk_scale_button_set_value(cast[ptr ScaleButton00](self.impl), value)

type
  Switch* = ref object of Widget
  Switch00* = object of Widget00

proc gtk_switch_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Switch()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Switch;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scStateSet*(self: Switch;  p: proc (self: ptr Switch00; state: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "state-set", cast[GCallback](p), xdata, nil, cf)

proc gtk_switch_new(): ptr Switch00 {.
    importc, libprag.}

proc newSwitch*(): Switch =
  let gobj = gtk_switch_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSwitch*(tdesc: typedesc): tdesc =
  assert(result is Switch)
  let gobj = gtk_switch_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSwitch*[T](result: var T) {.deprecated.} =
  assert(result is Switch)
  let gobj = gtk_switch_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_switch_get_active(self: ptr Switch00): gboolean {.
    importc, libprag.}

proc getActive*(self: Switch): bool =
  toBool(gtk_switch_get_active(cast[ptr Switch00](self.impl)))

proc active*(self: Switch): bool =
  toBool(gtk_switch_get_active(cast[ptr Switch00](self.impl)))

proc gtk_switch_get_state(self: ptr Switch00): gboolean {.
    importc, libprag.}

proc getState*(self: Switch): bool =
  toBool(gtk_switch_get_state(cast[ptr Switch00](self.impl)))

proc state*(self: Switch): bool =
  toBool(gtk_switch_get_state(cast[ptr Switch00](self.impl)))

proc gtk_switch_set_active(self: ptr Switch00; isActive: gboolean) {.
    importc, libprag.}

proc setActive*(self: Switch; isActive: bool = true) =
  gtk_switch_set_active(cast[ptr Switch00](self.impl), gboolean(isActive))

proc `active=`*(self: Switch; isActive: bool) =
  gtk_switch_set_active(cast[ptr Switch00](self.impl), gboolean(isActive))

proc gtk_switch_set_state(self: ptr Switch00; state: gboolean) {.
    importc, libprag.}

proc setState*(self: Switch; state: bool = true) =
  gtk_switch_set_state(cast[ptr Switch00](self.impl), gboolean(state))

proc `state=`*(self: Switch; state: bool) =
  gtk_switch_set_state(cast[ptr Switch00](self.impl), gboolean(state))

type
  RadioToolButton* = ref object of ToggleToolButton
  RadioToolButton00* = object of ToggleToolButton00

proc gtk_radio_tool_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RadioToolButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_radio_tool_button_new_from_widget(group: ptr RadioToolButton00): ptr RadioToolButton00 {.
    importc, libprag.}

proc newRadioToolButtonFromWidget*(group: RadioToolButton = nil): RadioToolButton =
  let gobj = gtk_radio_tool_button_new_from_widget(if group.isNil: nil else: cast[ptr RadioToolButton00](group.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioToolButtonFromWidget*(tdesc: typedesc; group: RadioToolButton = nil): tdesc =
  assert(result is RadioToolButton)
  let gobj = gtk_radio_tool_button_new_from_widget(if group.isNil: nil else: cast[ptr RadioToolButton00](group.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButtonFromWidget*[T](result: var T; group: RadioToolButton = nil) {.deprecated.} =
  assert(result is RadioToolButton)
  let gobj = gtk_radio_tool_button_new_from_widget(if group.isNil: nil else: cast[ptr RadioToolButton00](group.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_tool_button_new_with_stock_from_widget(group: ptr RadioToolButton00;
    stockId: cstring): ptr RadioToolButton00 {.
    importc, libprag.}

proc newRadioToolButtonWithStockFromWidget*(group: RadioToolButton = nil;
    stockId: cstring): RadioToolButton {.deprecated.}  =
  let gobj = gtk_radio_tool_button_new_with_stock_from_widget(if group.isNil: nil else: cast[ptr RadioToolButton00](group.impl), stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioToolButtonWithStockFromWidget*(tdesc: typedesc; group: RadioToolButton = nil;
    stockId: cstring): tdesc {.deprecated.}  =
  assert(result is RadioToolButton)
  let gobj = gtk_radio_tool_button_new_with_stock_from_widget(if group.isNil: nil else: cast[ptr RadioToolButton00](group.impl), stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButtonWithStockFromWidget*[T](result: var T; group: RadioToolButton = nil;
    stockId: cstring) {.deprecated.} =
  assert(result is RadioToolButton)
  let gobj = gtk_radio_tool_button_new_with_stock_from_widget(if group.isNil: nil else: cast[ptr RadioToolButton00](group.impl), stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ListBoxRow* = ref object of Bin
  ListBoxRow00* = object of Bin00

proc gtk_list_box_row_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListBoxRow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: ListBoxRow;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_list_box_row_new(): ptr ListBoxRow00 {.
    importc, libprag.}

proc newListBoxRow*(): ListBoxRow =
  let gobj = gtk_list_box_row_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newListBoxRow*(tdesc: typedesc): tdesc =
  assert(result is ListBoxRow)
  let gobj = gtk_list_box_row_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListBoxRow*[T](result: var T) {.deprecated.} =
  assert(result is ListBoxRow)
  let gobj = gtk_list_box_row_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_row_changed(self: ptr ListBoxRow00) {.
    importc, libprag.}

proc changed*(self: ListBoxRow) =
  gtk_list_box_row_changed(cast[ptr ListBoxRow00](self.impl))

proc gtk_list_box_row_get_activatable(self: ptr ListBoxRow00): gboolean {.
    importc, libprag.}

proc getActivatable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_activatable(cast[ptr ListBoxRow00](self.impl)))

proc activatable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_activatable(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_get_header(self: ptr ListBoxRow00): ptr Widget00 {.
    importc, libprag.}

proc getHeader*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_header(cast[ptr ListBoxRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc header*(self: ListBoxRow): Widget =
  let gobj = gtk_list_box_row_get_header(cast[ptr ListBoxRow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_row_get_index(self: ptr ListBoxRow00): int32 {.
    importc, libprag.}

proc getIndex*(self: ListBoxRow): int =
  int(gtk_list_box_row_get_index(cast[ptr ListBoxRow00](self.impl)))

proc index*(self: ListBoxRow): int =
  int(gtk_list_box_row_get_index(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_get_selectable(self: ptr ListBoxRow00): gboolean {.
    importc, libprag.}

proc getSelectable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_selectable(cast[ptr ListBoxRow00](self.impl)))

proc selectable*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_get_selectable(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_is_selected(self: ptr ListBoxRow00): gboolean {.
    importc, libprag.}

proc isSelected*(self: ListBoxRow): bool =
  toBool(gtk_list_box_row_is_selected(cast[ptr ListBoxRow00](self.impl)))

proc gtk_list_box_row_set_activatable(self: ptr ListBoxRow00; activatable: gboolean) {.
    importc, libprag.}

proc setActivatable*(self: ListBoxRow; activatable: bool = true) =
  gtk_list_box_row_set_activatable(cast[ptr ListBoxRow00](self.impl), gboolean(activatable))

proc `activatable=`*(self: ListBoxRow; activatable: bool) =
  gtk_list_box_row_set_activatable(cast[ptr ListBoxRow00](self.impl), gboolean(activatable))

proc gtk_list_box_row_set_header(self: ptr ListBoxRow00; header: ptr Widget00) {.
    importc, libprag.}

proc setHeader*(self: ListBoxRow; header: Widget = nil) =
  gtk_list_box_row_set_header(cast[ptr ListBoxRow00](self.impl), if header.isNil: nil else: cast[ptr Widget00](header.impl))

proc `header=`*(self: ListBoxRow; header: Widget = nil) =
  gtk_list_box_row_set_header(cast[ptr ListBoxRow00](self.impl), if header.isNil: nil else: cast[ptr Widget00](header.impl))

proc gtk_list_box_row_set_selectable(self: ptr ListBoxRow00; selectable: gboolean) {.
    importc, libprag.}

proc setSelectable*(self: ListBoxRow; selectable: bool = true) =
  gtk_list_box_row_set_selectable(cast[ptr ListBoxRow00](self.impl), gboolean(selectable))

proc `selectable=`*(self: ListBoxRow; selectable: bool) =
  gtk_list_box_row_set_selectable(cast[ptr ListBoxRow00](self.impl), gboolean(selectable))

type
  ColorButton* = ref object of Button
  ColorButton00* = object of Button00

proc gtk_color_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scColorSet*(self: ColorButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "color-set", cast[GCallback](p), xdata, nil, cf)

proc gtk_color_button_new(): ptr ColorButton00 {.
    importc, libprag.}

proc newColorButton*(): ColorButton =
  let gobj = gtk_color_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorButton*(tdesc: typedesc): tdesc =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButton*[T](result: var T) {.deprecated.} =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_new_with_color(color: gdk.Color): ptr ColorButton00 {.
    importc, libprag.}

proc newColorButtonWithColor*(color: gdk.Color): ColorButton {.deprecated.}  =
  let gobj = gtk_color_button_new_with_color(color)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorButtonWithColor*(tdesc: typedesc; color: gdk.Color): tdesc {.deprecated.}  =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new_with_color(color)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButtonWithColor*[T](result: var T; color: gdk.Color) {.deprecated.} =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new_with_color(color)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_new_with_rgba(rgba: gdk.RGBA): ptr ColorButton00 {.
    importc, libprag.}

proc newColorButtonWithRgba*(rgba: gdk.RGBA): ColorButton =
  let gobj = gtk_color_button_new_with_rgba(rgba)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorButtonWithRgba*(tdesc: typedesc; rgba: gdk.RGBA): tdesc =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new_with_rgba(rgba)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorButtonWithRgba*[T](result: var T; rgba: gdk.RGBA) {.deprecated.} =
  assert(result is ColorButton)
  let gobj = gtk_color_button_new_with_rgba(rgba)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_button_get_alpha(self: ptr ColorButton00): uint16 {.
    importc, libprag.}

proc getAlpha*(self: ColorButton): uint16 =
  gtk_color_button_get_alpha(cast[ptr ColorButton00](self.impl))

proc alpha*(self: ColorButton): uint16 =
  gtk_color_button_get_alpha(cast[ptr ColorButton00](self.impl))

proc gtk_color_button_get_color(self: ptr ColorButton00; color: var gdk.Color) {.
    importc, libprag.}

proc getColor*(self: ColorButton; color: var gdk.Color) =
  gtk_color_button_get_color(cast[ptr ColorButton00](self.impl), color)

proc getColor*(self: ColorButton): gdk.Color =
  gtk_color_button_get_color(cast[ptr ColorButton00](self.impl), result)

proc gtk_color_button_get_title(self: ptr ColorButton00): cstring {.
    importc, libprag.}

proc getTitle*(self: ColorButton): string =
  result = $gtk_color_button_get_title(cast[ptr ColorButton00](self.impl))

proc title*(self: ColorButton): string =
  result = $gtk_color_button_get_title(cast[ptr ColorButton00](self.impl))

proc gtk_color_button_get_use_alpha(self: ptr ColorButton00): gboolean {.
    importc, libprag.}

proc getUseAlpha*(self: ColorButton): bool =
  toBool(gtk_color_button_get_use_alpha(cast[ptr ColorButton00](self.impl)))

proc useAlpha*(self: ColorButton): bool =
  toBool(gtk_color_button_get_use_alpha(cast[ptr ColorButton00](self.impl)))

proc gtk_color_button_set_alpha(self: ptr ColorButton00; alpha: uint16) {.
    importc, libprag.}

proc setAlpha*(self: ColorButton; alpha: uint16) =
  gtk_color_button_set_alpha(cast[ptr ColorButton00](self.impl), alpha)

proc `alpha=`*(self: ColorButton; alpha: uint16) =
  gtk_color_button_set_alpha(cast[ptr ColorButton00](self.impl), alpha)

proc gtk_color_button_set_color(self: ptr ColorButton00; color: gdk.Color) {.
    importc, libprag.}

proc setColor*(self: ColorButton; color: gdk.Color) =
  gtk_color_button_set_color(cast[ptr ColorButton00](self.impl), color)

proc `color=`*(self: ColorButton; color: gdk.Color) =
  gtk_color_button_set_color(cast[ptr ColorButton00](self.impl), color)

proc gtk_color_button_set_title(self: ptr ColorButton00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: ColorButton; title: cstring) =
  gtk_color_button_set_title(cast[ptr ColorButton00](self.impl), title)

proc `title=`*(self: ColorButton; title: cstring) =
  gtk_color_button_set_title(cast[ptr ColorButton00](self.impl), title)

proc gtk_color_button_set_use_alpha(self: ptr ColorButton00; useAlpha: gboolean) {.
    importc, libprag.}

proc setUseAlpha*(self: ColorButton; useAlpha: bool = true) =
  gtk_color_button_set_use_alpha(cast[ptr ColorButton00](self.impl), gboolean(useAlpha))

proc `useAlpha=`*(self: ColorButton; useAlpha: bool) =
  gtk_color_button_set_use_alpha(cast[ptr ColorButton00](self.impl), gboolean(useAlpha))

type
  RadioButton* = ref object of CheckButton
  RadioButton00* = object of CheckButton00

proc gtk_radio_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RadioButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scGroupChanged*(self: RadioButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "group-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_radio_button_new(group: ptr glib.SList): ptr RadioButton00 {.
    importc, libprag.}

proc newRadioButton*(group: seq[RadioButton]): RadioButton =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioButton*(tdesc: typedesc; group: seq[RadioButton]): tdesc =
  assert(result is RadioButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButton*[T](result: var T; group: seq[RadioButton]) {.deprecated.} =
  assert(result is RadioButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_from_widget(radioGroupMember: ptr RadioButton00): ptr RadioButton00 {.
    importc, libprag.}

proc newRadioButtonFromWidget*(radioGroupMember: RadioButton = nil): RadioButton =
  let gobj = gtk_radio_button_new_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioButtonFromWidget*(tdesc: typedesc; radioGroupMember: RadioButton = nil): tdesc =
  assert(result is RadioButton)
  let gobj = gtk_radio_button_new_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonFromWidget*[T](result: var T; radioGroupMember: RadioButton = nil) {.deprecated.} =
  assert(result is RadioButton)
  let gobj = gtk_radio_button_new_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_label(group: ptr glib.SList; label: cstring): ptr RadioButton00 {.
    importc, libprag.}

proc newRadioButtonWithLabel*(group: seq[RadioButton]; label: cstring): RadioButton =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new_with_label(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioButtonWithLabel*(tdesc: typedesc; group: seq[RadioButton]; label: cstring): tdesc =
  assert(result is RadioButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new_with_label(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithLabel*[T](result: var T; group: seq[RadioButton]; label: cstring) {.deprecated.} =
  assert(result is RadioButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new_with_label(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_label_from_widget(radioGroupMember: ptr RadioButton00;
    label: cstring): ptr RadioButton00 {.
    importc, libprag.}

proc newRadioButtonWithLabelFromWidget*(radioGroupMember: RadioButton = nil;
    label: cstring): RadioButton =
  let gobj = gtk_radio_button_new_with_label_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioButtonWithLabelFromWidget*(tdesc: typedesc; radioGroupMember: RadioButton = nil;
    label: cstring): tdesc =
  assert(result is RadioButton)
  let gobj = gtk_radio_button_new_with_label_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithLabelFromWidget*[T](result: var T; radioGroupMember: RadioButton = nil;
    label: cstring) {.deprecated.} =
  assert(result is RadioButton)
  let gobj = gtk_radio_button_new_with_label_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_mnemonic(group: ptr glib.SList; label: cstring): ptr RadioButton00 {.
    importc, libprag.}

proc newRadioButtonWithMnemonic*(group: seq[RadioButton]; label: cstring): RadioButton =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new_with_mnemonic(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioButtonWithMnemonic*(tdesc: typedesc; group: seq[RadioButton]; label: cstring): tdesc =
  assert(result is RadioButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new_with_mnemonic(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithMnemonic*[T](result: var T; group: seq[RadioButton]; label: cstring) {.deprecated.} =
  assert(result is RadioButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_button_new_with_mnemonic(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_new_with_mnemonic_from_widget(radioGroupMember: ptr RadioButton00;
    label: cstring): ptr RadioButton00 {.
    importc, libprag.}

proc newRadioButtonWithMnemonicFromWidget*(radioGroupMember: RadioButton = nil;
    label: cstring): RadioButton =
  let gobj = gtk_radio_button_new_with_mnemonic_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioButtonWithMnemonicFromWidget*(tdesc: typedesc; radioGroupMember: RadioButton = nil;
    label: cstring): tdesc =
  assert(result is RadioButton)
  let gobj = gtk_radio_button_new_with_mnemonic_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioButtonWithMnemonicFromWidget*[T](result: var T; radioGroupMember: RadioButton = nil;
    label: cstring) {.deprecated.} =
  assert(result is RadioButton)
  let gobj = gtk_radio_button_new_with_mnemonic_from_widget(if radioGroupMember.isNil: nil else: cast[ptr RadioButton00](radioGroupMember.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_button_get_group(self: ptr RadioButton00): ptr glib.SList {.
    importc, libprag.}

proc getGroup*(self: RadioButton): seq[RadioButton] =
  result = gslistObjects2seq(RadioButton, gtk_radio_button_get_group(cast[ptr RadioButton00](self.impl)), false)

proc group*(self: RadioButton): seq[RadioButton] =
  result = gslistObjects2seq(RadioButton, gtk_radio_button_get_group(cast[ptr RadioButton00](self.impl)), false)

proc gtk_radio_button_join_group(self: ptr RadioButton00; groupSource: ptr RadioButton00) {.
    importc, libprag.}

proc joinGroup*(self: RadioButton; groupSource: RadioButton = nil) =
  gtk_radio_button_join_group(cast[ptr RadioButton00](self.impl), if groupSource.isNil: nil else: cast[ptr RadioButton00](groupSource.impl))

proc gtk_radio_button_set_group(self: ptr RadioButton00; group: ptr glib.SList) {.
    importc, libprag.}

proc setGroup*(self: RadioButton; group: seq[RadioButton]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_button_set_group(cast[ptr RadioButton00](self.impl), tempResGL)
  g_slist_free(tempResGL)

proc `group=`*(self: RadioButton; group: seq[RadioButton]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_button_set_group(cast[ptr RadioButton00](self.impl), tempResGL)
  g_slist_free(tempResGL)

proc gtk_radio_tool_button_new(group: ptr glib.SList): ptr RadioToolButton00 {.
    importc, libprag.}

proc newRadioToolButton*(group: seq[RadioButton]): RadioToolButton =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_tool_button_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioToolButton*(tdesc: typedesc; group: seq[RadioButton]): tdesc =
  assert(result is RadioToolButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_tool_button_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButton*[T](result: var T; group: seq[RadioButton]) {.deprecated.} =
  assert(result is RadioToolButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_tool_button_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_tool_button_new_from_stock(group: ptr glib.SList; stockId: cstring): ptr RadioToolButton00 {.
    importc, libprag.}

proc newRadioToolButtonFromStock*(group: seq[RadioButton]; stockId: cstring): RadioToolButton {.deprecated.}  =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_tool_button_new_from_stock(tempResGL, stockId)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioToolButtonFromStock*(tdesc: typedesc; group: seq[RadioButton]; stockId: cstring): tdesc {.deprecated.}  =
  assert(result is RadioToolButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_tool_button_new_from_stock(tempResGL, stockId)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioToolButtonFromStock*[T](result: var T; group: seq[RadioButton]; stockId: cstring) {.deprecated.} =
  assert(result is RadioToolButton)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_tool_button_new_from_stock(tempResGL, stockId)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_tool_button_get_group(self: ptr RadioToolButton00): ptr glib.SList {.
    importc, libprag.}

proc getGroup*(self: RadioToolButton): seq[RadioButton] =
  result = gslistObjects2seq(RadioButton, gtk_radio_tool_button_get_group(cast[ptr RadioToolButton00](self.impl)), false)

proc group*(self: RadioToolButton): seq[RadioButton] =
  result = gslistObjects2seq(RadioButton, gtk_radio_tool_button_get_group(cast[ptr RadioToolButton00](self.impl)), false)

proc gtk_radio_tool_button_set_group(self: ptr RadioToolButton00; group: ptr glib.SList) {.
    importc, libprag.}

proc setGroup*(self: RadioToolButton; group: seq[RadioButton]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_tool_button_set_group(cast[ptr RadioToolButton00](self.impl), tempResGL)
  g_slist_free(tempResGL)

proc `group=`*(self: RadioToolButton; group: seq[RadioButton]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_tool_button_set_group(cast[ptr RadioToolButton00](self.impl), tempResGL)
  g_slist_free(tempResGL)

type
  LinkButton* = ref object of Button
  LinkButton00* = object of Button00

proc gtk_link_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LinkButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateLink*(self: LinkButton;  p: proc (self: ptr LinkButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-link", cast[GCallback](p), xdata, nil, cf)

proc gtk_link_button_new(uri: cstring): ptr LinkButton00 {.
    importc, libprag.}

proc newLinkButton*(uri: cstring): LinkButton =
  let gobj = gtk_link_button_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLinkButton*(tdesc: typedesc; uri: cstring): tdesc =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLinkButton*[T](result: var T; uri: cstring) {.deprecated.} =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new(uri)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_link_button_new_with_label(uri: cstring; label: cstring): ptr LinkButton00 {.
    importc, libprag.}

proc newLinkButton*(uri: cstring; label: cstring): LinkButton =
  let gobj = gtk_link_button_new_with_label(uri, label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLinkButton*(tdesc: typedesc; uri: cstring; label: cstring): tdesc =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new_with_label(uri, label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLinkButton*[T](result: var T; uri: cstring; label: cstring) {.deprecated.} =
  assert(result is LinkButton)
  let gobj = gtk_link_button_new_with_label(uri, label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_link_button_get_uri(self: ptr LinkButton00): cstring {.
    importc, libprag.}

proc getUri*(self: LinkButton): string =
  result = $gtk_link_button_get_uri(cast[ptr LinkButton00](self.impl))

proc uri*(self: LinkButton): string =
  result = $gtk_link_button_get_uri(cast[ptr LinkButton00](self.impl))

proc gtk_link_button_get_visited(self: ptr LinkButton00): gboolean {.
    importc, libprag.}

proc getVisited*(self: LinkButton): bool =
  toBool(gtk_link_button_get_visited(cast[ptr LinkButton00](self.impl)))

proc visited*(self: LinkButton): bool =
  toBool(gtk_link_button_get_visited(cast[ptr LinkButton00](self.impl)))

proc gtk_link_button_set_uri(self: ptr LinkButton00; uri: cstring) {.
    importc, libprag.}

proc setUri*(self: LinkButton; uri: cstring) =
  gtk_link_button_set_uri(cast[ptr LinkButton00](self.impl), uri)

proc `uri=`*(self: LinkButton; uri: cstring) =
  gtk_link_button_set_uri(cast[ptr LinkButton00](self.impl), uri)

proc gtk_link_button_set_visited(self: ptr LinkButton00; visited: gboolean) {.
    importc, libprag.}

proc setVisited*(self: LinkButton; visited: bool = true) =
  gtk_link_button_set_visited(cast[ptr LinkButton00](self.impl), gboolean(visited))

proc `visited=`*(self: LinkButton; visited: bool) =
  gtk_link_button_set_visited(cast[ptr LinkButton00](self.impl), gboolean(visited))

type
  ImageMenuItem* = ref object of MenuItem
  ImageMenuItem00* = object of MenuItem00

proc gtk_image_menu_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ImageMenuItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_image_menu_item_new(): ptr ImageMenuItem00 {.
    importc, libprag.}

proc newImageMenuItem*(): ImageMenuItem {.deprecated.}  =
  let gobj = gtk_image_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageMenuItem*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItem*[T](result: var T) {.deprecated.} =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_new_from_stock(stockId: cstring; accelGroup: ptr AccelGroup00): ptr ImageMenuItem00 {.
    importc, libprag.}

proc newImageMenuItemFromStock*(stockId: cstring; accelGroup: AccelGroup = nil): ImageMenuItem {.deprecated.}  =
  let gobj = gtk_image_menu_item_new_from_stock(stockId, if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageMenuItemFromStock*(tdesc: typedesc; stockId: cstring; accelGroup: AccelGroup = nil): tdesc {.deprecated.}  =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new_from_stock(stockId, if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItemFromStock*[T](result: var T; stockId: cstring; accelGroup: AccelGroup = nil) {.deprecated.} =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new_from_stock(stockId, if accelGroup.isNil: nil else: cast[ptr AccelGroup00](accelGroup.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_new_with_label(label: cstring): ptr ImageMenuItem00 {.
    importc, libprag.}

proc newImageMenuItemWithLabel*(label: cstring): ImageMenuItem {.deprecated.}  =
  let gobj = gtk_image_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageMenuItemWithLabel*(tdesc: typedesc; label: cstring): tdesc {.deprecated.}  =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItemWithLabel*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_new_with_mnemonic(label: cstring): ptr ImageMenuItem00 {.
    importc, libprag.}

proc newImageMenuItemWithMnemonic*(label: cstring): ImageMenuItem {.deprecated.}  =
  let gobj = gtk_image_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageMenuItemWithMnemonic*(tdesc: typedesc; label: cstring): tdesc {.deprecated.}  =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageMenuItemWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is ImageMenuItem)
  let gobj = gtk_image_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_get_always_show_image(self: ptr ImageMenuItem00): gboolean {.
    importc, libprag.}

proc getAlwaysShowImage*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_always_show_image(cast[ptr ImageMenuItem00](self.impl)))

proc alwaysShowImage*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_always_show_image(cast[ptr ImageMenuItem00](self.impl)))

proc gtk_image_menu_item_get_image(self: ptr ImageMenuItem00): ptr Widget00 {.
    importc, libprag.}

proc getImage*(self: ImageMenuItem): Widget =
  let gobj = gtk_image_menu_item_get_image(cast[ptr ImageMenuItem00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc image*(self: ImageMenuItem): Widget =
  let gobj = gtk_image_menu_item_get_image(cast[ptr ImageMenuItem00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_menu_item_get_use_stock(self: ptr ImageMenuItem00): gboolean {.
    importc, libprag.}

proc getUseStock*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_use_stock(cast[ptr ImageMenuItem00](self.impl)))

proc useStock*(self: ImageMenuItem): bool =
  toBool(gtk_image_menu_item_get_use_stock(cast[ptr ImageMenuItem00](self.impl)))

proc gtk_image_menu_item_set_accel_group(self: ptr ImageMenuItem00; accelGroup: ptr AccelGroup00) {.
    importc, libprag.}

proc setAccelGroup*(self: ImageMenuItem; accelGroup: AccelGroup) =
  gtk_image_menu_item_set_accel_group(cast[ptr ImageMenuItem00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc `accelGroup=`*(self: ImageMenuItem; accelGroup: AccelGroup) =
  gtk_image_menu_item_set_accel_group(cast[ptr ImageMenuItem00](self.impl), cast[ptr AccelGroup00](accelGroup.impl))

proc gtk_image_menu_item_set_always_show_image(self: ptr ImageMenuItem00;
    alwaysShow: gboolean) {.
    importc, libprag.}

proc setAlwaysShowImage*(self: ImageMenuItem; alwaysShow: bool = true) =
  gtk_image_menu_item_set_always_show_image(cast[ptr ImageMenuItem00](self.impl), gboolean(alwaysShow))

proc `alwaysShowImage=`*(self: ImageMenuItem; alwaysShow: bool) =
  gtk_image_menu_item_set_always_show_image(cast[ptr ImageMenuItem00](self.impl), gboolean(alwaysShow))

proc gtk_image_menu_item_set_image(self: ptr ImageMenuItem00; image: ptr Widget00) {.
    importc, libprag.}

proc setImage*(self: ImageMenuItem; image: Widget = nil) =
  gtk_image_menu_item_set_image(cast[ptr ImageMenuItem00](self.impl), if image.isNil: nil else: cast[ptr Widget00](image.impl))

proc `image=`*(self: ImageMenuItem; image: Widget = nil) =
  gtk_image_menu_item_set_image(cast[ptr ImageMenuItem00](self.impl), if image.isNil: nil else: cast[ptr Widget00](image.impl))

proc gtk_image_menu_item_set_use_stock(self: ptr ImageMenuItem00; useStock: gboolean) {.
    importc, libprag.}

proc setUseStock*(self: ImageMenuItem; useStock: bool = true) =
  gtk_image_menu_item_set_use_stock(cast[ptr ImageMenuItem00](self.impl), gboolean(useStock))

proc `useStock=`*(self: ImageMenuItem; useStock: bool) =
  gtk_image_menu_item_set_use_stock(cast[ptr ImageMenuItem00](self.impl), gboolean(useStock))

type
  MenuToolButton* = ref object of ToolButton
  MenuToolButton00* = object of ToolButton00

proc gtk_menu_tool_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuToolButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scShowMenu*(self: MenuToolButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-menu", cast[GCallback](p), xdata, nil, cf)

proc gtk_menu_tool_button_new(iconWidget: ptr Widget00; label: cstring): ptr MenuToolButton00 {.
    importc, libprag.}

proc newMenuToolButton*(iconWidget: Widget = nil; label: cstring = nil): MenuToolButton =
  let gobj = gtk_menu_tool_button_new(if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuToolButton*(tdesc: typedesc; iconWidget: Widget = nil; label: cstring = nil): tdesc =
  assert(result is MenuToolButton)
  let gobj = gtk_menu_tool_button_new(if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuToolButton*[T](result: var T; iconWidget: Widget = nil; label: cstring = nil) {.deprecated.} =
  assert(result is MenuToolButton)
  let gobj = gtk_menu_tool_button_new(if iconWidget.isNil: nil else: cast[ptr Widget00](iconWidget.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_tool_button_new_from_stock(stockId: cstring): ptr MenuToolButton00 {.
    importc, libprag.}

proc newMenuToolButtonFromStock*(stockId: cstring): MenuToolButton {.deprecated.}  =
  let gobj = gtk_menu_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuToolButtonFromStock*(tdesc: typedesc; stockId: cstring): tdesc {.deprecated.}  =
  assert(result is MenuToolButton)
  let gobj = gtk_menu_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuToolButtonFromStock*[T](result: var T; stockId: cstring) {.deprecated.} =
  assert(result is MenuToolButton)
  let gobj = gtk_menu_tool_button_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_tool_button_get_menu(self: ptr MenuToolButton00): ptr Widget00 {.
    importc, libprag.}

proc getMenu*(self: MenuToolButton): Widget =
  let gobj = gtk_menu_tool_button_get_menu(cast[ptr MenuToolButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menu*(self: MenuToolButton): Widget =
  let gobj = gtk_menu_tool_button_get_menu(cast[ptr MenuToolButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_tool_button_set_arrow_tooltip_markup(self: ptr MenuToolButton00;
    markup: cstring) {.
    importc, libprag.}

proc setArrowTooltipMarkup*(self: MenuToolButton;
    markup: cstring) =
  gtk_menu_tool_button_set_arrow_tooltip_markup(cast[ptr MenuToolButton00](self.impl), markup)

proc `arrowTooltipMarkup=`*(self: MenuToolButton;
    markup: cstring) =
  gtk_menu_tool_button_set_arrow_tooltip_markup(cast[ptr MenuToolButton00](self.impl), markup)

proc gtk_menu_tool_button_set_arrow_tooltip_text(self: ptr MenuToolButton00;
    text: cstring) {.
    importc, libprag.}

proc setArrowTooltipText*(self: MenuToolButton; text: cstring) =
  gtk_menu_tool_button_set_arrow_tooltip_text(cast[ptr MenuToolButton00](self.impl), text)

proc `arrowTooltipText=`*(self: MenuToolButton; text: cstring) =
  gtk_menu_tool_button_set_arrow_tooltip_text(cast[ptr MenuToolButton00](self.impl), text)

proc gtk_menu_tool_button_set_menu(self: ptr MenuToolButton00; menu: ptr Widget00) {.
    importc, libprag.}

proc setMenu*(self: MenuToolButton; menu: Widget) =
  gtk_menu_tool_button_set_menu(cast[ptr MenuToolButton00](self.impl), cast[ptr Widget00](menu.impl))

proc `menu=`*(self: MenuToolButton; menu: Widget) =
  gtk_menu_tool_button_set_menu(cast[ptr MenuToolButton00](self.impl), cast[ptr Widget00](menu.impl))

type
  LockButton* = ref object of Button
  LockButton00* = object of Button00

proc gtk_lock_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LockButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_lock_button_new(permission: ptr gio.Permission00): ptr LockButton00 {.
    importc, libprag.}

proc newLockButton*(permission: gio.Permission = nil): LockButton =
  let gobj = gtk_lock_button_new(if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLockButton*(tdesc: typedesc; permission: gio.Permission = nil): tdesc =
  assert(result is LockButton)
  let gobj = gtk_lock_button_new(if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLockButton*[T](result: var T; permission: gio.Permission = nil) {.deprecated.} =
  assert(result is LockButton)
  let gobj = gtk_lock_button_new(if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_lock_button_get_permission(self: ptr LockButton00): ptr gio.Permission00 {.
    importc, libprag.}

proc getPermission*(self: LockButton): gio.Permission =
  let gobj = gtk_lock_button_get_permission(cast[ptr LockButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc permission*(self: LockButton): gio.Permission =
  let gobj = gtk_lock_button_get_permission(cast[ptr LockButton00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_lock_button_set_permission(self: ptr LockButton00; permission: ptr gio.Permission00) {.
    importc, libprag.}

proc setPermission*(self: LockButton; permission: gio.Permission = nil) =
  gtk_lock_button_set_permission(cast[ptr LockButton00](self.impl), if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))

proc `permission=`*(self: LockButton; permission: gio.Permission = nil) =
  gtk_lock_button_set_permission(cast[ptr LockButton00](self.impl), if permission.isNil: nil else: cast[ptr gio.Permission00](permission.impl))

type
  CheckMenuItem* = ref object of MenuItem
  CheckMenuItem00* = object of MenuItem00

proc gtk_check_menu_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CheckMenuItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scToggled*(self: CheckMenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_check_menu_item_new(): ptr CheckMenuItem00 {.
    importc, libprag.}

proc newCheckMenuItem*(): CheckMenuItem =
  let gobj = gtk_check_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckMenuItem*(tdesc: typedesc): tdesc =
  assert(result is CheckMenuItem)
  let gobj = gtk_check_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckMenuItem*[T](result: var T) {.deprecated.} =
  assert(result is CheckMenuItem)
  let gobj = gtk_check_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_menu_item_new_with_label(label: cstring): ptr CheckMenuItem00 {.
    importc, libprag.}

proc newCheckMenuItemWithLabel*(label: cstring): CheckMenuItem =
  let gobj = gtk_check_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckMenuItemWithLabel*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is CheckMenuItem)
  let gobj = gtk_check_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckMenuItemWithLabel*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is CheckMenuItem)
  let gobj = gtk_check_menu_item_new_with_label(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_menu_item_new_with_mnemonic(label: cstring): ptr CheckMenuItem00 {.
    importc, libprag.}

proc newCheckMenuItemWithMnemonic*(label: cstring): CheckMenuItem =
  let gobj = gtk_check_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCheckMenuItemWithMnemonic*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is CheckMenuItem)
  let gobj = gtk_check_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCheckMenuItemWithMnemonic*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is CheckMenuItem)
  let gobj = gtk_check_menu_item_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_check_menu_item_get_active(self: ptr CheckMenuItem00): gboolean {.
    importc, libprag.}

proc getActive*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_active(cast[ptr CheckMenuItem00](self.impl)))

proc active*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_active(cast[ptr CheckMenuItem00](self.impl)))

proc gtk_check_menu_item_get_draw_as_radio(self: ptr CheckMenuItem00): gboolean {.
    importc, libprag.}

proc getDrawAsRadio*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_draw_as_radio(cast[ptr CheckMenuItem00](self.impl)))

proc drawAsRadio*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_draw_as_radio(cast[ptr CheckMenuItem00](self.impl)))

proc gtk_check_menu_item_get_inconsistent(self: ptr CheckMenuItem00): gboolean {.
    importc, libprag.}

proc getInconsistent*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_inconsistent(cast[ptr CheckMenuItem00](self.impl)))

proc inconsistent*(self: CheckMenuItem): bool =
  toBool(gtk_check_menu_item_get_inconsistent(cast[ptr CheckMenuItem00](self.impl)))

proc gtk_check_menu_item_set_active(self: ptr CheckMenuItem00; isActive: gboolean) {.
    importc, libprag.}

proc setActive*(self: CheckMenuItem; isActive: bool = true) =
  gtk_check_menu_item_set_active(cast[ptr CheckMenuItem00](self.impl), gboolean(isActive))

proc `active=`*(self: CheckMenuItem; isActive: bool) =
  gtk_check_menu_item_set_active(cast[ptr CheckMenuItem00](self.impl), gboolean(isActive))

proc gtk_check_menu_item_set_draw_as_radio(self: ptr CheckMenuItem00; drawAsRadio: gboolean) {.
    importc, libprag.}

proc setDrawAsRadio*(self: CheckMenuItem; drawAsRadio: bool = true) =
  gtk_check_menu_item_set_draw_as_radio(cast[ptr CheckMenuItem00](self.impl), gboolean(drawAsRadio))

proc `drawAsRadio=`*(self: CheckMenuItem; drawAsRadio: bool) =
  gtk_check_menu_item_set_draw_as_radio(cast[ptr CheckMenuItem00](self.impl), gboolean(drawAsRadio))

proc gtk_check_menu_item_set_inconsistent(self: ptr CheckMenuItem00; setting: gboolean) {.
    importc, libprag.}

proc setInconsistent*(self: CheckMenuItem; setting: bool = true) =
  gtk_check_menu_item_set_inconsistent(cast[ptr CheckMenuItem00](self.impl), gboolean(setting))

proc `inconsistent=`*(self: CheckMenuItem; setting: bool) =
  gtk_check_menu_item_set_inconsistent(cast[ptr CheckMenuItem00](self.impl), gboolean(setting))

proc gtk_check_menu_item_toggled(self: ptr CheckMenuItem00) {.
    importc, libprag.}

proc toggled*(self: CheckMenuItem) =
  gtk_check_menu_item_toggled(cast[ptr CheckMenuItem00](self.impl))

type
  RadioMenuItem* = ref object of CheckMenuItem
  RadioMenuItem00* = object of CheckMenuItem00

proc gtk_radio_menu_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RadioMenuItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scGroupChanged*(self: RadioMenuItem;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "group-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_radio_menu_item_new(group: ptr glib.SList): ptr RadioMenuItem00 {.
    importc, libprag.}

proc newRadioMenuItem*(group: seq[RadioMenuItem]): RadioMenuItem =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioMenuItem*(tdesc: typedesc; group: seq[RadioMenuItem]): tdesc =
  assert(result is RadioMenuItem)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItem*[T](result: var T; group: seq[RadioMenuItem]) {.deprecated.} =
  assert(result is RadioMenuItem)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new(tempResGL)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_from_widget(group: ptr RadioMenuItem00): ptr RadioMenuItem00 {.
    importc, libprag.}

proc newRadioMenuItemFromWidget*(group: RadioMenuItem = nil): RadioMenuItem =
  let gobj = gtk_radio_menu_item_new_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioMenuItemFromWidget*(tdesc: typedesc; group: RadioMenuItem = nil): tdesc =
  assert(result is RadioMenuItem)
  let gobj = gtk_radio_menu_item_new_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemFromWidget*[T](result: var T; group: RadioMenuItem = nil) {.deprecated.} =
  assert(result is RadioMenuItem)
  let gobj = gtk_radio_menu_item_new_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_label(group: ptr glib.SList; label: cstring): ptr RadioMenuItem00 {.
    importc, libprag.}

proc newRadioMenuItemWithLabel*(group: seq[RadioMenuItem]; label: cstring): RadioMenuItem =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new_with_label(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioMenuItemWithLabel*(tdesc: typedesc; group: seq[RadioMenuItem]; label: cstring): tdesc =
  assert(result is RadioMenuItem)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new_with_label(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithLabel*[T](result: var T; group: seq[RadioMenuItem]; label: cstring) {.deprecated.} =
  assert(result is RadioMenuItem)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new_with_label(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_label_from_widget(group: ptr RadioMenuItem00;
    label: cstring): ptr RadioMenuItem00 {.
    importc, libprag.}

proc newRadioMenuItemWithLabelFromWidget*(group: RadioMenuItem = nil;
    label: cstring = nil): RadioMenuItem =
  let gobj = gtk_radio_menu_item_new_with_label_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioMenuItemWithLabelFromWidget*(tdesc: typedesc; group: RadioMenuItem = nil;
    label: cstring = nil): tdesc =
  assert(result is RadioMenuItem)
  let gobj = gtk_radio_menu_item_new_with_label_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithLabelFromWidget*[T](result: var T; group: RadioMenuItem = nil;
    label: cstring = nil) {.deprecated.} =
  assert(result is RadioMenuItem)
  let gobj = gtk_radio_menu_item_new_with_label_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_mnemonic(group: ptr glib.SList; label: cstring): ptr RadioMenuItem00 {.
    importc, libprag.}

proc newRadioMenuItemWithMnemonic*(group: seq[RadioMenuItem]; label: cstring): RadioMenuItem =
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new_with_mnemonic(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioMenuItemWithMnemonic*(tdesc: typedesc; group: seq[RadioMenuItem]; label: cstring): tdesc =
  assert(result is RadioMenuItem)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new_with_mnemonic(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithMnemonic*[T](result: var T; group: seq[RadioMenuItem]; label: cstring) {.deprecated.} =
  assert(result is RadioMenuItem)
  var tempResGL = seq2GSList(group)
  let gobj = gtk_radio_menu_item_new_with_mnemonic(tempResGL, label)
  g_slist_free(tempResGL)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_new_with_mnemonic_from_widget(group: ptr RadioMenuItem00;
    label: cstring): ptr RadioMenuItem00 {.
    importc, libprag.}

proc newRadioMenuItemWithMnemonicFromWidget*(group: RadioMenuItem = nil;
    label: cstring = nil): RadioMenuItem =
  let gobj = gtk_radio_menu_item_new_with_mnemonic_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioMenuItemWithMnemonicFromWidget*(tdesc: typedesc; group: RadioMenuItem = nil;
    label: cstring = nil): tdesc =
  assert(result is RadioMenuItem)
  let gobj = gtk_radio_menu_item_new_with_mnemonic_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioMenuItemWithMnemonicFromWidget*[T](result: var T; group: RadioMenuItem = nil;
    label: cstring = nil) {.deprecated.} =
  assert(result is RadioMenuItem)
  let gobj = gtk_radio_menu_item_new_with_mnemonic_from_widget(if group.isNil: nil else: cast[ptr RadioMenuItem00](group.impl), label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_menu_item_get_group(self: ptr RadioMenuItem00): ptr glib.SList {.
    importc, libprag.}

proc getGroup*(self: RadioMenuItem): seq[RadioMenuItem] =
  result = gslistObjects2seq(RadioMenuItem, gtk_radio_menu_item_get_group(cast[ptr RadioMenuItem00](self.impl)), false)

proc group*(self: RadioMenuItem): seq[RadioMenuItem] =
  result = gslistObjects2seq(RadioMenuItem, gtk_radio_menu_item_get_group(cast[ptr RadioMenuItem00](self.impl)), false)

proc gtk_radio_menu_item_join_group(self: ptr RadioMenuItem00; groupSource: ptr RadioMenuItem00) {.
    importc, libprag.}

proc joinGroup*(self: RadioMenuItem; groupSource: RadioMenuItem = nil) =
  gtk_radio_menu_item_join_group(cast[ptr RadioMenuItem00](self.impl), if groupSource.isNil: nil else: cast[ptr RadioMenuItem00](groupSource.impl))

proc gtk_radio_menu_item_set_group(self: ptr RadioMenuItem00; group: ptr glib.SList) {.
    importc, libprag.}

proc setGroup*(self: RadioMenuItem; group: seq[RadioMenuItem]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_menu_item_set_group(cast[ptr RadioMenuItem00](self.impl), tempResGL)
  g_slist_free(tempResGL)

proc `group=`*(self: RadioMenuItem; group: seq[RadioMenuItem]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_menu_item_set_group(cast[ptr RadioMenuItem00](self.impl), tempResGL)
  g_slist_free(tempResGL)

type
  VolumeButton* = ref object of ScaleButton
  VolumeButton00* = object of ScaleButton00

proc gtk_volume_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VolumeButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_volume_button_new(): ptr VolumeButton00 {.
    importc, libprag.}

proc newVolumeButton*(): VolumeButton =
  let gobj = gtk_volume_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVolumeButton*(tdesc: typedesc): tdesc =
  assert(result is VolumeButton)
  let gobj = gtk_volume_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVolumeButton*[T](result: var T) {.deprecated.} =
  assert(result is VolumeButton)
  let gobj = gtk_volume_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FontButton* = ref object of Button
  FontButton00* = object of Button00

proc gtk_font_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scFontSet*(self: FontButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "font-set", cast[GCallback](p), xdata, nil, cf)

proc gtk_font_button_new(): ptr FontButton00 {.
    importc, libprag.}

proc newFontButton*(): FontButton =
  let gobj = gtk_font_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontButton*(tdesc: typedesc): tdesc =
  assert(result is FontButton)
  let gobj = gtk_font_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontButton*[T](result: var T) {.deprecated.} =
  assert(result is FontButton)
  let gobj = gtk_font_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_button_new_with_font(fontname: cstring): ptr FontButton00 {.
    importc, libprag.}

proc newFontButtonWithFont*(fontname: cstring): FontButton =
  let gobj = gtk_font_button_new_with_font(fontname)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontButtonWithFont*(tdesc: typedesc; fontname: cstring): tdesc =
  assert(result is FontButton)
  let gobj = gtk_font_button_new_with_font(fontname)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontButtonWithFont*[T](result: var T; fontname: cstring) {.deprecated.} =
  assert(result is FontButton)
  let gobj = gtk_font_button_new_with_font(fontname)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_button_get_font_name(self: ptr FontButton00): cstring {.
    importc, libprag.}

proc getFontName*(self: FontButton): string =
  result = $gtk_font_button_get_font_name(cast[ptr FontButton00](self.impl))

proc fontName*(self: FontButton): string =
  result = $gtk_font_button_get_font_name(cast[ptr FontButton00](self.impl))

proc gtk_font_button_get_show_size(self: ptr FontButton00): gboolean {.
    importc, libprag.}

proc getShowSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_size(cast[ptr FontButton00](self.impl)))

proc showSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_size(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_show_style(self: ptr FontButton00): gboolean {.
    importc, libprag.}

proc getShowStyle*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_style(cast[ptr FontButton00](self.impl)))

proc showStyle*(self: FontButton): bool =
  toBool(gtk_font_button_get_show_style(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_title(self: ptr FontButton00): cstring {.
    importc, libprag.}

proc getTitle*(self: FontButton): string =
  result = $gtk_font_button_get_title(cast[ptr FontButton00](self.impl))

proc title*(self: FontButton): string =
  result = $gtk_font_button_get_title(cast[ptr FontButton00](self.impl))

proc gtk_font_button_get_use_font(self: ptr FontButton00): gboolean {.
    importc, libprag.}

proc getUseFont*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_font(cast[ptr FontButton00](self.impl)))

proc useFont*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_font(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_get_use_size(self: ptr FontButton00): gboolean {.
    importc, libprag.}

proc getUseSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_size(cast[ptr FontButton00](self.impl)))

proc useSize*(self: FontButton): bool =
  toBool(gtk_font_button_get_use_size(cast[ptr FontButton00](self.impl)))

proc gtk_font_button_set_font_name(self: ptr FontButton00; fontname: cstring): gboolean {.
    importc, libprag.}

proc setFontName*(self: FontButton; fontname: cstring): bool =
  toBool(gtk_font_button_set_font_name(cast[ptr FontButton00](self.impl), fontname))

proc gtk_font_button_set_show_size(self: ptr FontButton00; showSize: gboolean) {.
    importc, libprag.}

proc setShowSize*(self: FontButton; showSize: bool = true) =
  gtk_font_button_set_show_size(cast[ptr FontButton00](self.impl), gboolean(showSize))

proc `showSize=`*(self: FontButton; showSize: bool) =
  gtk_font_button_set_show_size(cast[ptr FontButton00](self.impl), gboolean(showSize))

proc gtk_font_button_set_show_style(self: ptr FontButton00; showStyle: gboolean) {.
    importc, libprag.}

proc setShowStyle*(self: FontButton; showStyle: bool = true) =
  gtk_font_button_set_show_style(cast[ptr FontButton00](self.impl), gboolean(showStyle))

proc `showStyle=`*(self: FontButton; showStyle: bool) =
  gtk_font_button_set_show_style(cast[ptr FontButton00](self.impl), gboolean(showStyle))

proc gtk_font_button_set_title(self: ptr FontButton00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: FontButton; title: cstring) =
  gtk_font_button_set_title(cast[ptr FontButton00](self.impl), title)

proc `title=`*(self: FontButton; title: cstring) =
  gtk_font_button_set_title(cast[ptr FontButton00](self.impl), title)

proc gtk_font_button_set_use_font(self: ptr FontButton00; useFont: gboolean) {.
    importc, libprag.}

proc setUseFont*(self: FontButton; useFont: bool = true) =
  gtk_font_button_set_use_font(cast[ptr FontButton00](self.impl), gboolean(useFont))

proc `useFont=`*(self: FontButton; useFont: bool) =
  gtk_font_button_set_use_font(cast[ptr FontButton00](self.impl), gboolean(useFont))

proc gtk_font_button_set_use_size(self: ptr FontButton00; useSize: gboolean) {.
    importc, libprag.}

proc setUseSize*(self: FontButton; useSize: bool = true) =
  gtk_font_button_set_use_size(cast[ptr FontButton00](self.impl), gboolean(useSize))

proc `useSize=`*(self: FontButton; useSize: bool) =
  gtk_font_button_set_use_size(cast[ptr FontButton00](self.impl), gboolean(useSize))

type
  SeparatorMenuItem* = ref object of MenuItem
  SeparatorMenuItem00* = object of MenuItem00

proc gtk_separator_menu_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SeparatorMenuItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_separator_menu_item_new(): ptr SeparatorMenuItem00 {.
    importc, libprag.}

proc newSeparatorMenuItem*(): SeparatorMenuItem =
  let gobj = gtk_separator_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSeparatorMenuItem*(tdesc: typedesc): tdesc =
  assert(result is SeparatorMenuItem)
  let gobj = gtk_separator_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSeparatorMenuItem*[T](result: var T) {.deprecated.} =
  assert(result is SeparatorMenuItem)
  let gobj = gtk_separator_menu_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  MenuButton* = ref object of ToggleButton
  MenuButton00* = object of ToggleButton00

proc gtk_menu_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_menu_button_new(): ptr MenuButton00 {.
    importc, libprag.}

proc newMenuButton*(): MenuButton =
  let gobj = gtk_menu_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuButton*(tdesc: typedesc): tdesc =
  assert(result is MenuButton)
  let gobj = gtk_menu_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuButton*[T](result: var T) {.deprecated.} =
  assert(result is MenuButton)
  let gobj = gtk_menu_button_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_align_widget(self: ptr MenuButton00): ptr Widget00 {.
    importc, libprag.}

proc getAlignWidget*(self: MenuButton): Widget =
  let gobj = gtk_menu_button_get_align_widget(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc alignWidget*(self: MenuButton): Widget =
  let gobj = gtk_menu_button_get_align_widget(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_menu_model(self: ptr MenuButton00): ptr gio.MenuModel00 {.
    importc, libprag.}

proc getMenuModel*(self: MenuButton): gio.MenuModel =
  let gobj = gtk_menu_button_get_menu_model(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc menuModel*(self: MenuButton): gio.MenuModel =
  let gobj = gtk_menu_button_get_menu_model(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_popup(self: ptr MenuButton00): ptr Menu00 {.
    importc, libprag.}

proc getPopup*(self: MenuButton): Menu =
  let gobj = gtk_menu_button_get_popup(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popup*(self: MenuButton): Menu =
  let gobj = gtk_menu_button_get_popup(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_button_get_use_popover(self: ptr MenuButton00): gboolean {.
    importc, libprag.}

proc getUsePopover*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_use_popover(cast[ptr MenuButton00](self.impl)))

proc usePopover*(self: MenuButton): bool =
  toBool(gtk_menu_button_get_use_popover(cast[ptr MenuButton00](self.impl)))

proc gtk_menu_button_set_align_widget(self: ptr MenuButton00; alignWidget: ptr Widget00) {.
    importc, libprag.}

proc setAlignWidget*(self: MenuButton; alignWidget: Widget = nil) =
  gtk_menu_button_set_align_widget(cast[ptr MenuButton00](self.impl), if alignWidget.isNil: nil else: cast[ptr Widget00](alignWidget.impl))

proc `alignWidget=`*(self: MenuButton; alignWidget: Widget = nil) =
  gtk_menu_button_set_align_widget(cast[ptr MenuButton00](self.impl), if alignWidget.isNil: nil else: cast[ptr Widget00](alignWidget.impl))

proc gtk_menu_button_set_menu_model(self: ptr MenuButton00; menuModel: ptr gio.MenuModel00) {.
    importc, libprag.}

proc setMenuModel*(self: MenuButton; menuModel: gio.MenuModel = nil) =
  gtk_menu_button_set_menu_model(cast[ptr MenuButton00](self.impl), if menuModel.isNil: nil else: cast[ptr gio.MenuModel00](menuModel.impl))

proc `menuModel=`*(self: MenuButton; menuModel: gio.MenuModel = nil) =
  gtk_menu_button_set_menu_model(cast[ptr MenuButton00](self.impl), if menuModel.isNil: nil else: cast[ptr gio.MenuModel00](menuModel.impl))

proc gtk_menu_button_set_popover(self: ptr MenuButton00; popover: ptr Widget00) {.
    importc, libprag.}

proc setPopover*(self: MenuButton; popover: Widget = nil) =
  gtk_menu_button_set_popover(cast[ptr MenuButton00](self.impl), if popover.isNil: nil else: cast[ptr Widget00](popover.impl))

proc `popover=`*(self: MenuButton; popover: Widget = nil) =
  gtk_menu_button_set_popover(cast[ptr MenuButton00](self.impl), if popover.isNil: nil else: cast[ptr Widget00](popover.impl))

proc gtk_menu_button_set_popup(self: ptr MenuButton00; menu: ptr Widget00) {.
    importc, libprag.}

proc setPopup*(self: MenuButton; menu: Widget = nil) =
  gtk_menu_button_set_popup(cast[ptr MenuButton00](self.impl), if menu.isNil: nil else: cast[ptr Widget00](menu.impl))

proc `popup=`*(self: MenuButton; menu: Widget = nil) =
  gtk_menu_button_set_popup(cast[ptr MenuButton00](self.impl), if menu.isNil: nil else: cast[ptr Widget00](menu.impl))

proc gtk_menu_button_set_use_popover(self: ptr MenuButton00; usePopover: gboolean) {.
    importc, libprag.}

proc setUsePopover*(self: MenuButton; usePopover: bool = true) =
  gtk_menu_button_set_use_popover(cast[ptr MenuButton00](self.impl), gboolean(usePopover))

proc `usePopover=`*(self: MenuButton; usePopover: bool) =
  gtk_menu_button_set_use_popover(cast[ptr MenuButton00](self.impl), gboolean(usePopover))

proc gtk_actionable_get_action_name(self: ptr Actionable00): cstring {.
    importc, libprag.}

proc getActionName*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): string =
  let resul0 = gtk_actionable_get_action_name(cast[ptr Actionable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc actionName*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): string =
  let resul0 = gtk_actionable_get_action_name(cast[ptr Actionable00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_actionable_get_action_target_value(self: ptr Actionable00): ptr glib.Variant00 {.
    importc, libprag.}

proc getActionTargetValue*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_actionable_get_action_target_value(cast[ptr Actionable00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc actionTargetValue*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_actionable_get_action_target_value(cast[ptr Actionable00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_actionable_set_action_name(self: ptr Actionable00; actionName: cstring) {.
    importc, libprag.}

proc setActionName*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    actionName: cstring = nil) =
  gtk_actionable_set_action_name(cast[ptr Actionable00](self.impl), actionName)

proc `actionName=`*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    actionName: cstring = nil) =
  gtk_actionable_set_action_name(cast[ptr Actionable00](self.impl), actionName)

proc gtk_actionable_set_action_target_value(self: ptr Actionable00; targetValue: ptr glib.Variant00) {.
    importc, libprag.}

proc setActionTargetValue*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    targetValue: glib.Variant = nil) =
  gtk_actionable_set_action_target_value(cast[ptr Actionable00](self.impl), if targetValue.isNil: nil else: cast[ptr glib.Variant00](targetValue.impl))

proc `actionTargetValue=`*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    targetValue: glib.Variant = nil) =
  gtk_actionable_set_action_target_value(cast[ptr Actionable00](self.impl), if targetValue.isNil: nil else: cast[ptr glib.Variant00](targetValue.impl))

proc gtk_actionable_set_detailed_action_name(self: ptr Actionable00; detailedActionName: cstring) {.
    importc, libprag.}

proc setDetailedActionName*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    detailedActionName: cstring) =
  gtk_actionable_set_detailed_action_name(cast[ptr Actionable00](self.impl), detailedActionName)

proc `detailedActionName=`*(self: Actionable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | Switch | RadioToolButton | ListBoxRow | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    detailedActionName: cstring) =
  gtk_actionable_set_detailed_action_name(cast[ptr Actionable00](self.impl), detailedActionName)

type
  Popover* = ref object of Bin
  Popover00* = object of Bin00

proc gtk_popover_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Popover()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClosed*(self: Popover;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "closed", cast[GCallback](p), xdata, nil, cf)

proc gtk_popover_new(relativeTo: ptr Widget00): ptr Popover00 {.
    importc, libprag.}

proc newPopover*(relativeTo: Widget = nil): Popover =
  let gobj = gtk_popover_new(if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPopover*(tdesc: typedesc; relativeTo: Widget = nil): tdesc =
  assert(result is Popover)
  let gobj = gtk_popover_new(if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopover*[T](result: var T; relativeTo: Widget = nil) {.deprecated.} =
  assert(result is Popover)
  let gobj = gtk_popover_new(if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_new_from_model(relativeTo: ptr Widget00; model: ptr gio.MenuModel00): ptr Popover00 {.
    importc, libprag.}

proc newPopoverFromModel*(relativeTo: Widget = nil; model: gio.MenuModel): Popover =
  let gobj = gtk_popover_new_from_model(if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl), cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPopoverFromModel*(tdesc: typedesc; relativeTo: Widget = nil; model: gio.MenuModel): tdesc =
  assert(result is Popover)
  let gobj = gtk_popover_new_from_model(if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl), cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopoverFromModel*[T](result: var T; relativeTo: Widget = nil; model: gio.MenuModel) {.deprecated.} =
  assert(result is Popover)
  let gobj = gtk_popover_new_from_model(if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl), cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_bind_model(self: ptr Popover00; model: ptr gio.MenuModel00;
    actionNamespace: cstring) {.
    importc, libprag.}

proc bindModel*(self: Popover; model: gio.MenuModel = nil; actionNamespace: cstring = nil) =
  gtk_popover_bind_model(cast[ptr Popover00](self.impl), if model.isNil: nil else: cast[ptr gio.MenuModel00](model.impl), actionNamespace)

proc gtk_popover_get_default_widget(self: ptr Popover00): ptr Widget00 {.
    importc, libprag.}

proc getDefaultWidget*(self: Popover): Widget =
  let gobj = gtk_popover_get_default_widget(cast[ptr Popover00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultWidget*(self: Popover): Widget =
  let gobj = gtk_popover_get_default_widget(cast[ptr Popover00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_get_modal(self: ptr Popover00): gboolean {.
    importc, libprag.}

proc getModal*(self: Popover): bool =
  toBool(gtk_popover_get_modal(cast[ptr Popover00](self.impl)))

proc modal*(self: Popover): bool =
  toBool(gtk_popover_get_modal(cast[ptr Popover00](self.impl)))

proc gtk_popover_get_pointing_to(self: ptr Popover00; rect: var gdk.Rectangle): gboolean {.
    importc, libprag.}

proc getPointingTo*(self: Popover; rect: var gdk.Rectangle): bool =
  toBool(gtk_popover_get_pointing_to(cast[ptr Popover00](self.impl), rect))

proc gtk_popover_get_relative_to(self: ptr Popover00): ptr Widget00 {.
    importc, libprag.}

proc getRelativeTo*(self: Popover): Widget =
  let gobj = gtk_popover_get_relative_to(cast[ptr Popover00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc relativeTo*(self: Popover): Widget =
  let gobj = gtk_popover_get_relative_to(cast[ptr Popover00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_get_transitions_enabled(self: ptr Popover00): gboolean {.
    importc, libprag.}

proc getTransitionsEnabled*(self: Popover): bool =
  toBool(gtk_popover_get_transitions_enabled(cast[ptr Popover00](self.impl)))

proc transitionsEnabled*(self: Popover): bool =
  toBool(gtk_popover_get_transitions_enabled(cast[ptr Popover00](self.impl)))

proc gtk_popover_popdown(self: ptr Popover00) {.
    importc, libprag.}

proc popdown*(self: Popover) =
  gtk_popover_popdown(cast[ptr Popover00](self.impl))

proc gtk_popover_popup(self: ptr Popover00) {.
    importc, libprag.}

proc popup*(self: Popover) =
  gtk_popover_popup(cast[ptr Popover00](self.impl))

proc gtk_popover_set_default_widget(self: ptr Popover00; widget: ptr Widget00) {.
    importc, libprag.}

proc setDefaultWidget*(self: Popover; widget: Widget = nil) =
  gtk_popover_set_default_widget(cast[ptr Popover00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `defaultWidget=`*(self: Popover; widget: Widget = nil) =
  gtk_popover_set_default_widget(cast[ptr Popover00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc gtk_popover_set_modal(self: ptr Popover00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: Popover; modal: bool = true) =
  gtk_popover_set_modal(cast[ptr Popover00](self.impl), gboolean(modal))

proc `modal=`*(self: Popover; modal: bool) =
  gtk_popover_set_modal(cast[ptr Popover00](self.impl), gboolean(modal))

proc gtk_popover_set_pointing_to(self: ptr Popover00; rect: gdk.Rectangle) {.
    importc, libprag.}

proc setPointingTo*(self: Popover; rect: gdk.Rectangle) =
  gtk_popover_set_pointing_to(cast[ptr Popover00](self.impl), rect)

proc `pointingTo=`*(self: Popover; rect: gdk.Rectangle) =
  gtk_popover_set_pointing_to(cast[ptr Popover00](self.impl), rect)

proc gtk_popover_set_relative_to(self: ptr Popover00; relativeTo: ptr Widget00) {.
    importc, libprag.}

proc setRelativeTo*(self: Popover; relativeTo: Widget = nil) =
  gtk_popover_set_relative_to(cast[ptr Popover00](self.impl), if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl))

proc `relativeTo=`*(self: Popover; relativeTo: Widget = nil) =
  gtk_popover_set_relative_to(cast[ptr Popover00](self.impl), if relativeTo.isNil: nil else: cast[ptr Widget00](relativeTo.impl))

proc gtk_popover_set_transitions_enabled(self: ptr Popover00; transitionsEnabled: gboolean) {.
    importc, libprag.}

proc setTransitionsEnabled*(self: Popover; transitionsEnabled: bool = true) =
  gtk_popover_set_transitions_enabled(cast[ptr Popover00](self.impl), gboolean(transitionsEnabled))

proc `transitionsEnabled=`*(self: Popover; transitionsEnabled: bool) =
  gtk_popover_set_transitions_enabled(cast[ptr Popover00](self.impl), gboolean(transitionsEnabled))

proc gtk_menu_button_get_popover(self: ptr MenuButton00): ptr Popover00 {.
    importc, libprag.}

proc getPopover*(self: MenuButton): Popover =
  let gobj = gtk_menu_button_get_popover(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc popover*(self: MenuButton): Popover =
  let gobj = gtk_menu_button_get_popover(cast[ptr MenuButton00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  PopoverConstraint* {.size: sizeof(cint), pure.} = enum
    none = 0
    window = 1

proc gtk_popover_get_constrain_to(self: ptr Popover00): PopoverConstraint {.
    importc, libprag.}

proc getConstrainTo*(self: Popover): PopoverConstraint =
  gtk_popover_get_constrain_to(cast[ptr Popover00](self.impl))

proc constrainTo*(self: Popover): PopoverConstraint =
  gtk_popover_get_constrain_to(cast[ptr Popover00](self.impl))

proc gtk_popover_set_constrain_to(self: ptr Popover00; constraint: PopoverConstraint) {.
    importc, libprag.}

proc setConstrainTo*(self: Popover; constraint: PopoverConstraint) =
  gtk_popover_set_constrain_to(cast[ptr Popover00](self.impl), constraint)

proc `constrainTo=`*(self: Popover; constraint: PopoverConstraint) =
  gtk_popover_set_constrain_to(cast[ptr Popover00](self.impl), constraint)

type
  ArrowType* {.size: sizeof(cint), pure.} = enum
    up = 0
    down = 1
    left = 2
    right = 3
    none = 4

proc gtk_menu_button_get_direction(self: ptr MenuButton00): ArrowType {.
    importc, libprag.}

proc getDirection*(self: MenuButton): ArrowType =
  gtk_menu_button_get_direction(cast[ptr MenuButton00](self.impl))

proc direction*(self: MenuButton): ArrowType =
  gtk_menu_button_get_direction(cast[ptr MenuButton00](self.impl))

proc gtk_menu_button_set_direction(self: ptr MenuButton00; direction: ArrowType) {.
    importc, libprag.}

proc setDirection*(self: MenuButton; direction: ArrowType) =
  gtk_menu_button_set_direction(cast[ptr MenuButton00](self.impl), direction)

proc `direction=`*(self: MenuButton; direction: ArrowType) =
  gtk_menu_button_set_direction(cast[ptr MenuButton00](self.impl), direction)

type
  SizeGroup* = ref object of gobject.Object
  SizeGroup00* = object of gobject.Object00

proc gtk_size_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SizeGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_size_group_add_widget(self: ptr SizeGroup00; widget: ptr Widget00) {.
    importc, libprag.}

proc addWidget*(self: SizeGroup; widget: Widget) =
  gtk_size_group_add_widget(cast[ptr SizeGroup00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_size_group_get_ignore_hidden(self: ptr SizeGroup00): gboolean {.
    importc, libprag.}

proc getIgnoreHidden*(self: SizeGroup): bool =
  toBool(gtk_size_group_get_ignore_hidden(cast[ptr SizeGroup00](self.impl)))

proc ignoreHidden*(self: SizeGroup): bool =
  toBool(gtk_size_group_get_ignore_hidden(cast[ptr SizeGroup00](self.impl)))

proc gtk_size_group_get_widgets(self: ptr SizeGroup00): ptr glib.SList {.
    importc, libprag.}

proc getWidgets*(self: SizeGroup): seq[Widget] =
  result = gslistObjects2seq(Widget, gtk_size_group_get_widgets(cast[ptr SizeGroup00](self.impl)), false)

proc widgets*(self: SizeGroup): seq[Widget] =
  result = gslistObjects2seq(Widget, gtk_size_group_get_widgets(cast[ptr SizeGroup00](self.impl)), false)

proc gtk_size_group_remove_widget(self: ptr SizeGroup00; widget: ptr Widget00) {.
    importc, libprag.}

proc removeWidget*(self: SizeGroup; widget: Widget) =
  gtk_size_group_remove_widget(cast[ptr SizeGroup00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_size_group_set_ignore_hidden(self: ptr SizeGroup00; ignoreHidden: gboolean) {.
    importc, libprag.}

proc setIgnoreHidden*(self: SizeGroup; ignoreHidden: bool = true) =
  gtk_size_group_set_ignore_hidden(cast[ptr SizeGroup00](self.impl), gboolean(ignoreHidden))

proc `ignoreHidden=`*(self: SizeGroup; ignoreHidden: bool) =
  gtk_size_group_set_ignore_hidden(cast[ptr SizeGroup00](self.impl), gboolean(ignoreHidden))

proc gtk_tool_item_get_text_size_group(self: ptr ToolItem00): ptr SizeGroup00 {.
    importc, libprag.}

proc getTextSizeGroup*(self: ToolItem): SizeGroup =
  let gobj = gtk_tool_item_get_text_size_group(cast[ptr ToolItem00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc textSizeGroup*(self: ToolItem): SizeGroup =
  let gobj = gtk_tool_item_get_text_size_group(cast[ptr ToolItem00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  SizeGroupMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    horizontal = 1
    vertical = 2
    both = 3

proc gtk_size_group_new(mode: SizeGroupMode): ptr SizeGroup00 {.
    importc, libprag.}

proc newSizeGroup*(mode: SizeGroupMode): SizeGroup =
  let gobj = gtk_size_group_new(mode)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSizeGroup*(tdesc: typedesc; mode: SizeGroupMode): tdesc =
  assert(result is SizeGroup)
  let gobj = gtk_size_group_new(mode)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSizeGroup*[T](result: var T; mode: SizeGroupMode) {.deprecated.} =
  assert(result is SizeGroup)
  let gobj = gtk_size_group_new(mode)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_size_group_get_mode(self: ptr SizeGroup00): SizeGroupMode {.
    importc, libprag.}

proc getMode*(self: SizeGroup): SizeGroupMode =
  gtk_size_group_get_mode(cast[ptr SizeGroup00](self.impl))

proc mode*(self: SizeGroup): SizeGroupMode =
  gtk_size_group_get_mode(cast[ptr SizeGroup00](self.impl))

proc gtk_size_group_set_mode(self: ptr SizeGroup00; mode: SizeGroupMode) {.
    importc, libprag.}

proc setMode*(self: SizeGroup; mode: SizeGroupMode) =
  gtk_size_group_set_mode(cast[ptr SizeGroup00](self.impl), mode)

proc `mode=`*(self: SizeGroup; mode: SizeGroupMode) =
  gtk_size_group_set_mode(cast[ptr SizeGroup00](self.impl), mode)

type
  ToolbarStyle* {.size: sizeof(cint), pure.} = enum
    icons = 0
    text = 1
    both = 2
    bothHoriz = 3

proc gtk_tool_item_get_toolbar_style(self: ptr ToolItem00): ToolbarStyle {.
    importc, libprag.}

proc getToolbarStyle*(self: ToolItem): ToolbarStyle =
  gtk_tool_item_get_toolbar_style(cast[ptr ToolItem00](self.impl))

proc toolbarStyle*(self: ToolItem): ToolbarStyle =
  gtk_tool_item_get_toolbar_style(cast[ptr ToolItem00](self.impl))

type
  PositionType* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    top = 2
    bottom = 3

proc gtk_button_get_image_position(self: ptr Button00): PositionType {.
    importc, libprag.}

proc getImagePosition*(self: Button): PositionType =
  gtk_button_get_image_position(cast[ptr Button00](self.impl))

proc imagePosition*(self: Button): PositionType =
  gtk_button_get_image_position(cast[ptr Button00](self.impl))

proc gtk_button_set_image_position(self: ptr Button00; position: PositionType) {.
    importc, libprag.}

proc setImagePosition*(self: Button; position: PositionType) =
  gtk_button_set_image_position(cast[ptr Button00](self.impl), position)

proc `imagePosition=`*(self: Button; position: PositionType) =
  gtk_button_set_image_position(cast[ptr Button00](self.impl), position)

proc gtk_popover_get_position(self: ptr Popover00): PositionType {.
    importc, libprag.}

proc getPosition*(self: Popover): PositionType =
  gtk_popover_get_position(cast[ptr Popover00](self.impl))

proc position*(self: Popover): PositionType =
  gtk_popover_get_position(cast[ptr Popover00](self.impl))

proc gtk_popover_set_position(self: ptr Popover00; position: PositionType) {.
    importc, libprag.}

proc setPosition*(self: Popover; position: PositionType) =
  gtk_popover_set_position(cast[ptr Popover00](self.impl), position)

proc `position=`*(self: Popover; position: PositionType) =
  gtk_popover_set_position(cast[ptr Popover00](self.impl), position)

type
  ReliefStyle* {.size: sizeof(cint), pure.} = enum
    normal = 0
    half = 1
    none = 2

proc gtk_button_get_relief(self: ptr Button00): ReliefStyle {.
    importc, libprag.}

proc getRelief*(self: Button): ReliefStyle =
  gtk_button_get_relief(cast[ptr Button00](self.impl))

proc relief*(self: Button): ReliefStyle =
  gtk_button_get_relief(cast[ptr Button00](self.impl))

proc gtk_button_set_relief(self: ptr Button00; relief: ReliefStyle) {.
    importc, libprag.}

proc setRelief*(self: Button; relief: ReliefStyle) =
  gtk_button_set_relief(cast[ptr Button00](self.impl), relief)

proc `relief=`*(self: Button; relief: ReliefStyle) =
  gtk_button_set_relief(cast[ptr Button00](self.impl), relief)

proc gtk_tool_item_get_relief_style(self: ptr ToolItem00): ReliefStyle {.
    importc, libprag.}

proc getReliefStyle*(self: ToolItem): ReliefStyle =
  gtk_tool_item_get_relief_style(cast[ptr ToolItem00](self.impl))

proc reliefStyle*(self: ToolItem): ReliefStyle =
  gtk_tool_item_get_relief_style(cast[ptr ToolItem00](self.impl))

type
  Activatable00* = object of gobject.Object00
  Activatable* = ref object of gobject.Object

type
  SeparatorToolItem* = ref object of ToolItem
  SeparatorToolItem00* = object of ToolItem00

proc gtk_separator_tool_item_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SeparatorToolItem()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_separator_tool_item_new(): ptr SeparatorToolItem00 {.
    importc, libprag.}

proc newSeparatorToolItem*(): SeparatorToolItem =
  let gobj = gtk_separator_tool_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSeparatorToolItem*(tdesc: typedesc): tdesc =
  assert(result is SeparatorToolItem)
  let gobj = gtk_separator_tool_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSeparatorToolItem*[T](result: var T) {.deprecated.} =
  assert(result is SeparatorToolItem)
  let gobj = gtk_separator_tool_item_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_separator_tool_item_get_draw(self: ptr SeparatorToolItem00): gboolean {.
    importc, libprag.}

proc getDraw*(self: SeparatorToolItem): bool =
  toBool(gtk_separator_tool_item_get_draw(cast[ptr SeparatorToolItem00](self.impl)))

proc draw*(self: SeparatorToolItem): bool =
  toBool(gtk_separator_tool_item_get_draw(cast[ptr SeparatorToolItem00](self.impl)))

proc gtk_separator_tool_item_set_draw(self: ptr SeparatorToolItem00; draw: gboolean) {.
    importc, libprag.}

proc setDraw*(self: SeparatorToolItem; draw: bool = true) =
  gtk_separator_tool_item_set_draw(cast[ptr SeparatorToolItem00](self.impl), gboolean(draw))

proc `draw=`*(self: SeparatorToolItem; draw: bool) =
  gtk_separator_tool_item_set_draw(cast[ptr SeparatorToolItem00](self.impl), gboolean(draw))

type
  RecentChooserMenu* = ref object of Menu
  RecentChooserMenu00* = object of Menu00

proc gtk_recent_chooser_menu_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentChooserMenu()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_recent_chooser_menu_new(): ptr RecentChooserMenu00 {.
    importc, libprag.}

proc newRecentChooserMenu*(): RecentChooserMenu =
  let gobj = gtk_recent_chooser_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentChooserMenu*(tdesc: typedesc): tdesc =
  assert(result is RecentChooserMenu)
  let gobj = gtk_recent_chooser_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserMenu*[T](result: var T) {.deprecated.} =
  assert(result is RecentChooserMenu)
  let gobj = gtk_recent_chooser_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_chooser_menu_get_show_numbers(self: ptr RecentChooserMenu00): gboolean {.
    importc, libprag.}

proc getShowNumbers*(self: RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_menu_get_show_numbers(cast[ptr RecentChooserMenu00](self.impl)))

proc showNumbers*(self: RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_menu_get_show_numbers(cast[ptr RecentChooserMenu00](self.impl)))

proc gtk_recent_chooser_menu_set_show_numbers(self: ptr RecentChooserMenu00;
    showNumbers: gboolean) {.
    importc, libprag.}

proc setShowNumbers*(self: RecentChooserMenu; showNumbers: bool = true) =
  gtk_recent_chooser_menu_set_show_numbers(cast[ptr RecentChooserMenu00](self.impl), gboolean(showNumbers))

proc `showNumbers=`*(self: RecentChooserMenu; showNumbers: bool) =
  gtk_recent_chooser_menu_set_show_numbers(cast[ptr RecentChooserMenu00](self.impl), gboolean(showNumbers))

proc gtk_activatable_do_set_related_action(self: ptr Activatable00; action: ptr Action00) {.
    importc, libprag.}

proc doSetRelatedAction*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    action: Action) =
  gtk_activatable_do_set_related_action(cast[ptr Activatable00](self.impl), cast[ptr Action00](action.impl))

proc gtk_activatable_get_related_action(self: ptr Activatable00): ptr Action00 {.
    importc, libprag.}

proc getRelatedAction*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): Action =
  let gobj = gtk_activatable_get_related_action(cast[ptr Activatable00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc relatedAction*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): Action =
  let gobj = gtk_activatable_get_related_action(cast[ptr Activatable00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_activatable_get_use_action_appearance(self: ptr Activatable00): gboolean {.
    importc, libprag.}

proc getUseActionAppearance*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): bool =
  toBool(gtk_activatable_get_use_action_appearance(cast[ptr Activatable00](self.impl)))

proc useActionAppearance*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton): bool =
  toBool(gtk_activatable_get_use_action_appearance(cast[ptr Activatable00](self.impl)))

proc gtk_activatable_set_related_action(self: ptr Activatable00; action: ptr Action00) {.
    importc, libprag.}

proc setRelatedAction*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    action: Action) =
  gtk_activatable_set_related_action(cast[ptr Activatable00](self.impl), cast[ptr Action00](action.impl))

proc `relatedAction=`*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    action: Action) =
  gtk_activatable_set_related_action(cast[ptr Activatable00](self.impl), cast[ptr Action00](action.impl))

proc gtk_activatable_set_use_action_appearance(self: ptr Activatable00; useAppearance: gboolean) {.
    importc, libprag.}

proc setUseActionAppearance*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    useAppearance: bool = true) =
  gtk_activatable_set_use_action_appearance(cast[ptr Activatable00](self.impl), gboolean(useAppearance))

proc `useActionAppearance=`*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    useAppearance: bool) =
  gtk_activatable_set_use_action_appearance(cast[ptr Activatable00](self.impl), gboolean(useAppearance))

proc gtk_activatable_sync_action_properties(self: ptr Activatable00; action: ptr Action00) {.
    importc, libprag.}

proc syncActionProperties*(self: Activatable | TearoffMenuItem | CheckButton | ToggleToolButton | ModelButton | ScaleButton | SeparatorToolItem | Switch | ToolItem | RadioToolButton | ColorButton | RadioButton | LinkButton | ImageMenuItem | MenuToolButton | ToggleButton | LockButton | CheckMenuItem | MenuItem | RadioMenuItem | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | Button | MenuButton | ToolButton;
    action: Action = nil) =
  gtk_activatable_sync_action_properties(cast[ptr Activatable00](self.impl), if action.isNil: nil else: cast[ptr Action00](action.impl))

type
  RecentManager* = ref object of gobject.Object
  RecentManager00* = object of gobject.Object00

proc gtk_recent_manager_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentManager()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: RecentManager;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_recent_manager_new(): ptr RecentManager00 {.
    importc, libprag.}

proc newRecentManager*(): RecentManager =
  let gobj = gtk_recent_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentManager*(tdesc: typedesc): tdesc =
  assert(result is RecentManager)
  let gobj = gtk_recent_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentManager*[T](result: var T) {.deprecated.} =
  assert(result is RecentManager)
  let gobj = gtk_recent_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_manager_get_default(): ptr RecentManager00 {.
    importc, libprag.}

proc getDefaultRecentManager*(): RecentManager =
  let gobj = gtk_recent_manager_get_default()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_manager_add_item(self: ptr RecentManager00; uri: cstring): gboolean {.
    importc, libprag.}

proc addItem*(self: RecentManager; uri: cstring): bool =
  toBool(gtk_recent_manager_add_item(cast[ptr RecentManager00](self.impl), uri))

proc gtk_recent_manager_has_item(self: ptr RecentManager00; uri: cstring): gboolean {.
    importc, libprag.}

proc hasItem*(self: RecentManager; uri: cstring): bool =
  toBool(gtk_recent_manager_has_item(cast[ptr RecentManager00](self.impl), uri))

proc gtk_recent_manager_move_item(self: ptr RecentManager00; uri: cstring;
    newUri: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc moveItem*(self: RecentManager; uri: cstring; newUri: cstring = nil): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_manager_move_item(cast[ptr RecentManager00](self.impl), uri, newUri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_recent_manager_purge_items(self: ptr RecentManager00; error: ptr ptr glib.Error = nil): int32 {.
    importc, libprag.}

proc purgeItems*(self: RecentManager): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_manager_purge_items(cast[ptr RecentManager00](self.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_recent_manager_remove_item(self: ptr RecentManager00; uri: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc removeItem*(self: RecentManager; uri: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_manager_remove_item(cast[ptr RecentManager00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_recent_chooser_menu_new_for_manager(manager: ptr RecentManager00): ptr RecentChooserMenu00 {.
    importc, libprag.}

proc newRecentChooserMenuForManager*(manager: RecentManager): RecentChooserMenu =
  let gobj = gtk_recent_chooser_menu_new_for_manager(cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentChooserMenuForManager*(tdesc: typedesc; manager: RecentManager): tdesc =
  assert(result is RecentChooserMenu)
  let gobj = gtk_recent_chooser_menu_new_for_manager(cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserMenuForManager*[T](result: var T; manager: RecentManager) {.deprecated.} =
  assert(result is RecentChooserMenu)
  let gobj = gtk_recent_chooser_menu_new_for_manager(cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  RecentData* {.pure, byRef.} = object
    displayName*: cstring
    description*: cstring
    mimeType*: cstring
    appName*: cstring
    appExec*: cstring
    groups*: ptr cstring
    isPrivate*: gboolean

proc gtk_recent_manager_add_full(self: ptr RecentManager00; uri: cstring;
    recentData: RecentData): gboolean {.
    importc, libprag.}

proc addFull*(self: RecentManager; uri: cstring; recentData: RecentData): bool =
  toBool(gtk_recent_manager_add_full(cast[ptr RecentManager00](self.impl), uri, recentData))

type
  RecentInfo00* {.pure.} = object
  RecentInfo* = ref object
    impl*: ptr RecentInfo00
    ignoreFinalizer*: bool

proc gtk_recent_info_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkRecentInfo*(self: RecentInfo) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_recent_info_get_type(), cast[ptr RecentInfo00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentInfo()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_recent_info_get_type(), cast[ptr RecentInfo00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var RecentInfo) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkRecentInfo)

proc gtk_recent_info_unref(self: ptr RecentInfo00) {.
    importc, libprag.}

proc unref*(self: RecentInfo) =
  gtk_recent_info_unref(cast[ptr RecentInfo00](self.impl))

proc finalizerunref*(self: RecentInfo) =
  if not self.ignoreFinalizer:
    gtk_recent_info_unref(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_exists(self: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc exists*(self: RecentInfo): bool =
  toBool(gtk_recent_info_exists(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_added(self: ptr RecentInfo00): int64 {.
    importc, libprag.}

proc getAdded*(self: RecentInfo): int64 =
  gtk_recent_info_get_added(cast[ptr RecentInfo00](self.impl))

proc added*(self: RecentInfo): int64 =
  gtk_recent_info_get_added(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_age(self: ptr RecentInfo00): int32 {.
    importc, libprag.}

proc getAge*(self: RecentInfo): int =
  int(gtk_recent_info_get_age(cast[ptr RecentInfo00](self.impl)))

proc age*(self: RecentInfo): int =
  int(gtk_recent_info_get_age(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_application_info(self: ptr RecentInfo00; appName: cstring;
    appExec: var cstring; count: var uint32; time: var int64): gboolean {.
    importc, libprag.}

proc getApplicationInfo*(self: RecentInfo; appName: cstring;
    appExec: var string; count: var int; time: var int64): bool =
  var count_00: uint32
  var appExec_00: cstring
  result = toBool(gtk_recent_info_get_application_info(cast[ptr RecentInfo00](self.impl), appName, appExec_00, count_00, time))
  if count.addr != nil:
    count = int(count_00)
  if appExec.addr != nil:
    appExec = $(appExec_00)

proc gtk_recent_info_get_applications(self: ptr RecentInfo00; length: var uint64): ptr cstring {.
    importc, libprag.}

proc getApplications*(self: RecentInfo; length: var uint64 = cast[var uint64](nil)): seq[string] =
  let resul0 = gtk_recent_info_get_applications(cast[ptr RecentInfo00](self.impl), length)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_recent_info_get_description(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getDescription*(self: RecentInfo): string =
  result = $gtk_recent_info_get_description(cast[ptr RecentInfo00](self.impl))

proc description*(self: RecentInfo): string =
  result = $gtk_recent_info_get_description(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_display_name(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getDisplayName*(self: RecentInfo): string =
  result = $gtk_recent_info_get_display_name(cast[ptr RecentInfo00](self.impl))

proc displayName*(self: RecentInfo): string =
  result = $gtk_recent_info_get_display_name(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_gicon(self: ptr RecentInfo00): ptr gio.Icon00 {.
    importc, libprag.}

proc getGicon*(self: RecentInfo): gio.Icon =
  let gobj = gtk_recent_info_get_gicon(cast[ptr RecentInfo00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gicon*(self: RecentInfo): gio.Icon =
  let gobj = gtk_recent_info_get_gicon(cast[ptr RecentInfo00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_info_get_groups(self: ptr RecentInfo00; length: var uint64): ptr cstring {.
    importc, libprag.}

proc getGroups*(self: RecentInfo; length: var uint64 = cast[var uint64](nil)): seq[string] =
  let resul0 = gtk_recent_info_get_groups(cast[ptr RecentInfo00](self.impl), length)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_recent_info_get_icon(self: ptr RecentInfo00; size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getIcon*(self: RecentInfo; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_recent_info_get_icon(cast[ptr RecentInfo00](self.impl), int32(size))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_info_get_mime_type(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getMimeType*(self: RecentInfo): string =
  result = $gtk_recent_info_get_mime_type(cast[ptr RecentInfo00](self.impl))

proc mimeType*(self: RecentInfo): string =
  result = $gtk_recent_info_get_mime_type(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_modified(self: ptr RecentInfo00): int64 {.
    importc, libprag.}

proc getModified*(self: RecentInfo): int64 =
  gtk_recent_info_get_modified(cast[ptr RecentInfo00](self.impl))

proc modified*(self: RecentInfo): int64 =
  gtk_recent_info_get_modified(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_private_hint(self: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc getPrivateHint*(self: RecentInfo): bool =
  toBool(gtk_recent_info_get_private_hint(cast[ptr RecentInfo00](self.impl)))

proc privateHint*(self: RecentInfo): bool =
  toBool(gtk_recent_info_get_private_hint(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_get_short_name(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getShortName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_short_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc shortName*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_short_name(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_get_uri(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getUri*(self: RecentInfo): string =
  result = $gtk_recent_info_get_uri(cast[ptr RecentInfo00](self.impl))

proc uri*(self: RecentInfo): string =
  result = $gtk_recent_info_get_uri(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_get_uri_display(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc getUriDisplay*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri_display(cast[ptr RecentInfo00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc uriDisplay*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_get_uri_display(cast[ptr RecentInfo00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_get_visited(self: ptr RecentInfo00): int64 {.
    importc, libprag.}

proc getVisited*(self: RecentInfo): int64 =
  gtk_recent_info_get_visited(cast[ptr RecentInfo00](self.impl))

proc visited*(self: RecentInfo): int64 =
  gtk_recent_info_get_visited(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_has_application(self: ptr RecentInfo00; appName: cstring): gboolean {.
    importc, libprag.}

proc hasApplication*(self: RecentInfo; appName: cstring): bool =
  toBool(gtk_recent_info_has_application(cast[ptr RecentInfo00](self.impl), appName))

proc gtk_recent_info_has_group(self: ptr RecentInfo00; groupName: cstring): gboolean {.
    importc, libprag.}

proc hasGroup*(self: RecentInfo; groupName: cstring): bool =
  toBool(gtk_recent_info_has_group(cast[ptr RecentInfo00](self.impl), groupName))

proc gtk_recent_info_is_local(self: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc isLocal*(self: RecentInfo): bool =
  toBool(gtk_recent_info_is_local(cast[ptr RecentInfo00](self.impl)))

proc gtk_recent_info_last_application(self: ptr RecentInfo00): cstring {.
    importc, libprag.}

proc lastApplication*(self: RecentInfo): string =
  let resul0 = gtk_recent_info_last_application(cast[ptr RecentInfo00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_info_match(self: ptr RecentInfo00; infoB: ptr RecentInfo00): gboolean {.
    importc, libprag.}

proc match*(self: RecentInfo; infoB: RecentInfo): bool =
  toBool(gtk_recent_info_match(cast[ptr RecentInfo00](self.impl), cast[ptr RecentInfo00](infoB.impl)))

proc gtk_recent_info_ref(self: ptr RecentInfo00): ptr RecentInfo00 {.
    importc, libprag.}

proc `ref`*(self: RecentInfo): RecentInfo =
  fnew(result, gBoxedFreeGtkRecentInfo)
  result.impl = gtk_recent_info_ref(cast[ptr RecentInfo00](self.impl))

proc gtk_recent_info_create_app_info(self: ptr RecentInfo00; appName: cstring;
    error: ptr ptr glib.Error = nil): ptr gio.AppInfo00 {.
    importc, libprag.}

proc createAppInfo*(self: RecentInfo; appName: cstring = nil): gio.AppInfo =
  var gerror: ptr glib.Error
  let gobj = gtk_recent_info_create_app_info(cast[ptr RecentInfo00](self.impl), appName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_manager_get_items(self: ptr RecentManager00): ptr glib.List {.
    importc, libprag.}

proc getItems*(self: RecentManager): seq[RecentInfo] =
  let resul0 = gtk_recent_manager_get_items(cast[ptr RecentManager00](self.impl))
  result = glistStructs2seq[RecentInfo](resul0, false)
  g_list_free(resul0)

proc items*(self: RecentManager): seq[RecentInfo] =
  let resul0 = gtk_recent_manager_get_items(cast[ptr RecentManager00](self.impl))
  result = glistStructs2seq[RecentInfo](resul0, false)
  g_list_free(resul0)

proc gtk_recent_manager_lookup_item(self: ptr RecentManager00; uri: cstring;
    error: ptr ptr glib.Error = nil): ptr RecentInfo00 {.
    importc, libprag.}

proc lookupItem*(self: RecentManager; uri: cstring): RecentInfo =
  var gerror: ptr glib.Error
  let impl0 = gtk_recent_manager_lookup_item(cast[ptr RecentManager00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkRecentInfo)
  result.impl = impl0

type
  Alignment* = ref object of Bin
  Alignment00* = object of Bin00

proc gtk_alignment_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Alignment()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_alignment_new(xalign: cfloat; yalign: cfloat; xscale: cfloat; yscale: cfloat): ptr Alignment00 {.
    importc, libprag.}

proc newAlignment*(xalign: cfloat; yalign: cfloat; xscale: cfloat; yscale: cfloat): Alignment {.deprecated.}  =
  let gobj = gtk_alignment_new(xalign, yalign, xscale, yscale)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAlignment*(tdesc: typedesc; xalign: cfloat; yalign: cfloat; xscale: cfloat; yscale: cfloat): tdesc {.deprecated.}  =
  assert(result is Alignment)
  let gobj = gtk_alignment_new(xalign, yalign, xscale, yscale)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAlignment*[T](result: var T; xalign: cfloat; yalign: cfloat; xscale: cfloat; yscale: cfloat) {.deprecated.} =
  assert(result is Alignment)
  let gobj = gtk_alignment_new(xalign, yalign, xscale, yscale)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_alignment_get_padding(self: ptr Alignment00; paddingTop: var uint32;
    paddingBottom: var uint32; paddingLeft: var uint32; paddingRight: var uint32) {.
    importc, libprag.}

proc getPadding*(self: Alignment; paddingTop: var int = cast[var int](nil);
    paddingBottom: var int = cast[var int](nil); paddingLeft: var int = cast[var int](nil);
    paddingRight: var int = cast[var int](nil)) =
  var paddingTop_00: uint32
  var paddingRight_00: uint32
  var paddingBottom_00: uint32
  var paddingLeft_00: uint32
  gtk_alignment_get_padding(cast[ptr Alignment00](self.impl), paddingTop_00, paddingBottom_00, paddingLeft_00, paddingRight_00)
  if paddingTop.addr != nil:
    paddingTop = int(paddingTop_00)
  if paddingRight.addr != nil:
    paddingRight = int(paddingRight_00)
  if paddingBottom.addr != nil:
    paddingBottom = int(paddingBottom_00)
  if paddingLeft.addr != nil:
    paddingLeft = int(paddingLeft_00)

proc gtk_alignment_set(self: ptr Alignment00; xalign: cfloat; yalign: cfloat;
    xscale: cfloat; yscale: cfloat) {.
    importc, libprag.}

proc set*(self: Alignment; xalign: cfloat; yalign: cfloat; xscale: cfloat;
    yscale: cfloat) =
  gtk_alignment_set(cast[ptr Alignment00](self.impl), xalign, yalign, xscale, yscale)

proc gtk_alignment_set_padding(self: ptr Alignment00; paddingTop: uint32;
    paddingBottom: uint32; paddingLeft: uint32; paddingRight: uint32) {.
    importc, libprag.}

proc setPadding*(self: Alignment; paddingTop: int; paddingBottom: int;
    paddingLeft: int; paddingRight: int) =
  gtk_alignment_set_padding(cast[ptr Alignment00](self.impl), uint32(paddingTop), uint32(paddingBottom), uint32(paddingLeft), uint32(paddingRight))

type
  AppChooser00* = object of gobject.Object00
  AppChooser* = ref object of gobject.Object

type
  AppChooserDialog* = ref object of Dialog
  AppChooserDialog00* = object of Dialog00

proc gtk_app_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AppChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_app_chooser_dialog_get_heading(self: ptr AppChooserDialog00): cstring {.
    importc, libprag.}

proc getHeading*(self: AppChooserDialog): string =
  let resul0 = gtk_app_chooser_dialog_get_heading(cast[ptr AppChooserDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc heading*(self: AppChooserDialog): string =
  let resul0 = gtk_app_chooser_dialog_get_heading(cast[ptr AppChooserDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_app_chooser_dialog_get_widget(self: ptr AppChooserDialog00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: AppChooserDialog): Widget =
  let gobj = gtk_app_chooser_dialog_get_widget(cast[ptr AppChooserDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: AppChooserDialog): Widget =
  let gobj = gtk_app_chooser_dialog_get_widget(cast[ptr AppChooserDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_dialog_set_heading(self: ptr AppChooserDialog00; heading: cstring) {.
    importc, libprag.}

proc setHeading*(self: AppChooserDialog; heading: cstring) =
  gtk_app_chooser_dialog_set_heading(cast[ptr AppChooserDialog00](self.impl), heading)

proc `heading=`*(self: AppChooserDialog; heading: cstring) =
  gtk_app_chooser_dialog_set_heading(cast[ptr AppChooserDialog00](self.impl), heading)

type
  AppChooserWidget* = ref object of Box
  AppChooserWidget00* = object of Box00

proc gtk_app_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AppChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scApplicationActivated*(self: AppChooserWidget;  p: proc (self: ptr AppChooserWidget00; application: ptr gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "application-activated", cast[GCallback](p), xdata, nil, cf)

proc scApplicationSelected*(self: AppChooserWidget;  p: proc (self: ptr AppChooserWidget00; application: ptr gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "application-selected", cast[GCallback](p), xdata, nil, cf)

proc scPopulatePopup*(self: AppChooserWidget;  p: proc (self: ptr AppChooserWidget00; menu: ptr Menu00; application: ptr gio.AppInfo00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cf)

proc gtk_app_chooser_widget_new(contentType: cstring): ptr AppChooserWidget00 {.
    importc, libprag.}

proc newAppChooserWidget*(contentType: cstring): AppChooserWidget =
  let gobj = gtk_app_chooser_widget_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserWidget*(tdesc: typedesc; contentType: cstring): tdesc =
  assert(result is AppChooserWidget)
  let gobj = gtk_app_chooser_widget_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserWidget*[T](result: var T; contentType: cstring) {.deprecated.} =
  assert(result is AppChooserWidget)
  let gobj = gtk_app_chooser_widget_new(contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_widget_get_default_text(self: ptr AppChooserWidget00): cstring {.
    importc, libprag.}

proc getDefaultText*(self: AppChooserWidget): string =
  result = $gtk_app_chooser_widget_get_default_text(cast[ptr AppChooserWidget00](self.impl))

proc defaultText*(self: AppChooserWidget): string =
  result = $gtk_app_chooser_widget_get_default_text(cast[ptr AppChooserWidget00](self.impl))

proc gtk_app_chooser_widget_get_show_all(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowAll*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_all(cast[ptr AppChooserWidget00](self.impl)))

proc showAll*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_all(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_default(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowDefault*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_default(cast[ptr AppChooserWidget00](self.impl)))

proc showDefault*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_default(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_fallback(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowFallback*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_fallback(cast[ptr AppChooserWidget00](self.impl)))

proc showFallback*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_fallback(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_other(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowOther*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_other(cast[ptr AppChooserWidget00](self.impl)))

proc showOther*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_other(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_get_show_recommended(self: ptr AppChooserWidget00): gboolean {.
    importc, libprag.}

proc getShowRecommended*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_recommended(cast[ptr AppChooserWidget00](self.impl)))

proc showRecommended*(self: AppChooserWidget): bool =
  toBool(gtk_app_chooser_widget_get_show_recommended(cast[ptr AppChooserWidget00](self.impl)))

proc gtk_app_chooser_widget_set_default_text(self: ptr AppChooserWidget00;
    text: cstring) {.
    importc, libprag.}

proc setDefaultText*(self: AppChooserWidget; text: cstring) =
  gtk_app_chooser_widget_set_default_text(cast[ptr AppChooserWidget00](self.impl), text)

proc `defaultText=`*(self: AppChooserWidget; text: cstring) =
  gtk_app_chooser_widget_set_default_text(cast[ptr AppChooserWidget00](self.impl), text)

proc gtk_app_chooser_widget_set_show_all(self: ptr AppChooserWidget00; setting: gboolean) {.
    importc, libprag.}

proc setShowAll*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_all(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showAll=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_all(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_default(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowDefault*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_default(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showDefault=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_default(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_fallback(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowFallback*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_fallback(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showFallback=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_fallback(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_other(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowOther*(self: AppChooserWidget; setting: bool = true) =
  gtk_app_chooser_widget_set_show_other(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showOther=`*(self: AppChooserWidget; setting: bool) =
  gtk_app_chooser_widget_set_show_other(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_widget_set_show_recommended(self: ptr AppChooserWidget00;
    setting: gboolean) {.
    importc, libprag.}

proc setShowRecommended*(self: AppChooserWidget;
    setting: bool = true) =
  gtk_app_chooser_widget_set_show_recommended(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc `showRecommended=`*(self: AppChooserWidget;
    setting: bool) =
  gtk_app_chooser_widget_set_show_recommended(cast[ptr AppChooserWidget00](self.impl), gboolean(setting))

proc gtk_app_chooser_get_app_info(self: ptr AppChooser00): ptr gio.AppInfo00 {.
    importc, libprag.}

proc getAppInfo*(self: AppChooser | AppChooserButton | AppChooserDialog | AppChooserWidget): gio.AppInfo =
  let gobj = gtk_app_chooser_get_app_info(cast[ptr AppChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc appInfo*(self: AppChooser | AppChooserButton | AppChooserDialog | AppChooserWidget): gio.AppInfo =
  let gobj = gtk_app_chooser_get_app_info(cast[ptr AppChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_get_content_type(self: ptr AppChooser00): cstring {.
    importc, libprag.}

proc getContentType*(self: AppChooser | AppChooserButton | AppChooserDialog | AppChooserWidget): string =
  let resul0 = gtk_app_chooser_get_content_type(cast[ptr AppChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc contentType*(self: AppChooser | AppChooserButton | AppChooserDialog | AppChooserWidget): string =
  let resul0 = gtk_app_chooser_get_content_type(cast[ptr AppChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_app_chooser_refresh(self: ptr AppChooser00) {.
    importc, libprag.}

proc refresh*(self: AppChooser | AppChooserButton | AppChooserDialog | AppChooserWidget) =
  gtk_app_chooser_refresh(cast[ptr AppChooser00](self.impl))

type
  DialogFlag* {.size: sizeof(cint), pure.} = enum
    modal = 0
    destroyWithParent = 1
    useHeaderBar = 2

  DialogFlags* {.size: sizeof(cint).} = set[DialogFlag]

proc gtk_app_chooser_dialog_new(parent: ptr Window00; flags: DialogFlags;
    file: ptr gio.GFile00): ptr AppChooserDialog00 {.
    importc, libprag.}

proc newAppChooserDialog*(parent: Window = nil; flags: DialogFlags;
    file: gio.GFile): AppChooserDialog =
  let gobj = gtk_app_chooser_dialog_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserDialog*(tdesc: typedesc; parent: Window = nil; flags: DialogFlags;
    file: gio.GFile): tdesc =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserDialog*[T](result: var T; parent: Window = nil; flags: DialogFlags;
    file: gio.GFile) {.deprecated.} =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, cast[ptr gio.GFile00](file.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_app_chooser_dialog_new_for_content_type(parent: ptr Window00; flags: DialogFlags;
    contentType: cstring): ptr AppChooserDialog00 {.
    importc, libprag.}

proc newAppChooserDialogForContentType*(parent: Window = nil; flags: DialogFlags;
    contentType: cstring): AppChooserDialog =
  let gobj = gtk_app_chooser_dialog_new_for_content_type(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAppChooserDialogForContentType*(tdesc: typedesc; parent: Window = nil; flags: DialogFlags;
    contentType: cstring): tdesc =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new_for_content_type(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAppChooserDialogForContentType*[T](result: var T; parent: Window = nil; flags: DialogFlags;
    contentType: cstring) {.deprecated.} =
  assert(result is AppChooserDialog)
  let gobj = gtk_app_chooser_dialog_new_for_content_type(if parent.isNil: nil else: cast[ptr Window00](parent.impl), flags, contentType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Arrow* = ref object of Misc
  Arrow00* = object of Misc00

proc gtk_arrow_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Arrow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ShadowType* {.size: sizeof(cint), pure.} = enum
    none = 0
    `in` = 1
    `out` = 2
    etchedIn = 3
    etchedOut = 4

proc gtk_arrow_new(arrowType: ArrowType; shadowType: ShadowType): ptr Arrow00 {.
    importc, libprag.}

proc newArrow*(arrowType: ArrowType; shadowType: ShadowType): Arrow {.deprecated.}  =
  let gobj = gtk_arrow_new(arrowType, shadowType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newArrow*(tdesc: typedesc; arrowType: ArrowType; shadowType: ShadowType): tdesc {.deprecated.}  =
  assert(result is Arrow)
  let gobj = gtk_arrow_new(arrowType, shadowType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initArrow*[T](result: var T; arrowType: ArrowType; shadowType: ShadowType) {.deprecated.} =
  assert(result is Arrow)
  let gobj = gtk_arrow_new(arrowType, shadowType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_arrow_set(self: ptr Arrow00; arrowType: ArrowType; shadowType: ShadowType) {.
    importc, libprag.}

proc set*(self: Arrow; arrowType: ArrowType; shadowType: ShadowType) =
  gtk_arrow_set(cast[ptr Arrow00](self.impl), arrowType, shadowType)

type
  ArrowAccessible* = ref object of WidgetAccessible
  ArrowAccessible00* = object of WidgetAccessible00

proc gtk_arrow_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ArrowAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ArrowPlacement* {.size: sizeof(cint), pure.} = enum
    both = 0
    start = 1
    `end` = 2

type
  Frame* = ref object of Bin
  Frame00* = object of Bin00

proc gtk_frame_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Frame()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_frame_new(label: cstring): ptr Frame00 {.
    importc, libprag.}

proc newFrame*(label: cstring = nil): Frame =
  let gobj = gtk_frame_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFrame*(tdesc: typedesc; label: cstring = nil): tdesc =
  assert(result is Frame)
  let gobj = gtk_frame_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFrame*[T](result: var T; label: cstring = nil) {.deprecated.} =
  assert(result is Frame)
  let gobj = gtk_frame_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_frame_get_label(self: ptr Frame00): cstring {.
    importc, libprag.}

proc getLabel*(self: Frame): string =
  let resul0 = gtk_frame_get_label(cast[ptr Frame00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: Frame): string =
  let resul0 = gtk_frame_get_label(cast[ptr Frame00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_frame_get_label_align(self: ptr Frame00; xalign: var cfloat; yalign: var cfloat) {.
    importc, libprag.}

proc getLabelAlign*(self: Frame; xalign: var cfloat = cast[var cfloat](nil);
    yalign: var cfloat = cast[var cfloat](nil)) =
  gtk_frame_get_label_align(cast[ptr Frame00](self.impl), xalign, yalign)

proc gtk_frame_get_label_widget(self: ptr Frame00): ptr Widget00 {.
    importc, libprag.}

proc getLabelWidget*(self: Frame): Widget =
  let gobj = gtk_frame_get_label_widget(cast[ptr Frame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: Frame): Widget =
  let gobj = gtk_frame_get_label_widget(cast[ptr Frame00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_frame_get_shadow_type(self: ptr Frame00): ShadowType {.
    importc, libprag.}

proc getShadowType*(self: Frame): ShadowType =
  gtk_frame_get_shadow_type(cast[ptr Frame00](self.impl))

proc shadowType*(self: Frame): ShadowType =
  gtk_frame_get_shadow_type(cast[ptr Frame00](self.impl))

proc gtk_frame_set_label(self: ptr Frame00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: Frame; label: cstring = nil) =
  gtk_frame_set_label(cast[ptr Frame00](self.impl), label)

proc `label=`*(self: Frame; label: cstring = nil) =
  gtk_frame_set_label(cast[ptr Frame00](self.impl), label)

proc gtk_frame_set_label_align(self: ptr Frame00; xalign: cfloat; yalign: cfloat) {.
    importc, libprag.}

proc setLabelAlign*(self: Frame; xalign: cfloat; yalign: cfloat) =
  gtk_frame_set_label_align(cast[ptr Frame00](self.impl), xalign, yalign)

proc gtk_frame_set_label_widget(self: ptr Frame00; labelWidget: ptr Widget00) {.
    importc, libprag.}

proc setLabelWidget*(self: Frame; labelWidget: Widget = nil) =
  gtk_frame_set_label_widget(cast[ptr Frame00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: Frame; labelWidget: Widget = nil) =
  gtk_frame_set_label_widget(cast[ptr Frame00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc gtk_frame_set_shadow_type(self: ptr Frame00; `type`: ShadowType) {.
    importc, libprag.}

proc setShadowType*(self: Frame; `type`: ShadowType) =
  gtk_frame_set_shadow_type(cast[ptr Frame00](self.impl), `type`)

proc `shadowType=`*(self: Frame; `type`: ShadowType) =
  gtk_frame_set_shadow_type(cast[ptr Frame00](self.impl), `type`)

type
  AspectFrame* = ref object of Frame
  AspectFrame00* = object of Frame00

proc gtk_aspect_frame_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(AspectFrame()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_aspect_frame_new(label: cstring; xalign: cfloat; yalign: cfloat;
    ratio: cfloat; obeyChild: gboolean): ptr AspectFrame00 {.
    importc, libprag.}

proc newAspectFrame*(label: cstring = nil; xalign: cfloat; yalign: cfloat;
    ratio: cfloat; obeyChild: bool): AspectFrame =
  let gobj = gtk_aspect_frame_new(label, xalign, yalign, ratio, gboolean(obeyChild))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAspectFrame*(tdesc: typedesc; label: cstring = nil; xalign: cfloat; yalign: cfloat;
    ratio: cfloat; obeyChild: bool): tdesc =
  assert(result is AspectFrame)
  let gobj = gtk_aspect_frame_new(label, xalign, yalign, ratio, gboolean(obeyChild))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAspectFrame*[T](result: var T; label: cstring = nil; xalign: cfloat; yalign: cfloat;
    ratio: cfloat; obeyChild: bool) {.deprecated.} =
  assert(result is AspectFrame)
  let gobj = gtk_aspect_frame_new(label, xalign, yalign, ratio, gboolean(obeyChild))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_aspect_frame_set(self: ptr AspectFrame00; xalign: cfloat; yalign: cfloat;
    ratio: cfloat; obeyChild: gboolean) {.
    importc, libprag.}

proc set*(self: AspectFrame; xalign: cfloat; yalign: cfloat;
    ratio: cfloat; obeyChild: bool) =
  gtk_aspect_frame_set(cast[ptr AspectFrame00](self.impl), xalign, yalign, ratio, gboolean(obeyChild))

type
  Assistant* = ref object of Window
  Assistant00* = object of Window00

proc gtk_assistant_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Assistant()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scApply*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "apply", cast[GCallback](p), xdata, nil, cf)

proc scCancel*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cf)

proc scClose*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scEscape*(self: Assistant;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "escape", cast[GCallback](p), xdata, nil, cf)

proc scPrepare*(self: Assistant;  p: proc (self: ptr Assistant00; page: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "prepare", cast[GCallback](p), xdata, nil, cf)

proc gtk_assistant_new(): ptr Assistant00 {.
    importc, libprag.}

proc newAssistant*(): Assistant =
  let gobj = gtk_assistant_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newAssistant*(tdesc: typedesc): tdesc =
  assert(result is Assistant)
  let gobj = gtk_assistant_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initAssistant*[T](result: var T) {.deprecated.} =
  assert(result is Assistant)
  let gobj = gtk_assistant_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_add_action_widget(self: ptr Assistant00; child: ptr Widget00) {.
    importc, libprag.}

proc addActionWidget*(self: Assistant; child: Widget) =
  gtk_assistant_add_action_widget(cast[ptr Assistant00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_assistant_append_page(self: ptr Assistant00; page: ptr Widget00): int32 {.
    importc, libprag.}

proc appendPage*(self: Assistant; page: Widget): int =
  int(gtk_assistant_append_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_commit(self: ptr Assistant00) {.
    importc, libprag.}

proc commit*(self: Assistant) =
  gtk_assistant_commit(cast[ptr Assistant00](self.impl))

proc gtk_assistant_get_current_page(self: ptr Assistant00): int32 {.
    importc, libprag.}

proc getCurrentPage*(self: Assistant): int =
  int(gtk_assistant_get_current_page(cast[ptr Assistant00](self.impl)))

proc currentPage*(self: Assistant): int =
  int(gtk_assistant_get_current_page(cast[ptr Assistant00](self.impl)))

proc gtk_assistant_get_n_pages(self: ptr Assistant00): int32 {.
    importc, libprag.}

proc getNPages*(self: Assistant): int =
  int(gtk_assistant_get_n_pages(cast[ptr Assistant00](self.impl)))

proc nPages*(self: Assistant): int =
  int(gtk_assistant_get_n_pages(cast[ptr Assistant00](self.impl)))

proc gtk_assistant_get_nth_page(self: ptr Assistant00; pageNum: int32): ptr Widget00 {.
    importc, libprag.}

proc getNthPage*(self: Assistant; pageNum: int): Widget =
  let gobj = gtk_assistant_get_nth_page(cast[ptr Assistant00](self.impl), int32(pageNum))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page_complete(self: ptr Assistant00; page: ptr Widget00): gboolean {.
    importc, libprag.}

proc getPageComplete*(self: Assistant; page: Widget): bool =
  toBool(gtk_assistant_get_page_complete(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_get_page_has_padding(self: ptr Assistant00; page: ptr Widget00): gboolean {.
    importc, libprag.}

proc getPageHasPadding*(self: Assistant; page: Widget): bool =
  toBool(gtk_assistant_get_page_has_padding(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_get_page_header_image(self: ptr Assistant00; page: ptr Widget00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPageHeaderImage*(self: Assistant; page: Widget): gdkpixbuf.Pixbuf =
  let gobj = gtk_assistant_get_page_header_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page_side_image(self: ptr Assistant00; page: ptr Widget00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPageSideImage*(self: Assistant; page: Widget): gdkpixbuf.Pixbuf =
  let gobj = gtk_assistant_get_page_side_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_assistant_get_page_title(self: ptr Assistant00; page: ptr Widget00): cstring {.
    importc, libprag.}

proc getPageTitle*(self: Assistant; page: Widget): string =
  result = $gtk_assistant_get_page_title(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))

proc gtk_assistant_insert_page(self: ptr Assistant00; page: ptr Widget00;
    position: int32): int32 {.
    importc, libprag.}

proc insertPage*(self: Assistant; page: Widget; position: int): int =
  int(gtk_assistant_insert_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), int32(position)))

proc gtk_assistant_next_page(self: ptr Assistant00) {.
    importc, libprag.}

proc nextPage*(self: Assistant) =
  gtk_assistant_next_page(cast[ptr Assistant00](self.impl))

proc gtk_assistant_prepend_page(self: ptr Assistant00; page: ptr Widget00): int32 {.
    importc, libprag.}

proc prependPage*(self: Assistant; page: Widget): int =
  int(gtk_assistant_prepend_page(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl)))

proc gtk_assistant_previous_page(self: ptr Assistant00) {.
    importc, libprag.}

proc previousPage*(self: Assistant) =
  gtk_assistant_previous_page(cast[ptr Assistant00](self.impl))

proc gtk_assistant_remove_action_widget(self: ptr Assistant00; child: ptr Widget00) {.
    importc, libprag.}

proc removeActionWidget*(self: Assistant; child: Widget) =
  gtk_assistant_remove_action_widget(cast[ptr Assistant00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_assistant_remove_page(self: ptr Assistant00; pageNum: int32) {.
    importc, libprag.}

proc removePage*(self: Assistant; pageNum: int) =
  gtk_assistant_remove_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc gtk_assistant_set_current_page(self: ptr Assistant00; pageNum: int32) {.
    importc, libprag.}

proc setCurrentPage*(self: Assistant; pageNum: int) =
  gtk_assistant_set_current_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc `currentPage=`*(self: Assistant; pageNum: int) =
  gtk_assistant_set_current_page(cast[ptr Assistant00](self.impl), int32(pageNum))

proc gtk_assistant_set_page_complete(self: ptr Assistant00; page: ptr Widget00;
    complete: gboolean) {.
    importc, libprag.}

proc setPageComplete*(self: Assistant; page: Widget; complete: bool) =
  gtk_assistant_set_page_complete(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), gboolean(complete))

proc gtk_assistant_set_page_has_padding(self: ptr Assistant00; page: ptr Widget00;
    hasPadding: gboolean) {.
    importc, libprag.}

proc setPageHasPadding*(self: Assistant; page: Widget; hasPadding: bool) =
  gtk_assistant_set_page_has_padding(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), gboolean(hasPadding))

proc gtk_assistant_set_page_header_image(self: ptr Assistant00; page: ptr Widget00;
    pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setPageHeaderImage*(self: Assistant; page: Widget; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_assistant_set_page_header_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_assistant_set_page_side_image(self: ptr Assistant00; page: ptr Widget00;
    pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setPageSideImage*(self: Assistant; page: Widget; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_assistant_set_page_side_image(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_assistant_set_page_title(self: ptr Assistant00; page: ptr Widget00;
    title: cstring) {.
    importc, libprag.}

proc setPageTitle*(self: Assistant; page: Widget; title: cstring) =
  gtk_assistant_set_page_title(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), title)

proc gtk_assistant_update_buttons_state(self: ptr Assistant00) {.
    importc, libprag.}

proc updateButtonsState*(self: Assistant) =
  gtk_assistant_update_buttons_state(cast[ptr Assistant00](self.impl))

type
  AssistantPageType* {.size: sizeof(cint), pure.} = enum
    content = 0
    intro = 1
    confirm = 2
    summary = 3
    progress = 4
    custom = 5

proc gtk_assistant_get_page_type(self: ptr Assistant00; page: ptr Widget00): AssistantPageType {.
    importc, libprag.}

proc getPageType*(self: Assistant; page: Widget): AssistantPageType =
  gtk_assistant_get_page_type(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl))

proc gtk_assistant_set_page_type(self: ptr Assistant00; page: ptr Widget00;
    `type`: AssistantPageType) {.
    importc, libprag.}

proc setPageType*(self: Assistant; page: Widget; `type`: AssistantPageType) =
  gtk_assistant_set_page_type(cast[ptr Assistant00](self.impl), cast[ptr Widget00](page.impl), `type`)

type
  AssistantPageFunc* = proc (currentPage: int32; data: pointer): int32 {.cdecl.}

proc gtk_assistant_set_forward_page_func(self: ptr Assistant00; pageFunc: AssistantPageFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setForwardPageFunc*(self: Assistant; pageFunc: AssistantPageFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_assistant_set_forward_page_func(cast[ptr Assistant00](self.impl), pageFunc, data, destroy)

type
  AttachFlag* {.size: sizeof(cint), pure.} = enum
    expand = 0
    shrink = 1
    fill = 2

  AttachOptions* {.size: sizeof(cint).} = set[AttachFlag]

const BINARY_AGE* = 2424'i32

type
  BindingArg* {.pure, byRef.} = object
    argType*: GType

type
  BindingEntry00* {.pure.} = object
  BindingEntry* = ref object
    impl*: ptr BindingEntry00
    ignoreFinalizer*: bool

type
  BindingSet00* {.pure.} = object
  BindingSet* = ref object
    impl*: ptr BindingSet00
    ignoreFinalizer*: bool

proc gtk_binding_set_activate(self: ptr BindingSet00; keyval: uint32; modifiers: gdk.ModifierType;
    `object`: ptr gobject.Object00): gboolean {.
    importc, libprag.}

proc activate*(self: BindingSet; keyval: int; modifiers: gdk.ModifierType;
    `object`: gobject.Object): bool =
  toBool(gtk_binding_set_activate(cast[ptr BindingSet00](self.impl), uint32(keyval), modifiers, cast[ptr gobject.Object00](`object`.impl)))

proc gtk_binding_set_find(setName: cstring): ptr BindingSet00 {.
    importc, libprag.}

proc findBindingSet*(setName: cstring): BindingSet =
  let impl0 = gtk_binding_set_find(setName)
  if impl0.isNil:
    return nil
  new(result)
  result.impl = impl0
  result.ignoreFinalizer = true

proc gtk_binding_entry_add_signal_from_string(bindingSet: ptr BindingSet00;
    signalDesc: cstring): glib.TokenType {.
    importc, libprag.}

proc addSignalFromString*(bindingSet: BindingSet; signalDesc: cstring): glib.TokenType =
  gtk_binding_entry_add_signal_from_string(cast[ptr BindingSet00](bindingSet.impl), signalDesc)

proc gtk_binding_entry_add_signall(bindingSet: ptr BindingSet00; keyval: uint32;
    modifiers: gdk.ModifierType; signalName: cstring; bindingArgs: ptr glib.SList) {.
    importc, libprag.}

proc addSignall*(bindingSet: BindingSet; keyval: int; modifiers: gdk.ModifierType;
    signalName: cstring; bindingArgs: seq[BindingArg]) =
  var tempResGL = seq2GSList(bindingArgs)
  gtk_binding_entry_add_signall(cast[ptr BindingSet00](bindingSet.impl), uint32(keyval), modifiers, signalName, tempResGL)
  g_slist_free(tempResGL)

proc gtk_binding_entry_remove(bindingSet: ptr BindingSet00; keyval: uint32;
    modifiers: gdk.ModifierType) {.
    importc, libprag.}

proc remove*(bindingSet: BindingSet; keyval: int; modifiers: gdk.ModifierType) =
  gtk_binding_entry_remove(cast[ptr BindingSet00](bindingSet.impl), uint32(keyval), modifiers)

proc gtk_binding_entry_skip(bindingSet: ptr BindingSet00; keyval: uint32;
    modifiers: gdk.ModifierType) {.
    importc, libprag.}

proc skip*(bindingSet: BindingSet; keyval: int; modifiers: gdk.ModifierType) =
  gtk_binding_entry_skip(cast[ptr BindingSet00](bindingSet.impl), uint32(keyval), modifiers)

type
  PathType* {.size: sizeof(cint), pure.} = enum
    widget = 0
    widgetClass = 1
    class = 2

type
  PathPriorityType* {.size: sizeof(cint), pure.} = enum
    lowest = 0
    gtk = 4
    application = 8
    theme = 10
    rc = 12
    highest = 15

proc gtk_binding_set_add_path(self: ptr BindingSet00; pathType: PathType;
    pathPattern: cstring; priority: PathPriorityType) {.
    importc, libprag.}

proc addPath*(self: BindingSet; pathType: PathType; pathPattern: cstring;
    priority: PathPriorityType) =
  gtk_binding_set_add_path(cast[ptr BindingSet00](self.impl), pathType, pathPattern, priority)

type
  BindingSignal* {.pure, byRef.} = object
    next*: ptr BindingSignal
    signalName*: cstring
    nArgs*: uint32
    args*: ptr BindingArg

type
  BorderStyle* {.size: sizeof(cint), pure.} = enum
    none = 0
    solid = 1
    inset = 2
    outset = 3
    hidden = 4
    dotted = 5
    dashed = 6
    double = 7
    groove = 8
    ridge = 9

type
  Buildable00* = object of gobject.Object00
  Buildable* = ref object of gobject.Object

type
  Builder* = ref object of gobject.Object
  Builder00* = object of gobject.Object00

proc gtk_builder_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Builder()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_builder_new(): ptr Builder00 {.
    importc, libprag.}

proc newBuilder*(): Builder =
  let gobj = gtk_builder_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilder*(tdesc: typedesc): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilder*[T](result: var T) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_file(filename: cstring): ptr Builder00 {.
    importc, libprag.}

proc newBuilderFromFile*(filename: cstring): Builder =
  let gobj = gtk_builder_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderFromFile*(tdesc: typedesc; filename: cstring): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromFile*[T](result: var T; filename: cstring) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_resource(resourcePath: cstring): ptr Builder00 {.
    importc, libprag.}

proc newBuilderFromResource*(resourcePath: cstring): Builder =
  let gobj = gtk_builder_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderFromResource*(tdesc: typedesc; resourcePath: cstring): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromResource*[T](result: var T; resourcePath: cstring) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_new_from_string(string: cstring; length: int64): ptr Builder00 {.
    importc, libprag.}

proc newBuilderFromString*(string: cstring; length: int64 = -1): Builder =
  let gobj = gtk_builder_new_from_string(string, length)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newBuilderFromString*(tdesc: typedesc; string: cstring; length: int64 = -1): tdesc =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_string(string, length)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initBuilderFromString*[T](result: var T; string: cstring; length: int64 = -1) {.deprecated.} =
  assert(result is Builder)
  let gobj = gtk_builder_new_from_string(string, length)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_add_from_file(self: ptr Builder00; filename: cstring; error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addFromFile*(self: Builder; filename: cstring): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_from_file(cast[ptr Builder00](self.impl), filename, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_builder_add_from_resource(self: ptr Builder00; resourcePath: cstring;
    error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addFromResource*(self: Builder; resourcePath: cstring): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_from_resource(cast[ptr Builder00](self.impl), resourcePath, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_builder_add_from_string(self: ptr Builder00; buffer: cstring; length: uint64;
    error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addFromString*(self: Builder; buffer: cstring; length: uint64): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_from_string(cast[ptr Builder00](self.impl), buffer, length, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_builder_add_objects_from_file(self: ptr Builder00; filename: cstring;
    objectIds: ptr cstring; error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addObjectsFromFile*(self: Builder; filename: cstring;
    objectIds: varargs[string, `$`]): int =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_objects_from_file(cast[ptr Builder00](self.impl), filename, seq2CstringArray(objectIds, fs469n23), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_builder_add_objects_from_resource(self: ptr Builder00; resourcePath: cstring;
    objectIds: ptr cstring; error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addObjectsFromResource*(self: Builder; resourcePath: cstring;
    objectIds: varargs[string, `$`]): int =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_objects_from_resource(cast[ptr Builder00](self.impl), resourcePath, seq2CstringArray(objectIds, fs469n23), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_builder_add_objects_from_string(self: ptr Builder00; buffer: cstring;
    length: uint64; objectIds: ptr cstring; error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addObjectsFromString*(self: Builder; buffer: cstring;
    length: uint64; objectIds: varargs[string, `$`]): int =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_add_objects_from_string(cast[ptr Builder00](self.impl), buffer, length, seq2CstringArray(objectIds, fs469n23), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_builder_connect_signals(self: ptr Builder00; userData: pointer) {.
    importc, libprag.}

proc connectSignals*(self: Builder; userData: pointer) =
  gtk_builder_connect_signals(cast[ptr Builder00](self.impl), userData)

proc gtk_builder_expose_object(self: ptr Builder00; name: cstring; `object`: ptr gobject.Object00) {.
    importc, libprag.}

proc exposeObject*(self: Builder; name: cstring; `object`: gobject.Object) =
  gtk_builder_expose_object(cast[ptr Builder00](self.impl), name, cast[ptr gobject.Object00](`object`.impl))

proc gtk_builder_extend_with_template(self: ptr Builder00; widget: ptr Widget00;
    templateType: GType; buffer: cstring; length: uint64; error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc extendWithTemplate*(self: Builder; widget: Widget; templateType: GType;
    buffer: cstring; length: uint64): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_extend_with_template(cast[ptr Builder00](self.impl), cast[ptr Widget00](widget.impl), templateType, buffer, length, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_builder_get_application(self: ptr Builder00): ptr Application00 {.
    importc, libprag.}

proc getApplication*(self: Builder): Application =
  let gobj = gtk_builder_get_application(cast[ptr Builder00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc application*(self: Builder): Application =
  let gobj = gtk_builder_get_application(cast[ptr Builder00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_get_object*(self: ptr Builder00; name: cstring): ptr gobject.Object00 {.
    importc, libprag.}

proc getObject*(self: Builder; name: cstring): gobject.Object =
  let gobj = gtk_builder_get_object(cast[ptr Builder00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_builder_get_objects(self: ptr Builder00): ptr glib.SList {.
    importc, libprag.}

proc getObjects*(self: Builder): seq[gobject.Object] =
  let resul0 = gtk_builder_get_objects(cast[ptr Builder00](self.impl))
  result = gslistObjects2seq(gobject.Object, resul0, false)
  g_slist_free(resul0)

proc objects*(self: Builder): seq[gobject.Object] =
  let resul0 = gtk_builder_get_objects(cast[ptr Builder00](self.impl))
  result = gslistObjects2seq(gobject.Object, resul0, false)
  g_slist_free(resul0)

proc gtk_builder_get_translation_domain(self: ptr Builder00): cstring {.
    importc, libprag.}

proc getTranslationDomain*(self: Builder): string =
  result = $gtk_builder_get_translation_domain(cast[ptr Builder00](self.impl))

proc translationDomain*(self: Builder): string =
  result = $gtk_builder_get_translation_domain(cast[ptr Builder00](self.impl))

proc gtk_builder_get_type_from_name(self: ptr Builder00; typeName: cstring): GType {.
    importc, libprag.}

proc getTypeFromName*(self: Builder; typeName: cstring): GType =
  gtk_builder_get_type_from_name(cast[ptr Builder00](self.impl), typeName)

proc gtk_builder_set_application(self: ptr Builder00; application: ptr Application00) {.
    importc, libprag.}

proc setApplication*(self: Builder; application: Application) =
  gtk_builder_set_application(cast[ptr Builder00](self.impl), cast[ptr Application00](application.impl))

proc `application=`*(self: Builder; application: Application) =
  gtk_builder_set_application(cast[ptr Builder00](self.impl), cast[ptr Application00](application.impl))

proc gtk_builder_set_translation_domain(self: ptr Builder00; domain: cstring) {.
    importc, libprag.}

proc setTranslationDomain*(self: Builder; domain: cstring = nil) =
  gtk_builder_set_translation_domain(cast[ptr Builder00](self.impl), domain)

proc `translationDomain=`*(self: Builder; domain: cstring = nil) =
  gtk_builder_set_translation_domain(cast[ptr Builder00](self.impl), domain)

proc gtk_builder_value_from_string(self: ptr Builder00; pspec: ptr gobject.ParamSpec00;
    string: cstring; value: var gobject.Value; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc valueFromString*(self: Builder; pspec: gobject.ParamSpec;
    string: cstring; value: var gobject.Value): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_value_from_string(cast[ptr Builder00](self.impl), cast[ptr gobject.ParamSpec00](pspec.impl), string, value, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_builder_value_from_string_type(self: ptr Builder00; `type`: GType;
    string: cstring; value: var gobject.Value; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc valueFromStringType*(self: Builder; `type`: GType; string: cstring;
    value: var gobject.Value): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_builder_value_from_string_type(cast[ptr Builder00](self.impl), `type`, string, value, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

type
  IconView* = ref object of Container
  IconView00* = object of Container00

proc gtk_icon_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCursorItem*(self: IconView;  p: proc (self: ptr IconView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-cursor-item", cast[GCallback](p), xdata, nil, cf)

proc scItemActivated*(self: IconView;  p: proc (self: ptr IconView00; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "item-activated", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: IconView;  p: proc (self: ptr IconView00; step: MovementStep; count: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectCursorItem*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-cursor-item", cast[GCallback](p), xdata, nil, cf)

proc scSelectionChanged*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorItem*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-item", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: IconView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_icon_view_new(): ptr IconView00 {.
    importc, libprag.}

proc newIconView*(): IconView =
  let gobj = gtk_icon_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconView*(tdesc: typedesc): tdesc =
  assert(result is IconView)
  let gobj = gtk_icon_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconView*[T](result: var T) {.deprecated.} =
  assert(result is IconView)
  let gobj = gtk_icon_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_new_with_area(area: ptr CellArea00): ptr IconView00 {.
    importc, libprag.}

proc newIconViewWithArea*(area: CellArea): IconView =
  let gobj = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconViewWithArea*(tdesc: typedesc; area: CellArea): tdesc =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconViewWithArea*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_new_with_model(model: ptr TreeModel00): ptr IconView00 {.
    importc, libprag.}

proc newIconViewWithModel*(model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): IconView =
  let gobj = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconViewWithModel*(tdesc: typedesc; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): tdesc =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconViewWithModel*[T](result: var T; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) {.deprecated.} =
  assert(result is IconView)
  let gobj = gtk_icon_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_convert_widget_to_bin_window_coords(self: ptr IconView00;
    wx: int32; wy: int32; bx: var int32; by: var int32) {.
    importc, libprag.}

proc convertWidgetToBinWindowCoords*(self: IconView; wx: int;
    wy: int; bx: var int; by: var int) =
  var bx_00: int32
  var by_00: int32
  gtk_icon_view_convert_widget_to_bin_window_coords(cast[ptr IconView00](self.impl), int32(wx), int32(wy), bx_00, by_00)
  if bx.addr != nil:
    bx = int(bx_00)
  if by.addr != nil:
    by = int(by_00)

proc gtk_icon_view_create_drag_icon(self: ptr IconView00; path: ptr TreePath00): ptr cairo.Surface00 {.
    importc, libprag.}

proc createDragIcon*(self: IconView; path: TreePath): cairo.Surface =
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = gtk_icon_view_create_drag_icon(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_enable_model_drag_dest(self: ptr IconView00; targets: ptr TargetEntry00;
    nTargets: int32; actions: gdk.DragAction) {.
    importc, libprag.}

proc enableModelDragDest*(self: IconView; targets: seq[TargetEntry];
    actions: gdk.DragAction) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_icon_view_enable_model_drag_dest(cast[ptr IconView00](self.impl), seq2TargetEntryArray(targets, fs469n23), int32(nTargets), actions)

proc gtk_icon_view_enable_model_drag_source(self: ptr IconView00; startButtonMask: gdk.ModifierType;
    targets: ptr TargetEntry00; nTargets: int32; actions: gdk.DragAction) {.
    importc, libprag.}

proc enableModelDragSource*(self: IconView; startButtonMask: gdk.ModifierType;
    targets: seq[TargetEntry]; actions: gdk.DragAction) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_icon_view_enable_model_drag_source(cast[ptr IconView00](self.impl), startButtonMask, seq2TargetEntryArray(targets, fs469n23), int32(nTargets), actions)

proc gtk_icon_view_get_activate_on_single_click(self: ptr IconView00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: IconView): bool =
  toBool(gtk_icon_view_get_activate_on_single_click(cast[ptr IconView00](self.impl)))

proc activateOnSingleClick*(self: IconView): bool =
  toBool(gtk_icon_view_get_activate_on_single_click(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_cell_rect(self: ptr IconView00; path: ptr TreePath00;
    cell: ptr CellRenderer00; rect: var gdk.Rectangle): gboolean {.
    importc, libprag.}

proc getCellRect*(self: IconView; path: TreePath; cell: CellRenderer = nil;
    rect: var gdk.Rectangle): bool =
  toBool(gtk_icon_view_get_cell_rect(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl), rect))

proc gtk_icon_view_get_column_spacing(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getColumnSpacing*(self: IconView): int =
  int(gtk_icon_view_get_column_spacing(cast[ptr IconView00](self.impl)))

proc columnSpacing*(self: IconView): int =
  int(gtk_icon_view_get_column_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_columns(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getColumns*(self: IconView): int =
  int(gtk_icon_view_get_columns(cast[ptr IconView00](self.impl)))

proc columns*(self: IconView): int =
  int(gtk_icon_view_get_columns(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_cursor(self: ptr IconView00; path: var ptr TreePath00;
    cell: var ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getCursor*(self: IconView; path: var TreePath = cast[var TreePath](nil);
    cell: var CellRenderer = cast[var CellRenderer](nil)): bool =
  var tmpoutgobjectarg: ptr CellRenderer00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_icon_view_get_cursor(cast[ptr IconView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr CellRenderer00](if addr(cell) == nil: nil else: addr tmpoutgobjectarg)))
#  dothemagic(cell
  if addr(cell) != nil:
    cell = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      cell = cast[type(cell)](argqdata)
      assert(cell.impl == tmpoutgobjectarg)
    else:
      fnew(cell, gtk.finalizeGObject)
      cell.impl = tmpoutgobjectarg
      GC_ref(cell)
      if g_object_is_floating(cell.impl).int != 0:
        discard g_object_ref_sink(cell.impl)
      g_object_add_toggle_ref(cell.impl, toggleNotify, addr(cell[]))
      g_object_unref(cell.impl)
      assert(g_object_get_qdata(cell.impl, Quark) == nil)
      g_object_set_qdata(cell.impl, Quark, addr(cell[]))


proc gtk_icon_view_get_item_at_pos(self: ptr IconView00; x: int32; y: int32;
    path: var ptr TreePath00; cell: var ptr CellRenderer00): gboolean {.
    importc, libprag.}

proc getItemAtPos*(self: IconView; x: int; y: int; path: var TreePath = cast[var TreePath](nil);
    cell: var CellRenderer = cast[var CellRenderer](nil)): bool =
  var tmpoutgobjectarg: ptr CellRenderer00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_icon_view_get_item_at_pos(cast[ptr IconView00](self.impl), int32(x), int32(y), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr CellRenderer00](if addr(cell) == nil: nil else: addr tmpoutgobjectarg)))
#  dothemagic(cell
  if addr(cell) != nil:
    cell = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      cell = cast[type(cell)](argqdata)
      assert(cell.impl == tmpoutgobjectarg)
    else:
      fnew(cell, gtk.finalizeGObject)
      cell.impl = tmpoutgobjectarg
      GC_ref(cell)
      if g_object_is_floating(cell.impl).int != 0:
        discard g_object_ref_sink(cell.impl)
      g_object_add_toggle_ref(cell.impl, toggleNotify, addr(cell[]))
      g_object_unref(cell.impl)
      assert(g_object_get_qdata(cell.impl, Quark) == nil)
      g_object_set_qdata(cell.impl, Quark, addr(cell[]))


proc gtk_icon_view_get_item_column(self: ptr IconView00; path: ptr TreePath00): int32 {.
    importc, libprag.}

proc getItemColumn*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_column(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_get_item_orientation(self: ptr IconView00): Orientation {.
    importc, libprag.}

proc getItemOrientation*(self: IconView): Orientation =
  gtk_icon_view_get_item_orientation(cast[ptr IconView00](self.impl))

proc itemOrientation*(self: IconView): Orientation =
  gtk_icon_view_get_item_orientation(cast[ptr IconView00](self.impl))

proc gtk_icon_view_get_item_padding(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getItemPadding*(self: IconView): int =
  int(gtk_icon_view_get_item_padding(cast[ptr IconView00](self.impl)))

proc itemPadding*(self: IconView): int =
  int(gtk_icon_view_get_item_padding(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_item_row(self: ptr IconView00; path: ptr TreePath00): int32 {.
    importc, libprag.}

proc getItemRow*(self: IconView; path: TreePath): int =
  int(gtk_icon_view_get_item_row(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_get_item_width(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getItemWidth*(self: IconView): int =
  int(gtk_icon_view_get_item_width(cast[ptr IconView00](self.impl)))

proc itemWidth*(self: IconView): int =
  int(gtk_icon_view_get_item_width(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_margin(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getMargin*(self: IconView): int =
  int(gtk_icon_view_get_margin(cast[ptr IconView00](self.impl)))

proc margin*(self: IconView): int =
  int(gtk_icon_view_get_margin(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_markup_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getMarkupColumn*(self: IconView): int =
  int(gtk_icon_view_get_markup_column(cast[ptr IconView00](self.impl)))

proc markupColumn*(self: IconView): int =
  int(gtk_icon_view_get_markup_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_model(self: ptr IconView00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: IconView): TreeModel =
  let gobj = gtk_icon_view_get_model(cast[ptr IconView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: IconView): TreeModel =
  let gobj = gtk_icon_view_get_model(cast[ptr IconView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_view_get_path_at_pos(self: ptr IconView00; x: int32; y: int32): ptr TreePath00 {.
    importc, libprag.}

proc getPathAtPos*(self: IconView; x: int; y: int): TreePath =
  let impl0 = gtk_icon_view_get_path_at_pos(cast[ptr IconView00](self.impl), int32(x), int32(y))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_icon_view_get_pixbuf_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getPixbufColumn*(self: IconView): int =
  int(gtk_icon_view_get_pixbuf_column(cast[ptr IconView00](self.impl)))

proc pixbufColumn*(self: IconView): int =
  int(gtk_icon_view_get_pixbuf_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_reorderable(self: ptr IconView00): gboolean {.
    importc, libprag.}

proc getReorderable*(self: IconView): bool =
  toBool(gtk_icon_view_get_reorderable(cast[ptr IconView00](self.impl)))

proc reorderable*(self: IconView): bool =
  toBool(gtk_icon_view_get_reorderable(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_row_spacing(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getRowSpacing*(self: IconView): int =
  int(gtk_icon_view_get_row_spacing(cast[ptr IconView00](self.impl)))

proc rowSpacing*(self: IconView): int =
  int(gtk_icon_view_get_row_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_selected_items(self: ptr IconView00): ptr glib.List {.
    importc, libprag.}

proc getSelectedItems*(self: IconView): seq[TreePath] =
  let resul0 = gtk_icon_view_get_selected_items(cast[ptr IconView00](self.impl))
  result = glistStructs2seq[TreePath](resul0, false)
  g_list_free(resul0)

proc selectedItems*(self: IconView): seq[TreePath] =
  let resul0 = gtk_icon_view_get_selected_items(cast[ptr IconView00](self.impl))
  result = glistStructs2seq[TreePath](resul0, false)
  g_list_free(resul0)

proc gtk_icon_view_get_spacing(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getSpacing*(self: IconView): int =
  int(gtk_icon_view_get_spacing(cast[ptr IconView00](self.impl)))

proc spacing*(self: IconView): int =
  int(gtk_icon_view_get_spacing(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_text_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getTextColumn*(self: IconView): int =
  int(gtk_icon_view_get_text_column(cast[ptr IconView00](self.impl)))

proc textColumn*(self: IconView): int =
  int(gtk_icon_view_get_text_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_tooltip_column(self: ptr IconView00): int32 {.
    importc, libprag.}

proc getTooltipColumn*(self: IconView): int =
  int(gtk_icon_view_get_tooltip_column(cast[ptr IconView00](self.impl)))

proc tooltipColumn*(self: IconView): int =
  int(gtk_icon_view_get_tooltip_column(cast[ptr IconView00](self.impl)))

proc gtk_icon_view_get_tooltip_context(self: ptr IconView00; x: var int32;
    y: var int32; keyboardTip: gboolean; model: var ptr TreeModel00; path: var ptr TreePath00;
    iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getTooltipContext*(self: IconView; x: var int; y: var int;
    keyboardTip: bool; model: var (TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) = cast[var TreeModel](nil);
    path: var TreePath = cast[var TreePath](nil); iter: var TreeIter = cast[var TreeIter](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  var y_00 = int32(y)
  var x_00 = int32(x)
  result = toBool(gtk_icon_view_get_tooltip_context(cast[ptr IconView00](self.impl), x_00, y_00, gboolean(keyboardTip), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), iter))
  y = int(y_00)
  x = int(x_00)
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_icon_view_get_visible_range(self: ptr IconView00; startPath: var ptr TreePath00;
    endPath: var ptr TreePath00): gboolean {.
    importc, libprag.}

proc getVisibleRange*(self: IconView; startPath: var TreePath = cast[var TreePath](nil);
    endPath: var TreePath = cast[var TreePath](nil)): bool =
  if addr(startPath) != nil:
    fnew(startPath, gBoxedFreeGtkTreePath)
  if addr(endPath) != nil:
    fnew(endPath, gBoxedFreeGtkTreePath)
  toBool(gtk_icon_view_get_visible_range(cast[ptr IconView00](self.impl), cast[var ptr TreePath00](if addr(startPath) == nil: nil else: addr startPath.impl), cast[var ptr TreePath00](if addr(endPath) == nil: nil else: addr endPath.impl)))

proc gtk_icon_view_item_activated(self: ptr IconView00; path: ptr TreePath00) {.
    importc, libprag.}

proc itemActivated*(self: IconView; path: TreePath) =
  gtk_icon_view_item_activated(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_path_is_selected(self: ptr IconView00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc pathIsSelected*(self: IconView; path: TreePath): bool =
  toBool(gtk_icon_view_path_is_selected(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_icon_view_scroll_to_path(self: ptr IconView00; path: ptr TreePath00;
    useAlign: gboolean; rowAlign: cfloat; colAlign: cfloat) {.
    importc, libprag.}

proc scrollToPath*(self: IconView; path: TreePath; useAlign: bool;
    rowAlign: cfloat; colAlign: cfloat) =
  gtk_icon_view_scroll_to_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), gboolean(useAlign), rowAlign, colAlign)

proc gtk_icon_view_select_all(self: ptr IconView00) {.
    importc, libprag.}

proc selectAll*(self: IconView) =
  gtk_icon_view_select_all(cast[ptr IconView00](self.impl))

proc gtk_icon_view_select_path(self: ptr IconView00; path: ptr TreePath00) {.
    importc, libprag.}

proc selectPath*(self: IconView; path: TreePath) =
  gtk_icon_view_select_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_set_activate_on_single_click(self: ptr IconView00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: IconView; single: bool = true) =
  gtk_icon_view_set_activate_on_single_click(cast[ptr IconView00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: IconView; single: bool) =
  gtk_icon_view_set_activate_on_single_click(cast[ptr IconView00](self.impl), gboolean(single))

proc gtk_icon_view_set_column_spacing(self: ptr IconView00; columnSpacing: int32) {.
    importc, libprag.}

proc setColumnSpacing*(self: IconView; columnSpacing: int) =
  gtk_icon_view_set_column_spacing(cast[ptr IconView00](self.impl), int32(columnSpacing))

proc `columnSpacing=`*(self: IconView; columnSpacing: int) =
  gtk_icon_view_set_column_spacing(cast[ptr IconView00](self.impl), int32(columnSpacing))

proc gtk_icon_view_set_columns(self: ptr IconView00; columns: int32) {.
    importc, libprag.}

proc setColumns*(self: IconView; columns: int) =
  gtk_icon_view_set_columns(cast[ptr IconView00](self.impl), int32(columns))

proc `columns=`*(self: IconView; columns: int) =
  gtk_icon_view_set_columns(cast[ptr IconView00](self.impl), int32(columns))

proc gtk_icon_view_set_cursor(self: ptr IconView00; path: ptr TreePath00;
    cell: ptr CellRenderer00; startEditing: gboolean) {.
    importc, libprag.}

proc setCursor*(self: IconView; path: TreePath; cell: CellRenderer = nil;
    startEditing: bool) =
  gtk_icon_view_set_cursor(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl), gboolean(startEditing))

proc gtk_icon_view_set_item_orientation(self: ptr IconView00; orientation: Orientation) {.
    importc, libprag.}

proc setItemOrientation*(self: IconView; orientation: Orientation) =
  gtk_icon_view_set_item_orientation(cast[ptr IconView00](self.impl), orientation)

proc `itemOrientation=`*(self: IconView; orientation: Orientation) =
  gtk_icon_view_set_item_orientation(cast[ptr IconView00](self.impl), orientation)

proc gtk_icon_view_set_item_padding(self: ptr IconView00; itemPadding: int32) {.
    importc, libprag.}

proc setItemPadding*(self: IconView; itemPadding: int) =
  gtk_icon_view_set_item_padding(cast[ptr IconView00](self.impl), int32(itemPadding))

proc `itemPadding=`*(self: IconView; itemPadding: int) =
  gtk_icon_view_set_item_padding(cast[ptr IconView00](self.impl), int32(itemPadding))

proc gtk_icon_view_set_item_width(self: ptr IconView00; itemWidth: int32) {.
    importc, libprag.}

proc setItemWidth*(self: IconView; itemWidth: int) =
  gtk_icon_view_set_item_width(cast[ptr IconView00](self.impl), int32(itemWidth))

proc `itemWidth=`*(self: IconView; itemWidth: int) =
  gtk_icon_view_set_item_width(cast[ptr IconView00](self.impl), int32(itemWidth))

proc gtk_icon_view_set_margin(self: ptr IconView00; margin: int32) {.
    importc, libprag.}

proc setMargin*(self: IconView; margin: int) =
  gtk_icon_view_set_margin(cast[ptr IconView00](self.impl), int32(margin))

proc `margin=`*(self: IconView; margin: int) =
  gtk_icon_view_set_margin(cast[ptr IconView00](self.impl), int32(margin))

proc gtk_icon_view_set_markup_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setMarkupColumn*(self: IconView; column: int) =
  gtk_icon_view_set_markup_column(cast[ptr IconView00](self.impl), int32(column))

proc `markupColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_markup_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_model(self: ptr IconView00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: IconView; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_icon_view_set_model(cast[ptr IconView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: IconView; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_icon_view_set_model(cast[ptr IconView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_icon_view_set_pixbuf_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setPixbufColumn*(self: IconView; column: int) =
  gtk_icon_view_set_pixbuf_column(cast[ptr IconView00](self.impl), int32(column))

proc `pixbufColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_pixbuf_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_reorderable(self: ptr IconView00; reorderable: gboolean) {.
    importc, libprag.}

proc setReorderable*(self: IconView; reorderable: bool = true) =
  gtk_icon_view_set_reorderable(cast[ptr IconView00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: IconView; reorderable: bool) =
  gtk_icon_view_set_reorderable(cast[ptr IconView00](self.impl), gboolean(reorderable))

proc gtk_icon_view_set_row_spacing(self: ptr IconView00; rowSpacing: int32) {.
    importc, libprag.}

proc setRowSpacing*(self: IconView; rowSpacing: int) =
  gtk_icon_view_set_row_spacing(cast[ptr IconView00](self.impl), int32(rowSpacing))

proc `rowSpacing=`*(self: IconView; rowSpacing: int) =
  gtk_icon_view_set_row_spacing(cast[ptr IconView00](self.impl), int32(rowSpacing))

proc gtk_icon_view_set_spacing(self: ptr IconView00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: IconView; spacing: int) =
  gtk_icon_view_set_spacing(cast[ptr IconView00](self.impl), int32(spacing))

proc `spacing=`*(self: IconView; spacing: int) =
  gtk_icon_view_set_spacing(cast[ptr IconView00](self.impl), int32(spacing))

proc gtk_icon_view_set_text_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setTextColumn*(self: IconView; column: int) =
  gtk_icon_view_set_text_column(cast[ptr IconView00](self.impl), int32(column))

proc `textColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_text_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_tooltip_cell(self: ptr IconView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc setTooltipCell*(self: IconView; tooltip: Tooltip; path: TreePath;
    cell: CellRenderer = nil) =
  gtk_icon_view_set_tooltip_cell(cast[ptr IconView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl))

proc gtk_icon_view_set_tooltip_column(self: ptr IconView00; column: int32) {.
    importc, libprag.}

proc setTooltipColumn*(self: IconView; column: int) =
  gtk_icon_view_set_tooltip_column(cast[ptr IconView00](self.impl), int32(column))

proc `tooltipColumn=`*(self: IconView; column: int) =
  gtk_icon_view_set_tooltip_column(cast[ptr IconView00](self.impl), int32(column))

proc gtk_icon_view_set_tooltip_item(self: ptr IconView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00) {.
    importc, libprag.}

proc setTooltipItem*(self: IconView; tooltip: Tooltip; path: TreePath) =
  gtk_icon_view_set_tooltip_item(cast[ptr IconView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_unselect_all(self: ptr IconView00) {.
    importc, libprag.}

proc unselectAll*(self: IconView) =
  gtk_icon_view_unselect_all(cast[ptr IconView00](self.impl))

proc gtk_icon_view_unselect_path(self: ptr IconView00; path: ptr TreePath00) {.
    importc, libprag.}

proc unselectPath*(self: IconView; path: TreePath) =
  gtk_icon_view_unselect_path(cast[ptr IconView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_icon_view_unset_model_drag_dest(self: ptr IconView00) {.
    importc, libprag.}

proc unsetModelDragDest*(self: IconView) =
  gtk_icon_view_unset_model_drag_dest(cast[ptr IconView00](self.impl))

proc gtk_icon_view_unset_model_drag_source(self: ptr IconView00) {.
    importc, libprag.}

proc unsetModelDragSource*(self: IconView) =
  gtk_icon_view_unset_model_drag_source(cast[ptr IconView00](self.impl))

type
  Spinner* = ref object of Widget
  Spinner00* = object of Widget00

proc gtk_spinner_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Spinner()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_spinner_new(): ptr Spinner00 {.
    importc, libprag.}

proc newSpinner*(): Spinner =
  let gobj = gtk_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSpinner*(tdesc: typedesc): tdesc =
  assert(result is Spinner)
  let gobj = gtk_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSpinner*[T](result: var T) {.deprecated.} =
  assert(result is Spinner)
  let gobj = gtk_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_spinner_start(self: ptr Spinner00) {.
    importc, libprag.}

proc start*(self: Spinner) =
  gtk_spinner_start(cast[ptr Spinner00](self.impl))

proc gtk_spinner_stop(self: ptr Spinner00) {.
    importc, libprag.}

proc stop*(self: Spinner) =
  gtk_spinner_stop(cast[ptr Spinner00](self.impl))

type
  Viewport* = ref object of Bin
  Viewport00* = object of Bin00

proc gtk_viewport_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Viewport()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_viewport_new(hadjustment: ptr Adjustment00; vadjustment: ptr Adjustment00): ptr Viewport00 {.
    importc, libprag.}

proc newViewport*(hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): Viewport =
  let gobj = gtk_viewport_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newViewport*(tdesc: typedesc; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): tdesc =
  assert(result is Viewport)
  let gobj = gtk_viewport_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initViewport*[T](result: var T; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil) {.deprecated.} =
  assert(result is Viewport)
  let gobj = gtk_viewport_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_bin_window(self: ptr Viewport00): ptr gdk.Window00 {.
    importc, libprag.}

proc getBinWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_bin_window(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc binWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_bin_window(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_hadjustment(self: ptr Viewport00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_hadjustment(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_hadjustment(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_shadow_type(self: ptr Viewport00): ShadowType {.
    importc, libprag.}

proc getShadowType*(self: Viewport): ShadowType =
  gtk_viewport_get_shadow_type(cast[ptr Viewport00](self.impl))

proc shadowType*(self: Viewport): ShadowType =
  gtk_viewport_get_shadow_type(cast[ptr Viewport00](self.impl))

proc gtk_viewport_get_vadjustment(self: ptr Viewport00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_vadjustment(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: Viewport): Adjustment =
  let gobj = gtk_viewport_get_vadjustment(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_get_view_window(self: ptr Viewport00): ptr gdk.Window00 {.
    importc, libprag.}

proc getViewWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_view_window(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc viewWindow*(self: Viewport): gdk.Window =
  let gobj = gtk_viewport_get_view_window(cast[ptr Viewport00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_viewport_set_hadjustment(self: ptr Viewport00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: Viewport; adjustment: Adjustment = nil) =
  gtk_viewport_set_hadjustment(cast[ptr Viewport00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: Viewport; adjustment: Adjustment = nil) =
  gtk_viewport_set_hadjustment(cast[ptr Viewport00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_viewport_set_shadow_type(self: ptr Viewport00; `type`: ShadowType) {.
    importc, libprag.}

proc setShadowType*(self: Viewport; `type`: ShadowType) =
  gtk_viewport_set_shadow_type(cast[ptr Viewport00](self.impl), `type`)

proc `shadowType=`*(self: Viewport; `type`: ShadowType) =
  gtk_viewport_set_shadow_type(cast[ptr Viewport00](self.impl), `type`)

proc gtk_viewport_set_vadjustment(self: ptr Viewport00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: Viewport; adjustment: Adjustment = nil) =
  gtk_viewport_set_vadjustment(cast[ptr Viewport00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: Viewport; adjustment: Adjustment = nil) =
  gtk_viewport_set_vadjustment(cast[ptr Viewport00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

type
  ShortcutLabel* = ref object of Box
  ShortcutLabel00* = object of Box00

proc gtk_shortcut_label_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutLabel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_shortcut_label_new(accelerator: cstring): ptr ShortcutLabel00 {.
    importc, libprag.}

proc newShortcutLabel*(accelerator: cstring): ShortcutLabel =
  let gobj = gtk_shortcut_label_new(accelerator)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newShortcutLabel*(tdesc: typedesc; accelerator: cstring): tdesc =
  assert(result is ShortcutLabel)
  let gobj = gtk_shortcut_label_new(accelerator)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initShortcutLabel*[T](result: var T; accelerator: cstring) {.deprecated.} =
  assert(result is ShortcutLabel)
  let gobj = gtk_shortcut_label_new(accelerator)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_shortcut_label_get_accelerator(self: ptr ShortcutLabel00): cstring {.
    importc, libprag.}

proc getAccelerator*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_accelerator(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc accelerator*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_accelerator(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_shortcut_label_get_disabled_text(self: ptr ShortcutLabel00): cstring {.
    importc, libprag.}

proc getDisabledText*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_disabled_text(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc disabledText*(self: ShortcutLabel): string =
  let resul0 = gtk_shortcut_label_get_disabled_text(cast[ptr ShortcutLabel00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_shortcut_label_set_accelerator(self: ptr ShortcutLabel00; accelerator: cstring) {.
    importc, libprag.}

proc setAccelerator*(self: ShortcutLabel; accelerator: cstring) =
  gtk_shortcut_label_set_accelerator(cast[ptr ShortcutLabel00](self.impl), accelerator)

proc `accelerator=`*(self: ShortcutLabel; accelerator: cstring) =
  gtk_shortcut_label_set_accelerator(cast[ptr ShortcutLabel00](self.impl), accelerator)

proc gtk_shortcut_label_set_disabled_text(self: ptr ShortcutLabel00; disabledText: cstring) {.
    importc, libprag.}

proc setDisabledText*(self: ShortcutLabel; disabledText: cstring) =
  gtk_shortcut_label_set_disabled_text(cast[ptr ShortcutLabel00](self.impl), disabledText)

proc `disabledText=`*(self: ShortcutLabel; disabledText: cstring) =
  gtk_shortcut_label_set_disabled_text(cast[ptr ShortcutLabel00](self.impl), disabledText)

type
  FileFilter* = ref object of gobject.InitiallyUnowned
  FileFilter00* = object of gobject.InitiallyUnowned00

proc gtk_file_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_file_filter_new(): ptr FileFilter00 {.
    importc, libprag.}

proc newFileFilter*(): FileFilter =
  let gobj = gtk_file_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileFilter*(tdesc: typedesc): tdesc =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileFilter*[T](result: var T) {.deprecated.} =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_filter_new_from_gvariant(variant: ptr glib.Variant00): ptr FileFilter00 {.
    importc, libprag.}

proc newFileFilterFromGvariant*(variant: glib.Variant): FileFilter =
  let gobj = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileFilterFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileFilterFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is FileFilter)
  let gobj = gtk_file_filter_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_filter_add_mime_type(self: ptr FileFilter00; mimeType: cstring) {.
    importc, libprag.}

proc addMimeType*(self: FileFilter; mimeType: cstring) =
  gtk_file_filter_add_mime_type(cast[ptr FileFilter00](self.impl), mimeType)

proc gtk_file_filter_add_pattern(self: ptr FileFilter00; pattern: cstring) {.
    importc, libprag.}

proc addPattern*(self: FileFilter; pattern: cstring) =
  gtk_file_filter_add_pattern(cast[ptr FileFilter00](self.impl), pattern)

proc gtk_file_filter_add_pixbuf_formats(self: ptr FileFilter00) {.
    importc, libprag.}

proc addPixbufFormats*(self: FileFilter) =
  gtk_file_filter_add_pixbuf_formats(cast[ptr FileFilter00](self.impl))

proc gtk_file_filter_get_name(self: ptr FileFilter00): cstring {.
    importc, libprag.}

proc getName*(self: FileFilter): string =
  let resul0 = gtk_file_filter_get_name(cast[ptr FileFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: FileFilter): string =
  let resul0 = gtk_file_filter_get_name(cast[ptr FileFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_filter_set_name(self: ptr FileFilter00; name: cstring) {.
    importc, libprag.}

proc setName*(self: FileFilter; name: cstring = nil) =
  gtk_file_filter_set_name(cast[ptr FileFilter00](self.impl), name)

proc `name=`*(self: FileFilter; name: cstring = nil) =
  gtk_file_filter_set_name(cast[ptr FileFilter00](self.impl), name)

proc gtk_file_filter_to_gvariant(self: ptr FileFilter00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: FileFilter): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_file_filter_to_gvariant(cast[ptr FileFilter00](self.impl))
  result.ignoreFinalizer = true # GVariant

type
  ShortcutsGroup* = ref object of Box
  ShortcutsGroup00* = object of Box00

proc gtk_shortcuts_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  FlowBoxChild* = ref object of Bin
  FlowBoxChild00* = object of Bin00

proc gtk_flow_box_child_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FlowBoxChild()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: FlowBoxChild;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_flow_box_child_new(): ptr FlowBoxChild00 {.
    importc, libprag.}

proc newFlowBoxChild*(): FlowBoxChild =
  let gobj = gtk_flow_box_child_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFlowBoxChild*(tdesc: typedesc): tdesc =
  assert(result is FlowBoxChild)
  let gobj = gtk_flow_box_child_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFlowBoxChild*[T](result: var T) {.deprecated.} =
  assert(result is FlowBoxChild)
  let gobj = gtk_flow_box_child_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_child_changed(self: ptr FlowBoxChild00) {.
    importc, libprag.}

proc changed*(self: FlowBoxChild) =
  gtk_flow_box_child_changed(cast[ptr FlowBoxChild00](self.impl))

proc gtk_flow_box_child_get_index(self: ptr FlowBoxChild00): int32 {.
    importc, libprag.}

proc getIndex*(self: FlowBoxChild): int =
  int(gtk_flow_box_child_get_index(cast[ptr FlowBoxChild00](self.impl)))

proc index*(self: FlowBoxChild): int =
  int(gtk_flow_box_child_get_index(cast[ptr FlowBoxChild00](self.impl)))

proc gtk_flow_box_child_is_selected(self: ptr FlowBoxChild00): gboolean {.
    importc, libprag.}

proc isSelected*(self: FlowBoxChild): bool =
  toBool(gtk_flow_box_child_is_selected(cast[ptr FlowBoxChild00](self.impl)))

type
  FlowBox* = ref object of Container
  FlowBox00* = object of Container00

proc gtk_flow_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FlowBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCursorChild*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-cursor-child", cast[GCallback](p), xdata, nil, cf)

proc scChildActivated*(self: FlowBox;  p: proc (self: ptr FlowBox00; child: ptr FlowBoxChild00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "child-activated", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: FlowBox;  p: proc (self: ptr FlowBox00; step: MovementStep; count: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectedChildrenChanged*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selected-children-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorChild*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-child", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: FlowBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_flow_box_new(): ptr FlowBox00 {.
    importc, libprag.}

proc newFlowBox*(): FlowBox =
  let gobj = gtk_flow_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFlowBox*(tdesc: typedesc): tdesc =
  assert(result is FlowBox)
  let gobj = gtk_flow_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFlowBox*[T](result: var T) {.deprecated.} =
  assert(result is FlowBox)
  let gobj = gtk_flow_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_activate_on_single_click(self: ptr FlowBox00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_activate_on_single_click(cast[ptr FlowBox00](self.impl)))

proc activateOnSingleClick*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_activate_on_single_click(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_child_at_index(self: ptr FlowBox00; idx: int32): ptr FlowBoxChild00 {.
    importc, libprag.}

proc getChildAtIndex*(self: FlowBox; idx: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_index(cast[ptr FlowBox00](self.impl), int32(idx))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_child_at_pos(self: ptr FlowBox00; x: int32; y: int32): ptr FlowBoxChild00 {.
    importc, libprag.}

proc getChildAtPos*(self: FlowBox; x: int; y: int): FlowBoxChild =
  let gobj = gtk_flow_box_get_child_at_pos(cast[ptr FlowBox00](self.impl), int32(x), int32(y))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_flow_box_get_column_spacing(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getColumnSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_column_spacing(cast[ptr FlowBox00](self.impl)))

proc columnSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_column_spacing(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_homogeneous(self: ptr FlowBox00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_homogeneous(cast[ptr FlowBox00](self.impl)))

proc homogeneous*(self: FlowBox): bool =
  toBool(gtk_flow_box_get_homogeneous(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_max_children_per_line(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getMaxChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_max_children_per_line(cast[ptr FlowBox00](self.impl)))

proc maxChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_max_children_per_line(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_min_children_per_line(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getMinChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_min_children_per_line(cast[ptr FlowBox00](self.impl)))

proc minChildrenPerLine*(self: FlowBox): int =
  int(gtk_flow_box_get_min_children_per_line(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_row_spacing(self: ptr FlowBox00): uint32 {.
    importc, libprag.}

proc getRowSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_row_spacing(cast[ptr FlowBox00](self.impl)))

proc rowSpacing*(self: FlowBox): int =
  int(gtk_flow_box_get_row_spacing(cast[ptr FlowBox00](self.impl)))

proc gtk_flow_box_get_selected_children(self: ptr FlowBox00): ptr glib.List {.
    importc, libprag.}

proc getSelectedChildren*(self: FlowBox): seq[FlowBoxChild] =
  let resul0 = gtk_flow_box_get_selected_children(cast[ptr FlowBox00](self.impl))
  result = glistObjects2seq(FlowBoxChild, resul0, false)
  g_list_free(resul0)

proc selectedChildren*(self: FlowBox): seq[FlowBoxChild] =
  let resul0 = gtk_flow_box_get_selected_children(cast[ptr FlowBox00](self.impl))
  result = glistObjects2seq(FlowBoxChild, resul0, false)
  g_list_free(resul0)

proc gtk_flow_box_insert(self: ptr FlowBox00; widget: ptr Widget00; position: int32) {.
    importc, libprag.}

proc insert*(self: FlowBox; widget: Widget; position: int) =
  gtk_flow_box_insert(cast[ptr FlowBox00](self.impl), cast[ptr Widget00](widget.impl), int32(position))

proc gtk_flow_box_invalidate_filter(self: ptr FlowBox00) {.
    importc, libprag.}

proc invalidateFilter*(self: FlowBox) =
  gtk_flow_box_invalidate_filter(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_invalidate_sort(self: ptr FlowBox00) {.
    importc, libprag.}

proc invalidateSort*(self: FlowBox) =
  gtk_flow_box_invalidate_sort(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_select_all(self: ptr FlowBox00) {.
    importc, libprag.}

proc selectAll*(self: FlowBox) =
  gtk_flow_box_select_all(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_select_child(self: ptr FlowBox00; child: ptr FlowBoxChild00) {.
    importc, libprag.}

proc selectChild*(self: FlowBox; child: FlowBoxChild) =
  gtk_flow_box_select_child(cast[ptr FlowBox00](self.impl), cast[ptr FlowBoxChild00](child.impl))

proc gtk_flow_box_set_activate_on_single_click(self: ptr FlowBox00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: FlowBox; single: bool = true) =
  gtk_flow_box_set_activate_on_single_click(cast[ptr FlowBox00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: FlowBox; single: bool) =
  gtk_flow_box_set_activate_on_single_click(cast[ptr FlowBox00](self.impl), gboolean(single))

proc gtk_flow_box_set_column_spacing(self: ptr FlowBox00; spacing: uint32) {.
    importc, libprag.}

proc setColumnSpacing*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_column_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc `columnSpacing=`*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_column_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc gtk_flow_box_set_hadjustment(self: ptr FlowBox00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_hadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_hadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_flow_box_set_homogeneous(self: ptr FlowBox00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: FlowBox; homogeneous: bool = true) =
  gtk_flow_box_set_homogeneous(cast[ptr FlowBox00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: FlowBox; homogeneous: bool) =
  gtk_flow_box_set_homogeneous(cast[ptr FlowBox00](self.impl), gboolean(homogeneous))

proc gtk_flow_box_set_max_children_per_line(self: ptr FlowBox00; nChildren: uint32) {.
    importc, libprag.}

proc setMaxChildrenPerLine*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_max_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc `maxChildrenPerLine=`*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_max_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc gtk_flow_box_set_min_children_per_line(self: ptr FlowBox00; nChildren: uint32) {.
    importc, libprag.}

proc setMinChildrenPerLine*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_min_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc `minChildrenPerLine=`*(self: FlowBox; nChildren: int) =
  gtk_flow_box_set_min_children_per_line(cast[ptr FlowBox00](self.impl), uint32(nChildren))

proc gtk_flow_box_set_row_spacing(self: ptr FlowBox00; spacing: uint32) {.
    importc, libprag.}

proc setRowSpacing*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_row_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc `rowSpacing=`*(self: FlowBox; spacing: int) =
  gtk_flow_box_set_row_spacing(cast[ptr FlowBox00](self.impl), uint32(spacing))

proc gtk_flow_box_set_vadjustment(self: ptr FlowBox00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_vadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: FlowBox; adjustment: Adjustment) =
  gtk_flow_box_set_vadjustment(cast[ptr FlowBox00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_flow_box_unselect_all(self: ptr FlowBox00) {.
    importc, libprag.}

proc unselectAll*(self: FlowBox) =
  gtk_flow_box_unselect_all(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_unselect_child(self: ptr FlowBox00; child: ptr FlowBoxChild00) {.
    importc, libprag.}

proc unselectChild*(self: FlowBox; child: FlowBoxChild) =
  gtk_flow_box_unselect_child(cast[ptr FlowBox00](self.impl), cast[ptr FlowBoxChild00](child.impl))

type
  Paned* = ref object of Container
  Paned00* = object of Container00

proc gtk_paned_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Paned()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAcceptPosition*(self: Paned;  p: proc (self: ptr Paned00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accept-position", cast[GCallback](p), xdata, nil, cf)

proc scCancelPosition*(self: Paned;  p: proc (self: ptr Paned00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancel-position", cast[GCallback](p), xdata, nil, cf)

proc scCycleChildFocus*(self: Paned;  p: proc (self: ptr Paned00; reversed: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cycle-child-focus", cast[GCallback](p), xdata, nil, cf)

proc scCycleHandleFocus*(self: Paned;  p: proc (self: ptr Paned00; reversed: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cycle-handle-focus", cast[GCallback](p), xdata, nil, cf)

proc scMoveHandle*(self: Paned;  p: proc (self: ptr Paned00; scrollType: ScrollType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-handle", cast[GCallback](p), xdata, nil, cf)

proc scToggleHandleFocus*(self: Paned;  p: proc (self: ptr Paned00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-handle-focus", cast[GCallback](p), xdata, nil, cf)

proc gtk_paned_new(orientation: Orientation): ptr Paned00 {.
    importc, libprag.}

proc newPaned*(orientation: Orientation): Paned =
  let gobj = gtk_paned_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPaned*(tdesc: typedesc; orientation: Orientation): tdesc =
  assert(result is Paned)
  let gobj = gtk_paned_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPaned*[T](result: var T; orientation: Orientation) {.deprecated.} =
  assert(result is Paned)
  let gobj = gtk_paned_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_add1(self: ptr Paned00; child: ptr Widget00) {.
    importc, libprag.}

proc add1*(self: Paned; child: Widget) =
  gtk_paned_add1(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_paned_add2(self: ptr Paned00; child: ptr Widget00) {.
    importc, libprag.}

proc add2*(self: Paned; child: Widget) =
  gtk_paned_add2(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_paned_get_child1(self: ptr Paned00): ptr Widget00 {.
    importc, libprag.}

proc getChild1*(self: Paned): Widget =
  let gobj = gtk_paned_get_child1(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child1*(self: Paned): Widget =
  let gobj = gtk_paned_get_child1(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_child2(self: ptr Paned00): ptr Widget00 {.
    importc, libprag.}

proc getChild2*(self: Paned): Widget =
  let gobj = gtk_paned_get_child2(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc child2*(self: Paned): Widget =
  let gobj = gtk_paned_get_child2(cast[ptr Paned00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_handle_window(self: ptr Paned00): ptr gdk.Window00 {.
    importc, libprag.}

proc getHandleWindow*(self: Paned): gdk.Window =
  let gobj = gtk_paned_get_handle_window(cast[ptr Paned00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc handleWindow*(self: Paned): gdk.Window =
  let gobj = gtk_paned_get_handle_window(cast[ptr Paned00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_paned_get_position(self: ptr Paned00): int32 {.
    importc, libprag.}

proc getPosition*(self: Paned): int =
  int(gtk_paned_get_position(cast[ptr Paned00](self.impl)))

proc position*(self: Paned): int =
  int(gtk_paned_get_position(cast[ptr Paned00](self.impl)))

proc gtk_paned_get_wide_handle(self: ptr Paned00): gboolean {.
    importc, libprag.}

proc getWideHandle*(self: Paned): bool =
  toBool(gtk_paned_get_wide_handle(cast[ptr Paned00](self.impl)))

proc wideHandle*(self: Paned): bool =
  toBool(gtk_paned_get_wide_handle(cast[ptr Paned00](self.impl)))

proc gtk_paned_pack1(self: ptr Paned00; child: ptr Widget00; resize: gboolean;
    shrink: gboolean) {.
    importc, libprag.}

proc pack1*(self: Paned; child: Widget; resize: bool; shrink: bool) =
  gtk_paned_pack1(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl), gboolean(resize), gboolean(shrink))

proc gtk_paned_pack2(self: ptr Paned00; child: ptr Widget00; resize: gboolean;
    shrink: gboolean) {.
    importc, libprag.}

proc pack2*(self: Paned; child: Widget; resize: bool; shrink: bool) =
  gtk_paned_pack2(cast[ptr Paned00](self.impl), cast[ptr Widget00](child.impl), gboolean(resize), gboolean(shrink))

proc gtk_paned_set_position(self: ptr Paned00; position: int32) {.
    importc, libprag.}

proc setPosition*(self: Paned; position: int) =
  gtk_paned_set_position(cast[ptr Paned00](self.impl), int32(position))

proc `position=`*(self: Paned; position: int) =
  gtk_paned_set_position(cast[ptr Paned00](self.impl), int32(position))

proc gtk_paned_set_wide_handle(self: ptr Paned00; wide: gboolean) {.
    importc, libprag.}

proc setWideHandle*(self: Paned; wide: bool = true) =
  gtk_paned_set_wide_handle(cast[ptr Paned00](self.impl), gboolean(wide))

proc `wideHandle=`*(self: Paned; wide: bool) =
  gtk_paned_set_wide_handle(cast[ptr Paned00](self.impl), gboolean(wide))

type
  VPaned* = ref object of Paned
  VPaned00* = object of Paned00

proc gtk_vpaned_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VPaned()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_vpaned_new(): ptr VPaned00 {.
    importc, libprag.}

proc newVPaned*(): VPaned {.deprecated.}  =
  let gobj = gtk_vpaned_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVPaned*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is VPaned)
  let gobj = gtk_vpaned_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVPaned*[T](result: var T) {.deprecated.} =
  assert(result is VPaned)
  let gobj = gtk_vpaned_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VBox* = ref object of Box
  VBox00* = object of Box00

proc gtk_vbox_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_vbox_new(homogeneous: gboolean; spacing: int32): ptr VBox00 {.
    importc, libprag.}

proc newVBox*(homogeneous: bool; spacing: int): VBox {.deprecated.}  =
  let gobj = gtk_vbox_new(gboolean(homogeneous), int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVBox*(tdesc: typedesc; homogeneous: bool; spacing: int): tdesc {.deprecated.}  =
  assert(result is VBox)
  let gobj = gtk_vbox_new(gboolean(homogeneous), int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVBox*[T](result: var T; homogeneous: bool; spacing: int) {.deprecated.} =
  assert(result is VBox)
  let gobj = gtk_vbox_new(gboolean(homogeneous), int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FontChooserWidget* = ref object of Box
  FontChooserWidget00* = object of Box00

proc gtk_font_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_font_chooser_widget_new(): ptr FontChooserWidget00 {.
    importc, libprag.}

proc newFontChooserWidget*(): FontChooserWidget =
  let gobj = gtk_font_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontChooserWidget*(tdesc: typedesc): tdesc =
  assert(result is FontChooserWidget)
  let gobj = gtk_font_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontChooserWidget*[T](result: var T) {.deprecated.} =
  assert(result is FontChooserWidget)
  let gobj = gtk_font_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TreeViewColumn* = ref object of gobject.InitiallyUnowned
  TreeViewColumn00* = object of gobject.InitiallyUnowned00

proc gtk_tree_view_column_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeViewColumn()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClicked*(self: TreeViewColumn;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "clicked", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_view_column_new(): ptr TreeViewColumn00 {.
    importc, libprag.}

proc newTreeViewColumn*(): TreeViewColumn =
  let gobj = gtk_tree_view_column_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeViewColumn*(tdesc: typedesc): tdesc =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewColumn*[T](result: var T) {.deprecated.} =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_new_with_area(area: ptr CellArea00): ptr TreeViewColumn00 {.
    importc, libprag.}

proc newTreeViewColumnWithArea*(area: CellArea): TreeViewColumn =
  let gobj = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeViewColumnWithArea*(tdesc: typedesc; area: CellArea): tdesc =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewColumnWithArea*[T](result: var T; area: CellArea) {.deprecated.} =
  assert(result is TreeViewColumn)
  let gobj = gtk_tree_view_column_new_with_area(cast[ptr CellArea00](area.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_add_attribute(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00;
    attribute: cstring; column: int32) {.
    importc, libprag.}

proc addAttribute*(self: TreeViewColumn; cellRenderer: CellRenderer;
    attribute: cstring; column: int) =
  gtk_tree_view_column_add_attribute(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), attribute, int32(column))

proc gtk_tree_view_column_cell_get_position(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00;
    xOffset: var int32; width: var int32): gboolean {.
    importc, libprag.}

proc cellGetPosition*(self: TreeViewColumn; cellRenderer: CellRenderer;
    xOffset: var int = cast[var int](nil); width: var int = cast[var int](nil)): bool =
  var width_00: int32
  var xOffset_00: int32
  result = toBool(gtk_tree_view_column_cell_get_position(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), xOffset_00, width_00))
  if width.addr != nil:
    width = int(width_00)
  if xOffset.addr != nil:
    xOffset = int(xOffset_00)

proc gtk_tree_view_column_cell_get_size(self: ptr TreeViewColumn00; cellArea: gdk.Rectangle;
    xOffset: var int32; yOffset: var int32; width: var int32; height: var int32) {.
    importc, libprag.}

proc cellGetSize*(self: TreeViewColumn; cellArea: gdk.Rectangle = cast[var gdk.Rectangle](nil);
    xOffset: var int = cast[var int](nil); yOffset: var int = cast[var int](nil);
    width: var int = cast[var int](nil); height: var int = cast[var int](nil)) =
  var width_00: int32
  var yOffset_00: int32
  var xOffset_00: int32
  var height_00: int32
  gtk_tree_view_column_cell_get_size(cast[ptr TreeViewColumn00](self.impl), cellArea, xOffset_00, yOffset_00, width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if yOffset.addr != nil:
    yOffset = int(yOffset_00)
  if xOffset.addr != nil:
    xOffset = int(xOffset_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_tree_view_column_cell_is_visible(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc cellIsVisible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_cell_is_visible(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_cell_set_cell_data(self: ptr TreeViewColumn00;
    treeModel: ptr TreeModel00; iter: TreeIter; isExpander: gboolean; isExpanded: gboolean) {.
    importc, libprag.}

proc cellSetCellData*(self: TreeViewColumn; treeModel: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    iter: TreeIter; isExpander: bool; isExpanded: bool) =
  gtk_tree_view_column_cell_set_cell_data(cast[ptr TreeViewColumn00](self.impl), cast[ptr TreeModel00](treeModel.impl), iter, gboolean(isExpander), gboolean(isExpanded))

proc gtk_tree_view_column_clear(self: ptr TreeViewColumn00) {.
    importc, libprag.}

proc clear*(self: TreeViewColumn) =
  gtk_tree_view_column_clear(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_clear_attributes(self: ptr TreeViewColumn00; cellRenderer: ptr CellRenderer00) {.
    importc, libprag.}

proc clearAttributes*(self: TreeViewColumn; cellRenderer: CellRenderer) =
  gtk_tree_view_column_clear_attributes(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl))

proc gtk_tree_view_column_clicked(self: ptr TreeViewColumn00) {.
    importc, libprag.}

proc clicked*(self: TreeViewColumn) =
  gtk_tree_view_column_clicked(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_focus_cell(self: ptr TreeViewColumn00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc focusCell*(self: TreeViewColumn; cell: CellRenderer) =
  gtk_tree_view_column_focus_cell(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_tree_view_column_get_alignment(self: ptr TreeViewColumn00): cfloat {.
    importc, libprag.}

proc getAlignment*(self: TreeViewColumn): cfloat =
  gtk_tree_view_column_get_alignment(cast[ptr TreeViewColumn00](self.impl))

proc alignment*(self: TreeViewColumn): cfloat =
  gtk_tree_view_column_get_alignment(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_get_button(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc, libprag.}

proc getButton*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_button(cast[ptr TreeViewColumn00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc button*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_button(cast[ptr TreeViewColumn00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_clickable(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getClickable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_clickable(cast[ptr TreeViewColumn00](self.impl)))

proc clickable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_clickable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_expand(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getExpand*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_expand(cast[ptr TreeViewColumn00](self.impl)))

proc expand*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_expand(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_fixed_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getFixedWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_fixed_width(cast[ptr TreeViewColumn00](self.impl)))

proc fixedWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_fixed_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_max_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getMaxWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_max_width(cast[ptr TreeViewColumn00](self.impl)))

proc maxWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_max_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_min_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getMinWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_min_width(cast[ptr TreeViewColumn00](self.impl)))

proc minWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_min_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_reorderable(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getReorderable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_reorderable(cast[ptr TreeViewColumn00](self.impl)))

proc reorderable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_reorderable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_resizable(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getResizable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_resizable(cast[ptr TreeViewColumn00](self.impl)))

proc resizable*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_resizable(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_sort_column_id(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getSortColumnId*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_sort_column_id(cast[ptr TreeViewColumn00](self.impl)))

proc sortColumnId*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_sort_column_id(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_sort_indicator(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getSortIndicator*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_sort_indicator(cast[ptr TreeViewColumn00](self.impl)))

proc sortIndicator*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_sort_indicator(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_spacing(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getSpacing*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_spacing(cast[ptr TreeViewColumn00](self.impl)))

proc spacing*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_spacing(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_title(self: ptr TreeViewColumn00): cstring {.
    importc, libprag.}

proc getTitle*(self: TreeViewColumn): string =
  result = $gtk_tree_view_column_get_title(cast[ptr TreeViewColumn00](self.impl))

proc title*(self: TreeViewColumn): string =
  result = $gtk_tree_view_column_get_title(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_get_tree_view(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc, libprag.}

proc getTreeView*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_tree_view(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc treeView*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_tree_view(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_visible(self: ptr TreeViewColumn00): gboolean {.
    importc, libprag.}

proc getVisible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_visible(cast[ptr TreeViewColumn00](self.impl)))

proc visible*(self: TreeViewColumn): bool =
  toBool(gtk_tree_view_column_get_visible(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_widget(self: ptr TreeViewColumn00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_widget(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: TreeViewColumn): Widget =
  let gobj = gtk_tree_view_column_get_widget(cast[ptr TreeViewColumn00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_column_get_width(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getWidth*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_width(cast[ptr TreeViewColumn00](self.impl)))

proc width*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_width(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_get_x_offset(self: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc getXOffset*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_x_offset(cast[ptr TreeViewColumn00](self.impl)))

proc xOffset*(self: TreeViewColumn): int =
  int(gtk_tree_view_column_get_x_offset(cast[ptr TreeViewColumn00](self.impl)))

proc gtk_tree_view_column_pack_end(self: ptr TreeViewColumn00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packEnd*(self: TreeViewColumn; cell: CellRenderer;
    expand: bool) =
  gtk_tree_view_column_pack_end(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_tree_view_column_pack_start(self: ptr TreeViewColumn00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packStart*(self: TreeViewColumn; cell: CellRenderer;
    expand: bool) =
  gtk_tree_view_column_pack_start(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_tree_view_column_queue_resize(self: ptr TreeViewColumn00) {.
    importc, libprag.}

proc queueResize*(self: TreeViewColumn) =
  gtk_tree_view_column_queue_resize(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_alignment(self: ptr TreeViewColumn00; xalign: cfloat) {.
    importc, libprag.}

proc setAlignment*(self: TreeViewColumn; xalign: cfloat) =
  gtk_tree_view_column_set_alignment(cast[ptr TreeViewColumn00](self.impl), xalign)

proc `alignment=`*(self: TreeViewColumn; xalign: cfloat) =
  gtk_tree_view_column_set_alignment(cast[ptr TreeViewColumn00](self.impl), xalign)

proc gtk_tree_view_column_set_clickable(self: ptr TreeViewColumn00; clickable: gboolean) {.
    importc, libprag.}

proc setClickable*(self: TreeViewColumn; clickable: bool = true) =
  gtk_tree_view_column_set_clickable(cast[ptr TreeViewColumn00](self.impl), gboolean(clickable))

proc `clickable=`*(self: TreeViewColumn; clickable: bool) =
  gtk_tree_view_column_set_clickable(cast[ptr TreeViewColumn00](self.impl), gboolean(clickable))

proc gtk_tree_view_column_set_expand(self: ptr TreeViewColumn00; expand: gboolean) {.
    importc, libprag.}

proc setExpand*(self: TreeViewColumn; expand: bool = true) =
  gtk_tree_view_column_set_expand(cast[ptr TreeViewColumn00](self.impl), gboolean(expand))

proc `expand=`*(self: TreeViewColumn; expand: bool) =
  gtk_tree_view_column_set_expand(cast[ptr TreeViewColumn00](self.impl), gboolean(expand))

proc gtk_tree_view_column_set_fixed_width(self: ptr TreeViewColumn00; fixedWidth: int32) {.
    importc, libprag.}

proc setFixedWidth*(self: TreeViewColumn; fixedWidth: int) =
  gtk_tree_view_column_set_fixed_width(cast[ptr TreeViewColumn00](self.impl), int32(fixedWidth))

proc `fixedWidth=`*(self: TreeViewColumn; fixedWidth: int) =
  gtk_tree_view_column_set_fixed_width(cast[ptr TreeViewColumn00](self.impl), int32(fixedWidth))

proc gtk_tree_view_column_set_max_width(self: ptr TreeViewColumn00; maxWidth: int32) {.
    importc, libprag.}

proc setMaxWidth*(self: TreeViewColumn; maxWidth: int) =
  gtk_tree_view_column_set_max_width(cast[ptr TreeViewColumn00](self.impl), int32(maxWidth))

proc `maxWidth=`*(self: TreeViewColumn; maxWidth: int) =
  gtk_tree_view_column_set_max_width(cast[ptr TreeViewColumn00](self.impl), int32(maxWidth))

proc gtk_tree_view_column_set_min_width(self: ptr TreeViewColumn00; minWidth: int32) {.
    importc, libprag.}

proc setMinWidth*(self: TreeViewColumn; minWidth: int) =
  gtk_tree_view_column_set_min_width(cast[ptr TreeViewColumn00](self.impl), int32(minWidth))

proc `minWidth=`*(self: TreeViewColumn; minWidth: int) =
  gtk_tree_view_column_set_min_width(cast[ptr TreeViewColumn00](self.impl), int32(minWidth))

proc gtk_tree_view_column_set_reorderable(self: ptr TreeViewColumn00; reorderable: gboolean) {.
    importc, libprag.}

proc setReorderable*(self: TreeViewColumn; reorderable: bool = true) =
  gtk_tree_view_column_set_reorderable(cast[ptr TreeViewColumn00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: TreeViewColumn; reorderable: bool) =
  gtk_tree_view_column_set_reorderable(cast[ptr TreeViewColumn00](self.impl), gboolean(reorderable))

proc gtk_tree_view_column_set_resizable(self: ptr TreeViewColumn00; resizable: gboolean) {.
    importc, libprag.}

proc setResizable*(self: TreeViewColumn; resizable: bool = true) =
  gtk_tree_view_column_set_resizable(cast[ptr TreeViewColumn00](self.impl), gboolean(resizable))

proc `resizable=`*(self: TreeViewColumn; resizable: bool) =
  gtk_tree_view_column_set_resizable(cast[ptr TreeViewColumn00](self.impl), gboolean(resizable))

proc gtk_tree_view_column_set_sort_column_id(self: ptr TreeViewColumn00;
    sortColumnId: int32) {.
    importc, libprag.}

proc setSortColumnId*(self: TreeViewColumn; sortColumnId: int) =
  gtk_tree_view_column_set_sort_column_id(cast[ptr TreeViewColumn00](self.impl), int32(sortColumnId))

proc `sortColumnId=`*(self: TreeViewColumn; sortColumnId: int) =
  gtk_tree_view_column_set_sort_column_id(cast[ptr TreeViewColumn00](self.impl), int32(sortColumnId))

proc gtk_tree_view_column_set_sort_indicator(self: ptr TreeViewColumn00;
    setting: gboolean) {.
    importc, libprag.}

proc setSortIndicator*(self: TreeViewColumn; setting: bool = true) =
  gtk_tree_view_column_set_sort_indicator(cast[ptr TreeViewColumn00](self.impl), gboolean(setting))

proc `sortIndicator=`*(self: TreeViewColumn; setting: bool) =
  gtk_tree_view_column_set_sort_indicator(cast[ptr TreeViewColumn00](self.impl), gboolean(setting))

proc gtk_tree_view_column_set_spacing(self: ptr TreeViewColumn00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: TreeViewColumn; spacing: int) =
  gtk_tree_view_column_set_spacing(cast[ptr TreeViewColumn00](self.impl), int32(spacing))

proc `spacing=`*(self: TreeViewColumn; spacing: int) =
  gtk_tree_view_column_set_spacing(cast[ptr TreeViewColumn00](self.impl), int32(spacing))

proc gtk_tree_view_column_set_title(self: ptr TreeViewColumn00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: TreeViewColumn; title: cstring) =
  gtk_tree_view_column_set_title(cast[ptr TreeViewColumn00](self.impl), title)

proc `title=`*(self: TreeViewColumn; title: cstring) =
  gtk_tree_view_column_set_title(cast[ptr TreeViewColumn00](self.impl), title)

proc gtk_tree_view_column_set_visible(self: ptr TreeViewColumn00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: TreeViewColumn; visible: bool = true) =
  gtk_tree_view_column_set_visible(cast[ptr TreeViewColumn00](self.impl), gboolean(visible))

proc `visible=`*(self: TreeViewColumn; visible: bool) =
  gtk_tree_view_column_set_visible(cast[ptr TreeViewColumn00](self.impl), gboolean(visible))

proc gtk_tree_view_column_set_widget(self: ptr TreeViewColumn00; widget: ptr Widget00) {.
    importc, libprag.}

proc setWidget*(self: TreeViewColumn; widget: Widget = nil) =
  gtk_tree_view_column_set_widget(cast[ptr TreeViewColumn00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

proc `widget=`*(self: TreeViewColumn; widget: Widget = nil) =
  gtk_tree_view_column_set_widget(cast[ptr TreeViewColumn00](self.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl))

type
  OffscreenWindow* = ref object of Window
  OffscreenWindow00* = object of Window00

proc gtk_offscreen_window_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(OffscreenWindow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_offscreen_window_new(): ptr OffscreenWindow00 {.
    importc, libprag.}

proc newOffscreenWindow*(): OffscreenWindow =
  let gobj = gtk_offscreen_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newOffscreenWindow*(tdesc: typedesc): tdesc =
  assert(result is OffscreenWindow)
  let gobj = gtk_offscreen_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initOffscreenWindow*[T](result: var T) {.deprecated.} =
  assert(result is OffscreenWindow)
  let gobj = gtk_offscreen_window_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_offscreen_window_get_pixbuf(self: ptr OffscreenWindow00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPixbuf*(self: OffscreenWindow): gdkpixbuf.Pixbuf =
  let gobj = gtk_offscreen_window_get_pixbuf(cast[ptr OffscreenWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: OffscreenWindow): gdkpixbuf.Pixbuf =
  let gobj = gtk_offscreen_window_get_pixbuf(cast[ptr OffscreenWindow00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_offscreen_window_get_surface(self: ptr OffscreenWindow00): ptr cairo.Surface00 {.
    importc, libprag.}

proc getSurface*(self: OffscreenWindow): cairo.Surface =
  let impl0 = gtk_offscreen_window_get_surface(cast[ptr OffscreenWindow00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_surface_get_type(), impl0))

proc surface*(self: OffscreenWindow): cairo.Surface =
  let impl0 = gtk_offscreen_window_get_surface(cast[ptr OffscreenWindow00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_surface_get_type(), impl0))

type
  Range* = ref object of Widget
  Range00* = object of Widget00

proc gtk_range_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Range()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAdjustBounds*(self: Range;  p: proc (self: ptr Range00; value: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "adjust-bounds", cast[GCallback](p), xdata, nil, cf)

proc scChangeValue*(self: Range;  p: proc (self: ptr Range00; scroll: ScrollType; value: cdouble; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-value", cast[GCallback](p), xdata, nil, cf)

proc scMoveSlider*(self: Range;  p: proc (self: ptr Range00; step: ScrollType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-slider", cast[GCallback](p), xdata, nil, cf)

proc scValueChanged*(self: Range;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "value-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_range_get_adjustment(self: ptr Range00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: Range): Adjustment =
  let gobj = gtk_range_get_adjustment(cast[ptr Range00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: Range): Adjustment =
  let gobj = gtk_range_get_adjustment(cast[ptr Range00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_range_get_fill_level(self: ptr Range00): cdouble {.
    importc, libprag.}

proc getFillLevel*(self: Range): cdouble =
  gtk_range_get_fill_level(cast[ptr Range00](self.impl))

proc fillLevel*(self: Range): cdouble =
  gtk_range_get_fill_level(cast[ptr Range00](self.impl))

proc gtk_range_get_flippable(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getFlippable*(self: Range): bool =
  toBool(gtk_range_get_flippable(cast[ptr Range00](self.impl)))

proc flippable*(self: Range): bool =
  toBool(gtk_range_get_flippable(cast[ptr Range00](self.impl)))

proc gtk_range_get_inverted(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getInverted*(self: Range): bool =
  toBool(gtk_range_get_inverted(cast[ptr Range00](self.impl)))

proc inverted*(self: Range): bool =
  toBool(gtk_range_get_inverted(cast[ptr Range00](self.impl)))

proc gtk_range_get_lower_stepper_sensitivity(self: ptr Range00): SensitivityType {.
    importc, libprag.}

proc getLowerStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_lower_stepper_sensitivity(cast[ptr Range00](self.impl))

proc lowerStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_lower_stepper_sensitivity(cast[ptr Range00](self.impl))

proc gtk_range_get_min_slider_size(self: ptr Range00): int32 {.
    importc, libprag.}

proc getMinSliderSize*(self: Range): int =
  int(gtk_range_get_min_slider_size(cast[ptr Range00](self.impl)))

proc minSliderSize*(self: Range): int =
  int(gtk_range_get_min_slider_size(cast[ptr Range00](self.impl)))

proc gtk_range_get_range_rect(self: ptr Range00; rangeRect: var gdk.Rectangle) {.
    importc, libprag.}

proc getRangeRect*(self: Range; rangeRect: var gdk.Rectangle) =
  gtk_range_get_range_rect(cast[ptr Range00](self.impl), rangeRect)

proc getRangeRect*(self: Range): gdk.Rectangle =
  gtk_range_get_range_rect(cast[ptr Range00](self.impl), result)

proc gtk_range_get_restrict_to_fill_level(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getRestrictToFillLevel*(self: Range): bool =
  toBool(gtk_range_get_restrict_to_fill_level(cast[ptr Range00](self.impl)))

proc restrictToFillLevel*(self: Range): bool =
  toBool(gtk_range_get_restrict_to_fill_level(cast[ptr Range00](self.impl)))

proc gtk_range_get_round_digits(self: ptr Range00): int32 {.
    importc, libprag.}

proc getRoundDigits*(self: Range): int =
  int(gtk_range_get_round_digits(cast[ptr Range00](self.impl)))

proc roundDigits*(self: Range): int =
  int(gtk_range_get_round_digits(cast[ptr Range00](self.impl)))

proc gtk_range_get_show_fill_level(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getShowFillLevel*(self: Range): bool =
  toBool(gtk_range_get_show_fill_level(cast[ptr Range00](self.impl)))

proc showFillLevel*(self: Range): bool =
  toBool(gtk_range_get_show_fill_level(cast[ptr Range00](self.impl)))

proc gtk_range_get_slider_range(self: ptr Range00; sliderStart: var int32;
    sliderEnd: var int32) {.
    importc, libprag.}

proc getSliderRange*(self: Range; sliderStart: var int = cast[var int](nil);
    sliderEnd: var int = cast[var int](nil)) =
  var sliderEnd_00: int32
  var sliderStart_00: int32
  gtk_range_get_slider_range(cast[ptr Range00](self.impl), sliderStart_00, sliderEnd_00)
  if sliderEnd.addr != nil:
    sliderEnd = int(sliderEnd_00)
  if sliderStart.addr != nil:
    sliderStart = int(sliderStart_00)

proc gtk_range_get_slider_size_fixed(self: ptr Range00): gboolean {.
    importc, libprag.}

proc getSliderSizeFixed*(self: Range): bool =
  toBool(gtk_range_get_slider_size_fixed(cast[ptr Range00](self.impl)))

proc sliderSizeFixed*(self: Range): bool =
  toBool(gtk_range_get_slider_size_fixed(cast[ptr Range00](self.impl)))

proc gtk_range_get_upper_stepper_sensitivity(self: ptr Range00): SensitivityType {.
    importc, libprag.}

proc getUpperStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_upper_stepper_sensitivity(cast[ptr Range00](self.impl))

proc upperStepperSensitivity*(self: Range): SensitivityType =
  gtk_range_get_upper_stepper_sensitivity(cast[ptr Range00](self.impl))

proc gtk_range_get_value(self: ptr Range00): cdouble {.
    importc, libprag.}

proc getValue*(self: Range): cdouble =
  gtk_range_get_value(cast[ptr Range00](self.impl))

proc value*(self: Range): cdouble =
  gtk_range_get_value(cast[ptr Range00](self.impl))

proc gtk_range_set_adjustment(self: ptr Range00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: Range; adjustment: Adjustment) =
  gtk_range_set_adjustment(cast[ptr Range00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: Range; adjustment: Adjustment) =
  gtk_range_set_adjustment(cast[ptr Range00](self.impl), cast[ptr Adjustment00](adjustment.impl))

proc gtk_range_set_fill_level(self: ptr Range00; fillLevel: cdouble) {.
    importc, libprag.}

proc setFillLevel*(self: Range; fillLevel: cdouble) =
  gtk_range_set_fill_level(cast[ptr Range00](self.impl), fillLevel)

proc `fillLevel=`*(self: Range; fillLevel: cdouble) =
  gtk_range_set_fill_level(cast[ptr Range00](self.impl), fillLevel)

proc gtk_range_set_flippable(self: ptr Range00; flippable: gboolean) {.
    importc, libprag.}

proc setFlippable*(self: Range; flippable: bool = true) =
  gtk_range_set_flippable(cast[ptr Range00](self.impl), gboolean(flippable))

proc `flippable=`*(self: Range; flippable: bool) =
  gtk_range_set_flippable(cast[ptr Range00](self.impl), gboolean(flippable))

proc gtk_range_set_increments(self: ptr Range00; step: cdouble; page: cdouble) {.
    importc, libprag.}

proc setIncrements*(self: Range; step: cdouble; page: cdouble) =
  gtk_range_set_increments(cast[ptr Range00](self.impl), step, page)

proc gtk_range_set_inverted(self: ptr Range00; setting: gboolean) {.
    importc, libprag.}

proc setInverted*(self: Range; setting: bool = true) =
  gtk_range_set_inverted(cast[ptr Range00](self.impl), gboolean(setting))

proc `inverted=`*(self: Range; setting: bool) =
  gtk_range_set_inverted(cast[ptr Range00](self.impl), gboolean(setting))

proc gtk_range_set_lower_stepper_sensitivity(self: ptr Range00; sensitivity: SensitivityType) {.
    importc, libprag.}

proc setLowerStepperSensitivity*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_lower_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc `lowerStepperSensitivity=`*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_lower_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc gtk_range_set_min_slider_size(self: ptr Range00; minSize: int32) {.
    importc, libprag.}

proc setMinSliderSize*(self: Range; minSize: int) =
  gtk_range_set_min_slider_size(cast[ptr Range00](self.impl), int32(minSize))

proc `minSliderSize=`*(self: Range; minSize: int) =
  gtk_range_set_min_slider_size(cast[ptr Range00](self.impl), int32(minSize))

proc gtk_range_set_range(self: ptr Range00; min: cdouble; max: cdouble) {.
    importc, libprag.}

proc setRange*(self: Range; min: cdouble; max: cdouble) =
  gtk_range_set_range(cast[ptr Range00](self.impl), min, max)

proc gtk_range_set_restrict_to_fill_level(self: ptr Range00; restrictToFillLevel: gboolean) {.
    importc, libprag.}

proc setRestrictToFillLevel*(self: Range; restrictToFillLevel: bool = true) =
  gtk_range_set_restrict_to_fill_level(cast[ptr Range00](self.impl), gboolean(restrictToFillLevel))

proc `restrictToFillLevel=`*(self: Range; restrictToFillLevel: bool) =
  gtk_range_set_restrict_to_fill_level(cast[ptr Range00](self.impl), gboolean(restrictToFillLevel))

proc gtk_range_set_round_digits(self: ptr Range00; roundDigits: int32) {.
    importc, libprag.}

proc setRoundDigits*(self: Range; roundDigits: int) =
  gtk_range_set_round_digits(cast[ptr Range00](self.impl), int32(roundDigits))

proc `roundDigits=`*(self: Range; roundDigits: int) =
  gtk_range_set_round_digits(cast[ptr Range00](self.impl), int32(roundDigits))

proc gtk_range_set_show_fill_level(self: ptr Range00; showFillLevel: gboolean) {.
    importc, libprag.}

proc setShowFillLevel*(self: Range; showFillLevel: bool = true) =
  gtk_range_set_show_fill_level(cast[ptr Range00](self.impl), gboolean(showFillLevel))

proc `showFillLevel=`*(self: Range; showFillLevel: bool) =
  gtk_range_set_show_fill_level(cast[ptr Range00](self.impl), gboolean(showFillLevel))

proc gtk_range_set_slider_size_fixed(self: ptr Range00; sizeFixed: gboolean) {.
    importc, libprag.}

proc setSliderSizeFixed*(self: Range; sizeFixed: bool = true) =
  gtk_range_set_slider_size_fixed(cast[ptr Range00](self.impl), gboolean(sizeFixed))

proc `sliderSizeFixed=`*(self: Range; sizeFixed: bool) =
  gtk_range_set_slider_size_fixed(cast[ptr Range00](self.impl), gboolean(sizeFixed))

proc gtk_range_set_upper_stepper_sensitivity(self: ptr Range00; sensitivity: SensitivityType) {.
    importc, libprag.}

proc setUpperStepperSensitivity*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_upper_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc `upperStepperSensitivity=`*(self: Range; sensitivity: SensitivityType) =
  gtk_range_set_upper_stepper_sensitivity(cast[ptr Range00](self.impl), sensitivity)

proc gtk_range_set_value(self: ptr Range00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: Range; value: cdouble) =
  gtk_range_set_value(cast[ptr Range00](self.impl), value)

proc `value=`*(self: Range; value: cdouble) =
  gtk_range_set_value(cast[ptr Range00](self.impl), value)

type
  Scale* = ref object of Range
  Scale00* = object of Range00

proc gtk_scale_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Scale()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scFormatValue*(self: Scale;  p: proc (self: ptr Scale00; value: cdouble; xdata: pointer): cstring {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "format-value", cast[GCallback](p), xdata, nil, cf)

proc gtk_scale_new(orientation: Orientation; adjustment: ptr Adjustment00): ptr Scale00 {.
    importc, libprag.}

proc newScale*(orientation: Orientation; adjustment: Adjustment = nil): Scale =
  let gobj = gtk_scale_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScale*(tdesc: typedesc; orientation: Orientation; adjustment: Adjustment = nil): tdesc =
  assert(result is Scale)
  let gobj = gtk_scale_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScale*[T](result: var T; orientation: Orientation; adjustment: Adjustment = nil) {.deprecated.} =
  assert(result is Scale)
  let gobj = gtk_scale_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_new_with_range(orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble): ptr Scale00 {.
    importc, libprag.}

proc newScaleWithRange*(orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble): Scale =
  let gobj = gtk_scale_new_with_range(orientation, min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScaleWithRange*(tdesc: typedesc; orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble): tdesc =
  assert(result is Scale)
  let gobj = gtk_scale_new_with_range(orientation, min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScaleWithRange*[T](result: var T; orientation: Orientation; min: cdouble; max: cdouble;
    step: cdouble) {.deprecated.} =
  assert(result is Scale)
  let gobj = gtk_scale_new_with_range(orientation, min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_add_mark(self: ptr Scale00; value: cdouble; position: PositionType;
    markup: cstring) {.
    importc, libprag.}

proc addMark*(self: Scale; value: cdouble; position: PositionType;
    markup: cstring = nil) =
  gtk_scale_add_mark(cast[ptr Scale00](self.impl), value, position, markup)

proc gtk_scale_clear_marks(self: ptr Scale00) {.
    importc, libprag.}

proc clearMarks*(self: Scale) =
  gtk_scale_clear_marks(cast[ptr Scale00](self.impl))

proc gtk_scale_get_digits(self: ptr Scale00): int32 {.
    importc, libprag.}

proc getDigits*(self: Scale): int =
  int(gtk_scale_get_digits(cast[ptr Scale00](self.impl)))

proc digits*(self: Scale): int =
  int(gtk_scale_get_digits(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_draw_value(self: ptr Scale00): gboolean {.
    importc, libprag.}

proc getDrawValue*(self: Scale): bool =
  toBool(gtk_scale_get_draw_value(cast[ptr Scale00](self.impl)))

proc drawValue*(self: Scale): bool =
  toBool(gtk_scale_get_draw_value(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_has_origin(self: ptr Scale00): gboolean {.
    importc, libprag.}

proc getHasOrigin*(self: Scale): bool =
  toBool(gtk_scale_get_has_origin(cast[ptr Scale00](self.impl)))

proc hasOrigin*(self: Scale): bool =
  toBool(gtk_scale_get_has_origin(cast[ptr Scale00](self.impl)))

proc gtk_scale_get_layout(self: ptr Scale00): ptr pango.Layout00 {.
    importc, libprag.}

proc getLayout*(self: Scale): pango.Layout =
  let gobj = gtk_scale_get_layout(cast[ptr Scale00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc layout*(self: Scale): pango.Layout =
  let gobj = gtk_scale_get_layout(cast[ptr Scale00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scale_get_layout_offsets(self: ptr Scale00; x: var int32; y: var int32) {.
    importc, libprag.}

proc getLayoutOffsets*(self: Scale; x: var int = cast[var int](nil);
    y: var int = cast[var int](nil)) =
  var y_00: int32
  var x_00: int32
  gtk_scale_get_layout_offsets(cast[ptr Scale00](self.impl), x_00, y_00)
  if y.addr != nil:
    y = int(y_00)
  if x.addr != nil:
    x = int(x_00)

proc gtk_scale_get_value_pos(self: ptr Scale00): PositionType {.
    importc, libprag.}

proc getValuePos*(self: Scale): PositionType =
  gtk_scale_get_value_pos(cast[ptr Scale00](self.impl))

proc valuePos*(self: Scale): PositionType =
  gtk_scale_get_value_pos(cast[ptr Scale00](self.impl))

proc gtk_scale_set_digits(self: ptr Scale00; digits: int32) {.
    importc, libprag.}

proc setDigits*(self: Scale; digits: int) =
  gtk_scale_set_digits(cast[ptr Scale00](self.impl), int32(digits))

proc `digits=`*(self: Scale; digits: int) =
  gtk_scale_set_digits(cast[ptr Scale00](self.impl), int32(digits))

proc gtk_scale_set_draw_value(self: ptr Scale00; drawValue: gboolean) {.
    importc, libprag.}

proc setDrawValue*(self: Scale; drawValue: bool = true) =
  gtk_scale_set_draw_value(cast[ptr Scale00](self.impl), gboolean(drawValue))

proc `drawValue=`*(self: Scale; drawValue: bool) =
  gtk_scale_set_draw_value(cast[ptr Scale00](self.impl), gboolean(drawValue))

proc gtk_scale_set_has_origin(self: ptr Scale00; hasOrigin: gboolean) {.
    importc, libprag.}

proc setHasOrigin*(self: Scale; hasOrigin: bool = true) =
  gtk_scale_set_has_origin(cast[ptr Scale00](self.impl), gboolean(hasOrigin))

proc `hasOrigin=`*(self: Scale; hasOrigin: bool) =
  gtk_scale_set_has_origin(cast[ptr Scale00](self.impl), gboolean(hasOrigin))

proc gtk_scale_set_value_pos(self: ptr Scale00; pos: PositionType) {.
    importc, libprag.}

proc setValuePos*(self: Scale; pos: PositionType) =
  gtk_scale_set_value_pos(cast[ptr Scale00](self.impl), pos)

proc `valuePos=`*(self: Scale; pos: PositionType) =
  gtk_scale_set_value_pos(cast[ptr Scale00](self.impl), pos)

type
  HScale* = ref object of Scale
  HScale00* = object of Scale00

proc gtk_hscale_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HScale()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_hscale_new(adjustment: ptr Adjustment00): ptr HScale00 {.
    importc, libprag.}

proc newHScale*(adjustment: Adjustment = nil): HScale {.deprecated.}  =
  let gobj = gtk_hscale_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHScale*(tdesc: typedesc; adjustment: Adjustment = nil): tdesc {.deprecated.}  =
  assert(result is HScale)
  let gobj = gtk_hscale_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHScale*[T](result: var T; adjustment: Adjustment = nil) {.deprecated.} =
  assert(result is HScale)
  let gobj = gtk_hscale_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_hscale_new_with_range(min: cdouble; max: cdouble; step: cdouble): ptr HScale00 {.
    importc, libprag.}

proc newHScaleWithRange*(min: cdouble; max: cdouble; step: cdouble): HScale {.deprecated.}  =
  let gobj = gtk_hscale_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHScaleWithRange*(tdesc: typedesc; min: cdouble; max: cdouble; step: cdouble): tdesc {.deprecated.}  =
  assert(result is HScale)
  let gobj = gtk_hscale_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHScaleWithRange*[T](result: var T; min: cdouble; max: cdouble; step: cdouble) {.deprecated.} =
  assert(result is HScale)
  let gobj = gtk_hscale_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  MenuBar* = ref object of MenuShell
  MenuBar00* = object of MenuShell00

proc gtk_menu_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_menu_bar_new(): ptr MenuBar00 {.
    importc, libprag.}

proc newMenuBar*(): MenuBar =
  let gobj = gtk_menu_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuBar*(tdesc: typedesc): tdesc =
  assert(result is MenuBar)
  let gobj = gtk_menu_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuBar*[T](result: var T) {.deprecated.} =
  assert(result is MenuBar)
  let gobj = gtk_menu_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_menu_bar_new_from_model(model: ptr gio.MenuModel00): ptr MenuBar00 {.
    importc, libprag.}

proc newMenuBarFromModel*(model: gio.MenuModel): MenuBar =
  let gobj = gtk_menu_bar_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMenuBarFromModel*(tdesc: typedesc; model: gio.MenuModel): tdesc =
  assert(result is MenuBar)
  let gobj = gtk_menu_bar_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMenuBarFromModel*[T](result: var T; model: gio.MenuModel) {.deprecated.} =
  assert(result is MenuBar)
  let gobj = gtk_menu_bar_new_from_model(cast[ptr gio.MenuModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Statusbar* = ref object of Box
  Statusbar00* = object of Box00

proc gtk_statusbar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Statusbar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scTextPopped*(self: Statusbar;  p: proc (self: ptr Statusbar00; contextId: uint32; text: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "text-popped", cast[GCallback](p), xdata, nil, cf)

proc scTextPushed*(self: Statusbar;  p: proc (self: ptr Statusbar00; contextId: uint32; text: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "text-pushed", cast[GCallback](p), xdata, nil, cf)

proc gtk_statusbar_new(): ptr Statusbar00 {.
    importc, libprag.}

proc newStatusbar*(): Statusbar =
  let gobj = gtk_statusbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusbar*(tdesc: typedesc): tdesc =
  assert(result is Statusbar)
  let gobj = gtk_statusbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusbar*[T](result: var T) {.deprecated.} =
  assert(result is Statusbar)
  let gobj = gtk_statusbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_statusbar_get_context_id(self: ptr Statusbar00; contextDescription: cstring): uint32 {.
    importc, libprag.}

proc getContextId*(self: Statusbar; contextDescription: cstring): int =
  int(gtk_statusbar_get_context_id(cast[ptr Statusbar00](self.impl), contextDescription))

proc gtk_statusbar_get_message_area(self: ptr Statusbar00): ptr Box00 {.
    importc, libprag.}

proc getMessageArea*(self: Statusbar): Box =
  let gobj = gtk_statusbar_get_message_area(cast[ptr Statusbar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc messageArea*(self: Statusbar): Box =
  let gobj = gtk_statusbar_get_message_area(cast[ptr Statusbar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_statusbar_pop(self: ptr Statusbar00; contextId: uint32) {.
    importc, libprag.}

proc pop*(self: Statusbar; contextId: int) =
  gtk_statusbar_pop(cast[ptr Statusbar00](self.impl), uint32(contextId))

proc gtk_statusbar_push(self: ptr Statusbar00; contextId: uint32; text: cstring): uint32 {.
    importc, libprag.}

proc push*(self: Statusbar; contextId: int; text: cstring): int =
  int(gtk_statusbar_push(cast[ptr Statusbar00](self.impl), uint32(contextId), text))

proc gtk_statusbar_remove(self: ptr Statusbar00; contextId: uint32; messageId: uint32) {.
    importc, libprag.}

proc remove*(self: Statusbar; contextId: int; messageId: int) =
  gtk_statusbar_remove(cast[ptr Statusbar00](self.impl), uint32(contextId), uint32(messageId))

proc gtk_statusbar_remove_all(self: ptr Statusbar00; contextId: uint32) {.
    importc, libprag.}

proc removeAll*(self: Statusbar; contextId: int) =
  gtk_statusbar_remove_all(cast[ptr Statusbar00](self.impl), uint32(contextId))

type
  ToolPalette* = ref object of Container
  ToolPalette00* = object of Container00

proc gtk_tool_palette_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToolPalette()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tool_palette_new(): ptr ToolPalette00 {.
    importc, libprag.}

proc newToolPalette*(): ToolPalette =
  let gobj = gtk_tool_palette_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToolPalette*(tdesc: typedesc): tdesc =
  assert(result is ToolPalette)
  let gobj = gtk_tool_palette_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolPalette*[T](result: var T) {.deprecated.} =
  assert(result is ToolPalette)
  let gobj = gtk_tool_palette_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_drag_target_group(): ptr TargetEntry00 {.
    importc, libprag.}

proc getDragTargetGroup*(): TargetEntry =
  fnew(result, gBoxedFreeGtkTargetEntry)
  result.impl = gtk_tool_palette_get_drag_target_group()
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_entry_get_type(), result.impl))

proc gtk_tool_palette_get_drag_target_item(): ptr TargetEntry00 {.
    importc, libprag.}

proc getDragTargetItem*(): TargetEntry =
  fnew(result, gBoxedFreeGtkTargetEntry)
  result.impl = gtk_tool_palette_get_drag_target_item()
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_target_entry_get_type(), result.impl))

proc gtk_tool_palette_get_drag_item(self: ptr ToolPalette00; selection: ptr SelectionData00): ptr Widget00 {.
    importc, libprag.}

proc getDragItem*(self: ToolPalette; selection: SelectionData): Widget =
  let gobj = gtk_tool_palette_get_drag_item(cast[ptr ToolPalette00](self.impl), cast[ptr SelectionData00](selection.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_drop_item(self: ptr ToolPalette00; x: int32; y: int32): ptr ToolItem00 {.
    importc, libprag.}

proc getDropItem*(self: ToolPalette; x: int; y: int): ToolItem =
  let gobj = gtk_tool_palette_get_drop_item(cast[ptr ToolPalette00](self.impl), int32(x), int32(y))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_hadjustment(self: ptr ToolPalette00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_hadjustment(cast[ptr ToolPalette00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_hadjustment(cast[ptr ToolPalette00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_icon_size(self: ptr ToolPalette00): int32 {.
    importc, libprag.}

proc getIconSize*(self: ToolPalette): int =
  int(gtk_tool_palette_get_icon_size(cast[ptr ToolPalette00](self.impl)))

proc iconSize*(self: ToolPalette): int =
  int(gtk_tool_palette_get_icon_size(cast[ptr ToolPalette00](self.impl)))

proc gtk_tool_palette_get_style(self: ptr ToolPalette00): ToolbarStyle {.
    importc, libprag.}

proc getStyle*(self: ToolPalette): ToolbarStyle =
  gtk_tool_palette_get_style(cast[ptr ToolPalette00](self.impl))

proc style*(self: ToolPalette): ToolbarStyle =
  gtk_tool_palette_get_style(cast[ptr ToolPalette00](self.impl))

proc gtk_tool_palette_get_vadjustment(self: ptr ToolPalette00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_vadjustment(cast[ptr ToolPalette00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: ToolPalette): Adjustment =
  let gobj = gtk_tool_palette_get_vadjustment(cast[ptr ToolPalette00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_set_icon_size(self: ptr ToolPalette00; iconSize: int32) {.
    importc, libprag.}

proc setIconSize*(self: ToolPalette; iconSize: int) =
  gtk_tool_palette_set_icon_size(cast[ptr ToolPalette00](self.impl), int32(iconSize))

proc `iconSize=`*(self: ToolPalette; iconSize: int) =
  gtk_tool_palette_set_icon_size(cast[ptr ToolPalette00](self.impl), int32(iconSize))

proc gtk_tool_palette_set_style(self: ptr ToolPalette00; style: ToolbarStyle) {.
    importc, libprag.}

proc setStyle*(self: ToolPalette; style: ToolbarStyle) =
  gtk_tool_palette_set_style(cast[ptr ToolPalette00](self.impl), style)

proc `style=`*(self: ToolPalette; style: ToolbarStyle) =
  gtk_tool_palette_set_style(cast[ptr ToolPalette00](self.impl), style)

proc gtk_tool_palette_unset_icon_size(self: ptr ToolPalette00) {.
    importc, libprag.}

proc unsetIconSize*(self: ToolPalette) =
  gtk_tool_palette_unset_icon_size(cast[ptr ToolPalette00](self.impl))

proc gtk_tool_palette_unset_style(self: ptr ToolPalette00) {.
    importc, libprag.}

proc unsetStyle*(self: ToolPalette) =
  gtk_tool_palette_unset_style(cast[ptr ToolPalette00](self.impl))

type
  FileChooserButton* = ref object of Box
  FileChooserButton00* = object of Box00

proc gtk_file_chooser_button_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileChooserButton()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scFileSet*(self: FileChooserButton;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "file-set", cast[GCallback](p), xdata, nil, cf)

proc gtk_file_chooser_button_new_with_dialog(dialog: ptr Dialog00): ptr FileChooserButton00 {.
    importc, libprag.}

proc newFileChooserButtonWithDialog*(dialog: Dialog): FileChooserButton =
  let gobj = gtk_file_chooser_button_new_with_dialog(cast[ptr Dialog00](dialog.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileChooserButtonWithDialog*(tdesc: typedesc; dialog: Dialog): tdesc =
  assert(result is FileChooserButton)
  let gobj = gtk_file_chooser_button_new_with_dialog(cast[ptr Dialog00](dialog.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserButtonWithDialog*[T](result: var T; dialog: Dialog) {.deprecated.} =
  assert(result is FileChooserButton)
  let gobj = gtk_file_chooser_button_new_with_dialog(cast[ptr Dialog00](dialog.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_button_get_focus_on_click(self: ptr FileChooserButton00): gboolean {.
    importc, libprag.}

proc getFocusOnClick*(self: FileChooserButton): bool =
  toBool(gtk_file_chooser_button_get_focus_on_click(cast[ptr FileChooserButton00](self.impl)))

proc focusOnClick*(self: FileChooserButton): bool =
  toBool(gtk_file_chooser_button_get_focus_on_click(cast[ptr FileChooserButton00](self.impl)))

proc gtk_file_chooser_button_get_title(self: ptr FileChooserButton00): cstring {.
    importc, libprag.}

proc getTitle*(self: FileChooserButton): string =
  result = $gtk_file_chooser_button_get_title(cast[ptr FileChooserButton00](self.impl))

proc title*(self: FileChooserButton): string =
  result = $gtk_file_chooser_button_get_title(cast[ptr FileChooserButton00](self.impl))

proc gtk_file_chooser_button_get_width_chars(self: ptr FileChooserButton00): int32 {.
    importc, libprag.}

proc getWidthChars*(self: FileChooserButton): int =
  int(gtk_file_chooser_button_get_width_chars(cast[ptr FileChooserButton00](self.impl)))

proc widthChars*(self: FileChooserButton): int =
  int(gtk_file_chooser_button_get_width_chars(cast[ptr FileChooserButton00](self.impl)))

proc gtk_file_chooser_button_set_focus_on_click(self: ptr FileChooserButton00;
    focusOnClick: gboolean) {.
    importc, libprag.}

proc setFocusOnClick*(self: FileChooserButton;
    focusOnClick: bool = true) =
  gtk_file_chooser_button_set_focus_on_click(cast[ptr FileChooserButton00](self.impl), gboolean(focusOnClick))

proc `focusOnClick=`*(self: FileChooserButton;
    focusOnClick: bool) =
  gtk_file_chooser_button_set_focus_on_click(cast[ptr FileChooserButton00](self.impl), gboolean(focusOnClick))

proc gtk_file_chooser_button_set_title(self: ptr FileChooserButton00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: FileChooserButton; title: cstring) =
  gtk_file_chooser_button_set_title(cast[ptr FileChooserButton00](self.impl), title)

proc `title=`*(self: FileChooserButton; title: cstring) =
  gtk_file_chooser_button_set_title(cast[ptr FileChooserButton00](self.impl), title)

proc gtk_file_chooser_button_set_width_chars(self: ptr FileChooserButton00;
    nChars: int32) {.
    importc, libprag.}

proc setWidthChars*(self: FileChooserButton; nChars: int) =
  gtk_file_chooser_button_set_width_chars(cast[ptr FileChooserButton00](self.impl), int32(nChars))

proc `widthChars=`*(self: FileChooserButton; nChars: int) =
  gtk_file_chooser_button_set_width_chars(cast[ptr FileChooserButton00](self.impl), int32(nChars))

type
  CellView* = ref object of Widget
  CellView00* = object of Widget00

proc gtk_cell_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_view_new(): ptr CellView00 {.
    importc, libprag.}

proc newCellView*(): CellView =
  let gobj = gtk_cell_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellView*(tdesc: typedesc): tdesc =
  assert(result is CellView)
  let gobj = gtk_cell_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellView*[T](result: var T) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_context(area: ptr CellArea00; context: ptr CellAreaContext00): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithContext*(area: CellArea; context: CellAreaContext): CellView =
  let gobj = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithContext*(tdesc: typedesc; area: CellArea; context: CellAreaContext): tdesc =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithContext*[T](result: var T; area: CellArea; context: CellAreaContext) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_context(cast[ptr CellArea00](area.impl), cast[ptr CellAreaContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_markup(markup: cstring): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithMarkup*(markup: cstring): CellView =
  let gobj = gtk_cell_view_new_with_markup(markup)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithMarkup*(tdesc: typedesc; markup: cstring): tdesc =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_markup(markup)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithMarkup*[T](result: var T; markup: cstring) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_markup(markup)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_pixbuf(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithPixbuf*(pixbuf: gdkpixbuf.Pixbuf): CellView =
  let gobj = gtk_cell_view_new_with_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithPixbuf*(tdesc: typedesc; pixbuf: gdkpixbuf.Pixbuf): tdesc =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_new_with_text(text: cstring): ptr CellView00 {.
    importc, libprag.}

proc newCellViewWithText*(text: cstring): CellView =
  let gobj = gtk_cell_view_new_with_text(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellViewWithText*(tdesc: typedesc; text: cstring): tdesc =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_text(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellViewWithText*[T](result: var T; text: cstring) {.deprecated.} =
  assert(result is CellView)
  let gobj = gtk_cell_view_new_with_text(text)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_get_displayed_row(self: ptr CellView00): ptr TreePath00 {.
    importc, libprag.}

proc getDisplayedRow*(self: CellView): TreePath =
  let impl0 = gtk_cell_view_get_displayed_row(cast[ptr CellView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc displayedRow*(self: CellView): TreePath =
  let impl0 = gtk_cell_view_get_displayed_row(cast[ptr CellView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_cell_view_get_draw_sensitive(self: ptr CellView00): gboolean {.
    importc, libprag.}

proc getDrawSensitive*(self: CellView): bool =
  toBool(gtk_cell_view_get_draw_sensitive(cast[ptr CellView00](self.impl)))

proc drawSensitive*(self: CellView): bool =
  toBool(gtk_cell_view_get_draw_sensitive(cast[ptr CellView00](self.impl)))

proc gtk_cell_view_get_fit_model(self: ptr CellView00): gboolean {.
    importc, libprag.}

proc getFitModel*(self: CellView): bool =
  toBool(gtk_cell_view_get_fit_model(cast[ptr CellView00](self.impl)))

proc fitModel*(self: CellView): bool =
  toBool(gtk_cell_view_get_fit_model(cast[ptr CellView00](self.impl)))

proc gtk_cell_view_get_model(self: ptr CellView00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: CellView): TreeModel =
  let gobj = gtk_cell_view_get_model(cast[ptr CellView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: CellView): TreeModel =
  let gobj = gtk_cell_view_get_model(cast[ptr CellView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_view_get_size_of_row(self: ptr CellView00; path: ptr TreePath00;
    requisition: var Requisition): gboolean {.
    importc, libprag.}

proc getSizeOfRow*(self: CellView; path: TreePath; requisition: var Requisition): bool =
  toBool(gtk_cell_view_get_size_of_row(cast[ptr CellView00](self.impl), cast[ptr TreePath00](path.impl), requisition))

proc gtk_cell_view_set_background_color(self: ptr CellView00; color: gdk.Color) {.
    importc, libprag.}

proc setBackgroundColor*(self: CellView; color: gdk.Color) =
  gtk_cell_view_set_background_color(cast[ptr CellView00](self.impl), color)

proc `backgroundColor=`*(self: CellView; color: gdk.Color) =
  gtk_cell_view_set_background_color(cast[ptr CellView00](self.impl), color)

proc gtk_cell_view_set_background_rgba(self: ptr CellView00; rgba: gdk.RGBA) {.
    importc, libprag.}

proc setBackgroundRgba*(self: CellView; rgba: gdk.RGBA) =
  gtk_cell_view_set_background_rgba(cast[ptr CellView00](self.impl), rgba)

proc `backgroundRgba=`*(self: CellView; rgba: gdk.RGBA) =
  gtk_cell_view_set_background_rgba(cast[ptr CellView00](self.impl), rgba)

proc gtk_cell_view_set_displayed_row(self: ptr CellView00; path: ptr TreePath00) {.
    importc, libprag.}

proc setDisplayedRow*(self: CellView; path: TreePath = nil) =
  gtk_cell_view_set_displayed_row(cast[ptr CellView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl))

proc `displayedRow=`*(self: CellView; path: TreePath = nil) =
  gtk_cell_view_set_displayed_row(cast[ptr CellView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl))

proc gtk_cell_view_set_draw_sensitive(self: ptr CellView00; drawSensitive: gboolean) {.
    importc, libprag.}

proc setDrawSensitive*(self: CellView; drawSensitive: bool = true) =
  gtk_cell_view_set_draw_sensitive(cast[ptr CellView00](self.impl), gboolean(drawSensitive))

proc `drawSensitive=`*(self: CellView; drawSensitive: bool) =
  gtk_cell_view_set_draw_sensitive(cast[ptr CellView00](self.impl), gboolean(drawSensitive))

proc gtk_cell_view_set_fit_model(self: ptr CellView00; fitModel: gboolean) {.
    importc, libprag.}

proc setFitModel*(self: CellView; fitModel: bool = true) =
  gtk_cell_view_set_fit_model(cast[ptr CellView00](self.impl), gboolean(fitModel))

proc `fitModel=`*(self: CellView; fitModel: bool) =
  gtk_cell_view_set_fit_model(cast[ptr CellView00](self.impl), gboolean(fitModel))

proc gtk_cell_view_set_model(self: ptr CellView00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: CellView; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_cell_view_set_model(cast[ptr CellView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: CellView; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_cell_view_set_model(cast[ptr CellView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

type
  Toolbar* = ref object of Container
  Toolbar00* = object of Container00

proc gtk_toolbar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Toolbar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scFocusHomeOrEnd*(self: Toolbar;  p: proc (self: ptr Toolbar00; focusHome: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-home-or-end", cast[GCallback](p), xdata, nil, cf)

proc scOrientationChanged*(self: Toolbar;  p: proc (self: ptr Toolbar00; orientation: Orientation; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "orientation-changed", cast[GCallback](p), xdata, nil, cf)

proc scPopupContextMenu*(self: Toolbar;  p: proc (self: ptr Toolbar00; x: int32; y: int32; button: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popup-context-menu", cast[GCallback](p), xdata, nil, cf)

proc scStyleChanged*(self: Toolbar;  p: proc (self: ptr Toolbar00; style: ToolbarStyle; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "style-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_toolbar_new(): ptr Toolbar00 {.
    importc, libprag.}

proc newToolbar*(): Toolbar =
  let gobj = gtk_toolbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToolbar*(tdesc: typedesc): tdesc =
  assert(result is Toolbar)
  let gobj = gtk_toolbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolbar*[T](result: var T) {.deprecated.} =
  assert(result is Toolbar)
  let gobj = gtk_toolbar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toolbar_get_drop_index(self: ptr Toolbar00; x: int32; y: int32): int32 {.
    importc, libprag.}

proc getDropIndex*(self: Toolbar; x: int; y: int): int =
  int(gtk_toolbar_get_drop_index(cast[ptr Toolbar00](self.impl), int32(x), int32(y)))

proc gtk_toolbar_get_item_index(self: ptr Toolbar00; item: ptr ToolItem00): int32 {.
    importc, libprag.}

proc getItemIndex*(self: Toolbar; item: ToolItem): int =
  int(gtk_toolbar_get_item_index(cast[ptr Toolbar00](self.impl), cast[ptr ToolItem00](item.impl)))

proc gtk_toolbar_get_n_items(self: ptr Toolbar00): int32 {.
    importc, libprag.}

proc getNItems*(self: Toolbar): int =
  int(gtk_toolbar_get_n_items(cast[ptr Toolbar00](self.impl)))

proc nItems*(self: Toolbar): int =
  int(gtk_toolbar_get_n_items(cast[ptr Toolbar00](self.impl)))

proc gtk_toolbar_get_nth_item(self: ptr Toolbar00; n: int32): ptr ToolItem00 {.
    importc, libprag.}

proc getNthItem*(self: Toolbar; n: int): ToolItem =
  let gobj = gtk_toolbar_get_nth_item(cast[ptr Toolbar00](self.impl), int32(n))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toolbar_get_relief_style(self: ptr Toolbar00): ReliefStyle {.
    importc, libprag.}

proc getReliefStyle*(self: Toolbar): ReliefStyle =
  gtk_toolbar_get_relief_style(cast[ptr Toolbar00](self.impl))

proc reliefStyle*(self: Toolbar): ReliefStyle =
  gtk_toolbar_get_relief_style(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_get_show_arrow(self: ptr Toolbar00): gboolean {.
    importc, libprag.}

proc getShowArrow*(self: Toolbar): bool =
  toBool(gtk_toolbar_get_show_arrow(cast[ptr Toolbar00](self.impl)))

proc showArrow*(self: Toolbar): bool =
  toBool(gtk_toolbar_get_show_arrow(cast[ptr Toolbar00](self.impl)))

proc gtk_toolbar_get_style(self: ptr Toolbar00): ToolbarStyle {.
    importc, libprag.}

proc getStyle*(self: Toolbar): ToolbarStyle =
  gtk_toolbar_get_style(cast[ptr Toolbar00](self.impl))

proc style*(self: Toolbar): ToolbarStyle =
  gtk_toolbar_get_style(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_insert(self: ptr Toolbar00; item: ptr ToolItem00; pos: int32) {.
    importc, libprag.}

proc insert*(self: Toolbar; item: ToolItem; pos: int) =
  gtk_toolbar_insert(cast[ptr Toolbar00](self.impl), cast[ptr ToolItem00](item.impl), int32(pos))

proc gtk_toolbar_set_drop_highlight_item(self: ptr Toolbar00; toolItem: ptr ToolItem00;
    index: int32) {.
    importc, libprag.}

proc setDropHighlightItem*(self: Toolbar; toolItem: ToolItem = nil;
    index: int) =
  gtk_toolbar_set_drop_highlight_item(cast[ptr Toolbar00](self.impl), if toolItem.isNil: nil else: cast[ptr ToolItem00](toolItem.impl), int32(index))

proc gtk_toolbar_set_show_arrow(self: ptr Toolbar00; showArrow: gboolean) {.
    importc, libprag.}

proc setShowArrow*(self: Toolbar; showArrow: bool = true) =
  gtk_toolbar_set_show_arrow(cast[ptr Toolbar00](self.impl), gboolean(showArrow))

proc `showArrow=`*(self: Toolbar; showArrow: bool) =
  gtk_toolbar_set_show_arrow(cast[ptr Toolbar00](self.impl), gboolean(showArrow))

proc gtk_toolbar_set_style(self: ptr Toolbar00; style: ToolbarStyle) {.
    importc, libprag.}

proc setStyle*(self: Toolbar; style: ToolbarStyle) =
  gtk_toolbar_set_style(cast[ptr Toolbar00](self.impl), style)

proc `style=`*(self: Toolbar; style: ToolbarStyle) =
  gtk_toolbar_set_style(cast[ptr Toolbar00](self.impl), style)

proc gtk_toolbar_unset_icon_size(self: ptr Toolbar00) {.
    importc, libprag.}

proc unsetIconSize*(self: Toolbar) =
  gtk_toolbar_unset_icon_size(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_unset_style(self: ptr Toolbar00) {.
    importc, libprag.}

proc unsetStyle*(self: Toolbar) =
  gtk_toolbar_unset_style(cast[ptr Toolbar00](self.impl))

type
  DrawingArea* = ref object of Widget
  DrawingArea00* = object of Widget00

proc gtk_drawing_area_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(DrawingArea()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_drawing_area_new(): ptr DrawingArea00 {.
    importc, libprag.}

proc newDrawingArea*(): DrawingArea =
  let gobj = gtk_drawing_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newDrawingArea*(tdesc: typedesc): tdesc =
  assert(result is DrawingArea)
  let gobj = gtk_drawing_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initDrawingArea*[T](result: var T) {.deprecated.} =
  assert(result is DrawingArea)
  let gobj = gtk_drawing_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ToggleAction* = ref object of Action
  ToggleAction00* = object of Action00

proc gtk_toggle_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToggleAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scToggled*(self: ToggleAction;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_toggle_action_new(name: cstring; label: cstring; tooltip: cstring;
    stockId: cstring): ptr ToggleAction00 {.
    importc, libprag.}

proc newToggleAction*(name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil): ToggleAction {.deprecated.}  =
  let gobj = gtk_toggle_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToggleAction*(tdesc: typedesc; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil): tdesc {.deprecated.}  =
  assert(result is ToggleAction)
  let gobj = gtk_toggle_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToggleAction*[T](result: var T; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil) {.deprecated.} =
  assert(result is ToggleAction)
  let gobj = gtk_toggle_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_toggle_action_get_active(self: ptr ToggleAction00): gboolean {.
    importc, libprag.}

proc getActive*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_active(cast[ptr ToggleAction00](self.impl)))

proc active*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_active(cast[ptr ToggleAction00](self.impl)))

proc gtk_toggle_action_get_draw_as_radio(self: ptr ToggleAction00): gboolean {.
    importc, libprag.}

proc getDrawAsRadio*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_draw_as_radio(cast[ptr ToggleAction00](self.impl)))

proc drawAsRadio*(self: ToggleAction): bool =
  toBool(gtk_toggle_action_get_draw_as_radio(cast[ptr ToggleAction00](self.impl)))

proc gtk_toggle_action_set_active(self: ptr ToggleAction00; isActive: gboolean) {.
    importc, libprag.}

proc setActive*(self: ToggleAction; isActive: bool = true) =
  gtk_toggle_action_set_active(cast[ptr ToggleAction00](self.impl), gboolean(isActive))

proc `active=`*(self: ToggleAction; isActive: bool) =
  gtk_toggle_action_set_active(cast[ptr ToggleAction00](self.impl), gboolean(isActive))

proc gtk_toggle_action_set_draw_as_radio(self: ptr ToggleAction00; drawAsRadio: gboolean) {.
    importc, libprag.}

proc setDrawAsRadio*(self: ToggleAction; drawAsRadio: bool = true) =
  gtk_toggle_action_set_draw_as_radio(cast[ptr ToggleAction00](self.impl), gboolean(drawAsRadio))

proc `drawAsRadio=`*(self: ToggleAction; drawAsRadio: bool) =
  gtk_toggle_action_set_draw_as_radio(cast[ptr ToggleAction00](self.impl), gboolean(drawAsRadio))

proc gtk_toggle_action_toggled(self: ptr ToggleAction00) {.
    importc, libprag.}

proc toggled*(self: ToggleAction) =
  gtk_toggle_action_toggled(cast[ptr ToggleAction00](self.impl))

type
  RadioAction* = ref object of ToggleAction
  RadioAction00* = object of ToggleAction00

proc gtk_radio_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RadioAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: RadioAction;  p: proc (self: ptr RadioAction00; current: ptr RadioAction00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_radio_action_new(name: cstring; label: cstring; tooltip: cstring;
    stockId: cstring; value: int32): ptr RadioAction00 {.
    importc, libprag.}

proc newRadioAction*(name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil; value: int): RadioAction {.deprecated.}  =
  let gobj = gtk_radio_action_new(name, label, tooltip, stockId, int32(value))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRadioAction*(tdesc: typedesc; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil; value: int): tdesc {.deprecated.}  =
  assert(result is RadioAction)
  let gobj = gtk_radio_action_new(name, label, tooltip, stockId, int32(value))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRadioAction*[T](result: var T; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil; value: int) {.deprecated.} =
  assert(result is RadioAction)
  let gobj = gtk_radio_action_new(name, label, tooltip, stockId, int32(value))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_radio_action_get_current_value(self: ptr RadioAction00): int32 {.
    importc, libprag.}

proc getCurrentValue*(self: RadioAction): int =
  int(gtk_radio_action_get_current_value(cast[ptr RadioAction00](self.impl)))

proc currentValue*(self: RadioAction): int =
  int(gtk_radio_action_get_current_value(cast[ptr RadioAction00](self.impl)))

proc gtk_radio_action_get_group(self: ptr RadioAction00): ptr glib.SList {.
    importc, libprag.}

proc getGroup*(self: RadioAction): seq[RadioAction] =
  result = gslistObjects2seq(RadioAction, gtk_radio_action_get_group(cast[ptr RadioAction00](self.impl)), false)

proc group*(self: RadioAction): seq[RadioAction] =
  result = gslistObjects2seq(RadioAction, gtk_radio_action_get_group(cast[ptr RadioAction00](self.impl)), false)

proc gtk_radio_action_join_group(self: ptr RadioAction00; groupSource: ptr RadioAction00) {.
    importc, libprag.}

proc joinGroup*(self: RadioAction; groupSource: RadioAction = nil) =
  gtk_radio_action_join_group(cast[ptr RadioAction00](self.impl), if groupSource.isNil: nil else: cast[ptr RadioAction00](groupSource.impl))

proc gtk_radio_action_set_current_value(self: ptr RadioAction00; currentValue: int32) {.
    importc, libprag.}

proc setCurrentValue*(self: RadioAction; currentValue: int) =
  gtk_radio_action_set_current_value(cast[ptr RadioAction00](self.impl), int32(currentValue))

proc `currentValue=`*(self: RadioAction; currentValue: int) =
  gtk_radio_action_set_current_value(cast[ptr RadioAction00](self.impl), int32(currentValue))

proc gtk_radio_action_set_group(self: ptr RadioAction00; group: ptr glib.SList) {.
    importc, libprag.}

proc setGroup*(self: RadioAction; group: seq[RadioAction]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_action_set_group(cast[ptr RadioAction00](self.impl), tempResGL)
  g_slist_free(tempResGL)

proc `group=`*(self: RadioAction; group: seq[RadioAction]) =
  var tempResGL = seq2GSList(group)
  gtk_radio_action_set_group(cast[ptr RadioAction00](self.impl), tempResGL)
  g_slist_free(tempResGL)

type
  Scrollbar* = ref object of Range
  Scrollbar00* = object of Range00

proc gtk_scrollbar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Scrollbar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_scrollbar_new(orientation: Orientation; adjustment: ptr Adjustment00): ptr Scrollbar00 {.
    importc, libprag.}

proc newScrollbar*(orientation: Orientation; adjustment: Adjustment = nil): Scrollbar =
  let gobj = gtk_scrollbar_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScrollbar*(tdesc: typedesc; orientation: Orientation; adjustment: Adjustment = nil): tdesc =
  assert(result is Scrollbar)
  let gobj = gtk_scrollbar_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScrollbar*[T](result: var T; orientation: Orientation; adjustment: Adjustment = nil) {.deprecated.} =
  assert(result is Scrollbar)
  let gobj = gtk_scrollbar_new(orientation, if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  HScrollbar* = ref object of Scrollbar
  HScrollbar00* = object of Scrollbar00

proc gtk_hscrollbar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HScrollbar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_hscrollbar_new(adjustment: ptr Adjustment00): ptr HScrollbar00 {.
    importc, libprag.}

proc newHScrollbar*(adjustment: Adjustment = nil): HScrollbar {.deprecated.}  =
  let gobj = gtk_hscrollbar_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHScrollbar*(tdesc: typedesc; adjustment: Adjustment = nil): tdesc {.deprecated.}  =
  assert(result is HScrollbar)
  let gobj = gtk_hscrollbar_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHScrollbar*[T](result: var T; adjustment: Adjustment = nil) {.deprecated.} =
  assert(result is HScrollbar)
  let gobj = gtk_hscrollbar_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VScrollbar* = ref object of Scrollbar
  VScrollbar00* = object of Scrollbar00

proc gtk_vscrollbar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VScrollbar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_vscrollbar_new(adjustment: ptr Adjustment00): ptr VScrollbar00 {.
    importc, libprag.}

proc newVScrollbar*(adjustment: Adjustment = nil): VScrollbar {.deprecated.}  =
  let gobj = gtk_vscrollbar_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVScrollbar*(tdesc: typedesc; adjustment: Adjustment = nil): tdesc {.deprecated.}  =
  assert(result is VScrollbar)
  let gobj = gtk_vscrollbar_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVScrollbar*[T](result: var T; adjustment: Adjustment = nil) {.deprecated.} =
  assert(result is VScrollbar)
  let gobj = gtk_vscrollbar_new(if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  StackSidebar* = ref object of Bin
  StackSidebar00* = object of Bin00

proc gtk_stack_sidebar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StackSidebar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_stack_sidebar_new(): ptr StackSidebar00 {.
    importc, libprag.}

proc newStackSidebar*(): StackSidebar =
  let gobj = gtk_stack_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStackSidebar*(tdesc: typedesc): tdesc =
  assert(result is StackSidebar)
  let gobj = gtk_stack_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStackSidebar*[T](result: var T) {.deprecated.} =
  assert(result is StackSidebar)
  let gobj = gtk_stack_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Plug* = ref object of Window
  Plug00* = object of Window00

proc gtk_plug_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Plug()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEmbedded*(self: Plug;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "embedded", cast[GCallback](p), xdata, nil, cf)

proc gtk_plug_new(socketId: uint64): ptr Plug00 {.
    importc, libprag.}

proc newPlug*(socketId: uint64): Plug =
  let gobj = gtk_plug_new(socketId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPlug*(tdesc: typedesc; socketId: uint64): tdesc =
  assert(result is Plug)
  let gobj = gtk_plug_new(socketId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPlug*[T](result: var T; socketId: uint64) {.deprecated.} =
  assert(result is Plug)
  let gobj = gtk_plug_new(socketId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_plug_new_for_display(display: ptr gdk.Display00; socketId: uint64): ptr Plug00 {.
    importc, libprag.}

proc newPlugForDisplay*(display: gdk.Display; socketId: uint64): Plug =
  let gobj = gtk_plug_new_for_display(cast[ptr gdk.Display00](display.impl), socketId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPlugForDisplay*(tdesc: typedesc; display: gdk.Display; socketId: uint64): tdesc =
  assert(result is Plug)
  let gobj = gtk_plug_new_for_display(cast[ptr gdk.Display00](display.impl), socketId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPlugForDisplay*[T](result: var T; display: gdk.Display; socketId: uint64) {.deprecated.} =
  assert(result is Plug)
  let gobj = gtk_plug_new_for_display(cast[ptr gdk.Display00](display.impl), socketId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_plug_construct(self: ptr Plug00; socketId: uint64) {.
    importc, libprag.}

proc construct*(self: Plug; socketId: uint64) =
  gtk_plug_construct(cast[ptr Plug00](self.impl), socketId)

proc gtk_plug_construct_for_display(self: ptr Plug00; display: ptr gdk.Display00;
    socketId: uint64) {.
    importc, libprag.}

proc constructForDisplay*(self: Plug; display: gdk.Display; socketId: uint64) =
  gtk_plug_construct_for_display(cast[ptr Plug00](self.impl), cast[ptr gdk.Display00](display.impl), socketId)

proc gtk_plug_get_embedded(self: ptr Plug00): gboolean {.
    importc, libprag.}

proc getEmbedded*(self: Plug): bool =
  toBool(gtk_plug_get_embedded(cast[ptr Plug00](self.impl)))

proc embedded*(self: Plug): bool =
  toBool(gtk_plug_get_embedded(cast[ptr Plug00](self.impl)))

proc gtk_plug_get_id(self: ptr Plug00): uint64 {.
    importc, libprag.}

proc getId*(self: Plug): uint64 =
  gtk_plug_get_id(cast[ptr Plug00](self.impl))

proc id*(self: Plug): uint64 =
  gtk_plug_get_id(cast[ptr Plug00](self.impl))

proc gtk_plug_get_socket_window(self: ptr Plug00): ptr gdk.Window00 {.
    importc, libprag.}

proc getSocketWindow*(self: Plug): gdk.Window =
  let gobj = gtk_plug_get_socket_window(cast[ptr Plug00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc socketWindow*(self: Plug): gdk.Window =
  let gobj = gtk_plug_get_socket_window(cast[ptr Plug00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FontSelectionDialog* = ref object of Dialog
  FontSelectionDialog00* = object of Dialog00

proc gtk_font_selection_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontSelectionDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_font_selection_dialog_new(title: cstring): ptr FontSelectionDialog00 {.
    importc, libprag.}

proc newFontSelectionDialog*(title: cstring): FontSelectionDialog {.deprecated.}  =
  let gobj = gtk_font_selection_dialog_new(title)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontSelectionDialog*(tdesc: typedesc; title: cstring): tdesc {.deprecated.}  =
  assert(result is FontSelectionDialog)
  let gobj = gtk_font_selection_dialog_new(title)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontSelectionDialog*[T](result: var T; title: cstring) {.deprecated.} =
  assert(result is FontSelectionDialog)
  let gobj = gtk_font_selection_dialog_new(title)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_cancel_button(self: ptr FontSelectionDialog00): ptr Widget00 {.
    importc, libprag.}

proc getCancelButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_cancel_button(cast[ptr FontSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc cancelButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_cancel_button(cast[ptr FontSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_font_name(self: ptr FontSelectionDialog00): cstring {.
    importc, libprag.}

proc getFontName*(self: FontSelectionDialog): string =
  let resul0 = gtk_font_selection_dialog_get_font_name(cast[ptr FontSelectionDialog00](self.impl))
  result = $resul0
  cogfree(resul0)

proc fontName*(self: FontSelectionDialog): string =
  let resul0 = gtk_font_selection_dialog_get_font_name(cast[ptr FontSelectionDialog00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_selection_dialog_get_font_selection(self: ptr FontSelectionDialog00): ptr Widget00 {.
    importc, libprag.}

proc getFontSelection*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_font_selection(cast[ptr FontSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontSelection*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_font_selection(cast[ptr FontSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_ok_button(self: ptr FontSelectionDialog00): ptr Widget00 {.
    importc, libprag.}

proc getOkButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_ok_button(cast[ptr FontSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc okButton*(self: FontSelectionDialog): Widget =
  let gobj = gtk_font_selection_dialog_get_ok_button(cast[ptr FontSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_dialog_get_preview_text(self: ptr FontSelectionDialog00): cstring {.
    importc, libprag.}

proc getPreviewText*(self: FontSelectionDialog): string =
  result = $gtk_font_selection_dialog_get_preview_text(cast[ptr FontSelectionDialog00](self.impl))

proc previewText*(self: FontSelectionDialog): string =
  result = $gtk_font_selection_dialog_get_preview_text(cast[ptr FontSelectionDialog00](self.impl))

proc gtk_font_selection_dialog_set_font_name(self: ptr FontSelectionDialog00;
    fontname: cstring): gboolean {.
    importc, libprag.}

proc setFontName*(self: FontSelectionDialog; fontname: cstring): bool =
  toBool(gtk_font_selection_dialog_set_font_name(cast[ptr FontSelectionDialog00](self.impl), fontname))

proc gtk_font_selection_dialog_set_preview_text(self: ptr FontSelectionDialog00;
    text: cstring) {.
    importc, libprag.}

proc setPreviewText*(self: FontSelectionDialog;
    text: cstring) =
  gtk_font_selection_dialog_set_preview_text(cast[ptr FontSelectionDialog00](self.impl), text)

proc `previewText=`*(self: FontSelectionDialog;
    text: cstring) =
  gtk_font_selection_dialog_set_preview_text(cast[ptr FontSelectionDialog00](self.impl), text)

type
  UIManager* = ref object of gobject.Object
  UIManager00* = object of gobject.Object00

proc gtk_ui_manager_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(UIManager()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActionsChanged*(self: UIManager;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "actions-changed", cast[GCallback](p), xdata, nil, cf)

proc scAddWidget*(self: UIManager;  p: proc (self: ptr UIManager00; widget: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "add-widget", cast[GCallback](p), xdata, nil, cf)

proc scConnectProxy*(self: UIManager;  p: proc (self: ptr UIManager00; action: ptr Action00; proxy: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "connect-proxy", cast[GCallback](p), xdata, nil, cf)

proc scDisconnectProxy*(self: UIManager;  p: proc (self: ptr UIManager00; action: ptr Action00; proxy: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "disconnect-proxy", cast[GCallback](p), xdata, nil, cf)

proc scPostActivate*(self: UIManager;  p: proc (self: ptr UIManager00; action: ptr Action00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "post-activate", cast[GCallback](p), xdata, nil, cf)

proc scPreActivate*(self: UIManager;  p: proc (self: ptr UIManager00; action: ptr Action00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pre-activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_ui_manager_new(): ptr UIManager00 {.
    importc, libprag.}

proc newUIManager*(): UIManager {.deprecated.}  =
  let gobj = gtk_ui_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newUIManager*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is UIManager)
  let gobj = gtk_ui_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initUIManager*[T](result: var T) {.deprecated.} =
  assert(result is UIManager)
  let gobj = gtk_ui_manager_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_add_ui_from_file(self: ptr UIManager00; filename: cstring;
    error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addUiFromFile*(self: UIManager; filename: cstring): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_ui_manager_add_ui_from_file(cast[ptr UIManager00](self.impl), filename, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_ui_manager_add_ui_from_resource(self: ptr UIManager00; resourcePath: cstring;
    error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addUiFromResource*(self: UIManager; resourcePath: cstring): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_ui_manager_add_ui_from_resource(cast[ptr UIManager00](self.impl), resourcePath, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_ui_manager_add_ui_from_string(self: ptr UIManager00; buffer: cstring;
    length: int64; error: ptr ptr glib.Error = nil): uint32 {.
    importc, libprag.}

proc addUiFromString*(self: UIManager; buffer: cstring;
    length: int64): int =
  var gerror: ptr glib.Error
  let resul0 = gtk_ui_manager_add_ui_from_string(cast[ptr UIManager00](self.impl), buffer, length, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = int(resul0)

proc gtk_ui_manager_ensure_update(self: ptr UIManager00) {.
    importc, libprag.}

proc ensureUpdate*(self: UIManager) =
  gtk_ui_manager_ensure_update(cast[ptr UIManager00](self.impl))

proc gtk_ui_manager_get_accel_group(self: ptr UIManager00): ptr AccelGroup00 {.
    importc, libprag.}

proc getAccelGroup*(self: UIManager): AccelGroup =
  let gobj = gtk_ui_manager_get_accel_group(cast[ptr UIManager00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc accelGroup*(self: UIManager): AccelGroup =
  let gobj = gtk_ui_manager_get_accel_group(cast[ptr UIManager00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_get_action(self: ptr UIManager00; path: cstring): ptr Action00 {.
    importc, libprag.}

proc getAction*(self: UIManager; path: cstring): Action =
  let gobj = gtk_ui_manager_get_action(cast[ptr UIManager00](self.impl), path)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_get_action_groups(self: ptr UIManager00): ptr glib.List {.
    importc, libprag.}

proc getActionGroups*(self: UIManager): seq[ActionGroup] =
  result = glistObjects2seq(ActionGroup, gtk_ui_manager_get_action_groups(cast[ptr UIManager00](self.impl)), false)

proc actionGroups*(self: UIManager): seq[ActionGroup] =
  result = glistObjects2seq(ActionGroup, gtk_ui_manager_get_action_groups(cast[ptr UIManager00](self.impl)), false)

proc gtk_ui_manager_get_add_tearoffs(self: ptr UIManager00): gboolean {.
    importc, libprag.}

proc getAddTearoffs*(self: UIManager): bool =
  toBool(gtk_ui_manager_get_add_tearoffs(cast[ptr UIManager00](self.impl)))

proc addTearoffs*(self: UIManager): bool =
  toBool(gtk_ui_manager_get_add_tearoffs(cast[ptr UIManager00](self.impl)))

proc gtk_ui_manager_get_ui(self: ptr UIManager00): cstring {.
    importc, libprag.}

proc getUi*(self: UIManager): string =
  let resul0 = gtk_ui_manager_get_ui(cast[ptr UIManager00](self.impl))
  result = $resul0
  cogfree(resul0)

proc ui*(self: UIManager): string =
  let resul0 = gtk_ui_manager_get_ui(cast[ptr UIManager00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_ui_manager_get_widget(self: ptr UIManager00; path: cstring): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: UIManager; path: cstring): Widget =
  let gobj = gtk_ui_manager_get_widget(cast[ptr UIManager00](self.impl), path)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_ui_manager_insert_action_group(self: ptr UIManager00; actionGroup: ptr ActionGroup00;
    pos: int32) {.
    importc, libprag.}

proc insertActionGroup*(self: UIManager; actionGroup: ActionGroup;
    pos: int) =
  gtk_ui_manager_insert_action_group(cast[ptr UIManager00](self.impl), cast[ptr ActionGroup00](actionGroup.impl), int32(pos))

proc gtk_ui_manager_new_merge_id(self: ptr UIManager00): uint32 {.
    importc, libprag.}

proc newMergeId*(self: UIManager): int =
  int(gtk_ui_manager_new_merge_id(cast[ptr UIManager00](self.impl)))

proc gtk_ui_manager_remove_action_group(self: ptr UIManager00; actionGroup: ptr ActionGroup00) {.
    importc, libprag.}

proc removeActionGroup*(self: UIManager; actionGroup: ActionGroup) =
  gtk_ui_manager_remove_action_group(cast[ptr UIManager00](self.impl), cast[ptr ActionGroup00](actionGroup.impl))

proc gtk_ui_manager_remove_ui(self: ptr UIManager00; mergeId: uint32) {.
    importc, libprag.}

proc removeUi*(self: UIManager; mergeId: int) =
  gtk_ui_manager_remove_ui(cast[ptr UIManager00](self.impl), uint32(mergeId))

proc gtk_ui_manager_set_add_tearoffs(self: ptr UIManager00; addTearoffs: gboolean) {.
    importc, libprag.}

proc setAddTearoffs*(self: UIManager; addTearoffs: bool = true) =
  gtk_ui_manager_set_add_tearoffs(cast[ptr UIManager00](self.impl), gboolean(addTearoffs))

proc `addTearoffs=`*(self: UIManager; addTearoffs: bool) =
  gtk_ui_manager_set_add_tearoffs(cast[ptr UIManager00](self.impl), gboolean(addTearoffs))

type
  ShortcutsSection* = ref object of Box
  ShortcutsSection00* = object of Box00

proc gtk_shortcuts_section_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsSection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChangeCurrentPage*(self: ShortcutsSection;  p: proc (self: ptr ShortcutsSection00; `object`: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-current-page", cast[GCallback](p), xdata, nil, cf)

type
  ColorSelection* = ref object of Box
  ColorSelection00* = object of Box00

proc gtk_color_selection_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorSelection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scColorChanged*(self: ColorSelection;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "color-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_color_selection_new(): ptr ColorSelection00 {.
    importc, libprag.}

proc newColorSelection*(): ColorSelection =
  let gobj = gtk_color_selection_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorSelection*(tdesc: typedesc): tdesc =
  assert(result is ColorSelection)
  let gobj = gtk_color_selection_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorSelection*[T](result: var T) {.deprecated.} =
  assert(result is ColorSelection)
  let gobj = gtk_color_selection_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_selection_palette_from_string(str: cstring; colors: var ptr gdk.Color;
    nColors: var int32): gboolean {.
    importc, libprag.}

proc paletteFromString*(str: cstring; colors: var ptr gdk.Color;
    nColors: var int): bool =
  var nColors_00: int32
  result = toBool(gtk_color_selection_palette_from_string(str, colors, nColors_00))
  if nColors.addr != nil:
    nColors = int(nColors_00)

proc gtk_color_selection_palette_to_string(colors: ptr gdk.Color; nColors: int32): cstring {.
    importc, libprag.}

proc paletteToString*(colors: ptr gdk.Color; nColors: int): string =
  let resul0 = gtk_color_selection_palette_to_string(colors, int32(nColors))
  result = $resul0
  cogfree(resul0)

proc gtk_color_selection_get_current_alpha(self: ptr ColorSelection00): uint16 {.
    importc, libprag.}

proc getCurrentAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_current_alpha(cast[ptr ColorSelection00](self.impl))

proc currentAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_current_alpha(cast[ptr ColorSelection00](self.impl))

proc gtk_color_selection_get_current_color(self: ptr ColorSelection00; color: var gdk.Color) {.
    importc, libprag.}

proc getCurrentColor*(self: ColorSelection; color: var gdk.Color) =
  gtk_color_selection_get_current_color(cast[ptr ColorSelection00](self.impl), color)

proc getCurrentColor*(self: ColorSelection): gdk.Color =
  gtk_color_selection_get_current_color(cast[ptr ColorSelection00](self.impl), result)

proc gtk_color_selection_get_current_rgba(self: ptr ColorSelection00; rgba: var gdk.RGBA) {.
    importc, libprag.}

proc getCurrentRgba*(self: ColorSelection; rgba: var gdk.RGBA) =
  gtk_color_selection_get_current_rgba(cast[ptr ColorSelection00](self.impl), rgba)

proc getCurrentRgba*(self: ColorSelection): gdk.RGBA =
  gtk_color_selection_get_current_rgba(cast[ptr ColorSelection00](self.impl), result)

proc gtk_color_selection_get_has_opacity_control(self: ptr ColorSelection00): gboolean {.
    importc, libprag.}

proc getHasOpacityControl*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_opacity_control(cast[ptr ColorSelection00](self.impl)))

proc hasOpacityControl*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_opacity_control(cast[ptr ColorSelection00](self.impl)))

proc gtk_color_selection_get_has_palette(self: ptr ColorSelection00): gboolean {.
    importc, libprag.}

proc getHasPalette*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_palette(cast[ptr ColorSelection00](self.impl)))

proc hasPalette*(self: ColorSelection): bool =
  toBool(gtk_color_selection_get_has_palette(cast[ptr ColorSelection00](self.impl)))

proc gtk_color_selection_get_previous_alpha(self: ptr ColorSelection00): uint16 {.
    importc, libprag.}

proc getPreviousAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_previous_alpha(cast[ptr ColorSelection00](self.impl))

proc previousAlpha*(self: ColorSelection): uint16 =
  gtk_color_selection_get_previous_alpha(cast[ptr ColorSelection00](self.impl))

proc gtk_color_selection_get_previous_color(self: ptr ColorSelection00; color: var gdk.Color) {.
    importc, libprag.}

proc getPreviousColor*(self: ColorSelection; color: var gdk.Color) =
  gtk_color_selection_get_previous_color(cast[ptr ColorSelection00](self.impl), color)

proc getPreviousColor*(self: ColorSelection): gdk.Color =
  gtk_color_selection_get_previous_color(cast[ptr ColorSelection00](self.impl), result)

proc gtk_color_selection_get_previous_rgba(self: ptr ColorSelection00; rgba: var gdk.RGBA) {.
    importc, libprag.}

proc getPreviousRgba*(self: ColorSelection; rgba: var gdk.RGBA) =
  gtk_color_selection_get_previous_rgba(cast[ptr ColorSelection00](self.impl), rgba)

proc getPreviousRgba*(self: ColorSelection): gdk.RGBA =
  gtk_color_selection_get_previous_rgba(cast[ptr ColorSelection00](self.impl), result)

proc gtk_color_selection_is_adjusting(self: ptr ColorSelection00): gboolean {.
    importc, libprag.}

proc isAdjusting*(self: ColorSelection): bool =
  toBool(gtk_color_selection_is_adjusting(cast[ptr ColorSelection00](self.impl)))

proc gtk_color_selection_set_current_alpha(self: ptr ColorSelection00; alpha: uint16) {.
    importc, libprag.}

proc setCurrentAlpha*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_current_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc `currentAlpha=`*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_current_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc gtk_color_selection_set_current_color(self: ptr ColorSelection00; color: gdk.Color) {.
    importc, libprag.}

proc setCurrentColor*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_current_color(cast[ptr ColorSelection00](self.impl), color)

proc `currentColor=`*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_current_color(cast[ptr ColorSelection00](self.impl), color)

proc gtk_color_selection_set_current_rgba(self: ptr ColorSelection00; rgba: gdk.RGBA) {.
    importc, libprag.}

proc setCurrentRgba*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_current_rgba(cast[ptr ColorSelection00](self.impl), rgba)

proc `currentRgba=`*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_current_rgba(cast[ptr ColorSelection00](self.impl), rgba)

proc gtk_color_selection_set_has_opacity_control(self: ptr ColorSelection00;
    hasOpacity: gboolean) {.
    importc, libprag.}

proc setHasOpacityControl*(self: ColorSelection; hasOpacity: bool = true) =
  gtk_color_selection_set_has_opacity_control(cast[ptr ColorSelection00](self.impl), gboolean(hasOpacity))

proc `hasOpacityControl=`*(self: ColorSelection; hasOpacity: bool) =
  gtk_color_selection_set_has_opacity_control(cast[ptr ColorSelection00](self.impl), gboolean(hasOpacity))

proc gtk_color_selection_set_has_palette(self: ptr ColorSelection00; hasPalette: gboolean) {.
    importc, libprag.}

proc setHasPalette*(self: ColorSelection; hasPalette: bool = true) =
  gtk_color_selection_set_has_palette(cast[ptr ColorSelection00](self.impl), gboolean(hasPalette))

proc `hasPalette=`*(self: ColorSelection; hasPalette: bool) =
  gtk_color_selection_set_has_palette(cast[ptr ColorSelection00](self.impl), gboolean(hasPalette))

proc gtk_color_selection_set_previous_alpha(self: ptr ColorSelection00; alpha: uint16) {.
    importc, libprag.}

proc setPreviousAlpha*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_previous_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc `previousAlpha=`*(self: ColorSelection; alpha: uint16) =
  gtk_color_selection_set_previous_alpha(cast[ptr ColorSelection00](self.impl), alpha)

proc gtk_color_selection_set_previous_color(self: ptr ColorSelection00; color: gdk.Color) {.
    importc, libprag.}

proc setPreviousColor*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_previous_color(cast[ptr ColorSelection00](self.impl), color)

proc `previousColor=`*(self: ColorSelection; color: gdk.Color) =
  gtk_color_selection_set_previous_color(cast[ptr ColorSelection00](self.impl), color)

proc gtk_color_selection_set_previous_rgba(self: ptr ColorSelection00; rgba: gdk.RGBA) {.
    importc, libprag.}

proc setPreviousRgba*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_previous_rgba(cast[ptr ColorSelection00](self.impl), rgba)

proc `previousRgba=`*(self: ColorSelection; rgba: gdk.RGBA) =
  gtk_color_selection_set_previous_rgba(cast[ptr ColorSelection00](self.impl), rgba)

type
  ButtonBox* = ref object of Box
  ButtonBox00* = object of Box00

proc gtk_button_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ButtonBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_button_box_new(orientation: Orientation): ptr ButtonBox00 {.
    importc, libprag.}

proc newButtonBox*(orientation: Orientation): ButtonBox =
  let gobj = gtk_button_box_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newButtonBox*(tdesc: typedesc; orientation: Orientation): tdesc =
  assert(result is ButtonBox)
  let gobj = gtk_button_box_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initButtonBox*[T](result: var T; orientation: Orientation) {.deprecated.} =
  assert(result is ButtonBox)
  let gobj = gtk_button_box_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_button_box_get_child_non_homogeneous(self: ptr ButtonBox00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc getChildNonHomogeneous*(self: ButtonBox; child: Widget): bool =
  toBool(gtk_button_box_get_child_non_homogeneous(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_button_box_get_child_secondary(self: ptr ButtonBox00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc getChildSecondary*(self: ButtonBox; child: Widget): bool =
  toBool(gtk_button_box_get_child_secondary(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_button_box_set_child_non_homogeneous(self: ptr ButtonBox00; child: ptr Widget00;
    nonHomogeneous: gboolean) {.
    importc, libprag.}

proc setChildNonHomogeneous*(self: ButtonBox; child: Widget;
    nonHomogeneous: bool) =
  gtk_button_box_set_child_non_homogeneous(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl), gboolean(nonHomogeneous))

proc gtk_button_box_set_child_secondary(self: ptr ButtonBox00; child: ptr Widget00;
    isSecondary: gboolean) {.
    importc, libprag.}

proc setChildSecondary*(self: ButtonBox; child: Widget; isSecondary: bool) =
  gtk_button_box_set_child_secondary(cast[ptr ButtonBox00](self.impl), cast[ptr Widget00](child.impl), gboolean(isSecondary))

type
  ScrolledWindow* = ref object of Bin
  ScrolledWindow00* = object of Bin00

proc gtk_scrolled_window_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScrolledWindow()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEdgeOvershot*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; pos: PositionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "edge-overshot", cast[GCallback](p), xdata, nil, cf)

proc scEdgeReached*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; pos: PositionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "edge-reached", cast[GCallback](p), xdata, nil, cf)

proc scMoveFocusOut*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; directionType: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-focus-out", cast[GCallback](p), xdata, nil, cf)

proc scScrollChild*(self: ScrolledWindow;  p: proc (self: ptr ScrolledWindow00; scroll: ScrollType; horizontal: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-child", cast[GCallback](p), xdata, nil, cf)

proc gtk_scrolled_window_new(hadjustment: ptr Adjustment00; vadjustment: ptr Adjustment00): ptr ScrolledWindow00 {.
    importc, libprag.}

proc newScrolledWindow*(hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): ScrolledWindow =
  let gobj = gtk_scrolled_window_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newScrolledWindow*(tdesc: typedesc; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): tdesc =
  assert(result is ScrolledWindow)
  let gobj = gtk_scrolled_window_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initScrolledWindow*[T](result: var T; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil) {.deprecated.} =
  assert(result is ScrolledWindow)
  let gobj = gtk_scrolled_window_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_add_with_viewport(self: ptr ScrolledWindow00; child: ptr Widget00) {.
    importc, libprag.}

proc addWithViewport*(self: ScrolledWindow; child: Widget) =
  gtk_scrolled_window_add_with_viewport(cast[ptr ScrolledWindow00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_scrolled_window_get_capture_button_press(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getCaptureButtonPress*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_capture_button_press(cast[ptr ScrolledWindow00](self.impl)))

proc captureButtonPress*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_capture_button_press(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_hadjustment(self: ptr ScrolledWindow00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_hadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_hadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_hscrollbar(self: ptr ScrolledWindow00): ptr Widget00 {.
    importc, libprag.}

proc getHscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_hscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_hscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_kinetic_scrolling(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getKineticScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc kineticScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_max_content_height(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMaxContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc maxContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_max_content_width(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMaxContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc maxContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_max_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_min_content_height(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMinContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc minContentHeight*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_min_content_width(self: ptr ScrolledWindow00): int32 {.
    importc, libprag.}

proc getMinContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc minContentWidth*(self: ScrolledWindow): int =
  int(gtk_scrolled_window_get_min_content_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_overlay_scrolling(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getOverlayScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc overlayScrolling*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_propagate_natural_height(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getPropagateNaturalHeight*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl)))

proc propagateNaturalHeight*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_propagate_natural_width(self: ptr ScrolledWindow00): gboolean {.
    importc, libprag.}

proc getPropagateNaturalWidth*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl)))

proc propagateNaturalWidth*(self: ScrolledWindow): bool =
  toBool(gtk_scrolled_window_get_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl)))

proc gtk_scrolled_window_get_shadow_type(self: ptr ScrolledWindow00): ShadowType {.
    importc, libprag.}

proc getShadowType*(self: ScrolledWindow): ShadowType =
  gtk_scrolled_window_get_shadow_type(cast[ptr ScrolledWindow00](self.impl))

proc shadowType*(self: ScrolledWindow): ShadowType =
  gtk_scrolled_window_get_shadow_type(cast[ptr ScrolledWindow00](self.impl))

proc gtk_scrolled_window_get_vadjustment(self: ptr ScrolledWindow00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_vadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: ScrolledWindow): Adjustment =
  let gobj = gtk_scrolled_window_get_vadjustment(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_get_vscrollbar(self: ptr ScrolledWindow00): ptr Widget00 {.
    importc, libprag.}

proc getVscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_vscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vscrollbar*(self: ScrolledWindow): Widget =
  let gobj = gtk_scrolled_window_get_vscrollbar(cast[ptr ScrolledWindow00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrolled_window_set_capture_button_press(self: ptr ScrolledWindow00;
    captureButtonPress: gboolean) {.
    importc, libprag.}

proc setCaptureButtonPress*(self: ScrolledWindow; captureButtonPress: bool = true) =
  gtk_scrolled_window_set_capture_button_press(cast[ptr ScrolledWindow00](self.impl), gboolean(captureButtonPress))

proc `captureButtonPress=`*(self: ScrolledWindow; captureButtonPress: bool) =
  gtk_scrolled_window_set_capture_button_press(cast[ptr ScrolledWindow00](self.impl), gboolean(captureButtonPress))

proc gtk_scrolled_window_set_hadjustment(self: ptr ScrolledWindow00; hadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: ScrolledWindow; hadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_hadjustment(cast[ptr ScrolledWindow00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc `hadjustment=`*(self: ScrolledWindow; hadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_hadjustment(cast[ptr ScrolledWindow00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc gtk_scrolled_window_set_kinetic_scrolling(self: ptr ScrolledWindow00;
    kineticScrolling: gboolean) {.
    importc, libprag.}

proc setKineticScrolling*(self: ScrolledWindow; kineticScrolling: bool = true) =
  gtk_scrolled_window_set_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(kineticScrolling))

proc `kineticScrolling=`*(self: ScrolledWindow; kineticScrolling: bool) =
  gtk_scrolled_window_set_kinetic_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(kineticScrolling))

proc gtk_scrolled_window_set_max_content_height(self: ptr ScrolledWindow00;
    height: int32) {.
    importc, libprag.}

proc setMaxContentHeight*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_max_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc `maxContentHeight=`*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_max_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc gtk_scrolled_window_set_max_content_width(self: ptr ScrolledWindow00;
    width: int32) {.
    importc, libprag.}

proc setMaxContentWidth*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_max_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc `maxContentWidth=`*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_max_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc gtk_scrolled_window_set_min_content_height(self: ptr ScrolledWindow00;
    height: int32) {.
    importc, libprag.}

proc setMinContentHeight*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_min_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc `minContentHeight=`*(self: ScrolledWindow; height: int) =
  gtk_scrolled_window_set_min_content_height(cast[ptr ScrolledWindow00](self.impl), int32(height))

proc gtk_scrolled_window_set_min_content_width(self: ptr ScrolledWindow00;
    width: int32) {.
    importc, libprag.}

proc setMinContentWidth*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_min_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc `minContentWidth=`*(self: ScrolledWindow; width: int) =
  gtk_scrolled_window_set_min_content_width(cast[ptr ScrolledWindow00](self.impl), int32(width))

proc gtk_scrolled_window_set_overlay_scrolling(self: ptr ScrolledWindow00;
    overlayScrolling: gboolean) {.
    importc, libprag.}

proc setOverlayScrolling*(self: ScrolledWindow; overlayScrolling: bool = true) =
  gtk_scrolled_window_set_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(overlayScrolling))

proc `overlayScrolling=`*(self: ScrolledWindow; overlayScrolling: bool) =
  gtk_scrolled_window_set_overlay_scrolling(cast[ptr ScrolledWindow00](self.impl), gboolean(overlayScrolling))

proc gtk_scrolled_window_set_propagate_natural_height(self: ptr ScrolledWindow00;
    propagate: gboolean) {.
    importc, libprag.}

proc setPropagateNaturalHeight*(self: ScrolledWindow;
    propagate: bool = true) =
  gtk_scrolled_window_set_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc `propagateNaturalHeight=`*(self: ScrolledWindow;
    propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_height(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc gtk_scrolled_window_set_propagate_natural_width(self: ptr ScrolledWindow00;
    propagate: gboolean) {.
    importc, libprag.}

proc setPropagateNaturalWidth*(self: ScrolledWindow;
    propagate: bool = true) =
  gtk_scrolled_window_set_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc `propagateNaturalWidth=`*(self: ScrolledWindow;
    propagate: bool) =
  gtk_scrolled_window_set_propagate_natural_width(cast[ptr ScrolledWindow00](self.impl), gboolean(propagate))

proc gtk_scrolled_window_set_shadow_type(self: ptr ScrolledWindow00; `type`: ShadowType) {.
    importc, libprag.}

proc setShadowType*(self: ScrolledWindow; `type`: ShadowType) =
  gtk_scrolled_window_set_shadow_type(cast[ptr ScrolledWindow00](self.impl), `type`)

proc `shadowType=`*(self: ScrolledWindow; `type`: ShadowType) =
  gtk_scrolled_window_set_shadow_type(cast[ptr ScrolledWindow00](self.impl), `type`)

proc gtk_scrolled_window_set_vadjustment(self: ptr ScrolledWindow00; vadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: ScrolledWindow; vadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_vadjustment(cast[ptr ScrolledWindow00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

proc `vadjustment=`*(self: ScrolledWindow; vadjustment: Adjustment = nil) =
  gtk_scrolled_window_set_vadjustment(cast[ptr ScrolledWindow00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

proc gtk_scrolled_window_unset_placement(self: ptr ScrolledWindow00) {.
    importc, libprag.}

proc unsetPlacement*(self: ScrolledWindow) =
  gtk_scrolled_window_unset_placement(cast[ptr ScrolledWindow00](self.impl))

type
  PlacesOpenFlag* {.size: sizeof(cint), pure.} = enum
    normal = 0
    newTab = 1
    newWindow = 2

  PlacesOpenFlags* {.size: sizeof(cint).} = set[PlacesOpenFlag]

type
  PlacesSidebar* = ref object of ScrolledWindow
  PlacesSidebar00* = object of ScrolledWindow00

proc gtk_places_sidebar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PlacesSidebar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDragActionAsk*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; actions: int32; xdata: pointer): int32 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-action-ask", cast[GCallback](p), xdata, nil, cf)

proc scDragActionRequested*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; context: ptr gdk.DragContext00; destFile: ptr gio.GFile00; sourceFileList: ptr glib.List; xdata: pointer): int32 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-action-requested", cast[GCallback](p), xdata, nil, cf)

proc scDragPerformDrop*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; destFile: ptr gio.GFile00; sourceFileList: ptr glib.List; action: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-perform-drop", cast[GCallback](p), xdata, nil, cf)

proc scMount*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; mountOperation: ptr gio.MountOperation00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "mount", cast[GCallback](p), xdata, nil, cf)

proc scOpenLocation*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; location: ptr gio.GFile00; openFlags: PlacesOpenFlags; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "open-location", cast[GCallback](p), xdata, nil, cf)

proc scPopulatePopup*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; container: ptr Widget00; selectedItem: ptr gio.GFile00; selectedVolume: ptr gio.Volume00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cf)

proc scShowConnectToServer*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-connect-to-server", cast[GCallback](p), xdata, nil, cf)

proc scShowEnterLocation*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-enter-location", cast[GCallback](p), xdata, nil, cf)

proc scShowErrorMessage*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; primary: cstring; secondary: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-error-message", cast[GCallback](p), xdata, nil, cf)

proc scShowOtherLocations*(self: PlacesSidebar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-other-locations", cast[GCallback](p), xdata, nil, cf)

proc scShowOtherLocationsWithFlags*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; openFlags: PlacesOpenFlags; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-other-locations-with-flags", cast[GCallback](p), xdata, nil, cf)

proc scShowStarredLocation*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; openFlags: PlacesOpenFlags; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-starred-location", cast[GCallback](p), xdata, nil, cf)

proc scUnmount*(self: PlacesSidebar;  p: proc (self: ptr PlacesSidebar00; mountOperation: ptr gio.MountOperation00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unmount", cast[GCallback](p), xdata, nil, cf)

proc gtk_places_sidebar_new(): ptr PlacesSidebar00 {.
    importc, libprag.}

proc newPlacesSidebar*(): PlacesSidebar =
  let gobj = gtk_places_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPlacesSidebar*(tdesc: typedesc): tdesc =
  assert(result is PlacesSidebar)
  let gobj = gtk_places_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPlacesSidebar*[T](result: var T) {.deprecated.} =
  assert(result is PlacesSidebar)
  let gobj = gtk_places_sidebar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_places_sidebar_add_shortcut(self: ptr PlacesSidebar00; location: ptr gio.GFile00) {.
    importc, libprag.}

proc addShortcut*(self: PlacesSidebar; location: gio.GFile) =
  gtk_places_sidebar_add_shortcut(cast[ptr PlacesSidebar00](self.impl), cast[ptr gio.GFile00](location.impl))

proc gtk_places_sidebar_get_local_only(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getLocalOnly*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_local_only(cast[ptr PlacesSidebar00](self.impl)))

proc localOnly*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_local_only(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_location(self: ptr PlacesSidebar00): ptr gio.GFile00 {.
    importc, libprag.}

proc getLocation*(self: PlacesSidebar): gio.GFile =
  let gobj = gtk_places_sidebar_get_location(cast[ptr PlacesSidebar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc location*(self: PlacesSidebar): gio.GFile =
  let gobj = gtk_places_sidebar_get_location(cast[ptr PlacesSidebar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_places_sidebar_get_nth_bookmark(self: ptr PlacesSidebar00; n: int32): ptr gio.GFile00 {.
    importc, libprag.}

proc getNthBookmark*(self: PlacesSidebar; n: int): gio.GFile =
  let gobj = gtk_places_sidebar_get_nth_bookmark(cast[ptr PlacesSidebar00](self.impl), int32(n))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_places_sidebar_get_open_flags(self: ptr PlacesSidebar00): PlacesOpenFlags {.
    importc, libprag.}

proc getOpenFlags*(self: PlacesSidebar): PlacesOpenFlags =
  gtk_places_sidebar_get_open_flags(cast[ptr PlacesSidebar00](self.impl))

proc openFlags*(self: PlacesSidebar): PlacesOpenFlags =
  gtk_places_sidebar_get_open_flags(cast[ptr PlacesSidebar00](self.impl))

proc gtk_places_sidebar_get_show_connect_to_server(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getShowConnectToServer*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl)))

proc showConnectToServer*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_desktop(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getShowDesktop*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_desktop(cast[ptr PlacesSidebar00](self.impl)))

proc showDesktop*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_desktop(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_enter_location(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getShowEnterLocation*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_enter_location(cast[ptr PlacesSidebar00](self.impl)))

proc showEnterLocation*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_enter_location(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_other_locations(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getShowOtherLocations*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_other_locations(cast[ptr PlacesSidebar00](self.impl)))

proc showOtherLocations*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_other_locations(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_recent(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getShowRecent*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_recent(cast[ptr PlacesSidebar00](self.impl)))

proc showRecent*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_recent(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_starred_location(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getShowStarredLocation*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_starred_location(cast[ptr PlacesSidebar00](self.impl)))

proc showStarredLocation*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_starred_location(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_get_show_trash(self: ptr PlacesSidebar00): gboolean {.
    importc, libprag.}

proc getShowTrash*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_trash(cast[ptr PlacesSidebar00](self.impl)))

proc showTrash*(self: PlacesSidebar): bool =
  toBool(gtk_places_sidebar_get_show_trash(cast[ptr PlacesSidebar00](self.impl)))

proc gtk_places_sidebar_list_shortcuts(self: ptr PlacesSidebar00): ptr glib.SList {.
    importc, libprag.}

proc listShortcuts*(self: PlacesSidebar): seq[gio.GFile] =
  let resul0 = gtk_places_sidebar_list_shortcuts(cast[ptr PlacesSidebar00](self.impl))
  result = gslistObjects2seq(gio.GFile, resul0, true)
  g_slist_free(resul0)

proc gtk_places_sidebar_remove_shortcut(self: ptr PlacesSidebar00; location: ptr gio.GFile00) {.
    importc, libprag.}

proc removeShortcut*(self: PlacesSidebar; location: gio.GFile) =
  gtk_places_sidebar_remove_shortcut(cast[ptr PlacesSidebar00](self.impl), cast[ptr gio.GFile00](location.impl))

proc gtk_places_sidebar_set_drop_targets_visible(self: ptr PlacesSidebar00;
    visible: gboolean; context: ptr gdk.DragContext00) {.
    importc, libprag.}

proc setDropTargetsVisible*(self: PlacesSidebar; visible: bool;
    context: gdk.DragContext) =
  gtk_places_sidebar_set_drop_targets_visible(cast[ptr PlacesSidebar00](self.impl), gboolean(visible), cast[ptr gdk.DragContext00](context.impl))

proc gtk_places_sidebar_set_local_only(self: ptr PlacesSidebar00; localOnly: gboolean) {.
    importc, libprag.}

proc setLocalOnly*(self: PlacesSidebar; localOnly: bool = true) =
  gtk_places_sidebar_set_local_only(cast[ptr PlacesSidebar00](self.impl), gboolean(localOnly))

proc `localOnly=`*(self: PlacesSidebar; localOnly: bool) =
  gtk_places_sidebar_set_local_only(cast[ptr PlacesSidebar00](self.impl), gboolean(localOnly))

proc gtk_places_sidebar_set_location(self: ptr PlacesSidebar00; location: ptr gio.GFile00) {.
    importc, libprag.}

proc setLocation*(self: PlacesSidebar; location: gio.GFile = nil) =
  gtk_places_sidebar_set_location(cast[ptr PlacesSidebar00](self.impl), if location.isNil: nil else: cast[ptr gio.GFile00](location.impl))

proc `location=`*(self: PlacesSidebar; location: gio.GFile = nil) =
  gtk_places_sidebar_set_location(cast[ptr PlacesSidebar00](self.impl), if location.isNil: nil else: cast[ptr gio.GFile00](location.impl))

proc gtk_places_sidebar_set_open_flags(self: ptr PlacesSidebar00; flags: PlacesOpenFlags) {.
    importc, libprag.}

proc setOpenFlags*(self: PlacesSidebar; flags: PlacesOpenFlags) =
  gtk_places_sidebar_set_open_flags(cast[ptr PlacesSidebar00](self.impl), flags)

proc `openFlags=`*(self: PlacesSidebar; flags: PlacesOpenFlags) =
  gtk_places_sidebar_set_open_flags(cast[ptr PlacesSidebar00](self.impl), flags)

proc gtk_places_sidebar_set_show_connect_to_server(self: ptr PlacesSidebar00;
    showConnectToServer: gboolean) {.
    importc, libprag.}

proc setShowConnectToServer*(self: PlacesSidebar; showConnectToServer: bool = true) =
  gtk_places_sidebar_set_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl), gboolean(showConnectToServer))

proc `showConnectToServer=`*(self: PlacesSidebar; showConnectToServer: bool) =
  gtk_places_sidebar_set_show_connect_to_server(cast[ptr PlacesSidebar00](self.impl), gboolean(showConnectToServer))

proc gtk_places_sidebar_set_show_desktop(self: ptr PlacesSidebar00; showDesktop: gboolean) {.
    importc, libprag.}

proc setShowDesktop*(self: PlacesSidebar; showDesktop: bool = true) =
  gtk_places_sidebar_set_show_desktop(cast[ptr PlacesSidebar00](self.impl), gboolean(showDesktop))

proc `showDesktop=`*(self: PlacesSidebar; showDesktop: bool) =
  gtk_places_sidebar_set_show_desktop(cast[ptr PlacesSidebar00](self.impl), gboolean(showDesktop))

proc gtk_places_sidebar_set_show_enter_location(self: ptr PlacesSidebar00;
    showEnterLocation: gboolean) {.
    importc, libprag.}

proc setShowEnterLocation*(self: PlacesSidebar; showEnterLocation: bool = true) =
  gtk_places_sidebar_set_show_enter_location(cast[ptr PlacesSidebar00](self.impl), gboolean(showEnterLocation))

proc `showEnterLocation=`*(self: PlacesSidebar; showEnterLocation: bool) =
  gtk_places_sidebar_set_show_enter_location(cast[ptr PlacesSidebar00](self.impl), gboolean(showEnterLocation))

proc gtk_places_sidebar_set_show_other_locations(self: ptr PlacesSidebar00;
    showOtherLocations: gboolean) {.
    importc, libprag.}

proc setShowOtherLocations*(self: PlacesSidebar; showOtherLocations: bool = true) =
  gtk_places_sidebar_set_show_other_locations(cast[ptr PlacesSidebar00](self.impl), gboolean(showOtherLocations))

proc `showOtherLocations=`*(self: PlacesSidebar; showOtherLocations: bool) =
  gtk_places_sidebar_set_show_other_locations(cast[ptr PlacesSidebar00](self.impl), gboolean(showOtherLocations))

proc gtk_places_sidebar_set_show_recent(self: ptr PlacesSidebar00; showRecent: gboolean) {.
    importc, libprag.}

proc setShowRecent*(self: PlacesSidebar; showRecent: bool = true) =
  gtk_places_sidebar_set_show_recent(cast[ptr PlacesSidebar00](self.impl), gboolean(showRecent))

proc `showRecent=`*(self: PlacesSidebar; showRecent: bool) =
  gtk_places_sidebar_set_show_recent(cast[ptr PlacesSidebar00](self.impl), gboolean(showRecent))

proc gtk_places_sidebar_set_show_starred_location(self: ptr PlacesSidebar00;
    showStarredLocation: gboolean) {.
    importc, libprag.}

proc setShowStarredLocation*(self: PlacesSidebar; showStarredLocation: bool = true) =
  gtk_places_sidebar_set_show_starred_location(cast[ptr PlacesSidebar00](self.impl), gboolean(showStarredLocation))

proc `showStarredLocation=`*(self: PlacesSidebar; showStarredLocation: bool) =
  gtk_places_sidebar_set_show_starred_location(cast[ptr PlacesSidebar00](self.impl), gboolean(showStarredLocation))

proc gtk_places_sidebar_set_show_trash(self: ptr PlacesSidebar00; showTrash: gboolean) {.
    importc, libprag.}

proc setShowTrash*(self: PlacesSidebar; showTrash: bool = true) =
  gtk_places_sidebar_set_show_trash(cast[ptr PlacesSidebar00](self.impl), gboolean(showTrash))

proc `showTrash=`*(self: PlacesSidebar; showTrash: bool) =
  gtk_places_sidebar_set_show_trash(cast[ptr PlacesSidebar00](self.impl), gboolean(showTrash))

type
  Table* = ref object of Container
  Table00* = object of Container00

proc gtk_table_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Table()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_table_new(rows: uint32; columns: uint32; homogeneous: gboolean): ptr Table00 {.
    importc, libprag.}

proc newTable*(rows: int; columns: int; homogeneous: bool): Table {.deprecated.}  =
  let gobj = gtk_table_new(uint32(rows), uint32(columns), gboolean(homogeneous))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTable*(tdesc: typedesc; rows: int; columns: int; homogeneous: bool): tdesc {.deprecated.}  =
  assert(result is Table)
  let gobj = gtk_table_new(uint32(rows), uint32(columns), gboolean(homogeneous))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTable*[T](result: var T; rows: int; columns: int; homogeneous: bool) {.deprecated.} =
  assert(result is Table)
  let gobj = gtk_table_new(uint32(rows), uint32(columns), gboolean(homogeneous))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TextExtendSelection* {.size: sizeof(cint), pure.} = enum
    word = 0
    line = 1

type
  ScrollStep* {.size: sizeof(cint), pure.} = enum
    steps = 0
    pages = 1
    ends = 2
    horizontalSteps = 3
    horizontalPages = 4
    horizontalEnds = 5

type
  TextView* = ref object of Container
  TextView00* = object of Container00

proc gtk_text_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scBackspace*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "backspace", cast[GCallback](p), xdata, nil, cf)

proc scCopyClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "copy-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scCutClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cut-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scDeleteFromCursor*(self: TextView;  p: proc (self: ptr TextView00; `type`: DeleteType; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-from-cursor", cast[GCallback](p), xdata, nil, cf)

proc scExtendSelection*(self: TextView;  p: proc (self: ptr TextView00; granularity: TextExtendSelection; location: TextIter; start: TextIter;
    `end`: TextIter; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "extend-selection", cast[GCallback](p), xdata, nil, cf)

proc scInsertAtCursor*(self: TextView;  p: proc (self: ptr TextView00; string: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-at-cursor", cast[GCallback](p), xdata, nil, cf)

proc scInsertEmoji*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-emoji", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: TextView;  p: proc (self: ptr TextView00; step: MovementStep; count: int32; extendSelection: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scMoveViewport*(self: TextView;  p: proc (self: ptr TextView00; step: ScrollStep; count: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-viewport", cast[GCallback](p), xdata, nil, cf)

proc scPasteClipboard*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paste-clipboard", cast[GCallback](p), xdata, nil, cf)

proc scPopulatePopup*(self: TextView;  p: proc (self: ptr TextView00; popup: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "populate-popup", cast[GCallback](p), xdata, nil, cf)

proc scPreeditChanged*(self: TextView;  p: proc (self: ptr TextView00; preedit: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: TextView;  p: proc (self: ptr TextView00; select: gboolean; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSetAnchor*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "set-anchor", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorVisible*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-visible", cast[GCallback](p), xdata, nil, cf)

proc scToggleOverwrite*(self: TextView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-overwrite", cast[GCallback](p), xdata, nil, cf)

proc gtk_text_view_new(): ptr TextView00 {.
    importc, libprag.}

proc newTextView*(): TextView =
  let gobj = gtk_text_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextView*(tdesc: typedesc): tdesc =
  assert(result is TextView)
  let gobj = gtk_text_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextView*[T](result: var T) {.deprecated.} =
  assert(result is TextView)
  let gobj = gtk_text_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_new_with_buffer(buffer: ptr TextBuffer00): ptr TextView00 {.
    importc, libprag.}

proc newTextViewWithBuffer*(buffer: TextBuffer): TextView =
  let gobj = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTextViewWithBuffer*(tdesc: typedesc; buffer: TextBuffer): tdesc =
  assert(result is TextView)
  let gobj = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTextViewWithBuffer*[T](result: var T; buffer: TextBuffer) {.deprecated.} =
  assert(result is TextView)
  let gobj = gtk_text_view_new_with_buffer(cast[ptr TextBuffer00](buffer.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_add_child_at_anchor(self: ptr TextView00; child: ptr Widget00;
    anchor: ptr TextChildAnchor00) {.
    importc, libprag.}

proc addChildAtAnchor*(self: TextView; child: Widget; anchor: TextChildAnchor) =
  gtk_text_view_add_child_at_anchor(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), cast[ptr TextChildAnchor00](anchor.impl))

proc gtk_text_view_backward_display_line(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc backwardDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_backward_display_line(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_backward_display_line_start(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc backwardDisplayLineStart*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_backward_display_line_start(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_forward_display_line(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc forwardDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_forward_display_line(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_forward_display_line_end(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc forwardDisplayLineEnd*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_forward_display_line_end(cast[ptr TextView00](self.impl), iter))

proc gtk_text_view_get_accepts_tab(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getAcceptsTab*(self: TextView): bool =
  toBool(gtk_text_view_get_accepts_tab(cast[ptr TextView00](self.impl)))

proc acceptsTab*(self: TextView): bool =
  toBool(gtk_text_view_get_accepts_tab(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_bottom_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getBottomMargin*(self: TextView): int =
  int(gtk_text_view_get_bottom_margin(cast[ptr TextView00](self.impl)))

proc bottomMargin*(self: TextView): int =
  int(gtk_text_view_get_bottom_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_buffer(self: ptr TextView00): ptr TextBuffer00 {.
    importc, libprag.}

proc getBuffer*(self: TextView): TextBuffer =
  let gobj = gtk_text_view_get_buffer(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc buffer*(self: TextView): TextBuffer =
  let gobj = gtk_text_view_get_buffer(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_cursor_locations(self: ptr TextView00; iter: TextIter;
    strong: var gdk.Rectangle; weak: var gdk.Rectangle) {.
    importc, libprag.}

proc getCursorLocations*(self: TextView; iter: TextIter = cast[var TextIter](nil);
    strong: var gdk.Rectangle = cast[var gdk.Rectangle](nil); weak: var gdk.Rectangle = cast[var gdk.Rectangle](nil)) =
  gtk_text_view_get_cursor_locations(cast[ptr TextView00](self.impl), iter, strong, weak)

proc gtk_text_view_get_cursor_visible(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getCursorVisible*(self: TextView): bool =
  toBool(gtk_text_view_get_cursor_visible(cast[ptr TextView00](self.impl)))

proc cursorVisible*(self: TextView): bool =
  toBool(gtk_text_view_get_cursor_visible(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_default_attributes(self: ptr TextView00): ptr TextAttributes00 {.
    importc, libprag.}

proc getDefaultAttributes*(self: TextView): TextAttributes =
  fnew(result, gBoxedFreeGtkTextAttributes)
  result.impl = gtk_text_view_get_default_attributes(cast[ptr TextView00](self.impl))

proc defaultAttributes*(self: TextView): TextAttributes =
  fnew(result, gBoxedFreeGtkTextAttributes)
  result.impl = gtk_text_view_get_default_attributes(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_editable(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getEditable*(self: TextView): bool =
  toBool(gtk_text_view_get_editable(cast[ptr TextView00](self.impl)))

proc editable*(self: TextView): bool =
  toBool(gtk_text_view_get_editable(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_hadjustment(self: ptr TextView00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_hadjustment(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_hadjustment(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_indent(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getIndent*(self: TextView): int =
  int(gtk_text_view_get_indent(cast[ptr TextView00](self.impl)))

proc indent*(self: TextView): int =
  int(gtk_text_view_get_indent(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_input_hints(self: ptr TextView00): InputHints {.
    importc, libprag.}

proc getInputHints*(self: TextView): InputHints =
  gtk_text_view_get_input_hints(cast[ptr TextView00](self.impl))

proc inputHints*(self: TextView): InputHints =
  gtk_text_view_get_input_hints(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_input_purpose(self: ptr TextView00): InputPurpose {.
    importc, libprag.}

proc getInputPurpose*(self: TextView): InputPurpose =
  gtk_text_view_get_input_purpose(cast[ptr TextView00](self.impl))

proc inputPurpose*(self: TextView): InputPurpose =
  gtk_text_view_get_input_purpose(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_iter_at_location(self: ptr TextView00; iter: var TextIter;
    x: int32; y: int32): gboolean {.
    importc, libprag.}

proc getIterAtLocation*(self: TextView; iter: var TextIter;
    x: int; y: int): bool =
  toBool(gtk_text_view_get_iter_at_location(cast[ptr TextView00](self.impl), iter, int32(x), int32(y)))

proc gtk_text_view_get_iter_at_position(self: ptr TextView00; iter: var TextIter;
    trailing: var int32; x: int32; y: int32): gboolean {.
    importc, libprag.}

proc getIterAtPosition*(self: TextView; iter: var TextIter;
    trailing: var int = cast[var int](nil); x: int; y: int): bool =
  var trailing_00: int32
  result = toBool(gtk_text_view_get_iter_at_position(cast[ptr TextView00](self.impl), iter, trailing_00, int32(x), int32(y)))
  if trailing.addr != nil:
    trailing = int(trailing_00)

proc gtk_text_view_get_iter_location(self: ptr TextView00; iter: TextIter;
    location: var gdk.Rectangle) {.
    importc, libprag.}

proc getIterLocation*(self: TextView; iter: TextIter; location: var gdk.Rectangle) =
  gtk_text_view_get_iter_location(cast[ptr TextView00](self.impl), iter, location)

proc gtk_text_view_get_justification(self: ptr TextView00): Justification {.
    importc, libprag.}

proc getJustification*(self: TextView): Justification =
  gtk_text_view_get_justification(cast[ptr TextView00](self.impl))

proc justification*(self: TextView): Justification =
  gtk_text_view_get_justification(cast[ptr TextView00](self.impl))

proc gtk_text_view_get_left_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getLeftMargin*(self: TextView): int =
  int(gtk_text_view_get_left_margin(cast[ptr TextView00](self.impl)))

proc leftMargin*(self: TextView): int =
  int(gtk_text_view_get_left_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_line_at_y(self: ptr TextView00; targetIter: var TextIter;
    y: int32; lineTop: var int32) {.
    importc, libprag.}

proc getLineAtY*(self: TextView; targetIter: var TextIter;
    y: int; lineTop: var int) =
  var lineTop_00: int32
  gtk_text_view_get_line_at_y(cast[ptr TextView00](self.impl), targetIter, int32(y), lineTop_00)
  if lineTop.addr != nil:
    lineTop = int(lineTop_00)

proc gtk_text_view_get_line_yrange(self: ptr TextView00; iter: TextIter;
    y: var int32; height: var int32) {.
    importc, libprag.}

proc getLineYrange*(self: TextView; iter: TextIter; y: var int;
    height: var int) =
  var y_00: int32
  var height_00: int32
  gtk_text_view_get_line_yrange(cast[ptr TextView00](self.impl), iter, y_00, height_00)
  if y.addr != nil:
    y = int(y_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_text_view_get_monospace(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getMonospace*(self: TextView): bool =
  toBool(gtk_text_view_get_monospace(cast[ptr TextView00](self.impl)))

proc monospace*(self: TextView): bool =
  toBool(gtk_text_view_get_monospace(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_overwrite(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc getOverwrite*(self: TextView): bool =
  toBool(gtk_text_view_get_overwrite(cast[ptr TextView00](self.impl)))

proc overwrite*(self: TextView): bool =
  toBool(gtk_text_view_get_overwrite(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_above_lines(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getPixelsAboveLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_above_lines(cast[ptr TextView00](self.impl)))

proc pixelsAboveLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_above_lines(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_below_lines(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getPixelsBelowLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_below_lines(cast[ptr TextView00](self.impl)))

proc pixelsBelowLines*(self: TextView): int =
  int(gtk_text_view_get_pixels_below_lines(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_pixels_inside_wrap(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getPixelsInsideWrap*(self: TextView): int =
  int(gtk_text_view_get_pixels_inside_wrap(cast[ptr TextView00](self.impl)))

proc pixelsInsideWrap*(self: TextView): int =
  int(gtk_text_view_get_pixels_inside_wrap(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_right_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getRightMargin*(self: TextView): int =
  int(gtk_text_view_get_right_margin(cast[ptr TextView00](self.impl)))

proc rightMargin*(self: TextView): int =
  int(gtk_text_view_get_right_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_tabs(self: ptr TextView00): ptr pango.TabArray00 {.
    importc, libprag.}

proc getTabs*(self: TextView): pango.TabArray =
  let impl0 = gtk_text_view_get_tabs(cast[ptr TextView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = impl0

proc tabs*(self: TextView): pango.TabArray =
  let impl0 = gtk_text_view_get_tabs(cast[ptr TextView00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoTabArray)
  result.impl = impl0

proc gtk_text_view_get_top_margin(self: ptr TextView00): int32 {.
    importc, libprag.}

proc getTopMargin*(self: TextView): int =
  int(gtk_text_view_get_top_margin(cast[ptr TextView00](self.impl)))

proc topMargin*(self: TextView): int =
  int(gtk_text_view_get_top_margin(cast[ptr TextView00](self.impl)))

proc gtk_text_view_get_vadjustment(self: ptr TextView00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_vadjustment(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: TextView): Adjustment =
  let gobj = gtk_text_view_get_vadjustment(cast[ptr TextView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_visible_rect(self: ptr TextView00; visibleRect: var gdk.Rectangle) {.
    importc, libprag.}

proc getVisibleRect*(self: TextView; visibleRect: var gdk.Rectangle) =
  gtk_text_view_get_visible_rect(cast[ptr TextView00](self.impl), visibleRect)

proc getVisibleRect*(self: TextView): gdk.Rectangle =
  gtk_text_view_get_visible_rect(cast[ptr TextView00](self.impl), result)

proc gtk_text_view_im_context_filter_keypress(self: ptr TextView00; event: ptr gdk.EventKey00): gboolean {.
    importc, libprag.}

proc imContextFilterKeypress*(self: TextView; event: gdk.EventKey): bool =
  toBool(gtk_text_view_im_context_filter_keypress(cast[ptr TextView00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_text_view_move_child(self: ptr TextView00; child: ptr Widget00;
    xpos: int32; ypos: int32) {.
    importc, libprag.}

proc moveChild*(self: TextView; child: Widget; xpos: int; ypos: int) =
  gtk_text_view_move_child(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), int32(xpos), int32(ypos))

proc gtk_text_view_move_mark_onscreen(self: ptr TextView00; mark: ptr TextMark00): gboolean {.
    importc, libprag.}

proc moveMarkOnscreen*(self: TextView; mark: TextMark): bool =
  toBool(gtk_text_view_move_mark_onscreen(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl)))

proc gtk_text_view_move_visually(self: ptr TextView00; iter: TextIter; count: int32): gboolean {.
    importc, libprag.}

proc moveVisually*(self: TextView; iter: TextIter; count: int): bool =
  toBool(gtk_text_view_move_visually(cast[ptr TextView00](self.impl), iter, int32(count)))

proc gtk_text_view_place_cursor_onscreen(self: ptr TextView00): gboolean {.
    importc, libprag.}

proc placeCursorOnscreen*(self: TextView): bool =
  toBool(gtk_text_view_place_cursor_onscreen(cast[ptr TextView00](self.impl)))

proc gtk_text_view_reset_cursor_blink(self: ptr TextView00) {.
    importc, libprag.}

proc resetCursorBlink*(self: TextView) =
  gtk_text_view_reset_cursor_blink(cast[ptr TextView00](self.impl))

proc gtk_text_view_reset_im_context(self: ptr TextView00) {.
    importc, libprag.}

proc resetImContext*(self: TextView) =
  gtk_text_view_reset_im_context(cast[ptr TextView00](self.impl))

proc gtk_text_view_scroll_mark_onscreen(self: ptr TextView00; mark: ptr TextMark00) {.
    importc, libprag.}

proc scrollMarkOnscreen*(self: TextView; mark: TextMark) =
  gtk_text_view_scroll_mark_onscreen(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl))

proc gtk_text_view_scroll_to_iter(self: ptr TextView00; iter: TextIter; withinMargin: cdouble;
    useAlign: gboolean; xalign: cdouble; yalign: cdouble): gboolean {.
    importc, libprag.}

proc scrollToIter*(self: TextView; iter: TextIter; withinMargin: cdouble;
    useAlign: bool; xalign: cdouble; yalign: cdouble): bool =
  toBool(gtk_text_view_scroll_to_iter(cast[ptr TextView00](self.impl), iter, withinMargin, gboolean(useAlign), xalign, yalign))

proc gtk_text_view_scroll_to_mark(self: ptr TextView00; mark: ptr TextMark00;
    withinMargin: cdouble; useAlign: gboolean; xalign: cdouble; yalign: cdouble) {.
    importc, libprag.}

proc scrollToMark*(self: TextView; mark: TextMark; withinMargin: cdouble;
    useAlign: bool; xalign: cdouble; yalign: cdouble) =
  gtk_text_view_scroll_to_mark(cast[ptr TextView00](self.impl), cast[ptr TextMark00](mark.impl), withinMargin, gboolean(useAlign), xalign, yalign)

proc gtk_text_view_set_accepts_tab(self: ptr TextView00; acceptsTab: gboolean) {.
    importc, libprag.}

proc setAcceptsTab*(self: TextView; acceptsTab: bool = true) =
  gtk_text_view_set_accepts_tab(cast[ptr TextView00](self.impl), gboolean(acceptsTab))

proc `acceptsTab=`*(self: TextView; acceptsTab: bool) =
  gtk_text_view_set_accepts_tab(cast[ptr TextView00](self.impl), gboolean(acceptsTab))

proc gtk_text_view_set_bottom_margin(self: ptr TextView00; bottomMargin: int32) {.
    importc, libprag.}

proc setBottomMargin*(self: TextView; bottomMargin: int) =
  gtk_text_view_set_bottom_margin(cast[ptr TextView00](self.impl), int32(bottomMargin))

proc `bottomMargin=`*(self: TextView; bottomMargin: int) =
  gtk_text_view_set_bottom_margin(cast[ptr TextView00](self.impl), int32(bottomMargin))

proc gtk_text_view_set_buffer(self: ptr TextView00; buffer: ptr TextBuffer00) {.
    importc, libprag.}

proc setBuffer*(self: TextView; buffer: TextBuffer = nil) =
  gtk_text_view_set_buffer(cast[ptr TextView00](self.impl), if buffer.isNil: nil else: cast[ptr TextBuffer00](buffer.impl))

proc `buffer=`*(self: TextView; buffer: TextBuffer = nil) =
  gtk_text_view_set_buffer(cast[ptr TextView00](self.impl), if buffer.isNil: nil else: cast[ptr TextBuffer00](buffer.impl))

proc gtk_text_view_set_cursor_visible(self: ptr TextView00; setting: gboolean) {.
    importc, libprag.}

proc setCursorVisible*(self: TextView; setting: bool = true) =
  gtk_text_view_set_cursor_visible(cast[ptr TextView00](self.impl), gboolean(setting))

proc `cursorVisible=`*(self: TextView; setting: bool) =
  gtk_text_view_set_cursor_visible(cast[ptr TextView00](self.impl), gboolean(setting))

proc gtk_text_view_set_editable(self: ptr TextView00; setting: gboolean) {.
    importc, libprag.}

proc setEditable*(self: TextView; setting: bool = true) =
  gtk_text_view_set_editable(cast[ptr TextView00](self.impl), gboolean(setting))

proc `editable=`*(self: TextView; setting: bool) =
  gtk_text_view_set_editable(cast[ptr TextView00](self.impl), gboolean(setting))

proc gtk_text_view_set_indent(self: ptr TextView00; indent: int32) {.
    importc, libprag.}

proc setIndent*(self: TextView; indent: int) =
  gtk_text_view_set_indent(cast[ptr TextView00](self.impl), int32(indent))

proc `indent=`*(self: TextView; indent: int) =
  gtk_text_view_set_indent(cast[ptr TextView00](self.impl), int32(indent))

proc gtk_text_view_set_input_hints(self: ptr TextView00; hints: InputHints) {.
    importc, libprag.}

proc setInputHints*(self: TextView; hints: InputHints) =
  gtk_text_view_set_input_hints(cast[ptr TextView00](self.impl), hints)

proc `inputHints=`*(self: TextView; hints: InputHints) =
  gtk_text_view_set_input_hints(cast[ptr TextView00](self.impl), hints)

proc gtk_text_view_set_input_purpose(self: ptr TextView00; purpose: InputPurpose) {.
    importc, libprag.}

proc setInputPurpose*(self: TextView; purpose: InputPurpose) =
  gtk_text_view_set_input_purpose(cast[ptr TextView00](self.impl), purpose)

proc `inputPurpose=`*(self: TextView; purpose: InputPurpose) =
  gtk_text_view_set_input_purpose(cast[ptr TextView00](self.impl), purpose)

proc gtk_text_view_set_justification(self: ptr TextView00; justification: Justification) {.
    importc, libprag.}

proc setJustification*(self: TextView; justification: Justification) =
  gtk_text_view_set_justification(cast[ptr TextView00](self.impl), justification)

proc `justification=`*(self: TextView; justification: Justification) =
  gtk_text_view_set_justification(cast[ptr TextView00](self.impl), justification)

proc gtk_text_view_set_left_margin(self: ptr TextView00; leftMargin: int32) {.
    importc, libprag.}

proc setLeftMargin*(self: TextView; leftMargin: int) =
  gtk_text_view_set_left_margin(cast[ptr TextView00](self.impl), int32(leftMargin))

proc `leftMargin=`*(self: TextView; leftMargin: int) =
  gtk_text_view_set_left_margin(cast[ptr TextView00](self.impl), int32(leftMargin))

proc gtk_text_view_set_monospace(self: ptr TextView00; monospace: gboolean) {.
    importc, libprag.}

proc setMonospace*(self: TextView; monospace: bool = true) =
  gtk_text_view_set_monospace(cast[ptr TextView00](self.impl), gboolean(monospace))

proc `monospace=`*(self: TextView; monospace: bool) =
  gtk_text_view_set_monospace(cast[ptr TextView00](self.impl), gboolean(monospace))

proc gtk_text_view_set_overwrite(self: ptr TextView00; overwrite: gboolean) {.
    importc, libprag.}

proc setOverwrite*(self: TextView; overwrite: bool = true) =
  gtk_text_view_set_overwrite(cast[ptr TextView00](self.impl), gboolean(overwrite))

proc `overwrite=`*(self: TextView; overwrite: bool) =
  gtk_text_view_set_overwrite(cast[ptr TextView00](self.impl), gboolean(overwrite))

proc gtk_text_view_set_pixels_above_lines(self: ptr TextView00; pixelsAboveLines: int32) {.
    importc, libprag.}

proc setPixelsAboveLines*(self: TextView; pixelsAboveLines: int) =
  gtk_text_view_set_pixels_above_lines(cast[ptr TextView00](self.impl), int32(pixelsAboveLines))

proc `pixelsAboveLines=`*(self: TextView; pixelsAboveLines: int) =
  gtk_text_view_set_pixels_above_lines(cast[ptr TextView00](self.impl), int32(pixelsAboveLines))

proc gtk_text_view_set_pixels_below_lines(self: ptr TextView00; pixelsBelowLines: int32) {.
    importc, libprag.}

proc setPixelsBelowLines*(self: TextView; pixelsBelowLines: int) =
  gtk_text_view_set_pixels_below_lines(cast[ptr TextView00](self.impl), int32(pixelsBelowLines))

proc `pixelsBelowLines=`*(self: TextView; pixelsBelowLines: int) =
  gtk_text_view_set_pixels_below_lines(cast[ptr TextView00](self.impl), int32(pixelsBelowLines))

proc gtk_text_view_set_pixels_inside_wrap(self: ptr TextView00; pixelsInsideWrap: int32) {.
    importc, libprag.}

proc setPixelsInsideWrap*(self: TextView; pixelsInsideWrap: int) =
  gtk_text_view_set_pixels_inside_wrap(cast[ptr TextView00](self.impl), int32(pixelsInsideWrap))

proc `pixelsInsideWrap=`*(self: TextView; pixelsInsideWrap: int) =
  gtk_text_view_set_pixels_inside_wrap(cast[ptr TextView00](self.impl), int32(pixelsInsideWrap))

proc gtk_text_view_set_right_margin(self: ptr TextView00; rightMargin: int32) {.
    importc, libprag.}

proc setRightMargin*(self: TextView; rightMargin: int) =
  gtk_text_view_set_right_margin(cast[ptr TextView00](self.impl), int32(rightMargin))

proc `rightMargin=`*(self: TextView; rightMargin: int) =
  gtk_text_view_set_right_margin(cast[ptr TextView00](self.impl), int32(rightMargin))

proc gtk_text_view_set_tabs(self: ptr TextView00; tabs: ptr pango.TabArray00) {.
    importc, libprag.}

proc setTabs*(self: TextView; tabs: pango.TabArray) =
  gtk_text_view_set_tabs(cast[ptr TextView00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc `tabs=`*(self: TextView; tabs: pango.TabArray) =
  gtk_text_view_set_tabs(cast[ptr TextView00](self.impl), cast[ptr pango.TabArray00](tabs.impl))

proc gtk_text_view_set_top_margin(self: ptr TextView00; topMargin: int32) {.
    importc, libprag.}

proc setTopMargin*(self: TextView; topMargin: int) =
  gtk_text_view_set_top_margin(cast[ptr TextView00](self.impl), int32(topMargin))

proc `topMargin=`*(self: TextView; topMargin: int) =
  gtk_text_view_set_top_margin(cast[ptr TextView00](self.impl), int32(topMargin))

proc gtk_text_view_starts_display_line(self: ptr TextView00; iter: TextIter): gboolean {.
    importc, libprag.}

proc startsDisplayLine*(self: TextView; iter: TextIter): bool =
  toBool(gtk_text_view_starts_display_line(cast[ptr TextView00](self.impl), iter))

type
  NotebookTab* {.size: sizeof(cint), pure.} = enum
    first = 0
    last = 1

type
  Notebook* = ref object of Container
  Notebook00* = object of Container00

proc gtk_notebook_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Notebook()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChangeCurrentPage*(self: Notebook;  p: proc (self: ptr Notebook00; `object`: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "change-current-page", cast[GCallback](p), xdata, nil, cf)

proc scCreateWindow*(self: Notebook;  p: proc (self: ptr Notebook00; page: ptr Widget00; x: int32; y: int32; xdata: pointer): Notebook00 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "create-window", cast[GCallback](p), xdata, nil, cf)

proc scFocusTab*(self: Notebook;  p: proc (self: ptr Notebook00; `object`: NotebookTab; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-tab", cast[GCallback](p), xdata, nil, cf)

proc scMoveFocusOut*(self: Notebook;  p: proc (self: ptr Notebook00; `object`: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-focus-out", cast[GCallback](p), xdata, nil, cf)

proc scPageAdded*(self: Notebook;  p: proc (self: ptr Notebook00; child: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "page-added", cast[GCallback](p), xdata, nil, cf)

proc scPageRemoved*(self: Notebook;  p: proc (self: ptr Notebook00; child: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "page-removed", cast[GCallback](p), xdata, nil, cf)

proc scPageReordered*(self: Notebook;  p: proc (self: ptr Notebook00; child: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "page-reordered", cast[GCallback](p), xdata, nil, cf)

proc scReorderTab*(self: Notebook;  p: proc (self: ptr Notebook00; `object`: DirectionType; p0: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "reorder-tab", cast[GCallback](p), xdata, nil, cf)

proc scSelectPage*(self: Notebook;  p: proc (self: ptr Notebook00; `object`: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-page", cast[GCallback](p), xdata, nil, cf)

proc scSwitchPage*(self: Notebook;  p: proc (self: ptr Notebook00; page: ptr Widget00; pageNum: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "switch-page", cast[GCallback](p), xdata, nil, cf)

proc gtk_notebook_new(): ptr Notebook00 {.
    importc, libprag.}

proc newNotebook*(): Notebook =
  let gobj = gtk_notebook_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newNotebook*(tdesc: typedesc): tdesc =
  assert(result is Notebook)
  let gobj = gtk_notebook_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNotebook*[T](result: var T) {.deprecated.} =
  assert(result is Notebook)
  let gobj = gtk_notebook_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_append_page(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc appendPage*(self: Notebook; child: Widget; tabLabel: Widget = nil): int =
  int(gtk_notebook_append_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl)))

proc gtk_notebook_append_page_menu(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; menuLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc appendPageMenu*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    menuLabel: Widget = nil): int =
  int(gtk_notebook_append_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl)))

proc gtk_notebook_detach_tab(self: ptr Notebook00; child: ptr Widget00) {.
    importc, libprag.}

proc detachTab*(self: Notebook; child: Widget) =
  gtk_notebook_detach_tab(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_notebook_get_action_widget(self: ptr Notebook00; packType: PackType): ptr Widget00 {.
    importc, libprag.}

proc getActionWidget*(self: Notebook; packType: PackType): Widget =
  let gobj = gtk_notebook_get_action_widget(cast[ptr Notebook00](self.impl), packType)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_current_page(self: ptr Notebook00): int32 {.
    importc, libprag.}

proc getCurrentPage*(self: Notebook): int =
  int(gtk_notebook_get_current_page(cast[ptr Notebook00](self.impl)))

proc currentPage*(self: Notebook): int =
  int(gtk_notebook_get_current_page(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_group_name(self: ptr Notebook00): cstring {.
    importc, libprag.}

proc getGroupName*(self: Notebook): string =
  let resul0 = gtk_notebook_get_group_name(cast[ptr Notebook00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc groupName*(self: Notebook): string =
  let resul0 = gtk_notebook_get_group_name(cast[ptr Notebook00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_notebook_get_menu_label(self: ptr Notebook00; child: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getMenuLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_menu_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_menu_label_text(self: ptr Notebook00; child: ptr Widget00): cstring {.
    importc, libprag.}

proc getMenuLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_menu_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_notebook_get_n_pages(self: ptr Notebook00): int32 {.
    importc, libprag.}

proc getNPages*(self: Notebook): int =
  int(gtk_notebook_get_n_pages(cast[ptr Notebook00](self.impl)))

proc nPages*(self: Notebook): int =
  int(gtk_notebook_get_n_pages(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_nth_page(self: ptr Notebook00; pageNum: int32): ptr Widget00 {.
    importc, libprag.}

proc getNthPage*(self: Notebook; pageNum: int): Widget =
  let gobj = gtk_notebook_get_nth_page(cast[ptr Notebook00](self.impl), int32(pageNum))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_scrollable(self: ptr Notebook00): gboolean {.
    importc, libprag.}

proc getScrollable*(self: Notebook): bool =
  toBool(gtk_notebook_get_scrollable(cast[ptr Notebook00](self.impl)))

proc scrollable*(self: Notebook): bool =
  toBool(gtk_notebook_get_scrollable(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_show_border(self: ptr Notebook00): gboolean {.
    importc, libprag.}

proc getShowBorder*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_border(cast[ptr Notebook00](self.impl)))

proc showBorder*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_border(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_show_tabs(self: ptr Notebook00): gboolean {.
    importc, libprag.}

proc getShowTabs*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_tabs(cast[ptr Notebook00](self.impl)))

proc showTabs*(self: Notebook): bool =
  toBool(gtk_notebook_get_show_tabs(cast[ptr Notebook00](self.impl)))

proc gtk_notebook_get_tab_detachable(self: ptr Notebook00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc getTabDetachable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_detachable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_get_tab_hborder(self: ptr Notebook00): uint16 {.
    importc, libprag.}

proc getTabHborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_hborder(cast[ptr Notebook00](self.impl))

proc tabHborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_hborder(cast[ptr Notebook00](self.impl))

proc gtk_notebook_get_tab_label(self: ptr Notebook00; child: ptr Widget00): ptr Widget00 {.
    importc, libprag.}

proc getTabLabel*(self: Notebook; child: Widget): Widget =
  let gobj = gtk_notebook_get_tab_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_get_tab_label_text(self: ptr Notebook00; child: ptr Widget00): cstring {.
    importc, libprag.}

proc getTabLabelText*(self: Notebook; child: Widget): string =
  let resul0 = gtk_notebook_get_tab_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_notebook_get_tab_pos(self: ptr Notebook00): PositionType {.
    importc, libprag.}

proc getTabPos*(self: Notebook): PositionType =
  gtk_notebook_get_tab_pos(cast[ptr Notebook00](self.impl))

proc tabPos*(self: Notebook): PositionType =
  gtk_notebook_get_tab_pos(cast[ptr Notebook00](self.impl))

proc gtk_notebook_get_tab_reorderable(self: ptr Notebook00; child: ptr Widget00): gboolean {.
    importc, libprag.}

proc getTabReorderable*(self: Notebook; child: Widget): bool =
  toBool(gtk_notebook_get_tab_reorderable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_get_tab_vborder(self: ptr Notebook00): uint16 {.
    importc, libprag.}

proc getTabVborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_vborder(cast[ptr Notebook00](self.impl))

proc tabVborder*(self: Notebook): uint16 =
  gtk_notebook_get_tab_vborder(cast[ptr Notebook00](self.impl))

proc gtk_notebook_insert_page(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; position: int32): int32 {.
    importc, libprag.}

proc insertPage*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    position: int): int =
  int(gtk_notebook_insert_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), int32(position)))

proc gtk_notebook_insert_page_menu(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; menuLabel: ptr Widget00; position: int32): int32 {.
    importc, libprag.}

proc insertPageMenu*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    menuLabel: Widget = nil; position: int): int =
  int(gtk_notebook_insert_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl), int32(position)))

proc gtk_notebook_next_page(self: ptr Notebook00) {.
    importc, libprag.}

proc nextPage*(self: Notebook) =
  gtk_notebook_next_page(cast[ptr Notebook00](self.impl))

proc gtk_notebook_page_num(self: ptr Notebook00; child: ptr Widget00): int32 {.
    importc, libprag.}

proc pageNum*(self: Notebook; child: Widget): int =
  int(gtk_notebook_page_num(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl)))

proc gtk_notebook_popup_disable(self: ptr Notebook00) {.
    importc, libprag.}

proc popupDisable*(self: Notebook) =
  gtk_notebook_popup_disable(cast[ptr Notebook00](self.impl))

proc gtk_notebook_popup_enable(self: ptr Notebook00) {.
    importc, libprag.}

proc popupEnable*(self: Notebook) =
  gtk_notebook_popup_enable(cast[ptr Notebook00](self.impl))

proc gtk_notebook_prepend_page(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc prependPage*(self: Notebook; child: Widget; tabLabel: Widget = nil): int =
  int(gtk_notebook_prepend_page(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl)))

proc gtk_notebook_prepend_page_menu(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00; menuLabel: ptr Widget00): int32 {.
    importc, libprag.}

proc prependPageMenu*(self: Notebook; child: Widget; tabLabel: Widget = nil;
    menuLabel: Widget = nil): int =
  int(gtk_notebook_prepend_page_menu(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl)))

proc gtk_notebook_prev_page(self: ptr Notebook00) {.
    importc, libprag.}

proc prevPage*(self: Notebook) =
  gtk_notebook_prev_page(cast[ptr Notebook00](self.impl))

proc gtk_notebook_remove_page(self: ptr Notebook00; pageNum: int32) {.
    importc, libprag.}

proc removePage*(self: Notebook; pageNum: int) =
  gtk_notebook_remove_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc gtk_notebook_reorder_child(self: ptr Notebook00; child: ptr Widget00;
    position: int32) {.
    importc, libprag.}

proc reorderChild*(self: Notebook; child: Widget; position: int) =
  gtk_notebook_reorder_child(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_notebook_set_action_widget(self: ptr Notebook00; widget: ptr Widget00;
    packType: PackType) {.
    importc, libprag.}

proc setActionWidget*(self: Notebook; widget: Widget; packType: PackType) =
  gtk_notebook_set_action_widget(cast[ptr Notebook00](self.impl), cast[ptr Widget00](widget.impl), packType)

proc gtk_notebook_set_current_page(self: ptr Notebook00; pageNum: int32) {.
    importc, libprag.}

proc setCurrentPage*(self: Notebook; pageNum: int) =
  gtk_notebook_set_current_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc `currentPage=`*(self: Notebook; pageNum: int) =
  gtk_notebook_set_current_page(cast[ptr Notebook00](self.impl), int32(pageNum))

proc gtk_notebook_set_group_name(self: ptr Notebook00; groupName: cstring) {.
    importc, libprag.}

proc setGroupName*(self: Notebook; groupName: cstring = nil) =
  gtk_notebook_set_group_name(cast[ptr Notebook00](self.impl), groupName)

proc `groupName=`*(self: Notebook; groupName: cstring = nil) =
  gtk_notebook_set_group_name(cast[ptr Notebook00](self.impl), groupName)

proc gtk_notebook_set_menu_label(self: ptr Notebook00; child: ptr Widget00;
    menuLabel: ptr Widget00) {.
    importc, libprag.}

proc setMenuLabel*(self: Notebook; child: Widget; menuLabel: Widget = nil) =
  gtk_notebook_set_menu_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if menuLabel.isNil: nil else: cast[ptr Widget00](menuLabel.impl))

proc gtk_notebook_set_menu_label_text(self: ptr Notebook00; child: ptr Widget00;
    menuText: cstring) {.
    importc, libprag.}

proc setMenuLabelText*(self: Notebook; child: Widget; menuText: cstring) =
  gtk_notebook_set_menu_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), menuText)

proc gtk_notebook_set_scrollable(self: ptr Notebook00; scrollable: gboolean) {.
    importc, libprag.}

proc setScrollable*(self: Notebook; scrollable: bool = true) =
  gtk_notebook_set_scrollable(cast[ptr Notebook00](self.impl), gboolean(scrollable))

proc `scrollable=`*(self: Notebook; scrollable: bool) =
  gtk_notebook_set_scrollable(cast[ptr Notebook00](self.impl), gboolean(scrollable))

proc gtk_notebook_set_show_border(self: ptr Notebook00; showBorder: gboolean) {.
    importc, libprag.}

proc setShowBorder*(self: Notebook; showBorder: bool = true) =
  gtk_notebook_set_show_border(cast[ptr Notebook00](self.impl), gboolean(showBorder))

proc `showBorder=`*(self: Notebook; showBorder: bool) =
  gtk_notebook_set_show_border(cast[ptr Notebook00](self.impl), gboolean(showBorder))

proc gtk_notebook_set_show_tabs(self: ptr Notebook00; showTabs: gboolean) {.
    importc, libprag.}

proc setShowTabs*(self: Notebook; showTabs: bool = true) =
  gtk_notebook_set_show_tabs(cast[ptr Notebook00](self.impl), gboolean(showTabs))

proc `showTabs=`*(self: Notebook; showTabs: bool) =
  gtk_notebook_set_show_tabs(cast[ptr Notebook00](self.impl), gboolean(showTabs))

proc gtk_notebook_set_tab_detachable(self: ptr Notebook00; child: ptr Widget00;
    detachable: gboolean) {.
    importc, libprag.}

proc setTabDetachable*(self: Notebook; child: Widget; detachable: bool) =
  gtk_notebook_set_tab_detachable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), gboolean(detachable))

proc gtk_notebook_set_tab_label(self: ptr Notebook00; child: ptr Widget00;
    tabLabel: ptr Widget00) {.
    importc, libprag.}

proc setTabLabel*(self: Notebook; child: Widget; tabLabel: Widget = nil) =
  gtk_notebook_set_tab_label(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), if tabLabel.isNil: nil else: cast[ptr Widget00](tabLabel.impl))

proc gtk_notebook_set_tab_label_text(self: ptr Notebook00; child: ptr Widget00;
    tabText: cstring) {.
    importc, libprag.}

proc setTabLabelText*(self: Notebook; child: Widget; tabText: cstring) =
  gtk_notebook_set_tab_label_text(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), tabText)

proc gtk_notebook_set_tab_pos(self: ptr Notebook00; pos: PositionType) {.
    importc, libprag.}

proc setTabPos*(self: Notebook; pos: PositionType) =
  gtk_notebook_set_tab_pos(cast[ptr Notebook00](self.impl), pos)

proc `tabPos=`*(self: Notebook; pos: PositionType) =
  gtk_notebook_set_tab_pos(cast[ptr Notebook00](self.impl), pos)

proc gtk_notebook_set_tab_reorderable(self: ptr Notebook00; child: ptr Widget00;
    reorderable: gboolean) {.
    importc, libprag.}

proc setTabReorderable*(self: Notebook; child: Widget; reorderable: bool) =
  gtk_notebook_set_tab_reorderable(cast[ptr Notebook00](self.impl), cast[ptr Widget00](child.impl), gboolean(reorderable))

type
  Separator* = ref object of Widget
  Separator00* = object of Widget00

proc gtk_separator_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Separator()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_separator_new(orientation: Orientation): ptr Separator00 {.
    importc, libprag.}

proc newSeparator*(orientation: Orientation): Separator =
  let gobj = gtk_separator_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSeparator*(tdesc: typedesc; orientation: Orientation): tdesc =
  assert(result is Separator)
  let gobj = gtk_separator_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSeparator*[T](result: var T; orientation: Orientation) {.deprecated.} =
  assert(result is Separator)
  let gobj = gtk_separator_new(orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VSeparator* = ref object of Separator
  VSeparator00* = object of Separator00

proc gtk_vseparator_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VSeparator()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_vseparator_new(): ptr VSeparator00 {.
    importc, libprag.}

proc newVSeparator*(): VSeparator {.deprecated.}  =
  let gobj = gtk_vseparator_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVSeparator*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is VSeparator)
  let gobj = gtk_vseparator_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVSeparator*[T](result: var T) {.deprecated.} =
  assert(result is VSeparator)
  let gobj = gtk_vseparator_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  StackSwitcher* = ref object of Box
  StackSwitcher00* = object of Box00

proc gtk_stack_switcher_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StackSwitcher()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_stack_switcher_new(): ptr StackSwitcher00 {.
    importc, libprag.}

proc newStackSwitcher*(): StackSwitcher =
  let gobj = gtk_stack_switcher_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStackSwitcher*(tdesc: typedesc): tdesc =
  assert(result is StackSwitcher)
  let gobj = gtk_stack_switcher_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStackSwitcher*[T](result: var T) {.deprecated.} =
  assert(result is StackSwitcher)
  let gobj = gtk_stack_switcher_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Image* = ref object of Misc
  Image00* = object of Misc00

proc gtk_image_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Image()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_image_new(): ptr Image00 {.
    importc, libprag.}

proc newImage*(): Image =
  let gobj = gtk_image_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImage*(tdesc: typedesc): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImage*[T](result: var T) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_animation(animation: ptr gdkpixbuf.PixbufAnimation00): ptr Image00 {.
    importc, libprag.}

proc newImageFromAnimation*(animation: gdkpixbuf.PixbufAnimation): Image =
  let gobj = gtk_image_new_from_animation(cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromAnimation*(tdesc: typedesc; animation: gdkpixbuf.PixbufAnimation): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_animation(cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromAnimation*[T](result: var T; animation: gdkpixbuf.PixbufAnimation) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_animation(cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_file(filename: cstring): ptr Image00 {.
    importc, libprag.}

proc newImageFromFile*(filename: cstring): Image =
  let gobj = gtk_image_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromFile*(tdesc: typedesc; filename: cstring): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromFile*[T](result: var T; filename: cstring) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_gicon(icon: ptr gio.Icon00; size: int32): ptr Image00 {.
    importc, libprag.}

proc newImageFromGicon*(icon: gio.Icon; size: int): Image =
  let gobj = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromGicon*(tdesc: typedesc; icon: gio.Icon; size: int): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromGicon*[T](result: var T; icon: gio.Icon; size: int) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_gicon(cast[ptr gio.Icon00](icon.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_icon_name(iconName: cstring; size: int32): ptr Image00 {.
    importc, libprag.}

proc newImageFromIconName*(iconName: cstring = nil; size: int): Image =
  let gobj = gtk_image_new_from_icon_name(iconName, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromIconName*(tdesc: typedesc; iconName: cstring = nil; size: int): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_icon_name(iconName, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromIconName*[T](result: var T; iconName: cstring = nil; size: int) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_icon_name(iconName, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_icon_set(iconSet: ptr IconSet00; size: int32): ptr Image00 {.
    importc, libprag.}

proc newImageFromIconSet*(iconSet: IconSet; size: int): Image {.deprecated.}  =
  let gobj = gtk_image_new_from_icon_set(cast[ptr IconSet00](iconSet.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromIconSet*(tdesc: typedesc; iconSet: IconSet; size: int): tdesc {.deprecated.}  =
  assert(result is Image)
  let gobj = gtk_image_new_from_icon_set(cast[ptr IconSet00](iconSet.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromIconSet*[T](result: var T; iconSet: IconSet; size: int) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_icon_set(cast[ptr IconSet00](iconSet.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_pixbuf(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr Image00 {.
    importc, libprag.}

proc newImageFromPixbuf*(pixbuf: gdkpixbuf.Pixbuf = nil): Image =
  let gobj = gtk_image_new_from_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromPixbuf*(tdesc: typedesc; pixbuf: gdkpixbuf.Pixbuf = nil): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf = nil) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_pixbuf(if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_resource(resourcePath: cstring): ptr Image00 {.
    importc, libprag.}

proc newImageFromResource*(resourcePath: cstring): Image =
  let gobj = gtk_image_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromResource*(tdesc: typedesc; resourcePath: cstring): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromResource*[T](result: var T; resourcePath: cstring) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_resource(resourcePath)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_stock(stockId: cstring; size: int32): ptr Image00 {.
    importc, libprag.}

proc newImageFromStock*(stockId: cstring; size: int): Image {.deprecated.}  =
  let gobj = gtk_image_new_from_stock(stockId, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromStock*(tdesc: typedesc; stockId: cstring; size: int): tdesc {.deprecated.}  =
  assert(result is Image)
  let gobj = gtk_image_new_from_stock(stockId, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromStock*[T](result: var T; stockId: cstring; size: int) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_stock(stockId, int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_new_from_surface(surface: ptr cairo.Surface00): ptr Image00 {.
    importc, libprag.}

proc newImageFromSurface*(surface: cairo.Surface = nil): Image =
  let gobj = gtk_image_new_from_surface(if surface.isNil: nil else: cast[ptr cairo.Surface00](surface.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newImageFromSurface*(tdesc: typedesc; surface: cairo.Surface = nil): tdesc =
  assert(result is Image)
  let gobj = gtk_image_new_from_surface(if surface.isNil: nil else: cast[ptr cairo.Surface00](surface.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initImageFromSurface*[T](result: var T; surface: cairo.Surface = nil) {.deprecated.} =
  assert(result is Image)
  let gobj = gtk_image_new_from_surface(if surface.isNil: nil else: cast[ptr cairo.Surface00](surface.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  HPaned* = ref object of Paned
  HPaned00* = object of Paned00

proc gtk_hpaned_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HPaned()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_hpaned_new(): ptr HPaned00 {.
    importc, libprag.}

proc newHPaned*(): HPaned {.deprecated.}  =
  let gobj = gtk_hpaned_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHPaned*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is HPaned)
  let gobj = gtk_hpaned_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHPaned*[T](result: var T) {.deprecated.} =
  assert(result is HPaned)
  let gobj = gtk_hpaned_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  VButtonBox* = ref object of ButtonBox
  VButtonBox00* = object of ButtonBox00

proc gtk_vbutton_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VButtonBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_vbutton_box_new(): ptr VButtonBox00 {.
    importc, libprag.}

proc newVButtonBox*(): VButtonBox {.deprecated.}  =
  let gobj = gtk_vbutton_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVButtonBox*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is VButtonBox)
  let gobj = gtk_vbutton_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVButtonBox*[T](result: var T) {.deprecated.} =
  assert(result is VButtonBox)
  let gobj = gtk_vbutton_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  FontSelection* = ref object of Box
  FontSelection00* = object of Box00

proc gtk_font_selection_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontSelection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_font_selection_new(): ptr FontSelection00 {.
    importc, libprag.}

proc newFontSelection*(): FontSelection {.deprecated.}  =
  let gobj = gtk_font_selection_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontSelection*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is FontSelection)
  let gobj = gtk_font_selection_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontSelection*[T](result: var T) {.deprecated.} =
  assert(result is FontSelection)
  let gobj = gtk_font_selection_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_face(self: ptr FontSelection00): ptr pango.FontFace00 {.
    importc, libprag.}

proc getFace*(self: FontSelection): pango.FontFace =
  let gobj = gtk_font_selection_get_face(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc face*(self: FontSelection): pango.FontFace =
  let gobj = gtk_font_selection_get_face(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_face_list(self: ptr FontSelection00): ptr Widget00 {.
    importc, libprag.}

proc getFaceList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_face_list(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc faceList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_face_list(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_family(self: ptr FontSelection00): ptr pango.FontFamily00 {.
    importc, libprag.}

proc getFamily*(self: FontSelection): pango.FontFamily =
  let gobj = gtk_font_selection_get_family(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc family*(self: FontSelection): pango.FontFamily =
  let gobj = gtk_font_selection_get_family(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_family_list(self: ptr FontSelection00): ptr Widget00 {.
    importc, libprag.}

proc getFamilyList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_family_list(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc familyList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_family_list(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_font_name(self: ptr FontSelection00): cstring {.
    importc, libprag.}

proc getFontName*(self: FontSelection): string =
  let resul0 = gtk_font_selection_get_font_name(cast[ptr FontSelection00](self.impl))
  result = $resul0
  cogfree(resul0)

proc fontName*(self: FontSelection): string =
  let resul0 = gtk_font_selection_get_font_name(cast[ptr FontSelection00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_selection_get_preview_entry(self: ptr FontSelection00): ptr Widget00 {.
    importc, libprag.}

proc getPreviewEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_preview_entry(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc previewEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_preview_entry(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_preview_text(self: ptr FontSelection00): cstring {.
    importc, libprag.}

proc getPreviewText*(self: FontSelection): string =
  result = $gtk_font_selection_get_preview_text(cast[ptr FontSelection00](self.impl))

proc previewText*(self: FontSelection): string =
  result = $gtk_font_selection_get_preview_text(cast[ptr FontSelection00](self.impl))

proc gtk_font_selection_get_size(self: ptr FontSelection00): int32 {.
    importc, libprag.}

proc getSize*(self: FontSelection): int =
  int(gtk_font_selection_get_size(cast[ptr FontSelection00](self.impl)))

proc size*(self: FontSelection): int =
  int(gtk_font_selection_get_size(cast[ptr FontSelection00](self.impl)))

proc gtk_font_selection_get_size_entry(self: ptr FontSelection00): ptr Widget00 {.
    importc, libprag.}

proc getSizeEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_entry(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sizeEntry*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_entry(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_get_size_list(self: ptr FontSelection00): ptr Widget00 {.
    importc, libprag.}

proc getSizeList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_list(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc sizeList*(self: FontSelection): Widget =
  let gobj = gtk_font_selection_get_size_list(cast[ptr FontSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_selection_set_font_name(self: ptr FontSelection00; fontname: cstring): gboolean {.
    importc, libprag.}

proc setFontName*(self: FontSelection; fontname: cstring): bool =
  toBool(gtk_font_selection_set_font_name(cast[ptr FontSelection00](self.impl), fontname))

proc gtk_font_selection_set_preview_text(self: ptr FontSelection00; text: cstring) {.
    importc, libprag.}

proc setPreviewText*(self: FontSelection; text: cstring) =
  gtk_font_selection_set_preview_text(cast[ptr FontSelection00](self.impl), text)

proc `previewText=`*(self: FontSelection; text: cstring) =
  gtk_font_selection_set_preview_text(cast[ptr FontSelection00](self.impl), text)

type
  HBox* = ref object of Box
  HBox00* = object of Box00

proc gtk_hbox_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_hbox_new(homogeneous: gboolean; spacing: int32): ptr HBox00 {.
    importc, libprag.}

proc newHBox*(homogeneous: bool; spacing: int): HBox {.deprecated.}  =
  let gobj = gtk_hbox_new(gboolean(homogeneous), int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHBox*(tdesc: typedesc; homogeneous: bool; spacing: int): tdesc {.deprecated.}  =
  assert(result is HBox)
  let gobj = gtk_hbox_new(gboolean(homogeneous), int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHBox*[T](result: var T; homogeneous: bool; spacing: int) {.deprecated.} =
  assert(result is HBox)
  let gobj = gtk_hbox_new(gboolean(homogeneous), int32(spacing))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellAreaBox* = ref object of CellArea
  CellAreaBox00* = object of CellArea00

proc gtk_cell_area_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellAreaBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_area_box_new(): ptr CellAreaBox00 {.
    importc, libprag.}

proc newCellAreaBox*(): CellAreaBox =
  let gobj = gtk_cell_area_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellAreaBox*(tdesc: typedesc): tdesc =
  assert(result is CellAreaBox)
  let gobj = gtk_cell_area_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellAreaBox*[T](result: var T) {.deprecated.} =
  assert(result is CellAreaBox)
  let gobj = gtk_cell_area_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_area_box_get_spacing(self: ptr CellAreaBox00): int32 {.
    importc, libprag.}

proc getSpacing*(self: CellAreaBox): int =
  int(gtk_cell_area_box_get_spacing(cast[ptr CellAreaBox00](self.impl)))

proc spacing*(self: CellAreaBox): int =
  int(gtk_cell_area_box_get_spacing(cast[ptr CellAreaBox00](self.impl)))

proc gtk_cell_area_box_pack_end(self: ptr CellAreaBox00; renderer: ptr CellRenderer00;
    expand: gboolean; align: gboolean; fixed: gboolean) {.
    importc, libprag.}

proc packEnd*(self: CellAreaBox; renderer: CellRenderer;
    expand: bool; align: bool; fixed: bool) =
  gtk_cell_area_box_pack_end(cast[ptr CellAreaBox00](self.impl), cast[ptr CellRenderer00](renderer.impl), gboolean(expand), gboolean(align), gboolean(fixed))

proc gtk_cell_area_box_pack_start(self: ptr CellAreaBox00; renderer: ptr CellRenderer00;
    expand: gboolean; align: gboolean; fixed: gboolean) {.
    importc, libprag.}

proc packStart*(self: CellAreaBox; renderer: CellRenderer;
    expand: bool; align: bool; fixed: bool) =
  gtk_cell_area_box_pack_start(cast[ptr CellAreaBox00](self.impl), cast[ptr CellRenderer00](renderer.impl), gboolean(expand), gboolean(align), gboolean(fixed))

proc gtk_cell_area_box_set_spacing(self: ptr CellAreaBox00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: CellAreaBox; spacing: int) =
  gtk_cell_area_box_set_spacing(cast[ptr CellAreaBox00](self.impl), int32(spacing))

proc `spacing=`*(self: CellAreaBox; spacing: int) =
  gtk_cell_area_box_set_spacing(cast[ptr CellAreaBox00](self.impl), int32(spacing))

type
  Overlay* = ref object of Bin
  Overlay00* = object of Bin00

proc gtk_overlay_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Overlay()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scGetChildPosition*(self: Overlay;  p: proc (self: ptr Overlay00; widget: ptr Widget00; allocation: var gdk.Rectangle; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "get-child-position", cast[GCallback](p), xdata, nil, cf)

proc gtk_overlay_new(): ptr Overlay00 {.
    importc, libprag.}

proc newOverlay*(): Overlay =
  let gobj = gtk_overlay_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newOverlay*(tdesc: typedesc): tdesc =
  assert(result is Overlay)
  let gobj = gtk_overlay_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initOverlay*[T](result: var T) {.deprecated.} =
  assert(result is Overlay)
  let gobj = gtk_overlay_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_overlay_add_overlay(self: ptr Overlay00; widget: ptr Widget00) {.
    importc, libprag.}

proc addOverlay*(self: Overlay; widget: Widget) =
  gtk_overlay_add_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl))

proc gtk_overlay_get_overlay_pass_through(self: ptr Overlay00; widget: ptr Widget00): gboolean {.
    importc, libprag.}

proc getOverlayPassThrough*(self: Overlay; widget: Widget): bool =
  toBool(gtk_overlay_get_overlay_pass_through(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_overlay_reorder_overlay(self: ptr Overlay00; child: ptr Widget00;
    index: int32) {.
    importc, libprag.}

proc reorderOverlay*(self: Overlay; child: Widget; index: int) =
  gtk_overlay_reorder_overlay(cast[ptr Overlay00](self.impl), cast[ptr Widget00](child.impl), int32(index))

proc gtk_overlay_set_overlay_pass_through(self: ptr Overlay00; widget: ptr Widget00;
    passThrough: gboolean) {.
    importc, libprag.}

proc setOverlayPassThrough*(self: Overlay; widget: Widget;
    passThrough: bool) =
  gtk_overlay_set_overlay_pass_through(cast[ptr Overlay00](self.impl), cast[ptr Widget00](widget.impl), gboolean(passThrough))

type
  RecentChooserWidget* = ref object of Box
  RecentChooserWidget00* = object of Box00

proc gtk_recent_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_recent_chooser_widget_new(): ptr RecentChooserWidget00 {.
    importc, libprag.}

proc newRecentChooserWidget*(): RecentChooserWidget =
  let gobj = gtk_recent_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentChooserWidget*(tdesc: typedesc): tdesc =
  assert(result is RecentChooserWidget)
  let gobj = gtk_recent_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserWidget*[T](result: var T) {.deprecated.} =
  assert(result is RecentChooserWidget)
  let gobj = gtk_recent_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_chooser_widget_new_for_manager(manager: ptr RecentManager00): ptr RecentChooserWidget00 {.
    importc, libprag.}

proc newRecentChooserWidgetForManager*(manager: RecentManager): RecentChooserWidget =
  let gobj = gtk_recent_chooser_widget_new_for_manager(cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentChooserWidgetForManager*(tdesc: typedesc; manager: RecentManager): tdesc =
  assert(result is RecentChooserWidget)
  let gobj = gtk_recent_chooser_widget_new_for_manager(cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentChooserWidgetForManager*[T](result: var T; manager: RecentManager) {.deprecated.} =
  assert(result is RecentChooserWidget)
  let gobj = gtk_recent_chooser_widget_new_for_manager(cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Grid* = ref object of Container
  Grid00* = object of Container00

proc gtk_grid_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Grid()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_grid_new(): ptr Grid00 {.
    importc, libprag.}

proc newGrid*(): Grid =
  let gobj = gtk_grid_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGrid*(tdesc: typedesc): tdesc =
  assert(result is Grid)
  let gobj = gtk_grid_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGrid*[T](result: var T) {.deprecated.} =
  assert(result is Grid)
  let gobj = gtk_grid_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_attach(self: ptr Grid00; child: ptr Widget00; left: int32;
    top: int32; width: int32; height: int32) {.
    importc, libprag.}

proc attach*(self: Grid; child: Widget; left: int; top: int; width: int = 1;
    height: int = 1) =
  gtk_grid_attach(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl), int32(left), int32(top), int32(width), int32(height))

proc gtk_grid_attach_next_to(self: ptr Grid00; child: ptr Widget00; sibling: ptr Widget00;
    side: PositionType; width: int32; height: int32) {.
    importc, libprag.}

proc attachNextTo*(self: Grid; child: Widget; sibling: Widget = nil;
    side: PositionType; width: int; height: int) =
  gtk_grid_attach_next_to(cast[ptr Grid00](self.impl), cast[ptr Widget00](child.impl), if sibling.isNil: nil else: cast[ptr Widget00](sibling.impl), side, int32(width), int32(height))

proc gtk_grid_get_baseline_row(self: ptr Grid00): int32 {.
    importc, libprag.}

proc getBaselineRow*(self: Grid): int =
  int(gtk_grid_get_baseline_row(cast[ptr Grid00](self.impl)))

proc baselineRow*(self: Grid): int =
  int(gtk_grid_get_baseline_row(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_child_at(self: ptr Grid00; left: int32; top: int32): ptr Widget00 {.
    importc, libprag.}

proc getChildAt*(self: Grid; left: int; top: int): Widget =
  let gobj = gtk_grid_get_child_at(cast[ptr Grid00](self.impl), int32(left), int32(top))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_grid_get_column_homogeneous(self: ptr Grid00): gboolean {.
    importc, libprag.}

proc getColumnHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_column_homogeneous(cast[ptr Grid00](self.impl)))

proc columnHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_column_homogeneous(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_column_spacing(self: ptr Grid00): uint32 {.
    importc, libprag.}

proc getColumnSpacing*(self: Grid): int =
  int(gtk_grid_get_column_spacing(cast[ptr Grid00](self.impl)))

proc columnSpacing*(self: Grid): int =
  int(gtk_grid_get_column_spacing(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_row_baseline_position(self: ptr Grid00; row: int32): BaselinePosition {.
    importc, libprag.}

proc getRowBaselinePosition*(self: Grid; row: int): BaselinePosition =
  gtk_grid_get_row_baseline_position(cast[ptr Grid00](self.impl), int32(row))

proc gtk_grid_get_row_homogeneous(self: ptr Grid00): gboolean {.
    importc, libprag.}

proc getRowHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_row_homogeneous(cast[ptr Grid00](self.impl)))

proc rowHomogeneous*(self: Grid): bool =
  toBool(gtk_grid_get_row_homogeneous(cast[ptr Grid00](self.impl)))

proc gtk_grid_get_row_spacing(self: ptr Grid00): uint32 {.
    importc, libprag.}

proc getRowSpacing*(self: Grid): int =
  int(gtk_grid_get_row_spacing(cast[ptr Grid00](self.impl)))

proc rowSpacing*(self: Grid): int =
  int(gtk_grid_get_row_spacing(cast[ptr Grid00](self.impl)))

proc gtk_grid_insert_column(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc insertColumn*(self: Grid; position: int) =
  gtk_grid_insert_column(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_insert_next_to(self: ptr Grid00; sibling: ptr Widget00; side: PositionType) {.
    importc, libprag.}

proc insertNextTo*(self: Grid; sibling: Widget; side: PositionType) =
  gtk_grid_insert_next_to(cast[ptr Grid00](self.impl), cast[ptr Widget00](sibling.impl), side)

proc gtk_grid_insert_row(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc insertRow*(self: Grid; position: int) =
  gtk_grid_insert_row(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_remove_column(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc removeColumn*(self: Grid; position: int) =
  gtk_grid_remove_column(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_remove_row(self: ptr Grid00; position: int32) {.
    importc, libprag.}

proc removeRow*(self: Grid; position: int) =
  gtk_grid_remove_row(cast[ptr Grid00](self.impl), int32(position))

proc gtk_grid_set_baseline_row(self: ptr Grid00; row: int32) {.
    importc, libprag.}

proc setBaselineRow*(self: Grid; row: int) =
  gtk_grid_set_baseline_row(cast[ptr Grid00](self.impl), int32(row))

proc `baselineRow=`*(self: Grid; row: int) =
  gtk_grid_set_baseline_row(cast[ptr Grid00](self.impl), int32(row))

proc gtk_grid_set_column_homogeneous(self: ptr Grid00; homogeneous: gboolean) {.
    importc, libprag.}

proc setColumnHomogeneous*(self: Grid; homogeneous: bool = true) =
  gtk_grid_set_column_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc `columnHomogeneous=`*(self: Grid; homogeneous: bool) =
  gtk_grid_set_column_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc gtk_grid_set_column_spacing(self: ptr Grid00; spacing: uint32) {.
    importc, libprag.}

proc setColumnSpacing*(self: Grid; spacing: int) =
  gtk_grid_set_column_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc `columnSpacing=`*(self: Grid; spacing: int) =
  gtk_grid_set_column_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc gtk_grid_set_row_baseline_position(self: ptr Grid00; row: int32; pos: BaselinePosition) {.
    importc, libprag.}

proc setRowBaselinePosition*(self: Grid; row: int; pos: BaselinePosition) =
  gtk_grid_set_row_baseline_position(cast[ptr Grid00](self.impl), int32(row), pos)

proc gtk_grid_set_row_homogeneous(self: ptr Grid00; homogeneous: gboolean) {.
    importc, libprag.}

proc setRowHomogeneous*(self: Grid; homogeneous: bool = true) =
  gtk_grid_set_row_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc `rowHomogeneous=`*(self: Grid; homogeneous: bool) =
  gtk_grid_set_row_homogeneous(cast[ptr Grid00](self.impl), gboolean(homogeneous))

proc gtk_grid_set_row_spacing(self: ptr Grid00; spacing: uint32) {.
    importc, libprag.}

proc setRowSpacing*(self: Grid; spacing: int) =
  gtk_grid_set_row_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

proc `rowSpacing=`*(self: Grid; spacing: int) =
  gtk_grid_set_row_spacing(cast[ptr Grid00](self.impl), uint32(spacing))

type
  ProgressBar* = ref object of Widget
  ProgressBar00* = object of Widget00

proc gtk_progress_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ProgressBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_progress_bar_new(): ptr ProgressBar00 {.
    importc, libprag.}

proc newProgressBar*(): ProgressBar =
  let gobj = gtk_progress_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newProgressBar*(tdesc: typedesc): tdesc =
  assert(result is ProgressBar)
  let gobj = gtk_progress_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initProgressBar*[T](result: var T) {.deprecated.} =
  assert(result is ProgressBar)
  let gobj = gtk_progress_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_progress_bar_get_ellipsize(self: ptr ProgressBar00): pango.EllipsizeMode {.
    importc, libprag.}

proc getEllipsize*(self: ProgressBar): pango.EllipsizeMode =
  gtk_progress_bar_get_ellipsize(cast[ptr ProgressBar00](self.impl))

proc ellipsize*(self: ProgressBar): pango.EllipsizeMode =
  gtk_progress_bar_get_ellipsize(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_fraction(self: ptr ProgressBar00): cdouble {.
    importc, libprag.}

proc getFraction*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_fraction(cast[ptr ProgressBar00](self.impl))

proc fraction*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_fraction(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_inverted(self: ptr ProgressBar00): gboolean {.
    importc, libprag.}

proc getInverted*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_inverted(cast[ptr ProgressBar00](self.impl)))

proc inverted*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_inverted(cast[ptr ProgressBar00](self.impl)))

proc gtk_progress_bar_get_pulse_step(self: ptr ProgressBar00): cdouble {.
    importc, libprag.}

proc getPulseStep*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_pulse_step(cast[ptr ProgressBar00](self.impl))

proc pulseStep*(self: ProgressBar): cdouble =
  gtk_progress_bar_get_pulse_step(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_get_show_text(self: ptr ProgressBar00): gboolean {.
    importc, libprag.}

proc getShowText*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_show_text(cast[ptr ProgressBar00](self.impl)))

proc showText*(self: ProgressBar): bool =
  toBool(gtk_progress_bar_get_show_text(cast[ptr ProgressBar00](self.impl)))

proc gtk_progress_bar_get_text(self: ptr ProgressBar00): cstring {.
    importc, libprag.}

proc getText*(self: ProgressBar): string =
  let resul0 = gtk_progress_bar_get_text(cast[ptr ProgressBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc text*(self: ProgressBar): string =
  let resul0 = gtk_progress_bar_get_text(cast[ptr ProgressBar00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_progress_bar_pulse(self: ptr ProgressBar00) {.
    importc, libprag.}

proc pulse*(self: ProgressBar) =
  gtk_progress_bar_pulse(cast[ptr ProgressBar00](self.impl))

proc gtk_progress_bar_set_ellipsize(self: ptr ProgressBar00; mode: pango.EllipsizeMode) {.
    importc, libprag.}

proc setEllipsize*(self: ProgressBar; mode: pango.EllipsizeMode) =
  gtk_progress_bar_set_ellipsize(cast[ptr ProgressBar00](self.impl), mode)

proc `ellipsize=`*(self: ProgressBar; mode: pango.EllipsizeMode) =
  gtk_progress_bar_set_ellipsize(cast[ptr ProgressBar00](self.impl), mode)

proc gtk_progress_bar_set_fraction(self: ptr ProgressBar00; fraction: cdouble) {.
    importc, libprag.}

proc setFraction*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_fraction(cast[ptr ProgressBar00](self.impl), fraction)

proc `fraction=`*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_fraction(cast[ptr ProgressBar00](self.impl), fraction)

proc gtk_progress_bar_set_inverted(self: ptr ProgressBar00; inverted: gboolean) {.
    importc, libprag.}

proc setInverted*(self: ProgressBar; inverted: bool = true) =
  gtk_progress_bar_set_inverted(cast[ptr ProgressBar00](self.impl), gboolean(inverted))

proc `inverted=`*(self: ProgressBar; inverted: bool) =
  gtk_progress_bar_set_inverted(cast[ptr ProgressBar00](self.impl), gboolean(inverted))

proc gtk_progress_bar_set_pulse_step(self: ptr ProgressBar00; fraction: cdouble) {.
    importc, libprag.}

proc setPulseStep*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_pulse_step(cast[ptr ProgressBar00](self.impl), fraction)

proc `pulseStep=`*(self: ProgressBar; fraction: cdouble) =
  gtk_progress_bar_set_pulse_step(cast[ptr ProgressBar00](self.impl), fraction)

proc gtk_progress_bar_set_show_text(self: ptr ProgressBar00; showText: gboolean) {.
    importc, libprag.}

proc setShowText*(self: ProgressBar; showText: bool = true) =
  gtk_progress_bar_set_show_text(cast[ptr ProgressBar00](self.impl), gboolean(showText))

proc `showText=`*(self: ProgressBar; showText: bool) =
  gtk_progress_bar_set_show_text(cast[ptr ProgressBar00](self.impl), gboolean(showText))

proc gtk_progress_bar_set_text(self: ptr ProgressBar00; text: cstring) {.
    importc, libprag.}

proc setText*(self: ProgressBar; text: cstring = nil) =
  gtk_progress_bar_set_text(cast[ptr ProgressBar00](self.impl), text)

proc `text=`*(self: ProgressBar; text: cstring = nil) =
  gtk_progress_bar_set_text(cast[ptr ProgressBar00](self.impl), text)

type
  HSeparator* = ref object of Separator
  HSeparator00* = object of Separator00

proc gtk_hseparator_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HSeparator()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_hseparator_new(): ptr HSeparator00 {.
    importc, libprag.}

proc newHSeparator*(): HSeparator {.deprecated.}  =
  let gobj = gtk_hseparator_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHSeparator*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is HSeparator)
  let gobj = gtk_hseparator_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHSeparator*[T](result: var T) {.deprecated.} =
  assert(result is HSeparator)
  let gobj = gtk_hseparator_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  HandleBox* = ref object of Bin
  HandleBox00* = object of Bin00

proc gtk_handle_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HandleBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChildAttached*(self: HandleBox;  p: proc (self: ptr HandleBox00; widget: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "child-attached", cast[GCallback](p), xdata, nil, cf)

proc scChildDetached*(self: HandleBox;  p: proc (self: ptr HandleBox00; widget: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "child-detached", cast[GCallback](p), xdata, nil, cf)

proc gtk_handle_box_new(): ptr HandleBox00 {.
    importc, libprag.}

proc newHandleBox*(): HandleBox {.deprecated.}  =
  let gobj = gtk_handle_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHandleBox*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is HandleBox)
  let gobj = gtk_handle_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHandleBox*[T](result: var T) {.deprecated.} =
  assert(result is HandleBox)
  let gobj = gtk_handle_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_handle_box_get_child_detached(self: ptr HandleBox00): gboolean {.
    importc, libprag.}

proc getChildDetached*(self: HandleBox): bool =
  toBool(gtk_handle_box_get_child_detached(cast[ptr HandleBox00](self.impl)))

proc childDetached*(self: HandleBox): bool =
  toBool(gtk_handle_box_get_child_detached(cast[ptr HandleBox00](self.impl)))

proc gtk_handle_box_get_handle_position(self: ptr HandleBox00): PositionType {.
    importc, libprag.}

proc getHandlePosition*(self: HandleBox): PositionType =
  gtk_handle_box_get_handle_position(cast[ptr HandleBox00](self.impl))

proc handlePosition*(self: HandleBox): PositionType =
  gtk_handle_box_get_handle_position(cast[ptr HandleBox00](self.impl))

proc gtk_handle_box_get_shadow_type(self: ptr HandleBox00): ShadowType {.
    importc, libprag.}

proc getShadowType*(self: HandleBox): ShadowType =
  gtk_handle_box_get_shadow_type(cast[ptr HandleBox00](self.impl))

proc shadowType*(self: HandleBox): ShadowType =
  gtk_handle_box_get_shadow_type(cast[ptr HandleBox00](self.impl))

proc gtk_handle_box_get_snap_edge(self: ptr HandleBox00): PositionType {.
    importc, libprag.}

proc getSnapEdge*(self: HandleBox): PositionType =
  gtk_handle_box_get_snap_edge(cast[ptr HandleBox00](self.impl))

proc snapEdge*(self: HandleBox): PositionType =
  gtk_handle_box_get_snap_edge(cast[ptr HandleBox00](self.impl))

proc gtk_handle_box_set_handle_position(self: ptr HandleBox00; position: PositionType) {.
    importc, libprag.}

proc setHandlePosition*(self: HandleBox; position: PositionType) =
  gtk_handle_box_set_handle_position(cast[ptr HandleBox00](self.impl), position)

proc `handlePosition=`*(self: HandleBox; position: PositionType) =
  gtk_handle_box_set_handle_position(cast[ptr HandleBox00](self.impl), position)

proc gtk_handle_box_set_shadow_type(self: ptr HandleBox00; `type`: ShadowType) {.
    importc, libprag.}

proc setShadowType*(self: HandleBox; `type`: ShadowType) =
  gtk_handle_box_set_shadow_type(cast[ptr HandleBox00](self.impl), `type`)

proc `shadowType=`*(self: HandleBox; `type`: ShadowType) =
  gtk_handle_box_set_shadow_type(cast[ptr HandleBox00](self.impl), `type`)

proc gtk_handle_box_set_snap_edge(self: ptr HandleBox00; edge: PositionType) {.
    importc, libprag.}

proc setSnapEdge*(self: HandleBox; edge: PositionType) =
  gtk_handle_box_set_snap_edge(cast[ptr HandleBox00](self.impl), edge)

proc `snapEdge=`*(self: HandleBox; edge: PositionType) =
  gtk_handle_box_set_snap_edge(cast[ptr HandleBox00](self.impl), edge)

type
  Socket* = ref object of Container
  Socket00* = object of Container00

proc gtk_socket_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Socket()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scPlugAdded*(self: Socket;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "plug-added", cast[GCallback](p), xdata, nil, cf)

proc scPlugRemoved*(self: Socket;  p: proc (self: ptr Socket00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "plug-removed", cast[GCallback](p), xdata, nil, cf)

proc gtk_socket_new(): ptr Socket00 {.
    importc, libprag.}

proc newSocket*(): Socket =
  let gobj = gtk_socket_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSocket*(tdesc: typedesc): tdesc =
  assert(result is Socket)
  let gobj = gtk_socket_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSocket*[T](result: var T) {.deprecated.} =
  assert(result is Socket)
  let gobj = gtk_socket_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_socket_add_id(self: ptr Socket00; window: uint64) {.
    importc, libprag.}

proc addId*(self: Socket; window: uint64) =
  gtk_socket_add_id(cast[ptr Socket00](self.impl), window)

proc gtk_socket_get_id(self: ptr Socket00): uint64 {.
    importc, libprag.}

proc getId*(self: Socket): uint64 =
  gtk_socket_get_id(cast[ptr Socket00](self.impl))

proc id*(self: Socket): uint64 =
  gtk_socket_get_id(cast[ptr Socket00](self.impl))

proc gtk_socket_get_plug_window(self: ptr Socket00): ptr gdk.Window00 {.
    importc, libprag.}

proc getPlugWindow*(self: Socket): gdk.Window =
  let gobj = gtk_socket_get_plug_window(cast[ptr Socket00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc plugWindow*(self: Socket): gdk.Window =
  let gobj = gtk_socket_get_plug_window(cast[ptr Socket00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ImageAccessible* = ref object of WidgetAccessible
  ImageAccessible00* = object of WidgetAccessible00

proc gtk_image_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ImageAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  SpinnerAccessible* = ref object of WidgetAccessible
  SpinnerAccessible00* = object of WidgetAccessible00

proc gtk_spinner_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SpinnerAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_image_clear(self: ptr Image00) {.
    importc, libprag.}

proc clear*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible) =
  gtk_image_clear(cast[ptr Image00](self.impl))

proc gtk_image_get_animation(self: ptr Image00): ptr gdkpixbuf.PixbufAnimation00 {.
    importc, libprag.}

proc getAnimation*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): gdkpixbuf.PixbufAnimation =
  let gobj = gtk_image_get_animation(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc animation*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): gdkpixbuf.PixbufAnimation =
  let gobj = gtk_image_get_animation(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_get_gicon(self: ptr Image00; gicon: var ptr gio.Icon00; size: var int32) {.
    importc, libprag.}

proc getGicon*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    gicon: var gio.Icon = cast[var gio.Icon](nil); size: var int = cast[var int](nil)) =
  var tmpoutgobjectarg: ptr gio.Icon00
  var size_00: int32
  gtk_image_get_gicon(cast[ptr Image00](self.impl), cast[var ptr gio.Icon00](if addr(gicon) == nil: nil else: addr tmpoutgobjectarg), size_00)
  if size.addr != nil:
    size = int(size_00)
#  dothemagic(gicon
  if addr(gicon) != nil:
    gicon = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      gicon = cast[type(gicon)](argqdata)
      assert(gicon.impl == tmpoutgobjectarg)
    else:
      fnew(gicon, gtk.finalizeGObject)
      gicon.impl = tmpoutgobjectarg
      GC_ref(gicon)
      if g_object_is_floating(gicon.impl).int != 0:
        discard g_object_ref_sink(gicon.impl)
      g_object_add_toggle_ref(gicon.impl, toggleNotify, addr(gicon[]))
      g_object_unref(gicon.impl)
      assert(g_object_get_qdata(gicon.impl, Quark) == nil)
      g_object_set_qdata(gicon.impl, Quark, addr(gicon[]))


proc gtk_image_get_icon_name(self: ptr Image00; iconName: var cstring; size: var int32) {.
    importc, libprag.}

proc getIconName*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    iconName: var string = cast[var string](nil); size: var int = cast[var int](nil)) =
  var iconName_00: cstring
  var size_00: int32
  gtk_image_get_icon_name(cast[ptr Image00](self.impl), iconName_00, size_00)
  if iconName.addr != nil:
    iconName = $(iconName_00)
  if size.addr != nil:
    size = int(size_00)

proc gtk_image_get_icon_set(self: ptr Image00; iconSet: var ptr IconSet00;
    size: var int32) {.
    importc, libprag.}

proc getIconSet*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    iconSet: var IconSet = cast[var IconSet](nil); size: var int = cast[var int](nil)) =
  if addr(iconSet) != nil:
    fnew(iconSet, gBoxedFreeGtkIconSet)
  var size_00: int32
  gtk_image_get_icon_set(cast[ptr Image00](self.impl), cast[var ptr IconSet00](if addr(iconSet) == nil: nil else: addr iconSet.impl), size_00)
  iconSet.impl = cast[ptr IconSet00](g_boxed_copy(gtk_icon_set_get_type(), iconSet.impl))
  if size.addr != nil:
    size = int(size_00)

proc gtk_image_get_pixbuf(self: ptr Image00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPixbuf*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): gdkpixbuf.Pixbuf =
  let gobj = gtk_image_get_pixbuf(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): gdkpixbuf.Pixbuf =
  let gobj = gtk_image_get_pixbuf(cast[ptr Image00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_image_get_pixel_size(self: ptr Image00): int32 {.
    importc, libprag.}

proc getPixelSize*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): int =
  int(gtk_image_get_pixel_size(cast[ptr Image00](self.impl)))

proc pixelSize*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): int =
  int(gtk_image_get_pixel_size(cast[ptr Image00](self.impl)))

proc gtk_image_get_stock(self: ptr Image00; stockId: var cstring; size: var int32) {.
    importc, libprag.}

proc getStock*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    stockId: var string = cast[var string](nil); size: var int = cast[var int](nil)) =
  var stockId_00: cstring
  var size_00: int32
  gtk_image_get_stock(cast[ptr Image00](self.impl), stockId_00, size_00)
  if stockId.addr != nil:
    stockId = $(stockId_00)
  if size.addr != nil:
    size = int(size_00)

proc gtk_image_get_storage_type(self: ptr Image00): ImageType {.
    importc, libprag.}

proc getStorageType*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): ImageType =
  gtk_image_get_storage_type(cast[ptr Image00](self.impl))

proc storageType*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible): ImageType =
  gtk_image_get_storage_type(cast[ptr Image00](self.impl))

proc gtk_image_set_from_animation(self: ptr Image00; animation: ptr gdkpixbuf.PixbufAnimation00) {.
    importc, libprag.}

proc setFromAnimation*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    animation: gdkpixbuf.PixbufAnimation) =
  gtk_image_set_from_animation(cast[ptr Image00](self.impl), cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))

proc `fromAnimation=`*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    animation: gdkpixbuf.PixbufAnimation) =
  gtk_image_set_from_animation(cast[ptr Image00](self.impl), cast[ptr gdkpixbuf.PixbufAnimation00](animation.impl))

proc gtk_image_set_from_file(self: ptr Image00; filename: cstring) {.
    importc, libprag.}

proc setFromFile*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    filename: cstring = nil) =
  gtk_image_set_from_file(cast[ptr Image00](self.impl), filename)

proc `fromFile=`*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    filename: cstring = nil) =
  gtk_image_set_from_file(cast[ptr Image00](self.impl), filename)

proc gtk_image_set_from_gicon(self: ptr Image00; icon: ptr gio.Icon00; size: int32) {.
    importc, libprag.}

proc setFromGicon*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    icon: gio.Icon; size: int) =
  gtk_image_set_from_gicon(cast[ptr Image00](self.impl), cast[ptr gio.Icon00](icon.impl), int32(size))

proc gtk_image_set_from_icon_name(self: ptr Image00; iconName: cstring; size: int32) {.
    importc, libprag.}

proc setFromIconName*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    iconName: cstring = nil; size: int) =
  gtk_image_set_from_icon_name(cast[ptr Image00](self.impl), iconName, int32(size))

proc gtk_image_set_from_icon_set(self: ptr Image00; iconSet: ptr IconSet00;
    size: int32) {.
    importc, libprag.}

proc setFromIconSet*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    iconSet: IconSet; size: int) =
  gtk_image_set_from_icon_set(cast[ptr Image00](self.impl), cast[ptr IconSet00](iconSet.impl), int32(size))

proc gtk_image_set_from_pixbuf(self: ptr Image00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setFromPixbuf*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_image_set_from_pixbuf(cast[ptr Image00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `fromPixbuf=`*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_image_set_from_pixbuf(cast[ptr Image00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_image_set_from_resource(self: ptr Image00; resourcePath: cstring) {.
    importc, libprag.}

proc setFromResource*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    resourcePath: cstring = nil) =
  gtk_image_set_from_resource(cast[ptr Image00](self.impl), resourcePath)

proc `fromResource=`*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    resourcePath: cstring = nil) =
  gtk_image_set_from_resource(cast[ptr Image00](self.impl), resourcePath)

proc gtk_image_set_from_stock(self: ptr Image00; stockId: cstring; size: int32) {.
    importc, libprag.}

proc setFromStock*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    stockId: cstring; size: int) =
  gtk_image_set_from_stock(cast[ptr Image00](self.impl), stockId, int32(size))

proc gtk_image_set_from_surface(self: ptr Image00; surface: ptr cairo.Surface00) {.
    importc, libprag.}

proc setFromSurface*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    surface: cairo.Surface = nil) =
  gtk_image_set_from_surface(cast[ptr Image00](self.impl), if surface.isNil: nil else: cast[ptr cairo.Surface00](surface.impl))

proc `fromSurface=`*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    surface: cairo.Surface = nil) =
  gtk_image_set_from_surface(cast[ptr Image00](self.impl), if surface.isNil: nil else: cast[ptr cairo.Surface00](surface.impl))

proc gtk_image_set_pixel_size(self: ptr Image00; pixelSize: int32) {.
    importc, libprag.}

proc setPixelSize*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    pixelSize: int) =
  gtk_image_set_pixel_size(cast[ptr Image00](self.impl), int32(pixelSize))

proc `pixelSize=`*(self: Image | LockButtonAccessible | RadioButtonAccessible | LinkButtonAccessible | ImageCellAccessible | MenuButtonAccessible | ToggleButtonAccessible | ArrowAccessible | ScaleButtonAccessible | ButtonAccessible | ImageAccessible | SpinnerAccessible;
    pixelSize: int) =
  gtk_image_set_pixel_size(cast[ptr Image00](self.impl), int32(pixelSize))

type
  WrapMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    char = 1
    word = 2
    wordChar = 3

proc gtk_text_view_get_wrap_mode(self: ptr TextView00): WrapMode {.
    importc, libprag.}

proc getWrapMode*(self: TextView): WrapMode =
  gtk_text_view_get_wrap_mode(cast[ptr TextView00](self.impl))

proc wrapMode*(self: TextView): WrapMode =
  gtk_text_view_get_wrap_mode(cast[ptr TextView00](self.impl))

proc gtk_text_view_set_wrap_mode(self: ptr TextView00; wrapMode: WrapMode) {.
    importc, libprag.}

proc setWrapMode*(self: TextView; wrapMode: WrapMode) =
  gtk_text_view_set_wrap_mode(cast[ptr TextView00](self.impl), wrapMode)

proc `wrapMode=`*(self: TextView; wrapMode: WrapMode) =
  gtk_text_view_set_wrap_mode(cast[ptr TextView00](self.impl), wrapMode)

type
  TextWindowType* {.size: sizeof(cint), pure.} = enum
    private = 0
    widget = 1
    text = 2
    left = 3
    right = 4
    top = 5
    bottom = 6

proc gtk_text_view_add_child_in_window(self: ptr TextView00; child: ptr Widget00;
    whichWindow: TextWindowType; xpos: int32; ypos: int32) {.
    importc, libprag.}

proc addChildInWindow*(self: TextView; child: Widget; whichWindow: TextWindowType;
    xpos: int; ypos: int) =
  gtk_text_view_add_child_in_window(cast[ptr TextView00](self.impl), cast[ptr Widget00](child.impl), whichWindow, int32(xpos), int32(ypos))

proc gtk_text_view_buffer_to_window_coords(self: ptr TextView00; win: TextWindowType;
    bufferX: int32; bufferY: int32; windowX: var int32; windowY: var int32) {.
    importc, libprag.}

proc bufferToWindowCoords*(self: TextView; win: TextWindowType;
    bufferX: int; bufferY: int; windowX: var int = cast[var int](nil); windowY: var int = cast[var int](nil)) =
  var windowY_00: int32
  var windowX_00: int32
  gtk_text_view_buffer_to_window_coords(cast[ptr TextView00](self.impl), win, int32(bufferX), int32(bufferY), windowX_00, windowY_00)
  if windowY.addr != nil:
    windowY = int(windowY_00)
  if windowX.addr != nil:
    windowX = int(windowX_00)

proc gtk_text_view_get_border_window_size(self: ptr TextView00; `type`: TextWindowType): int32 {.
    importc, libprag.}

proc getBorderWindowSize*(self: TextView; `type`: TextWindowType): int =
  int(gtk_text_view_get_border_window_size(cast[ptr TextView00](self.impl), `type`))

proc gtk_text_view_get_window(self: ptr TextView00; win: TextWindowType): ptr gdk.Window00 {.
    importc, libprag.}

proc getWindow*(self: TextView; win: TextWindowType): gdk.Window =
  let gobj = gtk_text_view_get_window(cast[ptr TextView00](self.impl), win)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_text_view_get_window_type(self: ptr TextView00; window: ptr gdk.Window00): TextWindowType {.
    importc, libprag.}

proc getWindowType*(self: TextView; window: gdk.Window): TextWindowType =
  gtk_text_view_get_window_type(cast[ptr TextView00](self.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_text_view_set_border_window_size(self: ptr TextView00; `type`: TextWindowType;
    size: int32) {.
    importc, libprag.}

proc setBorderWindowSize*(self: TextView; `type`: TextWindowType;
    size: int) =
  gtk_text_view_set_border_window_size(cast[ptr TextView00](self.impl), `type`, int32(size))

proc gtk_text_view_window_to_buffer_coords(self: ptr TextView00; win: TextWindowType;
    windowX: int32; windowY: int32; bufferX: var int32; bufferY: var int32) {.
    importc, libprag.}

proc windowToBufferCoords*(self: TextView; win: TextWindowType;
    windowX: int; windowY: int; bufferX: var int = cast[var int](nil); bufferY: var int = cast[var int](nil)) =
  var bufferY_00: int32
  var bufferX_00: int32
  gtk_text_view_window_to_buffer_coords(cast[ptr TextView00](self.impl), win, int32(windowX), int32(windowY), bufferX_00, bufferY_00)
  if bufferY.addr != nil:
    bufferY = int(bufferY_00)
  if bufferX.addr != nil:
    bufferX = int(bufferX_00)

type
  TreeViewAccessible* = ref object of ContainerAccessible
  TreeViewAccessible00* = object of ContainerAccessible00

proc gtk_tree_view_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeViewAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_table_attach(self: ptr Table00; child: ptr Widget00; leftAttach: uint32;
    rightAttach: uint32; topAttach: uint32; bottomAttach: uint32; xoptions: AttachOptions;
    yoptions: AttachOptions; xpadding: uint32; ypadding: uint32) {.
    importc, libprag.}

proc attach*(self: Table | TreeViewAccessible; child: Widget; leftAttach: int;
    rightAttach: int; topAttach: int; bottomAttach: int; xoptions: AttachOptions;
    yoptions: AttachOptions; xpadding: int; ypadding: int) =
  gtk_table_attach(cast[ptr Table00](self.impl), cast[ptr Widget00](child.impl), uint32(leftAttach), uint32(rightAttach), uint32(topAttach), uint32(bottomAttach), xoptions, yoptions, uint32(xpadding), uint32(ypadding))

proc gtk_table_attach_defaults(self: ptr Table00; widget: ptr Widget00; leftAttach: uint32;
    rightAttach: uint32; topAttach: uint32; bottomAttach: uint32) {.
    importc, libprag.}

proc attachDefaults*(self: Table | TreeViewAccessible; widget: Widget;
    leftAttach: int; rightAttach: int; topAttach: int; bottomAttach: int) =
  gtk_table_attach_defaults(cast[ptr Table00](self.impl), cast[ptr Widget00](widget.impl), uint32(leftAttach), uint32(rightAttach), uint32(topAttach), uint32(bottomAttach))

proc gtk_table_get_col_spacing(self: ptr Table00; column: uint32): uint32 {.
    importc, libprag.}

proc getColSpacing*(self: Table | TreeViewAccessible; column: int): int =
  int(gtk_table_get_col_spacing(cast[ptr Table00](self.impl), uint32(column)))

proc gtk_table_get_default_col_spacing(self: ptr Table00): uint32 {.
    importc, libprag.}

proc getDefaultColSpacing*(self: Table | TreeViewAccessible): int =
  int(gtk_table_get_default_col_spacing(cast[ptr Table00](self.impl)))

proc defaultColSpacing*(self: Table | TreeViewAccessible): int =
  int(gtk_table_get_default_col_spacing(cast[ptr Table00](self.impl)))

proc gtk_table_get_default_row_spacing(self: ptr Table00): uint32 {.
    importc, libprag.}

proc getDefaultRowSpacing*(self: Table | TreeViewAccessible): int =
  int(gtk_table_get_default_row_spacing(cast[ptr Table00](self.impl)))

proc defaultRowSpacing*(self: Table | TreeViewAccessible): int =
  int(gtk_table_get_default_row_spacing(cast[ptr Table00](self.impl)))

proc gtk_table_get_homogeneous(self: ptr Table00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: Table | TreeViewAccessible): bool =
  toBool(gtk_table_get_homogeneous(cast[ptr Table00](self.impl)))

proc homogeneous*(self: Table | TreeViewAccessible): bool =
  toBool(gtk_table_get_homogeneous(cast[ptr Table00](self.impl)))

proc gtk_table_get_row_spacing(self: ptr Table00; row: uint32): uint32 {.
    importc, libprag.}

proc getRowSpacing*(self: Table | TreeViewAccessible; row: int): int =
  int(gtk_table_get_row_spacing(cast[ptr Table00](self.impl), uint32(row)))

proc gtk_table_get_size(self: ptr Table00; rows: var uint32; columns: var uint32) {.
    importc, libprag.}

proc getSize*(self: Table | TreeViewAccessible; rows: var int = cast[var int](nil);
    columns: var int = cast[var int](nil)) =
  var rows_00: uint32
  var columns_00: uint32
  gtk_table_get_size(cast[ptr Table00](self.impl), rows_00, columns_00)
  if rows.addr != nil:
    rows = int(rows_00)
  if columns.addr != nil:
    columns = int(columns_00)

proc gtk_table_resize(self: ptr Table00; rows: uint32; columns: uint32) {.
    importc, libprag.}

proc resize*(self: Table | TreeViewAccessible; rows: int; columns: int) =
  gtk_table_resize(cast[ptr Table00](self.impl), uint32(rows), uint32(columns))

proc gtk_table_set_col_spacing(self: ptr Table00; column: uint32; spacing: uint32) {.
    importc, libprag.}

proc setColSpacing*(self: Table | TreeViewAccessible; column: int;
    spacing: int) =
  gtk_table_set_col_spacing(cast[ptr Table00](self.impl), uint32(column), uint32(spacing))

proc gtk_table_set_col_spacings(self: ptr Table00; spacing: uint32) {.
    importc, libprag.}

proc setColSpacings*(self: Table | TreeViewAccessible; spacing: int) =
  gtk_table_set_col_spacings(cast[ptr Table00](self.impl), uint32(spacing))

proc `colSpacings=`*(self: Table | TreeViewAccessible; spacing: int) =
  gtk_table_set_col_spacings(cast[ptr Table00](self.impl), uint32(spacing))

proc gtk_table_set_homogeneous(self: ptr Table00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: Table | TreeViewAccessible; homogeneous: bool = true) =
  gtk_table_set_homogeneous(cast[ptr Table00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: Table | TreeViewAccessible; homogeneous: bool) =
  gtk_table_set_homogeneous(cast[ptr Table00](self.impl), gboolean(homogeneous))

proc gtk_table_set_row_spacing(self: ptr Table00; row: uint32; spacing: uint32) {.
    importc, libprag.}

proc setRowSpacing*(self: Table | TreeViewAccessible; row: int;
    spacing: int) =
  gtk_table_set_row_spacing(cast[ptr Table00](self.impl), uint32(row), uint32(spacing))

proc gtk_table_set_row_spacings(self: ptr Table00; spacing: uint32) {.
    importc, libprag.}

proc setRowSpacings*(self: Table | TreeViewAccessible; spacing: int) =
  gtk_table_set_row_spacings(cast[ptr Table00](self.impl), uint32(spacing))

proc `rowSpacings=`*(self: Table | TreeViewAccessible; spacing: int) =
  gtk_table_set_row_spacings(cast[ptr Table00](self.impl), uint32(spacing))

type
  CornerType* {.size: sizeof(cint), pure.} = enum
    topLeft = 0
    bottomLeft = 1
    topRight = 2
    bottomRight = 3

proc gtk_scrolled_window_get_placement(self: ptr ScrolledWindow00): CornerType {.
    importc, libprag.}

proc getPlacement*(self: ScrolledWindow): CornerType =
  gtk_scrolled_window_get_placement(cast[ptr ScrolledWindow00](self.impl))

proc placement*(self: ScrolledWindow): CornerType =
  gtk_scrolled_window_get_placement(cast[ptr ScrolledWindow00](self.impl))

proc gtk_scrolled_window_set_placement(self: ptr ScrolledWindow00; windowPlacement: CornerType) {.
    importc, libprag.}

proc setPlacement*(self: ScrolledWindow; windowPlacement: CornerType) =
  gtk_scrolled_window_set_placement(cast[ptr ScrolledWindow00](self.impl), windowPlacement)

proc `placement=`*(self: ScrolledWindow; windowPlacement: CornerType) =
  gtk_scrolled_window_set_placement(cast[ptr ScrolledWindow00](self.impl), windowPlacement)

type
  PolicyType* {.size: sizeof(cint), pure.} = enum
    always = 0
    automatic = 1
    never = 2
    external = 3

proc gtk_scrolled_window_get_policy(self: ptr ScrolledWindow00; hscrollbarPolicy: var PolicyType;
    vscrollbarPolicy: var PolicyType) {.
    importc, libprag.}

proc getPolicy*(self: ScrolledWindow; hscrollbarPolicy: var PolicyType = cast[var PolicyType](nil);
    vscrollbarPolicy: var PolicyType = cast[var PolicyType](nil)) =
  gtk_scrolled_window_get_policy(cast[ptr ScrolledWindow00](self.impl), hscrollbarPolicy, vscrollbarPolicy)

proc gtk_scrolled_window_set_policy(self: ptr ScrolledWindow00; hscrollbarPolicy: PolicyType;
    vscrollbarPolicy: PolicyType) {.
    importc, libprag.}

proc setPolicy*(self: ScrolledWindow; hscrollbarPolicy: PolicyType;
    vscrollbarPolicy: PolicyType) =
  gtk_scrolled_window_set_policy(cast[ptr ScrolledWindow00](self.impl), hscrollbarPolicy, vscrollbarPolicy)

type
  ButtonBoxStyle* {.size: sizeof(cint), pure.} = enum
    spread = 1
    edge = 2
    start = 3
    `end` = 4
    center = 5
    expand = 6

proc gtk_button_box_get_layout(self: ptr ButtonBox00): ButtonBoxStyle {.
    importc, libprag.}

proc getLayout*(self: ButtonBox): ButtonBoxStyle =
  gtk_button_box_get_layout(cast[ptr ButtonBox00](self.impl))

proc layout*(self: ButtonBox): ButtonBoxStyle =
  gtk_button_box_get_layout(cast[ptr ButtonBox00](self.impl))

proc gtk_button_box_set_layout(self: ptr ButtonBox00; layoutStyle: ButtonBoxStyle) {.
    importc, libprag.}

proc setLayout*(self: ButtonBox; layoutStyle: ButtonBoxStyle) =
  gtk_button_box_set_layout(cast[ptr ButtonBox00](self.impl), layoutStyle)

proc `layout=`*(self: ButtonBox; layoutStyle: ButtonBoxStyle) =
  gtk_button_box_set_layout(cast[ptr ButtonBox00](self.impl), layoutStyle)

type
  UIManagerItemType* {.size: sizeof(cint), pure.} = enum
    auto = 0
    menubar = 1
    menu = 2
    toolbar = 4
    placeholder = 8
    popup = 16
    menuitem = 32
    toolitem = 64
    separator = 128
    accelerator = 256
    popupWithAccels = 512

proc gtk_ui_manager_add_ui(self: ptr UIManager00; mergeId: uint32; path: cstring;
    name: cstring; action: cstring; `type`: UIManagerItemType; top: gboolean) {.
    importc, libprag.}

proc addUi*(self: UIManager; mergeId: int; path: cstring;
    name: cstring; action: cstring = nil; `type`: UIManagerItemType; top: bool) =
  gtk_ui_manager_add_ui(cast[ptr UIManager00](self.impl), uint32(mergeId), path, name, action, `type`, gboolean(top))

proc gtk_ui_manager_get_toplevels(self: ptr UIManager00; types: UIManagerItemType): ptr glib.SList {.
    importc, libprag.}

proc getToplevels*(self: UIManager; types: UIManagerItemType): seq[Widget] =
  let resul0 = gtk_ui_manager_get_toplevels(cast[ptr UIManager00](self.impl), types)
  result = gslistObjects2seq(Widget, resul0, false)
  g_slist_free(resul0)

type
  Stack* = ref object of Container
  Stack00* = object of Container00

proc gtk_stack_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Stack()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_stack_new(): ptr Stack00 {.
    importc, libprag.}

proc newStack*(): Stack =
  let gobj = gtk_stack_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStack*(tdesc: typedesc): tdesc =
  assert(result is Stack)
  let gobj = gtk_stack_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStack*[T](result: var T) {.deprecated.} =
  assert(result is Stack)
  let gobj = gtk_stack_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_add_named(self: ptr Stack00; child: ptr Widget00; name: cstring) {.
    importc, libprag.}

proc addNamed*(self: Stack; child: Widget; name: cstring) =
  gtk_stack_add_named(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl), name)

proc gtk_stack_add_titled(self: ptr Stack00; child: ptr Widget00; name: cstring;
    title: cstring) {.
    importc, libprag.}

proc addTitled*(self: Stack; child: Widget; name: cstring; title: cstring) =
  gtk_stack_add_titled(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl), name, title)

proc gtk_stack_get_child_by_name(self: ptr Stack00; name: cstring): ptr Widget00 {.
    importc, libprag.}

proc getChildByName*(self: Stack; name: cstring): Widget =
  let gobj = gtk_stack_get_child_by_name(cast[ptr Stack00](self.impl), name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_hhomogeneous(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getHhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_hhomogeneous(cast[ptr Stack00](self.impl)))

proc hhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_hhomogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_homogeneous(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getHomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_homogeneous(cast[ptr Stack00](self.impl)))

proc homogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_homogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_interpolate_size(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getInterpolateSize*(self: Stack): bool =
  toBool(gtk_stack_get_interpolate_size(cast[ptr Stack00](self.impl)))

proc interpolateSize*(self: Stack): bool =
  toBool(gtk_stack_get_interpolate_size(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_transition_duration(self: ptr Stack00): uint32 {.
    importc, libprag.}

proc getTransitionDuration*(self: Stack): int =
  int(gtk_stack_get_transition_duration(cast[ptr Stack00](self.impl)))

proc transitionDuration*(self: Stack): int =
  int(gtk_stack_get_transition_duration(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_transition_running(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getTransitionRunning*(self: Stack): bool =
  toBool(gtk_stack_get_transition_running(cast[ptr Stack00](self.impl)))

proc transitionRunning*(self: Stack): bool =
  toBool(gtk_stack_get_transition_running(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_vhomogeneous(self: ptr Stack00): gboolean {.
    importc, libprag.}

proc getVhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_vhomogeneous(cast[ptr Stack00](self.impl)))

proc vhomogeneous*(self: Stack): bool =
  toBool(gtk_stack_get_vhomogeneous(cast[ptr Stack00](self.impl)))

proc gtk_stack_get_visible_child(self: ptr Stack00): ptr Widget00 {.
    importc, libprag.}

proc getVisibleChild*(self: Stack): Widget =
  let gobj = gtk_stack_get_visible_child(cast[ptr Stack00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc visibleChild*(self: Stack): Widget =
  let gobj = gtk_stack_get_visible_child(cast[ptr Stack00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_get_visible_child_name(self: ptr Stack00): cstring {.
    importc, libprag.}

proc getVisibleChildName*(self: Stack): string =
  let resul0 = gtk_stack_get_visible_child_name(cast[ptr Stack00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc visibleChildName*(self: Stack): string =
  let resul0 = gtk_stack_get_visible_child_name(cast[ptr Stack00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_stack_set_hhomogeneous(self: ptr Stack00; hhomogeneous: gboolean) {.
    importc, libprag.}

proc setHhomogeneous*(self: Stack; hhomogeneous: bool = true) =
  gtk_stack_set_hhomogeneous(cast[ptr Stack00](self.impl), gboolean(hhomogeneous))

proc `hhomogeneous=`*(self: Stack; hhomogeneous: bool) =
  gtk_stack_set_hhomogeneous(cast[ptr Stack00](self.impl), gboolean(hhomogeneous))

proc gtk_stack_set_homogeneous(self: ptr Stack00; homogeneous: gboolean) {.
    importc, libprag.}

proc setHomogeneous*(self: Stack; homogeneous: bool = true) =
  gtk_stack_set_homogeneous(cast[ptr Stack00](self.impl), gboolean(homogeneous))

proc `homogeneous=`*(self: Stack; homogeneous: bool) =
  gtk_stack_set_homogeneous(cast[ptr Stack00](self.impl), gboolean(homogeneous))

proc gtk_stack_set_interpolate_size(self: ptr Stack00; interpolateSize: gboolean) {.
    importc, libprag.}

proc setInterpolateSize*(self: Stack; interpolateSize: bool = true) =
  gtk_stack_set_interpolate_size(cast[ptr Stack00](self.impl), gboolean(interpolateSize))

proc `interpolateSize=`*(self: Stack; interpolateSize: bool) =
  gtk_stack_set_interpolate_size(cast[ptr Stack00](self.impl), gboolean(interpolateSize))

proc gtk_stack_set_transition_duration(self: ptr Stack00; duration: uint32) {.
    importc, libprag.}

proc setTransitionDuration*(self: Stack; duration: int) =
  gtk_stack_set_transition_duration(cast[ptr Stack00](self.impl), uint32(duration))

proc `transitionDuration=`*(self: Stack; duration: int) =
  gtk_stack_set_transition_duration(cast[ptr Stack00](self.impl), uint32(duration))

proc gtk_stack_set_vhomogeneous(self: ptr Stack00; vhomogeneous: gboolean) {.
    importc, libprag.}

proc setVhomogeneous*(self: Stack; vhomogeneous: bool = true) =
  gtk_stack_set_vhomogeneous(cast[ptr Stack00](self.impl), gboolean(vhomogeneous))

proc `vhomogeneous=`*(self: Stack; vhomogeneous: bool) =
  gtk_stack_set_vhomogeneous(cast[ptr Stack00](self.impl), gboolean(vhomogeneous))

proc gtk_stack_set_visible_child(self: ptr Stack00; child: ptr Widget00) {.
    importc, libprag.}

proc setVisibleChild*(self: Stack; child: Widget) =
  gtk_stack_set_visible_child(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))

proc `visibleChild=`*(self: Stack; child: Widget) =
  gtk_stack_set_visible_child(cast[ptr Stack00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_stack_set_visible_child_name(self: ptr Stack00; name: cstring) {.
    importc, libprag.}

proc setVisibleChildName*(self: Stack; name: cstring) =
  gtk_stack_set_visible_child_name(cast[ptr Stack00](self.impl), name)

proc `visibleChildName=`*(self: Stack; name: cstring) =
  gtk_stack_set_visible_child_name(cast[ptr Stack00](self.impl), name)

proc gtk_stack_sidebar_get_stack(self: ptr StackSidebar00): ptr Stack00 {.
    importc, libprag.}

proc getStack*(self: StackSidebar): Stack =
  let gobj = gtk_stack_sidebar_get_stack(cast[ptr StackSidebar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc stack*(self: StackSidebar): Stack =
  let gobj = gtk_stack_sidebar_get_stack(cast[ptr StackSidebar00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_sidebar_set_stack(self: ptr StackSidebar00; stack: ptr Stack00) {.
    importc, libprag.}

proc setStack*(self: StackSidebar; stack: Stack) =
  gtk_stack_sidebar_set_stack(cast[ptr StackSidebar00](self.impl), cast[ptr Stack00](stack.impl))

proc `stack=`*(self: StackSidebar; stack: Stack) =
  gtk_stack_sidebar_set_stack(cast[ptr StackSidebar00](self.impl), cast[ptr Stack00](stack.impl))

proc gtk_stack_switcher_get_stack(self: ptr StackSwitcher00): ptr Stack00 {.
    importc, libprag.}

proc getStack*(self: StackSwitcher): Stack =
  let gobj = gtk_stack_switcher_get_stack(cast[ptr StackSwitcher00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc stack*(self: StackSwitcher): Stack =
  let gobj = gtk_stack_switcher_get_stack(cast[ptr StackSwitcher00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_stack_switcher_set_stack(self: ptr StackSwitcher00; stack: ptr Stack00) {.
    importc, libprag.}

proc setStack*(self: StackSwitcher; stack: Stack = nil) =
  gtk_stack_switcher_set_stack(cast[ptr StackSwitcher00](self.impl), if stack.isNil: nil else: cast[ptr Stack00](stack.impl))

proc `stack=`*(self: StackSwitcher; stack: Stack = nil) =
  gtk_stack_switcher_set_stack(cast[ptr StackSwitcher00](self.impl), if stack.isNil: nil else: cast[ptr Stack00](stack.impl))

type
  FileChooserWidget* = ref object of Box
  FileChooserWidget00* = object of Box00

proc gtk_file_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDesktopFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "desktop-folder", cast[GCallback](p), xdata, nil, cf)

proc scDownFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "down-folder", cast[GCallback](p), xdata, nil, cf)

proc scHomeFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "home-folder", cast[GCallback](p), xdata, nil, cf)

proc scLocationPopup*(self: FileChooserWidget;  p: proc (self: ptr FileChooserWidget00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "location-popup", cast[GCallback](p), xdata, nil, cf)

proc scLocationPopupOnPaste*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "location-popup-on-paste", cast[GCallback](p), xdata, nil, cf)

proc scLocationTogglePopup*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "location-toggle-popup", cast[GCallback](p), xdata, nil, cf)

proc scPlacesShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "places-shortcut", cast[GCallback](p), xdata, nil, cf)

proc scQuickBookmark*(self: FileChooserWidget;  p: proc (self: ptr FileChooserWidget00; bookmarkIndex: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "quick-bookmark", cast[GCallback](p), xdata, nil, cf)

proc scRecentShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "recent-shortcut", cast[GCallback](p), xdata, nil, cf)

proc scSearchShortcut*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "search-shortcut", cast[GCallback](p), xdata, nil, cf)

proc scShowHidden*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "show-hidden", cast[GCallback](p), xdata, nil, cf)

proc scUpFolder*(self: FileChooserWidget;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "up-folder", cast[GCallback](p), xdata, nil, cf)

type
  FileChooserDialog* = ref object of Dialog
  FileChooserDialog00* = object of Dialog00

proc gtk_file_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  FontChooserDialog* = ref object of Dialog
  FontChooserDialog00* = object of Dialog00

proc gtk_font_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FontChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_font_chooser_dialog_new(title: cstring; parent: ptr Window00): ptr FontChooserDialog00 {.
    importc, libprag.}

proc newFontChooserDialog*(title: cstring = nil; parent: Window = nil): FontChooserDialog =
  let gobj = gtk_font_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFontChooserDialog*(tdesc: typedesc; title: cstring = nil; parent: Window = nil): tdesc =
  assert(result is FontChooserDialog)
  let gobj = gtk_font_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFontChooserDialog*[T](result: var T; title: cstring = nil; parent: Window = nil) {.deprecated.} =
  assert(result is FontChooserDialog)
  let gobj = gtk_font_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  MessageDialog* = ref object of Dialog
  MessageDialog00* = object of Dialog00

proc gtk_message_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MessageDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_message_dialog_get_image(self: ptr MessageDialog00): ptr Widget00 {.
    importc, libprag.}

proc getImage*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_image(cast[ptr MessageDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc image*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_image(cast[ptr MessageDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_message_dialog_get_message_area(self: ptr MessageDialog00): ptr Widget00 {.
    importc, libprag.}

proc getMessageArea*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_message_area(cast[ptr MessageDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc messageArea*(self: MessageDialog): Widget =
  let gobj = gtk_message_dialog_get_message_area(cast[ptr MessageDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_message_dialog_set_image(self: ptr MessageDialog00; image: ptr Widget00) {.
    importc, libprag.}

proc setImage*(self: MessageDialog; image: Widget) =
  gtk_message_dialog_set_image(cast[ptr MessageDialog00](self.impl), cast[ptr Widget00](image.impl))

proc `image=`*(self: MessageDialog; image: Widget) =
  gtk_message_dialog_set_image(cast[ptr MessageDialog00](self.impl), cast[ptr Widget00](image.impl))

proc gtk_message_dialog_set_markup(self: ptr MessageDialog00; str: cstring) {.
    importc, libprag.}

proc setMarkup*(self: MessageDialog; str: cstring) =
  gtk_message_dialog_set_markup(cast[ptr MessageDialog00](self.impl), str)

proc `markup=`*(self: MessageDialog; str: cstring) =
  gtk_message_dialog_set_markup(cast[ptr MessageDialog00](self.impl), str)

type
  RecentChooserDialog* = ref object of Dialog
  RecentChooserDialog00* = object of Dialog00

proc gtk_recent_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  Calendar* = ref object of Widget
  Calendar00* = object of Widget00

proc gtk_calendar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Calendar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDaySelected*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "day-selected", cast[GCallback](p), xdata, nil, cf)

proc scDaySelectedDoubleClick*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "day-selected-double-click", cast[GCallback](p), xdata, nil, cf)

proc scMonthChanged*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "month-changed", cast[GCallback](p), xdata, nil, cf)

proc scNextMonth*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "next-month", cast[GCallback](p), xdata, nil, cf)

proc scNextYear*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "next-year", cast[GCallback](p), xdata, nil, cf)

proc scPrevMonth*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "prev-month", cast[GCallback](p), xdata, nil, cf)

proc scPrevYear*(self: Calendar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "prev-year", cast[GCallback](p), xdata, nil, cf)

proc gtk_calendar_new(): ptr Calendar00 {.
    importc, libprag.}

proc newCalendar*(): Calendar =
  let gobj = gtk_calendar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCalendar*(tdesc: typedesc): tdesc =
  assert(result is Calendar)
  let gobj = gtk_calendar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCalendar*[T](result: var T) {.deprecated.} =
  assert(result is Calendar)
  let gobj = gtk_calendar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_calendar_clear_marks(self: ptr Calendar00) {.
    importc, libprag.}

proc clearMarks*(self: Calendar) =
  gtk_calendar_clear_marks(cast[ptr Calendar00](self.impl))

proc gtk_calendar_get_date(self: ptr Calendar00; year: var uint32; month: var uint32;
    day: var uint32) {.
    importc, libprag.}

proc getDate*(self: Calendar; year: var int = cast[var int](nil);
    month: var int = cast[var int](nil); day: var int = cast[var int](nil)) =
  var day_00: uint32
  var year_00: uint32
  var month_00: uint32
  gtk_calendar_get_date(cast[ptr Calendar00](self.impl), year_00, month_00, day_00)
  if day.addr != nil:
    day = int(day_00)
  if year.addr != nil:
    year = int(year_00)
  if month.addr != nil:
    month = int(month_00)

proc gtk_calendar_get_day_is_marked(self: ptr Calendar00; day: uint32): gboolean {.
    importc, libprag.}

proc getDayIsMarked*(self: Calendar; day: int): bool =
  toBool(gtk_calendar_get_day_is_marked(cast[ptr Calendar00](self.impl), uint32(day)))

proc gtk_calendar_get_detail_height_rows(self: ptr Calendar00): int32 {.
    importc, libprag.}

proc getDetailHeightRows*(self: Calendar): int =
  int(gtk_calendar_get_detail_height_rows(cast[ptr Calendar00](self.impl)))

proc detailHeightRows*(self: Calendar): int =
  int(gtk_calendar_get_detail_height_rows(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_get_detail_width_chars(self: ptr Calendar00): int32 {.
    importc, libprag.}

proc getDetailWidthChars*(self: Calendar): int =
  int(gtk_calendar_get_detail_width_chars(cast[ptr Calendar00](self.impl)))

proc detailWidthChars*(self: Calendar): int =
  int(gtk_calendar_get_detail_width_chars(cast[ptr Calendar00](self.impl)))

proc gtk_calendar_mark_day(self: ptr Calendar00; day: uint32) {.
    importc, libprag.}

proc markDay*(self: Calendar; day: int) =
  gtk_calendar_mark_day(cast[ptr Calendar00](self.impl), uint32(day))

proc gtk_calendar_select_day(self: ptr Calendar00; day: uint32) {.
    importc, libprag.}

proc selectDay*(self: Calendar; day: int) =
  gtk_calendar_select_day(cast[ptr Calendar00](self.impl), uint32(day))

proc gtk_calendar_select_month(self: ptr Calendar00; month: uint32; year: uint32) {.
    importc, libprag.}

proc selectMonth*(self: Calendar; month: int; year: int) =
  gtk_calendar_select_month(cast[ptr Calendar00](self.impl), uint32(month), uint32(year))

proc gtk_calendar_set_detail_height_rows(self: ptr Calendar00; rows: int32) {.
    importc, libprag.}

proc setDetailHeightRows*(self: Calendar; rows: int) =
  gtk_calendar_set_detail_height_rows(cast[ptr Calendar00](self.impl), int32(rows))

proc `detailHeightRows=`*(self: Calendar; rows: int) =
  gtk_calendar_set_detail_height_rows(cast[ptr Calendar00](self.impl), int32(rows))

proc gtk_calendar_set_detail_width_chars(self: ptr Calendar00; chars: int32) {.
    importc, libprag.}

proc setDetailWidthChars*(self: Calendar; chars: int) =
  gtk_calendar_set_detail_width_chars(cast[ptr Calendar00](self.impl), int32(chars))

proc `detailWidthChars=`*(self: Calendar; chars: int) =
  gtk_calendar_set_detail_width_chars(cast[ptr Calendar00](self.impl), int32(chars))

proc gtk_calendar_unmark_day(self: ptr Calendar00; day: uint32) {.
    importc, libprag.}

proc unmarkDay*(self: Calendar; day: int) =
  gtk_calendar_unmark_day(cast[ptr Calendar00](self.impl), uint32(day))

type
  RecentAction* = ref object of Action
  RecentAction00* = object of Action00

proc gtk_recent_action_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentAction()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_recent_action_new(name: cstring; label: cstring; tooltip: cstring;
    stockId: cstring): ptr RecentAction00 {.
    importc, libprag.}

proc newRecentAction*(name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil): RecentAction {.deprecated.}  =
  let gobj = gtk_recent_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentAction*(tdesc: typedesc; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil): tdesc {.deprecated.}  =
  assert(result is RecentAction)
  let gobj = gtk_recent_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentAction*[T](result: var T; name: cstring; label: cstring = nil; tooltip: cstring = nil;
    stockId: cstring = nil) {.deprecated.} =
  assert(result is RecentAction)
  let gobj = gtk_recent_action_new(name, label, tooltip, stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_action_new_for_manager(name: cstring; label: cstring; tooltip: cstring;
    stockId: cstring; manager: ptr RecentManager00): ptr RecentAction00 {.
    importc, libprag.}

proc newRecentActionForManager*(name: cstring; label: cstring = nil;
    tooltip: cstring = nil; stockId: cstring = nil; manager: RecentManager = nil): RecentAction {.deprecated.}  =
  let gobj = gtk_recent_action_new_for_manager(name, label, tooltip, stockId, if manager.isNil: nil else: cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentActionForManager*(tdesc: typedesc; name: cstring; label: cstring = nil;
    tooltip: cstring = nil; stockId: cstring = nil; manager: RecentManager = nil): tdesc {.deprecated.}  =
  assert(result is RecentAction)
  let gobj = gtk_recent_action_new_for_manager(name, label, tooltip, stockId, if manager.isNil: nil else: cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentActionForManager*[T](result: var T; name: cstring; label: cstring = nil;
    tooltip: cstring = nil; stockId: cstring = nil; manager: RecentManager = nil) {.deprecated.} =
  assert(result is RecentAction)
  let gobj = gtk_recent_action_new_for_manager(name, label, tooltip, stockId, if manager.isNil: nil else: cast[ptr RecentManager00](manager.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_action_get_show_numbers(self: ptr RecentAction00): gboolean {.
    importc, libprag.}

proc getShowNumbers*(self: RecentAction): bool =
  toBool(gtk_recent_action_get_show_numbers(cast[ptr RecentAction00](self.impl)))

proc showNumbers*(self: RecentAction): bool =
  toBool(gtk_recent_action_get_show_numbers(cast[ptr RecentAction00](self.impl)))

proc gtk_recent_action_set_show_numbers(self: ptr RecentAction00; showNumbers: gboolean) {.
    importc, libprag.}

proc setShowNumbers*(self: RecentAction; showNumbers: bool = true) =
  gtk_recent_action_set_show_numbers(cast[ptr RecentAction00](self.impl), gboolean(showNumbers))

proc `showNumbers=`*(self: RecentAction; showNumbers: bool) =
  gtk_recent_action_set_show_numbers(cast[ptr RecentAction00](self.impl), gboolean(showNumbers))

type
  SearchBar* = ref object of Bin
  SearchBar00* = object of Bin00

proc gtk_search_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SearchBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_search_bar_new(): ptr SearchBar00 {.
    importc, libprag.}

proc newSearchBar*(): SearchBar =
  let gobj = gtk_search_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newSearchBar*(tdesc: typedesc): tdesc =
  assert(result is SearchBar)
  let gobj = gtk_search_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initSearchBar*[T](result: var T) {.deprecated.} =
  assert(result is SearchBar)
  let gobj = gtk_search_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_search_bar_connect_entry(self: ptr SearchBar00; entry: ptr Entry00) {.
    importc, libprag.}

proc connectEntry*(self: SearchBar; entry: Entry) =
  gtk_search_bar_connect_entry(cast[ptr SearchBar00](self.impl), cast[ptr Entry00](entry.impl))

proc gtk_search_bar_get_search_mode(self: ptr SearchBar00): gboolean {.
    importc, libprag.}

proc getSearchMode*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_search_mode(cast[ptr SearchBar00](self.impl)))

proc searchMode*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_search_mode(cast[ptr SearchBar00](self.impl)))

proc gtk_search_bar_get_show_close_button(self: ptr SearchBar00): gboolean {.
    importc, libprag.}

proc getShowCloseButton*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_show_close_button(cast[ptr SearchBar00](self.impl)))

proc showCloseButton*(self: SearchBar): bool =
  toBool(gtk_search_bar_get_show_close_button(cast[ptr SearchBar00](self.impl)))

proc gtk_search_bar_handle_event(self: ptr SearchBar00; event: ptr gdk.Event00): gboolean {.
    importc, libprag.}

proc handleEvent*(self: SearchBar; event: gdk.Event): bool =
  toBool(gtk_search_bar_handle_event(cast[ptr SearchBar00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_search_bar_set_search_mode(self: ptr SearchBar00; searchMode: gboolean) {.
    importc, libprag.}

proc setSearchMode*(self: SearchBar; searchMode: bool = true) =
  gtk_search_bar_set_search_mode(cast[ptr SearchBar00](self.impl), gboolean(searchMode))

proc `searchMode=`*(self: SearchBar; searchMode: bool) =
  gtk_search_bar_set_search_mode(cast[ptr SearchBar00](self.impl), gboolean(searchMode))

proc gtk_search_bar_set_show_close_button(self: ptr SearchBar00; visible: gboolean) {.
    importc, libprag.}

proc setShowCloseButton*(self: SearchBar; visible: bool = true) =
  gtk_search_bar_set_show_close_button(cast[ptr SearchBar00](self.impl), gboolean(visible))

proc `showCloseButton=`*(self: SearchBar; visible: bool) =
  gtk_search_bar_set_show_close_button(cast[ptr SearchBar00](self.impl), gboolean(visible))

type
  Invisible* = ref object of Widget
  Invisible00* = object of Widget00

proc gtk_invisible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Invisible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_invisible_new(): ptr Invisible00 {.
    importc, libprag.}

proc newInvisible*(): Invisible =
  let gobj = gtk_invisible_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newInvisible*(tdesc: typedesc): tdesc =
  assert(result is Invisible)
  let gobj = gtk_invisible_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInvisible*[T](result: var T) {.deprecated.} =
  assert(result is Invisible)
  let gobj = gtk_invisible_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_invisible_new_for_screen(screen: ptr gdk.Screen00): ptr Invisible00 {.
    importc, libprag.}

proc newInvisibleForScreen*(screen: gdk.Screen): Invisible =
  let gobj = gtk_invisible_new_for_screen(cast[ptr gdk.Screen00](screen.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newInvisibleForScreen*(tdesc: typedesc; screen: gdk.Screen): tdesc =
  assert(result is Invisible)
  let gobj = gtk_invisible_new_for_screen(cast[ptr gdk.Screen00](screen.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInvisibleForScreen*[T](result: var T; screen: gdk.Screen) {.deprecated.} =
  assert(result is Invisible)
  let gobj = gtk_invisible_new_for_screen(cast[ptr gdk.Screen00](screen.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_invisible_get_screen(self: ptr Invisible00): ptr gdk.Screen00 {.
    importc, libprag.}

proc getScreen*(self: Invisible): gdk.Screen =
  let gobj = gtk_invisible_get_screen(cast[ptr Invisible00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: Invisible): gdk.Screen =
  let gobj = gtk_invisible_get_screen(cast[ptr Invisible00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_invisible_set_screen(self: ptr Invisible00; screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc setScreen*(self: Invisible; screen: gdk.Screen) =
  gtk_invisible_set_screen(cast[ptr Invisible00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: Invisible; screen: gdk.Screen) =
  gtk_invisible_set_screen(cast[ptr Invisible00](self.impl), cast[ptr gdk.Screen00](screen.impl))

type
  TreeView* = ref object of Container
  TreeView00* = object of Container00

proc gtk_tree_view_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeView()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scColumnsChanged*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "columns-changed", cast[GCallback](p), xdata, nil, cf)

proc scCursorChanged*(self: TreeView;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cursor-changed", cast[GCallback](p), xdata, nil, cf)

proc scExpandCollapseCursorRow*(self: TreeView;  p: proc (self: ptr TreeView00; `object`: gboolean; p0: gboolean; p1: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "expand-collapse-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: TreeView;  p: proc (self: ptr TreeView00; step: MovementStep; direction: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scRowActivated*(self: TreeView;  p: proc (self: ptr TreeView00; path: ptr TreePath00; column: ptr TreeViewColumn00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-activated", cast[GCallback](p), xdata, nil, cf)

proc scRowCollapsed*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-collapsed", cast[GCallback](p), xdata, nil, cf)

proc scRowExpanded*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-expanded", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectCursorParent*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-cursor-parent", cast[GCallback](p), xdata, nil, cf)

proc scSelectCursorRow*(self: TreeView;  p: proc (self: ptr TreeView00; `object`: gboolean; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scStartInteractiveSearch*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "start-interactive-search", cast[GCallback](p), xdata, nil, cf)

proc scTestCollapseRow*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "test-collapse-row", cast[GCallback](p), xdata, nil, cf)

proc scTestExpandRow*(self: TreeView;  p: proc (self: ptr TreeView00; iter: TreeIter; path: ptr TreePath00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "test-expand-row", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorRow*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: TreeView;  p: proc (self: ptr TreeView00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_view_new(): ptr TreeView00 {.
    importc, libprag.}

proc newTreeView*(): TreeView =
  let gobj = gtk_tree_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeView*(tdesc: typedesc): tdesc =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeView*[T](result: var T) {.deprecated.} =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_new_with_model(model: ptr TreeModel00): ptr TreeView00 {.
    importc, libprag.}

proc newTreeViewWithModel*(model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): TreeView =
  let gobj = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newTreeViewWithModel*(tdesc: typedesc; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore): tdesc =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initTreeViewWithModel*[T](result: var T; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) {.deprecated.} =
  assert(result is TreeView)
  let gobj = gtk_tree_view_new_with_model(cast[ptr TreeModel00](model.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_append_column(self: ptr TreeView00; column: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc appendColumn*(self: TreeView; column: TreeViewColumn): int =
  int(gtk_tree_view_append_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl)))

proc gtk_tree_view_collapse_all(self: ptr TreeView00) {.
    importc, libprag.}

proc collapseAll*(self: TreeView) =
  gtk_tree_view_collapse_all(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_collapse_row(self: ptr TreeView00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc collapseRow*(self: TreeView; path: TreePath): bool =
  toBool(gtk_tree_view_collapse_row(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_view_columns_autosize(self: ptr TreeView00) {.
    importc, libprag.}

proc columnsAutosize*(self: TreeView) =
  gtk_tree_view_columns_autosize(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_convert_bin_window_to_tree_coords(self: ptr TreeView00;
    bx: int32; by: int32; tx: var int32; ty: var int32) {.
    importc, libprag.}

proc convertBinWindowToTreeCoords*(self: TreeView; bx: int;
    by: int; tx: var int; ty: var int) =
  var tx_00: int32
  var ty_00: int32
  gtk_tree_view_convert_bin_window_to_tree_coords(cast[ptr TreeView00](self.impl), int32(bx), int32(by), tx_00, ty_00)
  if tx.addr != nil:
    tx = int(tx_00)
  if ty.addr != nil:
    ty = int(ty_00)

proc gtk_tree_view_convert_bin_window_to_widget_coords(self: ptr TreeView00;
    bx: int32; by: int32; wx: var int32; wy: var int32) {.
    importc, libprag.}

proc convertBinWindowToWidgetCoords*(self: TreeView; bx: int;
    by: int; wx: var int; wy: var int) =
  var wy_00: int32
  var wx_00: int32
  gtk_tree_view_convert_bin_window_to_widget_coords(cast[ptr TreeView00](self.impl), int32(bx), int32(by), wx_00, wy_00)
  if wy.addr != nil:
    wy = int(wy_00)
  if wx.addr != nil:
    wx = int(wx_00)

proc gtk_tree_view_convert_tree_to_bin_window_coords(self: ptr TreeView00;
    tx: int32; ty: int32; bx: var int32; by: var int32) {.
    importc, libprag.}

proc convertTreeToBinWindowCoords*(self: TreeView; tx: int;
    ty: int; bx: var int; by: var int) =
  var bx_00: int32
  var by_00: int32
  gtk_tree_view_convert_tree_to_bin_window_coords(cast[ptr TreeView00](self.impl), int32(tx), int32(ty), bx_00, by_00)
  if bx.addr != nil:
    bx = int(bx_00)
  if by.addr != nil:
    by = int(by_00)

proc gtk_tree_view_convert_tree_to_widget_coords(self: ptr TreeView00; tx: int32;
    ty: int32; wx: var int32; wy: var int32) {.
    importc, libprag.}

proc convertTreeToWidgetCoords*(self: TreeView; tx: int;
    ty: int; wx: var int; wy: var int) =
  var wy_00: int32
  var wx_00: int32
  gtk_tree_view_convert_tree_to_widget_coords(cast[ptr TreeView00](self.impl), int32(tx), int32(ty), wx_00, wy_00)
  if wy.addr != nil:
    wy = int(wy_00)
  if wx.addr != nil:
    wx = int(wx_00)

proc gtk_tree_view_convert_widget_to_bin_window_coords(self: ptr TreeView00;
    wx: int32; wy: int32; bx: var int32; by: var int32) {.
    importc, libprag.}

proc convertWidgetToBinWindowCoords*(self: TreeView; wx: int;
    wy: int; bx: var int; by: var int) =
  var bx_00: int32
  var by_00: int32
  gtk_tree_view_convert_widget_to_bin_window_coords(cast[ptr TreeView00](self.impl), int32(wx), int32(wy), bx_00, by_00)
  if bx.addr != nil:
    bx = int(bx_00)
  if by.addr != nil:
    by = int(by_00)

proc gtk_tree_view_convert_widget_to_tree_coords(self: ptr TreeView00; wx: int32;
    wy: int32; tx: var int32; ty: var int32) {.
    importc, libprag.}

proc convertWidgetToTreeCoords*(self: TreeView; wx: int;
    wy: int; tx: var int; ty: var int) =
  var tx_00: int32
  var ty_00: int32
  gtk_tree_view_convert_widget_to_tree_coords(cast[ptr TreeView00](self.impl), int32(wx), int32(wy), tx_00, ty_00)
  if tx.addr != nil:
    tx = int(tx_00)
  if ty.addr != nil:
    ty = int(ty_00)

proc gtk_tree_view_create_row_drag_icon(self: ptr TreeView00; path: ptr TreePath00): ptr cairo.Surface00 {.
    importc, libprag.}

proc createRowDragIcon*(self: TreeView; path: TreePath): cairo.Surface =
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = gtk_tree_view_create_row_drag_icon(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_enable_model_drag_dest(self: ptr TreeView00; targets: ptr TargetEntry00;
    nTargets: int32; actions: gdk.DragAction) {.
    importc, libprag.}

proc enableModelDragDest*(self: TreeView; targets: seq[TargetEntry];
    actions: gdk.DragAction) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_tree_view_enable_model_drag_dest(cast[ptr TreeView00](self.impl), seq2TargetEntryArray(targets, fs469n23), int32(nTargets), actions)

proc gtk_tree_view_enable_model_drag_source(self: ptr TreeView00; startButtonMask: gdk.ModifierType;
    targets: ptr TargetEntry00; nTargets: int32; actions: gdk.DragAction) {.
    importc, libprag.}

proc enableModelDragSource*(self: TreeView; startButtonMask: gdk.ModifierType;
    targets: seq[TargetEntry]; actions: gdk.DragAction) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_tree_view_enable_model_drag_source(cast[ptr TreeView00](self.impl), startButtonMask, seq2TargetEntryArray(targets, fs469n23), int32(nTargets), actions)

proc gtk_tree_view_expand_all(self: ptr TreeView00) {.
    importc, libprag.}

proc expandAll*(self: TreeView) =
  gtk_tree_view_expand_all(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_expand_row(self: ptr TreeView00; path: ptr TreePath00;
    openAll: gboolean): gboolean {.
    importc, libprag.}

proc expandRow*(self: TreeView; path: TreePath; openAll: bool): bool =
  toBool(gtk_tree_view_expand_row(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), gboolean(openAll)))

proc gtk_tree_view_expand_to_path(self: ptr TreeView00; path: ptr TreePath00) {.
    importc, libprag.}

proc expandToPath*(self: TreeView; path: TreePath) =
  gtk_tree_view_expand_to_path(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_get_activate_on_single_click(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: TreeView): bool =
  toBool(gtk_tree_view_get_activate_on_single_click(cast[ptr TreeView00](self.impl)))

proc activateOnSingleClick*(self: TreeView): bool =
  toBool(gtk_tree_view_get_activate_on_single_click(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_background_area(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00; rect: var gdk.Rectangle) {.
    importc, libprag.}

proc getBackgroundArea*(self: TreeView; path: TreePath = nil;
    column: TreeViewColumn = nil; rect: var gdk.Rectangle) =
  gtk_tree_view_get_background_area(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), rect)

proc gtk_tree_view_get_bin_window(self: ptr TreeView00): ptr gdk.Window00 {.
    importc, libprag.}

proc getBinWindow*(self: TreeView): gdk.Window =
  let gobj = gtk_tree_view_get_bin_window(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc binWindow*(self: TreeView): gdk.Window =
  let gobj = gtk_tree_view_get_bin_window(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_cell_area(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00; rect: var gdk.Rectangle) {.
    importc, libprag.}

proc getCellArea*(self: TreeView; path: TreePath = nil; column: TreeViewColumn = nil;
    rect: var gdk.Rectangle) =
  gtk_tree_view_get_cell_area(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), rect)

proc gtk_tree_view_get_column(self: ptr TreeView00; n: int32): ptr TreeViewColumn00 {.
    importc, libprag.}

proc getColumn*(self: TreeView; n: int): TreeViewColumn =
  let gobj = gtk_tree_view_get_column(cast[ptr TreeView00](self.impl), int32(n))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_columns(self: ptr TreeView00): ptr glib.List {.
    importc, libprag.}

proc getColumns*(self: TreeView): seq[TreeViewColumn] =
  let resul0 = gtk_tree_view_get_columns(cast[ptr TreeView00](self.impl))
  result = glistObjects2seq(TreeViewColumn, resul0, false)
  g_list_free(resul0)

proc columns*(self: TreeView): seq[TreeViewColumn] =
  let resul0 = gtk_tree_view_get_columns(cast[ptr TreeView00](self.impl))
  result = glistObjects2seq(TreeViewColumn, resul0, false)
  g_list_free(resul0)

proc gtk_tree_view_get_cursor(self: ptr TreeView00; path: var ptr TreePath00;
    focusColumn: var ptr TreeViewColumn00) {.
    importc, libprag.}

proc getCursor*(self: TreeView; path: var TreePath = cast[var TreePath](nil);
    focusColumn: var TreeViewColumn = cast[var TreeViewColumn](nil)) =
  var tmpoutgobjectarg: ptr TreeViewColumn00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  gtk_tree_view_get_cursor(cast[ptr TreeView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr TreeViewColumn00](if addr(focusColumn) == nil: nil else: addr tmpoutgobjectarg))
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(focusColumn
  if addr(focusColumn) != nil:
    focusColumn = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      focusColumn = cast[type(focusColumn)](argqdata)
      assert(focusColumn.impl == tmpoutgobjectarg)
    else:
      fnew(focusColumn, gtk.finalizeGObject)
      focusColumn.impl = tmpoutgobjectarg
      GC_ref(focusColumn)
      if g_object_is_floating(focusColumn.impl).int != 0:
        discard g_object_ref_sink(focusColumn.impl)
      g_object_add_toggle_ref(focusColumn.impl, toggleNotify, addr(focusColumn[]))
      g_object_unref(focusColumn.impl)
      assert(g_object_get_qdata(focusColumn.impl, Quark) == nil)
      g_object_set_qdata(focusColumn.impl, Quark, addr(focusColumn[]))


proc gtk_tree_view_get_enable_search(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getEnableSearch*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_search(cast[ptr TreeView00](self.impl)))

proc enableSearch*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_search(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_enable_tree_lines(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getEnableTreeLines*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_tree_lines(cast[ptr TreeView00](self.impl)))

proc enableTreeLines*(self: TreeView): bool =
  toBool(gtk_tree_view_get_enable_tree_lines(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_expander_column(self: ptr TreeView00): ptr TreeViewColumn00 {.
    importc, libprag.}

proc getExpanderColumn*(self: TreeView): TreeViewColumn =
  let gobj = gtk_tree_view_get_expander_column(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc expanderColumn*(self: TreeView): TreeViewColumn =
  let gobj = gtk_tree_view_get_expander_column(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_fixed_height_mode(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getFixedHeightMode*(self: TreeView): bool =
  toBool(gtk_tree_view_get_fixed_height_mode(cast[ptr TreeView00](self.impl)))

proc fixedHeightMode*(self: TreeView): bool =
  toBool(gtk_tree_view_get_fixed_height_mode(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hadjustment(self: ptr TreeView00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_hadjustment(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_hadjustment(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_headers_clickable(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHeadersClickable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_clickable(cast[ptr TreeView00](self.impl)))

proc headersClickable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_clickable(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_headers_visible(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHeadersVisible*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_visible(cast[ptr TreeView00](self.impl)))

proc headersVisible*(self: TreeView): bool =
  toBool(gtk_tree_view_get_headers_visible(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hover_expand(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHoverExpand*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_expand(cast[ptr TreeView00](self.impl)))

proc hoverExpand*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_expand(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_hover_selection(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getHoverSelection*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_selection(cast[ptr TreeView00](self.impl)))

proc hoverSelection*(self: TreeView): bool =
  toBool(gtk_tree_view_get_hover_selection(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_level_indentation(self: ptr TreeView00): int32 {.
    importc, libprag.}

proc getLevelIndentation*(self: TreeView): int =
  int(gtk_tree_view_get_level_indentation(cast[ptr TreeView00](self.impl)))

proc levelIndentation*(self: TreeView): int =
  int(gtk_tree_view_get_level_indentation(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_model(self: ptr TreeView00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeView): TreeModel =
  let gobj = gtk_tree_view_get_model(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeView): TreeModel =
  let gobj = gtk_tree_view_get_model(cast[ptr TreeView00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_n_columns(self: ptr TreeView00): uint32 {.
    importc, libprag.}

proc getNColumns*(self: TreeView): int =
  int(gtk_tree_view_get_n_columns(cast[ptr TreeView00](self.impl)))

proc nColumns*(self: TreeView): int =
  int(gtk_tree_view_get_n_columns(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_path_at_pos(self: ptr TreeView00; x: int32; y: int32;
    path: var ptr TreePath00; column: var ptr TreeViewColumn00; cellX: var int32;
    cellY: var int32): gboolean {.
    importc, libprag.}

proc getPathAtPos*(self: TreeView; x: int; y: int; path: var TreePath = cast[var TreePath](nil);
    column: var TreeViewColumn = cast[var TreeViewColumn](nil); cellX: var int = cast[var int](nil);
    cellY: var int = cast[var int](nil)): bool =
  var tmpoutgobjectarg: ptr TreeViewColumn00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  var cellX_00: int32
  var cellY_00: int32
  result = toBool(gtk_tree_view_get_path_at_pos(cast[ptr TreeView00](self.impl), int32(x), int32(y), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr TreeViewColumn00](if addr(column) == nil: nil else: addr tmpoutgobjectarg), cellX_00, cellY_00))
  if cellX.addr != nil:
    cellX = int(cellX_00)
  if cellY.addr != nil:
    cellY = int(cellY_00)
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(column
  if addr(column) != nil:
    column = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      column = cast[type(column)](argqdata)
      assert(column.impl == tmpoutgobjectarg)
    else:
      fnew(column, gtk.finalizeGObject)
      column.impl = tmpoutgobjectarg
      GC_ref(column)
      if g_object_is_floating(column.impl).int != 0:
        discard g_object_ref_sink(column.impl)
      g_object_add_toggle_ref(column.impl, toggleNotify, addr(column[]))
      g_object_unref(column.impl)
      assert(g_object_get_qdata(column.impl, Quark) == nil)
      g_object_set_qdata(column.impl, Quark, addr(column[]))


proc gtk_tree_view_get_reorderable(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getReorderable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_reorderable(cast[ptr TreeView00](self.impl)))

proc reorderable*(self: TreeView): bool =
  toBool(gtk_tree_view_get_reorderable(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_rubber_banding(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getRubberBanding*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rubber_banding(cast[ptr TreeView00](self.impl)))

proc rubberBanding*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rubber_banding(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_rules_hint(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getRulesHint*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rules_hint(cast[ptr TreeView00](self.impl)))

proc rulesHint*(self: TreeView): bool =
  toBool(gtk_tree_view_get_rules_hint(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_search_column(self: ptr TreeView00): int32 {.
    importc, libprag.}

proc getSearchColumn*(self: TreeView): int =
  int(gtk_tree_view_get_search_column(cast[ptr TreeView00](self.impl)))

proc searchColumn*(self: TreeView): int =
  int(gtk_tree_view_get_search_column(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_search_entry(self: ptr TreeView00): ptr Entry00 {.
    importc, libprag.}

proc getSearchEntry*(self: TreeView): Entry =
  let gobj = gtk_tree_view_get_search_entry(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc searchEntry*(self: TreeView): Entry =
  let gobj = gtk_tree_view_get_search_entry(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_show_expanders(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc getShowExpanders*(self: TreeView): bool =
  toBool(gtk_tree_view_get_show_expanders(cast[ptr TreeView00](self.impl)))

proc showExpanders*(self: TreeView): bool =
  toBool(gtk_tree_view_get_show_expanders(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_tooltip_column(self: ptr TreeView00): int32 {.
    importc, libprag.}

proc getTooltipColumn*(self: TreeView): int =
  int(gtk_tree_view_get_tooltip_column(cast[ptr TreeView00](self.impl)))

proc tooltipColumn*(self: TreeView): int =
  int(gtk_tree_view_get_tooltip_column(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_get_tooltip_context(self: ptr TreeView00; x: var int32;
    y: var int32; keyboardTip: gboolean; model: var ptr TreeModel00; path: var ptr TreePath00;
    iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getTooltipContext*(self: TreeView; x: var int; y: var int;
    keyboardTip: bool; model: var (TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) = cast[var TreeModel](nil);
    path: var TreePath = cast[var TreePath](nil); iter: var TreeIter = cast[var TreeIter](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  var y_00 = int32(y)
  var x_00 = int32(x)
  result = toBool(gtk_tree_view_get_tooltip_context(cast[ptr TreeView00](self.impl), x_00, y_00, gboolean(keyboardTip), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), iter))
  y = int(y_00)
  x = int(x_00)
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_tree_view_get_vadjustment(self: ptr TreeView00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_vadjustment(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: TreeView): Adjustment =
  let gobj = gtk_tree_view_get_vadjustment(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_view_get_visible_range(self: ptr TreeView00; startPath: var ptr TreePath00;
    endPath: var ptr TreePath00): gboolean {.
    importc, libprag.}

proc getVisibleRange*(self: TreeView; startPath: var TreePath = cast[var TreePath](nil);
    endPath: var TreePath = cast[var TreePath](nil)): bool =
  if addr(startPath) != nil:
    fnew(startPath, gBoxedFreeGtkTreePath)
  if addr(endPath) != nil:
    fnew(endPath, gBoxedFreeGtkTreePath)
  toBool(gtk_tree_view_get_visible_range(cast[ptr TreeView00](self.impl), cast[var ptr TreePath00](if addr(startPath) == nil: nil else: addr startPath.impl), cast[var ptr TreePath00](if addr(endPath) == nil: nil else: addr endPath.impl)))

proc gtk_tree_view_get_visible_rect(self: ptr TreeView00; visibleRect: var gdk.Rectangle) {.
    importc, libprag.}

proc getVisibleRect*(self: TreeView; visibleRect: var gdk.Rectangle) =
  gtk_tree_view_get_visible_rect(cast[ptr TreeView00](self.impl), visibleRect)

proc getVisibleRect*(self: TreeView): gdk.Rectangle =
  gtk_tree_view_get_visible_rect(cast[ptr TreeView00](self.impl), result)

proc gtk_tree_view_insert_column(self: ptr TreeView00; column: ptr TreeViewColumn00;
    position: int32): int32 {.
    importc, libprag.}

proc insertColumn*(self: TreeView; column: TreeViewColumn;
    position: int): int =
  int(gtk_tree_view_insert_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl), int32(position)))

proc gtk_tree_view_is_blank_at_pos(self: ptr TreeView00; x: int32; y: int32;
    path: var ptr TreePath00; column: var ptr TreeViewColumn00; cellX: var int32;
    cellY: var int32): gboolean {.
    importc, libprag.}

proc isBlankAtPos*(self: TreeView; x: int; y: int; path: var TreePath = cast[var TreePath](nil);
    column: var TreeViewColumn = cast[var TreeViewColumn](nil); cellX: var int = cast[var int](nil);
    cellY: var int = cast[var int](nil)): bool =
  var tmpoutgobjectarg: ptr TreeViewColumn00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  var cellX_00: int32
  var cellY_00: int32
  result = toBool(gtk_tree_view_is_blank_at_pos(cast[ptr TreeView00](self.impl), int32(x), int32(y), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), cast[var ptr TreeViewColumn00](if addr(column) == nil: nil else: addr tmpoutgobjectarg), cellX_00, cellY_00))
  if cellX.addr != nil:
    cellX = int(cellX_00)
  if cellY.addr != nil:
    cellY = int(cellY_00)
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(column
  if addr(column) != nil:
    column = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      column = cast[type(column)](argqdata)
      assert(column.impl == tmpoutgobjectarg)
    else:
      fnew(column, gtk.finalizeGObject)
      column.impl = tmpoutgobjectarg
      GC_ref(column)
      if g_object_is_floating(column.impl).int != 0:
        discard g_object_ref_sink(column.impl)
      g_object_add_toggle_ref(column.impl, toggleNotify, addr(column[]))
      g_object_unref(column.impl)
      assert(g_object_get_qdata(column.impl, Quark) == nil)
      g_object_set_qdata(column.impl, Quark, addr(column[]))


proc gtk_tree_view_is_rubber_banding_active(self: ptr TreeView00): gboolean {.
    importc, libprag.}

proc isRubberBandingActive*(self: TreeView): bool =
  toBool(gtk_tree_view_is_rubber_banding_active(cast[ptr TreeView00](self.impl)))

proc gtk_tree_view_move_column_after(self: ptr TreeView00; column: ptr TreeViewColumn00;
    baseColumn: ptr TreeViewColumn00) {.
    importc, libprag.}

proc moveColumnAfter*(self: TreeView; column: TreeViewColumn;
    baseColumn: TreeViewColumn = nil) =
  gtk_tree_view_move_column_after(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl), if baseColumn.isNil: nil else: cast[ptr TreeViewColumn00](baseColumn.impl))

proc gtk_tree_view_remove_column(self: ptr TreeView00; column: ptr TreeViewColumn00): int32 {.
    importc, libprag.}

proc removeColumn*(self: TreeView; column: TreeViewColumn): int =
  int(gtk_tree_view_remove_column(cast[ptr TreeView00](self.impl), cast[ptr TreeViewColumn00](column.impl)))

proc gtk_tree_view_row_activated(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00) {.
    importc, libprag.}

proc rowActivated*(self: TreeView; path: TreePath; column: TreeViewColumn) =
  gtk_tree_view_row_activated(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr TreeViewColumn00](column.impl))

proc gtk_tree_view_row_expanded(self: ptr TreeView00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc rowExpanded*(self: TreeView; path: TreePath): bool =
  toBool(gtk_tree_view_row_expanded(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_view_scroll_to_cell(self: ptr TreeView00; path: ptr TreePath00;
    column: ptr TreeViewColumn00; useAlign: gboolean; rowAlign: cfloat; colAlign: cfloat) {.
    importc, libprag.}

proc scrollToCell*(self: TreeView; path: TreePath = nil; column: TreeViewColumn = nil;
    useAlign: bool; rowAlign: cfloat; colAlign: cfloat) =
  gtk_tree_view_scroll_to_cell(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), gboolean(useAlign), rowAlign, colAlign)

proc gtk_tree_view_scroll_to_point(self: ptr TreeView00; treeX: int32; treeY: int32) {.
    importc, libprag.}

proc scrollToPoint*(self: TreeView; treeX: int; treeY: int) =
  gtk_tree_view_scroll_to_point(cast[ptr TreeView00](self.impl), int32(treeX), int32(treeY))

proc gtk_tree_view_set_activate_on_single_click(self: ptr TreeView00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: TreeView; single: bool = true) =
  gtk_tree_view_set_activate_on_single_click(cast[ptr TreeView00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: TreeView; single: bool) =
  gtk_tree_view_set_activate_on_single_click(cast[ptr TreeView00](self.impl), gboolean(single))

proc gtk_tree_view_set_cursor(self: ptr TreeView00; path: ptr TreePath00;
    focusColumn: ptr TreeViewColumn00; startEditing: gboolean) {.
    importc, libprag.}

proc setCursor*(self: TreeView; path: TreePath; focusColumn: TreeViewColumn = nil;
    startEditing: bool) =
  gtk_tree_view_set_cursor(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), if focusColumn.isNil: nil else: cast[ptr TreeViewColumn00](focusColumn.impl), gboolean(startEditing))

proc gtk_tree_view_set_cursor_on_cell(self: ptr TreeView00; path: ptr TreePath00;
    focusColumn: ptr TreeViewColumn00; focusCell: ptr CellRenderer00; startEditing: gboolean) {.
    importc, libprag.}

proc setCursorOnCell*(self: TreeView; path: TreePath; focusColumn: TreeViewColumn = nil;
    focusCell: CellRenderer = nil; startEditing: bool) =
  gtk_tree_view_set_cursor_on_cell(cast[ptr TreeView00](self.impl), cast[ptr TreePath00](path.impl), if focusColumn.isNil: nil else: cast[ptr TreeViewColumn00](focusColumn.impl), if focusCell.isNil: nil else: cast[ptr CellRenderer00](focusCell.impl), gboolean(startEditing))

proc gtk_tree_view_set_enable_search(self: ptr TreeView00; enableSearch: gboolean) {.
    importc, libprag.}

proc setEnableSearch*(self: TreeView; enableSearch: bool = true) =
  gtk_tree_view_set_enable_search(cast[ptr TreeView00](self.impl), gboolean(enableSearch))

proc `enableSearch=`*(self: TreeView; enableSearch: bool) =
  gtk_tree_view_set_enable_search(cast[ptr TreeView00](self.impl), gboolean(enableSearch))

proc gtk_tree_view_set_enable_tree_lines(self: ptr TreeView00; enabled: gboolean) {.
    importc, libprag.}

proc setEnableTreeLines*(self: TreeView; enabled: bool = true) =
  gtk_tree_view_set_enable_tree_lines(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc `enableTreeLines=`*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_enable_tree_lines(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc gtk_tree_view_set_expander_column(self: ptr TreeView00; column: ptr TreeViewColumn00) {.
    importc, libprag.}

proc setExpanderColumn*(self: TreeView; column: TreeViewColumn = nil) =
  gtk_tree_view_set_expander_column(cast[ptr TreeView00](self.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl))

proc `expanderColumn=`*(self: TreeView; column: TreeViewColumn = nil) =
  gtk_tree_view_set_expander_column(cast[ptr TreeView00](self.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl))

proc gtk_tree_view_set_fixed_height_mode(self: ptr TreeView00; enable: gboolean) {.
    importc, libprag.}

proc setFixedHeightMode*(self: TreeView; enable: bool = true) =
  gtk_tree_view_set_fixed_height_mode(cast[ptr TreeView00](self.impl), gboolean(enable))

proc `fixedHeightMode=`*(self: TreeView; enable: bool) =
  gtk_tree_view_set_fixed_height_mode(cast[ptr TreeView00](self.impl), gboolean(enable))

proc gtk_tree_view_set_hadjustment(self: ptr TreeView00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: TreeView; adjustment: Adjustment = nil) =
  gtk_tree_view_set_hadjustment(cast[ptr TreeView00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: TreeView; adjustment: Adjustment = nil) =
  gtk_tree_view_set_hadjustment(cast[ptr TreeView00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_tree_view_set_headers_clickable(self: ptr TreeView00; setting: gboolean) {.
    importc, libprag.}

proc setHeadersClickable*(self: TreeView; setting: bool = true) =
  gtk_tree_view_set_headers_clickable(cast[ptr TreeView00](self.impl), gboolean(setting))

proc `headersClickable=`*(self: TreeView; setting: bool) =
  gtk_tree_view_set_headers_clickable(cast[ptr TreeView00](self.impl), gboolean(setting))

proc gtk_tree_view_set_headers_visible(self: ptr TreeView00; headersVisible: gboolean) {.
    importc, libprag.}

proc setHeadersVisible*(self: TreeView; headersVisible: bool = true) =
  gtk_tree_view_set_headers_visible(cast[ptr TreeView00](self.impl), gboolean(headersVisible))

proc `headersVisible=`*(self: TreeView; headersVisible: bool) =
  gtk_tree_view_set_headers_visible(cast[ptr TreeView00](self.impl), gboolean(headersVisible))

proc gtk_tree_view_set_hover_expand(self: ptr TreeView00; expand: gboolean) {.
    importc, libprag.}

proc setHoverExpand*(self: TreeView; expand: bool = true) =
  gtk_tree_view_set_hover_expand(cast[ptr TreeView00](self.impl), gboolean(expand))

proc `hoverExpand=`*(self: TreeView; expand: bool) =
  gtk_tree_view_set_hover_expand(cast[ptr TreeView00](self.impl), gboolean(expand))

proc gtk_tree_view_set_hover_selection(self: ptr TreeView00; hover: gboolean) {.
    importc, libprag.}

proc setHoverSelection*(self: TreeView; hover: bool = true) =
  gtk_tree_view_set_hover_selection(cast[ptr TreeView00](self.impl), gboolean(hover))

proc `hoverSelection=`*(self: TreeView; hover: bool) =
  gtk_tree_view_set_hover_selection(cast[ptr TreeView00](self.impl), gboolean(hover))

proc gtk_tree_view_set_level_indentation(self: ptr TreeView00; indentation: int32) {.
    importc, libprag.}

proc setLevelIndentation*(self: TreeView; indentation: int) =
  gtk_tree_view_set_level_indentation(cast[ptr TreeView00](self.impl), int32(indentation))

proc `levelIndentation=`*(self: TreeView; indentation: int) =
  gtk_tree_view_set_level_indentation(cast[ptr TreeView00](self.impl), int32(indentation))

proc gtk_tree_view_set_model(self: ptr TreeView00; model: ptr TreeModel00) {.
    importc, libprag.}

proc setModel*(self: TreeView; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_tree_view_set_model(cast[ptr TreeView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc `model=`*(self: TreeView; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore = nil) =
  gtk_tree_view_set_model(cast[ptr TreeView00](self.impl), if model.isNil: nil else: cast[ptr TreeModel00](model.impl))

proc gtk_tree_view_set_reorderable(self: ptr TreeView00; reorderable: gboolean) {.
    importc, libprag.}

proc setReorderable*(self: TreeView; reorderable: bool = true) =
  gtk_tree_view_set_reorderable(cast[ptr TreeView00](self.impl), gboolean(reorderable))

proc `reorderable=`*(self: TreeView; reorderable: bool) =
  gtk_tree_view_set_reorderable(cast[ptr TreeView00](self.impl), gboolean(reorderable))

proc gtk_tree_view_set_rubber_banding(self: ptr TreeView00; enable: gboolean) {.
    importc, libprag.}

proc setRubberBanding*(self: TreeView; enable: bool = true) =
  gtk_tree_view_set_rubber_banding(cast[ptr TreeView00](self.impl), gboolean(enable))

proc `rubberBanding=`*(self: TreeView; enable: bool) =
  gtk_tree_view_set_rubber_banding(cast[ptr TreeView00](self.impl), gboolean(enable))

proc gtk_tree_view_set_rules_hint(self: ptr TreeView00; setting: gboolean) {.
    importc, libprag.}

proc setRulesHint*(self: TreeView; setting: bool = true) =
  gtk_tree_view_set_rules_hint(cast[ptr TreeView00](self.impl), gboolean(setting))

proc `rulesHint=`*(self: TreeView; setting: bool) =
  gtk_tree_view_set_rules_hint(cast[ptr TreeView00](self.impl), gboolean(setting))

proc gtk_tree_view_set_search_column(self: ptr TreeView00; column: int32) {.
    importc, libprag.}

proc setSearchColumn*(self: TreeView; column: int) =
  gtk_tree_view_set_search_column(cast[ptr TreeView00](self.impl), int32(column))

proc `searchColumn=`*(self: TreeView; column: int) =
  gtk_tree_view_set_search_column(cast[ptr TreeView00](self.impl), int32(column))

proc gtk_tree_view_set_search_entry(self: ptr TreeView00; entry: ptr Entry00) {.
    importc, libprag.}

proc setSearchEntry*(self: TreeView; entry: Entry = nil) =
  gtk_tree_view_set_search_entry(cast[ptr TreeView00](self.impl), if entry.isNil: nil else: cast[ptr Entry00](entry.impl))

proc `searchEntry=`*(self: TreeView; entry: Entry = nil) =
  gtk_tree_view_set_search_entry(cast[ptr TreeView00](self.impl), if entry.isNil: nil else: cast[ptr Entry00](entry.impl))

proc gtk_tree_view_set_show_expanders(self: ptr TreeView00; enabled: gboolean) {.
    importc, libprag.}

proc setShowExpanders*(self: TreeView; enabled: bool = true) =
  gtk_tree_view_set_show_expanders(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc `showExpanders=`*(self: TreeView; enabled: bool) =
  gtk_tree_view_set_show_expanders(cast[ptr TreeView00](self.impl), gboolean(enabled))

proc gtk_tree_view_set_tooltip_cell(self: ptr TreeView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00; column: ptr TreeViewColumn00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc setTooltipCell*(self: TreeView; tooltip: Tooltip; path: TreePath = nil;
    column: TreeViewColumn = nil; cell: CellRenderer = nil) =
  gtk_tree_view_set_tooltip_cell(cast[ptr TreeView00](self.impl), cast[ptr Tooltip00](tooltip.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), if column.isNil: nil else: cast[ptr TreeViewColumn00](column.impl), if cell.isNil: nil else: cast[ptr CellRenderer00](cell.impl))

proc gtk_tree_view_set_tooltip_column(self: ptr TreeView00; column: int32) {.
    importc, libprag.}

proc setTooltipColumn*(self: TreeView; column: int) =
  gtk_tree_view_set_tooltip_column(cast[ptr TreeView00](self.impl), int32(column))

proc `tooltipColumn=`*(self: TreeView; column: int) =
  gtk_tree_view_set_tooltip_column(cast[ptr TreeView00](self.impl), int32(column))

proc gtk_tree_view_set_tooltip_row(self: ptr TreeView00; tooltip: ptr Tooltip00;
    path: ptr TreePath00) {.
    importc, libprag.}

proc setTooltipRow*(self: TreeView; tooltip: Tooltip; path: TreePath) =
  gtk_tree_view_set_tooltip_row(cast[ptr TreeView00](self.impl), cast[ptr Tooltip00](tooltip.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_view_set_vadjustment(self: ptr TreeView00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: TreeView; adjustment: Adjustment = nil) =
  gtk_tree_view_set_vadjustment(cast[ptr TreeView00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: TreeView; adjustment: Adjustment = nil) =
  gtk_tree_view_set_vadjustment(cast[ptr TreeView00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_tree_view_unset_rows_drag_dest(self: ptr TreeView00) {.
    importc, libprag.}

proc unsetRowsDragDest*(self: TreeView) =
  gtk_tree_view_unset_rows_drag_dest(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_unset_rows_drag_source(self: ptr TreeView00) {.
    importc, libprag.}

proc unsetRowsDragSource*(self: TreeView) =
  gtk_tree_view_unset_rows_drag_source(cast[ptr TreeView00](self.impl))

type
  ColorChooserDialog* = ref object of Dialog
  ColorChooserDialog00* = object of Dialog00

proc gtk_color_chooser_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorChooserDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_color_chooser_dialog_new(title: cstring; parent: ptr Window00): ptr ColorChooserDialog00 {.
    importc, libprag.}

proc newColorChooserDialog*(title: cstring = nil; parent: Window = nil): ColorChooserDialog =
  let gobj = gtk_color_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorChooserDialog*(tdesc: typedesc; title: cstring = nil; parent: Window = nil): tdesc =
  assert(result is ColorChooserDialog)
  let gobj = gtk_color_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorChooserDialog*[T](result: var T; title: cstring = nil; parent: Window = nil) {.deprecated.} =
  assert(result is ColorChooserDialog)
  let gobj = gtk_color_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ColorChooserWidget* = ref object of Box
  ColorChooserWidget00* = object of Box00

proc gtk_color_chooser_widget_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorChooserWidget()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_color_chooser_widget_new(): ptr ColorChooserWidget00 {.
    importc, libprag.}

proc newColorChooserWidget*(): ColorChooserWidget =
  let gobj = gtk_color_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorChooserWidget*(tdesc: typedesc): tdesc =
  assert(result is ColorChooserWidget)
  let gobj = gtk_color_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorChooserWidget*[T](result: var T) {.deprecated.} =
  assert(result is ColorChooserWidget)
  let gobj = gtk_color_chooser_widget_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  EventBox* = ref object of Bin
  EventBox00* = object of Bin00

proc gtk_event_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_event_box_new(): ptr EventBox00 {.
    importc, libprag.}

proc newEventBox*(): EventBox =
  let gobj = gtk_event_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventBox*(tdesc: typedesc): tdesc =
  assert(result is EventBox)
  let gobj = gtk_event_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventBox*[T](result: var T) {.deprecated.} =
  assert(result is EventBox)
  let gobj = gtk_event_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_box_get_above_child(self: ptr EventBox00): gboolean {.
    importc, libprag.}

proc getAboveChild*(self: EventBox): bool =
  toBool(gtk_event_box_get_above_child(cast[ptr EventBox00](self.impl)))

proc aboveChild*(self: EventBox): bool =
  toBool(gtk_event_box_get_above_child(cast[ptr EventBox00](self.impl)))

proc gtk_event_box_get_visible_window(self: ptr EventBox00): gboolean {.
    importc, libprag.}

proc getVisibleWindow*(self: EventBox): bool =
  toBool(gtk_event_box_get_visible_window(cast[ptr EventBox00](self.impl)))

proc visibleWindow*(self: EventBox): bool =
  toBool(gtk_event_box_get_visible_window(cast[ptr EventBox00](self.impl)))

proc gtk_event_box_set_above_child(self: ptr EventBox00; aboveChild: gboolean) {.
    importc, libprag.}

proc setAboveChild*(self: EventBox; aboveChild: bool = true) =
  gtk_event_box_set_above_child(cast[ptr EventBox00](self.impl), gboolean(aboveChild))

proc `aboveChild=`*(self: EventBox; aboveChild: bool) =
  gtk_event_box_set_above_child(cast[ptr EventBox00](self.impl), gboolean(aboveChild))

proc gtk_event_box_set_visible_window(self: ptr EventBox00; visibleWindow: gboolean) {.
    importc, libprag.}

proc setVisibleWindow*(self: EventBox; visibleWindow: bool = true) =
  gtk_event_box_set_visible_window(cast[ptr EventBox00](self.impl), gboolean(visibleWindow))

proc `visibleWindow=`*(self: EventBox; visibleWindow: bool) =
  gtk_event_box_set_visible_window(cast[ptr EventBox00](self.impl), gboolean(visibleWindow))

type
  VScale* = ref object of Scale
  VScale00* = object of Scale00

proc gtk_vscale_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(VScale()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_vscale_new(adjustment: ptr Adjustment00): ptr VScale00 {.
    importc, libprag.}

proc newVScale*(adjustment: Adjustment): VScale {.deprecated.}  =
  let gobj = gtk_vscale_new(cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVScale*(tdesc: typedesc; adjustment: Adjustment): tdesc {.deprecated.}  =
  assert(result is VScale)
  let gobj = gtk_vscale_new(cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVScale*[T](result: var T; adjustment: Adjustment) {.deprecated.} =
  assert(result is VScale)
  let gobj = gtk_vscale_new(cast[ptr Adjustment00](adjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_vscale_new_with_range(min: cdouble; max: cdouble; step: cdouble): ptr VScale00 {.
    importc, libprag.}

proc newVScaleWithRange*(min: cdouble; max: cdouble; step: cdouble): VScale {.deprecated.}  =
  let gobj = gtk_vscale_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newVScaleWithRange*(tdesc: typedesc; min: cdouble; max: cdouble; step: cdouble): tdesc {.deprecated.}  =
  assert(result is VScale)
  let gobj = gtk_vscale_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initVScaleWithRange*[T](result: var T; min: cdouble; max: cdouble; step: cdouble) {.deprecated.} =
  assert(result is VScale)
  let gobj = gtk_vscale_new_with_range(min, max, step)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ShortcutsShortcut* = ref object of Box
  ShortcutsShortcut00* = object of Box00

proc gtk_shortcuts_shortcut_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ShortcutsShortcut()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ColorSelectionDialog* = ref object of Dialog
  ColorSelectionDialog00* = object of Dialog00

proc gtk_color_selection_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ColorSelectionDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_color_selection_dialog_new(title: cstring): ptr ColorSelectionDialog00 {.
    importc, libprag.}

proc newColorSelectionDialog*(title: cstring): ColorSelectionDialog =
  let gobj = gtk_color_selection_dialog_new(title)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newColorSelectionDialog*(tdesc: typedesc; title: cstring): tdesc =
  assert(result is ColorSelectionDialog)
  let gobj = gtk_color_selection_dialog_new(title)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initColorSelectionDialog*[T](result: var T; title: cstring) {.deprecated.} =
  assert(result is ColorSelectionDialog)
  let gobj = gtk_color_selection_dialog_new(title)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_color_selection_dialog_get_color_selection(self: ptr ColorSelectionDialog00): ptr Widget00 {.
    importc, libprag.}

proc getColorSelection*(self: ColorSelectionDialog): Widget =
  let gobj = gtk_color_selection_dialog_get_color_selection(cast[ptr ColorSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc colorSelection*(self: ColorSelectionDialog): Widget =
  let gobj = gtk_color_selection_dialog_get_color_selection(cast[ptr ColorSelectionDialog00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  Fixed* = ref object of Container
  Fixed00* = object of Container00

proc gtk_fixed_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Fixed()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_fixed_new(): ptr Fixed00 {.
    importc, libprag.}

proc newFixed*(): Fixed =
  let gobj = gtk_fixed_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFixed*(tdesc: typedesc): tdesc =
  assert(result is Fixed)
  let gobj = gtk_fixed_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFixed*[T](result: var T) {.deprecated.} =
  assert(result is Fixed)
  let gobj = gtk_fixed_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_fixed_move(self: ptr Fixed00; widget: ptr Widget00; x: int32; y: int32) {.
    importc, libprag.}

proc move*(self: Fixed; widget: Widget; x: int; y: int) =
  gtk_fixed_move(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), int32(x), int32(y))

proc gtk_fixed_put(self: ptr Fixed00; widget: ptr Widget00; x: int32; y: int32) {.
    importc, libprag.}

proc put*(self: Fixed; widget: Widget; x: int; y: int) =
  gtk_fixed_put(cast[ptr Fixed00](self.impl), cast[ptr Widget00](widget.impl), int32(x), int32(y))

type
  GLArea* = ref object of Widget
  GLArea00* = object of Widget00

proc gtk_gl_area_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GLArea()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCreateContext*(self: GLArea;  p: proc (self: ptr GLArea00; xdata: pointer): gdk.GLContext00 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "create-context", cast[GCallback](p), xdata, nil, cf)

proc scRender*(self: GLArea;  p: proc (self: ptr GLArea00; context: ptr gdk.GLContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "render", cast[GCallback](p), xdata, nil, cf)

proc scResize*(self: GLArea;  p: proc (self: ptr GLArea00; width: int32; height: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "resize", cast[GCallback](p), xdata, nil, cf)

proc gtk_gl_area_new(): ptr GLArea00 {.
    importc, libprag.}

proc newGLArea*(): GLArea =
  let gobj = gtk_gl_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGLArea*(tdesc: typedesc): tdesc =
  assert(result is GLArea)
  let gobj = gtk_gl_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGLArea*[T](result: var T) {.deprecated.} =
  assert(result is GLArea)
  let gobj = gtk_gl_area_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gl_area_attach_buffers(self: ptr GLArea00) {.
    importc, libprag.}

proc attachBuffers*(self: GLArea) =
  gtk_gl_area_attach_buffers(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_auto_render(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getAutoRender*(self: GLArea): bool =
  toBool(gtk_gl_area_get_auto_render(cast[ptr GLArea00](self.impl)))

proc autoRender*(self: GLArea): bool =
  toBool(gtk_gl_area_get_auto_render(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_context(self: ptr GLArea00): ptr gdk.GLContext00 {.
    importc, libprag.}

proc getContext*(self: GLArea): gdk.GLContext =
  let gobj = gtk_gl_area_get_context(cast[ptr GLArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc context*(self: GLArea): gdk.GLContext =
  let gobj = gtk_gl_area_get_context(cast[ptr GLArea00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gl_area_get_error(self: ptr GLArea00): ptr glib.Error {.
    importc, libprag.}

proc getError*(self: GLArea): ptr glib.Error =
  gtk_gl_area_get_error(cast[ptr GLArea00](self.impl))

proc error*(self: GLArea): ptr glib.Error =
  gtk_gl_area_get_error(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_get_has_alpha(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getHasAlpha*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_alpha(cast[ptr GLArea00](self.impl)))

proc hasAlpha*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_alpha(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_has_depth_buffer(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getHasDepthBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_depth_buffer(cast[ptr GLArea00](self.impl)))

proc hasDepthBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_depth_buffer(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_has_stencil_buffer(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getHasStencilBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_stencil_buffer(cast[ptr GLArea00](self.impl)))

proc hasStencilBuffer*(self: GLArea): bool =
  toBool(gtk_gl_area_get_has_stencil_buffer(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_get_required_version(self: ptr GLArea00; major: var int32;
    minor: var int32) {.
    importc, libprag.}

proc getRequiredVersion*(self: GLArea; major: var int; minor: var int) =
  var major_00: int32
  var minor_00: int32
  gtk_gl_area_get_required_version(cast[ptr GLArea00](self.impl), major_00, minor_00)
  if major.addr != nil:
    major = int(major_00)
  if minor.addr != nil:
    minor = int(minor_00)

proc gtk_gl_area_get_use_es(self: ptr GLArea00): gboolean {.
    importc, libprag.}

proc getUseEs*(self: GLArea): bool =
  toBool(gtk_gl_area_get_use_es(cast[ptr GLArea00](self.impl)))

proc useEs*(self: GLArea): bool =
  toBool(gtk_gl_area_get_use_es(cast[ptr GLArea00](self.impl)))

proc gtk_gl_area_make_current(self: ptr GLArea00) {.
    importc, libprag.}

proc makeCurrent*(self: GLArea) =
  gtk_gl_area_make_current(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_queue_render(self: ptr GLArea00) {.
    importc, libprag.}

proc queueRender*(self: GLArea) =
  gtk_gl_area_queue_render(cast[ptr GLArea00](self.impl))

proc gtk_gl_area_set_auto_render(self: ptr GLArea00; autoRender: gboolean) {.
    importc, libprag.}

proc setAutoRender*(self: GLArea; autoRender: bool = true) =
  gtk_gl_area_set_auto_render(cast[ptr GLArea00](self.impl), gboolean(autoRender))

proc `autoRender=`*(self: GLArea; autoRender: bool) =
  gtk_gl_area_set_auto_render(cast[ptr GLArea00](self.impl), gboolean(autoRender))

proc gtk_gl_area_set_error(self: ptr GLArea00; error: ptr glib.Error) {.
    importc, libprag.}

proc setError*(self: GLArea; error: ptr glib.Error) =
  gtk_gl_area_set_error(cast[ptr GLArea00](self.impl), error)

proc `error=`*(self: GLArea; error: ptr glib.Error) =
  gtk_gl_area_set_error(cast[ptr GLArea00](self.impl), error)

proc gtk_gl_area_set_has_alpha(self: ptr GLArea00; hasAlpha: gboolean) {.
    importc, libprag.}

proc setHasAlpha*(self: GLArea; hasAlpha: bool = true) =
  gtk_gl_area_set_has_alpha(cast[ptr GLArea00](self.impl), gboolean(hasAlpha))

proc `hasAlpha=`*(self: GLArea; hasAlpha: bool) =
  gtk_gl_area_set_has_alpha(cast[ptr GLArea00](self.impl), gboolean(hasAlpha))

proc gtk_gl_area_set_has_depth_buffer(self: ptr GLArea00; hasDepthBuffer: gboolean) {.
    importc, libprag.}

proc setHasDepthBuffer*(self: GLArea; hasDepthBuffer: bool = true) =
  gtk_gl_area_set_has_depth_buffer(cast[ptr GLArea00](self.impl), gboolean(hasDepthBuffer))

proc `hasDepthBuffer=`*(self: GLArea; hasDepthBuffer: bool) =
  gtk_gl_area_set_has_depth_buffer(cast[ptr GLArea00](self.impl), gboolean(hasDepthBuffer))

proc gtk_gl_area_set_has_stencil_buffer(self: ptr GLArea00; hasStencilBuffer: gboolean) {.
    importc, libprag.}

proc setHasStencilBuffer*(self: GLArea; hasStencilBuffer: bool = true) =
  gtk_gl_area_set_has_stencil_buffer(cast[ptr GLArea00](self.impl), gboolean(hasStencilBuffer))

proc `hasStencilBuffer=`*(self: GLArea; hasStencilBuffer: bool) =
  gtk_gl_area_set_has_stencil_buffer(cast[ptr GLArea00](self.impl), gboolean(hasStencilBuffer))

proc gtk_gl_area_set_required_version(self: ptr GLArea00; major: int32; minor: int32) {.
    importc, libprag.}

proc setRequiredVersion*(self: GLArea; major: int; minor: int) =
  gtk_gl_area_set_required_version(cast[ptr GLArea00](self.impl), int32(major), int32(minor))

proc gtk_gl_area_set_use_es(self: ptr GLArea00; useEs: gboolean) {.
    importc, libprag.}

proc setUseEs*(self: GLArea; useEs: bool = true) =
  gtk_gl_area_set_use_es(cast[ptr GLArea00](self.impl), gboolean(useEs))

proc `useEs=`*(self: GLArea; useEs: bool) =
  gtk_gl_area_set_use_es(cast[ptr GLArea00](self.impl), gboolean(useEs))

type
  TreeSelection* = ref object of gobject.Object
  TreeSelection00* = object of gobject.Object00

proc gtk_tree_selection_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeSelection()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: TreeSelection;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_selection_count_selected_rows(self: ptr TreeSelection00): int32 {.
    importc, libprag.}

proc countSelectedRows*(self: TreeSelection): int =
  int(gtk_tree_selection_count_selected_rows(cast[ptr TreeSelection00](self.impl)))

proc gtk_tree_selection_get_selected(self: ptr TreeSelection00; model: var ptr TreeModel00;
    iter: var TreeIter): gboolean {.
    importc, libprag.}

proc getSelected*(self: TreeSelection; model: var (TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) = cast[var TreeModel](nil);
    iter: var TreeIter = cast[var TreeIter](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  result = toBool(gtk_tree_selection_get_selected(cast[ptr TreeSelection00](self.impl), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg), iter))
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_tree_selection_get_selected_rows(self: ptr TreeSelection00; model: var ptr TreeModel00): ptr glib.List {.
    importc, libprag.}

proc getSelectedRows*(self: TreeSelection; model: var (TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) = cast[var TreeModel](nil)): seq[TreePath] =
  var tmpoutgobjectarg: ptr TreeModel00
  let resul0 = gtk_tree_selection_get_selected_rows(cast[ptr TreeSelection00](self.impl), cast[var ptr TreeModel00](if addr(model) == nil: nil else: addr tmpoutgobjectarg))
  result = glistStructs2seq[TreePath](resul0, false)
  g_list_free(resul0)
#  dothemagic(model
  if addr(model) != nil:
    model = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      model = cast[type(model)](argqdata)
      assert(model.impl == tmpoutgobjectarg)
    else:
      fnew(model, gtk.finalizeGObject)
      model.impl = tmpoutgobjectarg
      GC_ref(model)
      if g_object_is_floating(model.impl).int != 0:
        discard g_object_ref_sink(model.impl)
      g_object_add_toggle_ref(model.impl, toggleNotify, addr(model[]))
      g_object_unref(model.impl)
      assert(g_object_get_qdata(model.impl, Quark) == nil)
      g_object_set_qdata(model.impl, Quark, addr(model[]))


proc gtk_tree_selection_get_tree_view(self: ptr TreeSelection00): ptr TreeView00 {.
    importc, libprag.}

proc getTreeView*(self: TreeSelection): TreeView =
  let gobj = gtk_tree_selection_get_tree_view(cast[ptr TreeSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc treeView*(self: TreeSelection): TreeView =
  let gobj = gtk_tree_selection_get_tree_view(cast[ptr TreeSelection00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_selection_iter_is_selected(self: ptr TreeSelection00; iter: TreeIter): gboolean {.
    importc, libprag.}

proc iterIsSelected*(self: TreeSelection; iter: TreeIter): bool =
  toBool(gtk_tree_selection_iter_is_selected(cast[ptr TreeSelection00](self.impl), iter))

proc gtk_tree_selection_path_is_selected(self: ptr TreeSelection00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc pathIsSelected*(self: TreeSelection; path: TreePath): bool =
  toBool(gtk_tree_selection_path_is_selected(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_selection_select_all(self: ptr TreeSelection00) {.
    importc, libprag.}

proc selectAll*(self: TreeSelection) =
  gtk_tree_selection_select_all(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_select_iter(self: ptr TreeSelection00; iter: TreeIter) {.
    importc, libprag.}

proc selectIter*(self: TreeSelection; iter: TreeIter) =
  gtk_tree_selection_select_iter(cast[ptr TreeSelection00](self.impl), iter)

proc gtk_tree_selection_select_path(self: ptr TreeSelection00; path: ptr TreePath00) {.
    importc, libprag.}

proc selectPath*(self: TreeSelection; path: TreePath) =
  gtk_tree_selection_select_path(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_selection_select_range(self: ptr TreeSelection00; startPath: ptr TreePath00;
    endPath: ptr TreePath00) {.
    importc, libprag.}

proc selectRange*(self: TreeSelection; startPath: TreePath;
    endPath: TreePath) =
  gtk_tree_selection_select_range(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](startPath.impl), cast[ptr TreePath00](endPath.impl))

proc gtk_tree_selection_unselect_all(self: ptr TreeSelection00) {.
    importc, libprag.}

proc unselectAll*(self: TreeSelection) =
  gtk_tree_selection_unselect_all(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_unselect_iter(self: ptr TreeSelection00; iter: TreeIter) {.
    importc, libprag.}

proc unselectIter*(self: TreeSelection; iter: TreeIter) =
  gtk_tree_selection_unselect_iter(cast[ptr TreeSelection00](self.impl), iter)

proc gtk_tree_selection_unselect_path(self: ptr TreeSelection00; path: ptr TreePath00) {.
    importc, libprag.}

proc unselectPath*(self: TreeSelection; path: TreePath) =
  gtk_tree_selection_unselect_path(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_selection_unselect_range(self: ptr TreeSelection00; startPath: ptr TreePath00;
    endPath: ptr TreePath00) {.
    importc, libprag.}

proc unselectRange*(self: TreeSelection; startPath: TreePath;
    endPath: TreePath) =
  gtk_tree_selection_unselect_range(cast[ptr TreeSelection00](self.impl), cast[ptr TreePath00](startPath.impl), cast[ptr TreePath00](endPath.impl))

proc gtk_tree_view_get_selection(self: ptr TreeView00): ptr TreeSelection00 {.
    importc, libprag.}

proc getSelection*(self: TreeView): TreeSelection =
  let gobj = gtk_tree_view_get_selection(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selection*(self: TreeView): TreeSelection =
  let gobj = gtk_tree_view_get_selection(cast[ptr TreeView00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  TreeViewDropPosition* {.size: sizeof(cint), pure.} = enum
    before = 0
    after = 1
    intoOrBefore = 2
    intoOrAfter = 3

proc gtk_tree_view_get_dest_row_at_pos(self: ptr TreeView00; dragX: int32;
    dragY: int32; path: var ptr TreePath00; pos: var TreeViewDropPosition): gboolean {.
    importc, libprag.}

proc getDestRowAtPos*(self: TreeView; dragX: int; dragY: int;
    path: var TreePath = cast[var TreePath](nil); pos: var TreeViewDropPosition = cast[var TreeViewDropPosition](nil)): bool =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_tree_view_get_dest_row_at_pos(cast[ptr TreeView00](self.impl), int32(dragX), int32(dragY), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos))
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil

proc gtk_tree_view_get_drag_dest_row(self: ptr TreeView00; path: var ptr TreePath00;
    pos: var TreeViewDropPosition) {.
    importc, libprag.}

proc getDragDestRow*(self: TreeView; path: var TreePath = cast[var TreePath](nil);
    pos: var TreeViewDropPosition = cast[var TreeViewDropPosition](nil)) =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  gtk_tree_view_get_drag_dest_row(cast[ptr TreeView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos)
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil

proc gtk_tree_view_set_drag_dest_row(self: ptr TreeView00; path: ptr TreePath00;
    pos: TreeViewDropPosition) {.
    importc, libprag.}

proc setDragDestRow*(self: TreeView; path: TreePath = nil;
    pos: TreeViewDropPosition) =
  gtk_tree_view_set_drag_dest_row(cast[ptr TreeView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), pos)

type
  TreeViewGridLines* {.size: sizeof(cint), pure.} = enum
    none = 0
    horizontal = 1
    vertical = 2
    both = 3

proc gtk_tree_view_get_grid_lines(self: ptr TreeView00): TreeViewGridLines {.
    importc, libprag.}

proc getGridLines*(self: TreeView): TreeViewGridLines =
  gtk_tree_view_get_grid_lines(cast[ptr TreeView00](self.impl))

proc gridLines*(self: TreeView): TreeViewGridLines =
  gtk_tree_view_get_grid_lines(cast[ptr TreeView00](self.impl))

proc gtk_tree_view_set_grid_lines(self: ptr TreeView00; gridLines: TreeViewGridLines) {.
    importc, libprag.}

proc setGridLines*(self: TreeView; gridLines: TreeViewGridLines) =
  gtk_tree_view_set_grid_lines(cast[ptr TreeView00](self.impl), gridLines)

proc `gridLines=`*(self: TreeView; gridLines: TreeViewGridLines) =
  gtk_tree_view_set_grid_lines(cast[ptr TreeView00](self.impl), gridLines)

type
  CalendarDisplayOptions* {.size: sizeof(cint), pure.} = enum
    showHeading = 1
    showDayNames = 2
    noMonthChange = 4
    showWeekNumbers = 8
    showDetails = 32

proc gtk_calendar_get_display_options(self: ptr Calendar00): CalendarDisplayOptions {.
    importc, libprag.}

proc getDisplayOptions*(self: Calendar): CalendarDisplayOptions =
  gtk_calendar_get_display_options(cast[ptr Calendar00](self.impl))

proc displayOptions*(self: Calendar): CalendarDisplayOptions =
  gtk_calendar_get_display_options(cast[ptr Calendar00](self.impl))

proc gtk_calendar_set_display_options(self: ptr Calendar00; flags: CalendarDisplayOptions) {.
    importc, libprag.}

proc setDisplayOptions*(self: Calendar; flags: CalendarDisplayOptions) =
  gtk_calendar_set_display_options(cast[ptr Calendar00](self.impl), flags)

proc `displayOptions=`*(self: Calendar; flags: CalendarDisplayOptions) =
  gtk_calendar_set_display_options(cast[ptr Calendar00](self.impl), flags)

type
  StackTransitionType* {.size: sizeof(cint), pure.} = enum
    none = 0
    crossfade = 1
    slideRight = 2
    slideLeft = 3
    slideUp = 4
    slideDown = 5
    slideLeftRight = 6
    slideUpDown = 7
    overUp = 8
    overDown = 9
    overLeft = 10
    overRight = 11
    underUp = 12
    underDown = 13
    underLeft = 14
    underRight = 15
    overUpDown = 16
    overDownUp = 17
    overLeftRight = 18
    overRightLeft = 19

proc gtk_stack_get_transition_type(self: ptr Stack00): StackTransitionType {.
    importc, libprag.}

proc getTransitionType*(self: Stack): StackTransitionType =
  gtk_stack_get_transition_type(cast[ptr Stack00](self.impl))

proc transitionType*(self: Stack): StackTransitionType =
  gtk_stack_get_transition_type(cast[ptr Stack00](self.impl))

proc gtk_stack_set_transition_type(self: ptr Stack00; transition: StackTransitionType) {.
    importc, libprag.}

proc setTransitionType*(self: Stack; transition: StackTransitionType) =
  gtk_stack_set_transition_type(cast[ptr Stack00](self.impl), transition)

proc `transitionType=`*(self: Stack; transition: StackTransitionType) =
  gtk_stack_set_transition_type(cast[ptr Stack00](self.impl), transition)

proc gtk_stack_set_visible_child_full(self: ptr Stack00; name: cstring; transition: StackTransitionType) {.
    importc, libprag.}

proc setVisibleChildFull*(self: Stack; name: cstring; transition: StackTransitionType) =
  gtk_stack_set_visible_child_full(cast[ptr Stack00](self.impl), name, transition)

type
  IconSize* {.size: sizeof(cint), pure.} = enum
    invalid = 0
    menu = 1
    smallToolbar = 2
    largeToolbar = 3
    button = 4
    dnd = 5
    dialog = 6

proc gtk_icon_size_from_name(name: cstring): int32 {.
    importc, libprag.}

proc fromName*(name: cstring): int =
  int(gtk_icon_size_from_name(name))

proc gtk_icon_size_get_name(size: int32): cstring {.
    importc, libprag.}

proc getName*(size: int): string =
  result = $gtk_icon_size_get_name(int32(size))

proc name*(size: int): string =
  result = $gtk_icon_size_get_name(int32(size))

proc gtk_icon_size_lookup(size: int32; width: var int32; height: var int32): gboolean {.
    importc, libprag.}

proc lookup*(size: int; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)): bool =
  var width_00: int32
  var height_00: int32
  result = toBool(gtk_icon_size_lookup(int32(size), width_00, height_00))
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_icon_size_lookup_for_settings(settings: ptr Settings00; size: int32;
    width: var int32; height: var int32): gboolean {.
    importc, libprag.}

proc lookupForSettings*(settings: Settings; size: int; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)): bool =
  var width_00: int32
  var height_00: int32
  result = toBool(gtk_icon_size_lookup_for_settings(cast[ptr Settings00](settings.impl), int32(size), width_00, height_00))
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_icon_size_register(name: cstring; width: int32; height: int32): int32 {.
    importc, libprag.}

proc registerIconSize*(name: cstring; width: int; height: int): int =
  int(gtk_icon_size_register(name, int32(width), int32(height)))

proc gtk_icon_size_register_alias(alias: cstring; target: int32) {.
    importc, libprag.}

proc registerAlias*(alias: cstring; target: int) =
  gtk_icon_size_register_alias(alias, int32(target))

proc gtk_toolbar_get_icon_size(self: ptr Toolbar00): IconSize {.
    importc, libprag.}

proc getIconSize*(self: Toolbar): IconSize =
  gtk_toolbar_get_icon_size(cast[ptr Toolbar00](self.impl))

proc iconSize*(self: Toolbar): IconSize =
  gtk_toolbar_get_icon_size(cast[ptr Toolbar00](self.impl))

proc gtk_toolbar_set_icon_size(self: ptr Toolbar00; iconSize: IconSize) {.
    importc, libprag.}

proc setIconSize*(self: Toolbar; iconSize: IconSize) =
  gtk_toolbar_set_icon_size(cast[ptr Toolbar00](self.impl), iconSize)

proc `iconSize=`*(self: Toolbar; iconSize: IconSize) =
  gtk_toolbar_set_icon_size(cast[ptr Toolbar00](self.impl), iconSize)

type
  FileChooserAction* {.size: sizeof(cint), pure.} = enum
    open = 0
    save = 1
    selectFolder = 2
    createFolder = 3

proc gtk_file_chooser_button_new(title: cstring; action: FileChooserAction): ptr FileChooserButton00 {.
    importc, libprag.}

proc newFileChooserButton*(title: cstring; action: FileChooserAction): FileChooserButton =
  let gobj = gtk_file_chooser_button_new(title, action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileChooserButton*(tdesc: typedesc; title: cstring; action: FileChooserAction): tdesc =
  assert(result is FileChooserButton)
  let gobj = gtk_file_chooser_button_new(title, action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserButton*[T](result: var T; title: cstring; action: FileChooserAction) {.deprecated.} =
  assert(result is FileChooserButton)
  let gobj = gtk_file_chooser_button_new(title, action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_widget_new(action: FileChooserAction): ptr FileChooserWidget00 {.
    importc, libprag.}

proc newFileChooserWidget*(action: FileChooserAction): FileChooserWidget =
  let gobj = gtk_file_chooser_widget_new(action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileChooserWidget*(tdesc: typedesc; action: FileChooserAction): tdesc =
  assert(result is FileChooserWidget)
  let gobj = gtk_file_chooser_widget_new(action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserWidget*[T](result: var T; action: FileChooserAction) {.deprecated.} =
  assert(result is FileChooserWidget)
  let gobj = gtk_file_chooser_widget_new(action)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ToolPaletteDragTargets* {.size: sizeof(cint), pure.} = enum
    items = 1
    groups = 2

proc gtk_tool_palette_add_drag_dest(self: ptr ToolPalette00; widget: ptr Widget00;
    flags: DestDefaults; targets: ToolPaletteDragTargets; actions: gdk.DragAction) {.
    importc, libprag.}

proc addDragDest*(self: ToolPalette; widget: Widget; flags: DestDefaults;
    targets: ToolPaletteDragTargets; actions: gdk.DragAction) =
  gtk_tool_palette_add_drag_dest(cast[ptr ToolPalette00](self.impl), cast[ptr Widget00](widget.impl), flags, targets, actions)

proc gtk_tool_palette_set_drag_source(self: ptr ToolPalette00; targets: ToolPaletteDragTargets) {.
    importc, libprag.}

proc setDragSource*(self: ToolPalette; targets: ToolPaletteDragTargets) =
  gtk_tool_palette_set_drag_source(cast[ptr ToolPalette00](self.impl), targets)

proc `dragSource=`*(self: ToolPalette; targets: ToolPaletteDragTargets) =
  gtk_tool_palette_set_drag_source(cast[ptr ToolPalette00](self.impl), targets)

type
  ToolItemGroup* = ref object of Container
  ToolItemGroup00* = object of Container00

proc gtk_tool_item_group_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToolItemGroup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_tool_item_group_new(label: cstring): ptr ToolItemGroup00 {.
    importc, libprag.}

proc newToolItemGroup*(label: cstring): ToolItemGroup =
  let gobj = gtk_tool_item_group_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newToolItemGroup*(tdesc: typedesc; label: cstring): tdesc =
  assert(result is ToolItemGroup)
  let gobj = gtk_tool_item_group_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initToolItemGroup*[T](result: var T; label: cstring) {.deprecated.} =
  assert(result is ToolItemGroup)
  let gobj = gtk_tool_item_group_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_get_collapsed(self: ptr ToolItemGroup00): gboolean {.
    importc, libprag.}

proc getCollapsed*(self: ToolItemGroup): bool =
  toBool(gtk_tool_item_group_get_collapsed(cast[ptr ToolItemGroup00](self.impl)))

proc collapsed*(self: ToolItemGroup): bool =
  toBool(gtk_tool_item_group_get_collapsed(cast[ptr ToolItemGroup00](self.impl)))

proc gtk_tool_item_group_get_drop_item(self: ptr ToolItemGroup00; x: int32;
    y: int32): ptr ToolItem00 {.
    importc, libprag.}

proc getDropItem*(self: ToolItemGroup; x: int; y: int): ToolItem =
  let gobj = gtk_tool_item_group_get_drop_item(cast[ptr ToolItemGroup00](self.impl), int32(x), int32(y))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_get_ellipsize(self: ptr ToolItemGroup00): pango.EllipsizeMode {.
    importc, libprag.}

proc getEllipsize*(self: ToolItemGroup): pango.EllipsizeMode =
  gtk_tool_item_group_get_ellipsize(cast[ptr ToolItemGroup00](self.impl))

proc ellipsize*(self: ToolItemGroup): pango.EllipsizeMode =
  gtk_tool_item_group_get_ellipsize(cast[ptr ToolItemGroup00](self.impl))

proc gtk_tool_item_group_get_header_relief(self: ptr ToolItemGroup00): ReliefStyle {.
    importc, libprag.}

proc getHeaderRelief*(self: ToolItemGroup): ReliefStyle =
  gtk_tool_item_group_get_header_relief(cast[ptr ToolItemGroup00](self.impl))

proc headerRelief*(self: ToolItemGroup): ReliefStyle =
  gtk_tool_item_group_get_header_relief(cast[ptr ToolItemGroup00](self.impl))

proc gtk_tool_item_group_get_item_position(self: ptr ToolItemGroup00; item: ptr ToolItem00): int32 {.
    importc, libprag.}

proc getItemPosition*(self: ToolItemGroup; item: ToolItem): int =
  int(gtk_tool_item_group_get_item_position(cast[ptr ToolItemGroup00](self.impl), cast[ptr ToolItem00](item.impl)))

proc gtk_tool_item_group_get_label(self: ptr ToolItemGroup00): cstring {.
    importc, libprag.}

proc getLabel*(self: ToolItemGroup): string =
  result = $gtk_tool_item_group_get_label(cast[ptr ToolItemGroup00](self.impl))

proc label*(self: ToolItemGroup): string =
  result = $gtk_tool_item_group_get_label(cast[ptr ToolItemGroup00](self.impl))

proc gtk_tool_item_group_get_label_widget(self: ptr ToolItemGroup00): ptr Widget00 {.
    importc, libprag.}

proc getLabelWidget*(self: ToolItemGroup): Widget =
  let gobj = gtk_tool_item_group_get_label_widget(cast[ptr ToolItemGroup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: ToolItemGroup): Widget =
  let gobj = gtk_tool_item_group_get_label_widget(cast[ptr ToolItemGroup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_get_n_items(self: ptr ToolItemGroup00): uint32 {.
    importc, libprag.}

proc getNItems*(self: ToolItemGroup): int =
  int(gtk_tool_item_group_get_n_items(cast[ptr ToolItemGroup00](self.impl)))

proc nItems*(self: ToolItemGroup): int =
  int(gtk_tool_item_group_get_n_items(cast[ptr ToolItemGroup00](self.impl)))

proc gtk_tool_item_group_get_nth_item(self: ptr ToolItemGroup00; index: uint32): ptr ToolItem00 {.
    importc, libprag.}

proc getNthItem*(self: ToolItemGroup; index: int): ToolItem =
  let gobj = gtk_tool_item_group_get_nth_item(cast[ptr ToolItemGroup00](self.impl), uint32(index))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_item_group_insert(self: ptr ToolItemGroup00; item: ptr ToolItem00;
    position: int32) {.
    importc, libprag.}

proc insert*(self: ToolItemGroup; item: ToolItem; position: int) =
  gtk_tool_item_group_insert(cast[ptr ToolItemGroup00](self.impl), cast[ptr ToolItem00](item.impl), int32(position))

proc gtk_tool_item_group_set_collapsed(self: ptr ToolItemGroup00; collapsed: gboolean) {.
    importc, libprag.}

proc setCollapsed*(self: ToolItemGroup; collapsed: bool = true) =
  gtk_tool_item_group_set_collapsed(cast[ptr ToolItemGroup00](self.impl), gboolean(collapsed))

proc `collapsed=`*(self: ToolItemGroup; collapsed: bool) =
  gtk_tool_item_group_set_collapsed(cast[ptr ToolItemGroup00](self.impl), gboolean(collapsed))

proc gtk_tool_item_group_set_ellipsize(self: ptr ToolItemGroup00; ellipsize: pango.EllipsizeMode) {.
    importc, libprag.}

proc setEllipsize*(self: ToolItemGroup; ellipsize: pango.EllipsizeMode) =
  gtk_tool_item_group_set_ellipsize(cast[ptr ToolItemGroup00](self.impl), ellipsize)

proc `ellipsize=`*(self: ToolItemGroup; ellipsize: pango.EllipsizeMode) =
  gtk_tool_item_group_set_ellipsize(cast[ptr ToolItemGroup00](self.impl), ellipsize)

proc gtk_tool_item_group_set_header_relief(self: ptr ToolItemGroup00; style: ReliefStyle) {.
    importc, libprag.}

proc setHeaderRelief*(self: ToolItemGroup; style: ReliefStyle) =
  gtk_tool_item_group_set_header_relief(cast[ptr ToolItemGroup00](self.impl), style)

proc `headerRelief=`*(self: ToolItemGroup; style: ReliefStyle) =
  gtk_tool_item_group_set_header_relief(cast[ptr ToolItemGroup00](self.impl), style)

proc gtk_tool_item_group_set_item_position(self: ptr ToolItemGroup00; item: ptr ToolItem00;
    position: int32) {.
    importc, libprag.}

proc setItemPosition*(self: ToolItemGroup; item: ToolItem;
    position: int) =
  gtk_tool_item_group_set_item_position(cast[ptr ToolItemGroup00](self.impl), cast[ptr ToolItem00](item.impl), int32(position))

proc gtk_tool_item_group_set_label(self: ptr ToolItemGroup00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: ToolItemGroup; label: cstring) =
  gtk_tool_item_group_set_label(cast[ptr ToolItemGroup00](self.impl), label)

proc `label=`*(self: ToolItemGroup; label: cstring) =
  gtk_tool_item_group_set_label(cast[ptr ToolItemGroup00](self.impl), label)

proc gtk_tool_item_group_set_label_widget(self: ptr ToolItemGroup00; labelWidget: ptr Widget00) {.
    importc, libprag.}

proc setLabelWidget*(self: ToolItemGroup; labelWidget: Widget) =
  gtk_tool_item_group_set_label_widget(cast[ptr ToolItemGroup00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: ToolItemGroup; labelWidget: Widget) =
  gtk_tool_item_group_set_label_widget(cast[ptr ToolItemGroup00](self.impl), cast[ptr Widget00](labelWidget.impl))

proc gtk_tool_palette_get_drop_group(self: ptr ToolPalette00; x: int32; y: int32): ptr ToolItemGroup00 {.
    importc, libprag.}

proc getDropGroup*(self: ToolPalette; x: int; y: int): ToolItemGroup =
  let gobj = gtk_tool_palette_get_drop_group(cast[ptr ToolPalette00](self.impl), int32(x), int32(y))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_palette_get_exclusive(self: ptr ToolPalette00; group: ptr ToolItemGroup00): gboolean {.
    importc, libprag.}

proc getExclusive*(self: ToolPalette; group: ToolItemGroup): bool =
  toBool(gtk_tool_palette_get_exclusive(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc gtk_tool_palette_get_expand(self: ptr ToolPalette00; group: ptr ToolItemGroup00): gboolean {.
    importc, libprag.}

proc getExpand*(self: ToolPalette; group: ToolItemGroup): bool =
  toBool(gtk_tool_palette_get_expand(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc gtk_tool_palette_get_group_position(self: ptr ToolPalette00; group: ptr ToolItemGroup00): int32 {.
    importc, libprag.}

proc getGroupPosition*(self: ToolPalette; group: ToolItemGroup): int =
  int(gtk_tool_palette_get_group_position(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl)))

proc gtk_tool_palette_set_exclusive(self: ptr ToolPalette00; group: ptr ToolItemGroup00;
    exclusive: gboolean) {.
    importc, libprag.}

proc setExclusive*(self: ToolPalette; group: ToolItemGroup;
    exclusive: bool) =
  gtk_tool_palette_set_exclusive(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl), gboolean(exclusive))

proc gtk_tool_palette_set_expand(self: ptr ToolPalette00; group: ptr ToolItemGroup00;
    expand: gboolean) {.
    importc, libprag.}

proc setExpand*(self: ToolPalette; group: ToolItemGroup;
    expand: bool) =
  gtk_tool_palette_set_expand(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl), gboolean(expand))

proc gtk_tool_palette_set_group_position(self: ptr ToolPalette00; group: ptr ToolItemGroup00;
    position: int32) {.
    importc, libprag.}

proc setGroupPosition*(self: ToolPalette; group: ToolItemGroup;
    position: int) =
  gtk_tool_palette_set_group_position(cast[ptr ToolPalette00](self.impl), cast[ptr ToolItemGroup00](group.impl), int32(position))

type
  HButtonBox* = ref object of ButtonBox
  HButtonBox00* = object of ButtonBox00

proc gtk_hbutton_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HButtonBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_hbutton_box_new(): ptr HButtonBox00 {.
    importc, libprag.}

proc newHButtonBox*(): HButtonBox {.deprecated.}  =
  let gobj = gtk_hbutton_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHButtonBox*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is HButtonBox)
  let gobj = gtk_hbutton_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHButtonBox*[T](result: var T) {.deprecated.} =
  assert(result is HButtonBox)
  let gobj = gtk_hbutton_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  ListBox* = ref object of Container
  ListBox00* = object of Container00

proc gtk_list_box_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListBox()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivateCursorRow*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scMoveCursor*(self: ListBox;  p: proc (self: ptr ListBox00; `object`: MovementStep; p0: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move-cursor", cast[GCallback](p), xdata, nil, cf)

proc scRowActivated*(self: ListBox;  p: proc (self: ptr ListBox00; row: ptr ListBoxRow00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-activated", cast[GCallback](p), xdata, nil, cf)

proc scRowSelected*(self: ListBox;  p: proc (self: ptr ListBox00; row: ptr ListBoxRow00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "row-selected", cast[GCallback](p), xdata, nil, cf)

proc scSelectAll*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "select-all", cast[GCallback](p), xdata, nil, cf)

proc scSelectedRowsChanged*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selected-rows-changed", cast[GCallback](p), xdata, nil, cf)

proc scToggleCursorRow*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggle-cursor-row", cast[GCallback](p), xdata, nil, cf)

proc scUnselectAll*(self: ListBox;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "unselect-all", cast[GCallback](p), xdata, nil, cf)

proc gtk_list_box_new(): ptr ListBox00 {.
    importc, libprag.}

proc newListBox*(): ListBox =
  let gobj = gtk_list_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newListBox*(tdesc: typedesc): tdesc =
  assert(result is ListBox)
  let gobj = gtk_list_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initListBox*[T](result: var T) {.deprecated.} =
  assert(result is ListBox)
  let gobj = gtk_list_box_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_drag_highlight_row(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc, libprag.}

proc dragHighlightRow*(self: ListBox; row: ListBoxRow) =
  gtk_list_box_drag_highlight_row(cast[ptr ListBox00](self.impl), cast[ptr ListBoxRow00](row.impl))

proc gtk_list_box_drag_unhighlight_row(self: ptr ListBox00) {.
    importc, libprag.}

proc dragUnhighlightRow*(self: ListBox) =
  gtk_list_box_drag_unhighlight_row(cast[ptr ListBox00](self.impl))

proc gtk_list_box_get_activate_on_single_click(self: ptr ListBox00): gboolean {.
    importc, libprag.}

proc getActivateOnSingleClick*(self: ListBox): bool =
  toBool(gtk_list_box_get_activate_on_single_click(cast[ptr ListBox00](self.impl)))

proc activateOnSingleClick*(self: ListBox): bool =
  toBool(gtk_list_box_get_activate_on_single_click(cast[ptr ListBox00](self.impl)))

proc gtk_list_box_get_adjustment(self: ptr ListBox00): ptr Adjustment00 {.
    importc, libprag.}

proc getAdjustment*(self: ListBox): Adjustment =
  let gobj = gtk_list_box_get_adjustment(cast[ptr ListBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc adjustment*(self: ListBox): Adjustment =
  let gobj = gtk_list_box_get_adjustment(cast[ptr ListBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_row_at_index(self: ptr ListBox00; index: int32): ptr ListBoxRow00 {.
    importc, libprag.}

proc getRowAtIndex*(self: ListBox; index: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_index(cast[ptr ListBox00](self.impl), int32(index))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_row_at_y(self: ptr ListBox00; y: int32): ptr ListBoxRow00 {.
    importc, libprag.}

proc getRowAtY*(self: ListBox; y: int): ListBoxRow =
  let gobj = gtk_list_box_get_row_at_y(cast[ptr ListBox00](self.impl), int32(y))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_selected_row(self: ptr ListBox00): ptr ListBoxRow00 {.
    importc, libprag.}

proc getSelectedRow*(self: ListBox): ListBoxRow =
  let gobj = gtk_list_box_get_selected_row(cast[ptr ListBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc selectedRow*(self: ListBox): ListBoxRow =
  let gobj = gtk_list_box_get_selected_row(cast[ptr ListBox00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_list_box_get_selected_rows(self: ptr ListBox00): ptr glib.List {.
    importc, libprag.}

proc getSelectedRows*(self: ListBox): seq[ListBoxRow] =
  let resul0 = gtk_list_box_get_selected_rows(cast[ptr ListBox00](self.impl))
  result = glistObjects2seq(ListBoxRow, resul0, false)
  g_list_free(resul0)

proc selectedRows*(self: ListBox): seq[ListBoxRow] =
  let resul0 = gtk_list_box_get_selected_rows(cast[ptr ListBox00](self.impl))
  result = glistObjects2seq(ListBoxRow, resul0, false)
  g_list_free(resul0)

proc gtk_list_box_insert(self: ptr ListBox00; child: ptr Widget00; position: int32) {.
    importc, libprag.}

proc insert*(self: ListBox; child: Widget; position: int) =
  gtk_list_box_insert(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl), int32(position))

proc gtk_list_box_invalidate_filter(self: ptr ListBox00) {.
    importc, libprag.}

proc invalidateFilter*(self: ListBox) =
  gtk_list_box_invalidate_filter(cast[ptr ListBox00](self.impl))

proc gtk_list_box_invalidate_headers(self: ptr ListBox00) {.
    importc, libprag.}

proc invalidateHeaders*(self: ListBox) =
  gtk_list_box_invalidate_headers(cast[ptr ListBox00](self.impl))

proc gtk_list_box_invalidate_sort(self: ptr ListBox00) {.
    importc, libprag.}

proc invalidateSort*(self: ListBox) =
  gtk_list_box_invalidate_sort(cast[ptr ListBox00](self.impl))

proc gtk_list_box_prepend(self: ptr ListBox00; child: ptr Widget00) {.
    importc, libprag.}

proc prepend*(self: ListBox; child: Widget) =
  gtk_list_box_prepend(cast[ptr ListBox00](self.impl), cast[ptr Widget00](child.impl))

proc gtk_list_box_select_all(self: ptr ListBox00) {.
    importc, libprag.}

proc selectAll*(self: ListBox) =
  gtk_list_box_select_all(cast[ptr ListBox00](self.impl))

proc gtk_list_box_select_row(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc, libprag.}

proc selectRow*(self: ListBox; row: ListBoxRow = nil) =
  gtk_list_box_select_row(cast[ptr ListBox00](self.impl), if row.isNil: nil else: cast[ptr ListBoxRow00](row.impl))

proc gtk_list_box_set_activate_on_single_click(self: ptr ListBox00; single: gboolean) {.
    importc, libprag.}

proc setActivateOnSingleClick*(self: ListBox; single: bool = true) =
  gtk_list_box_set_activate_on_single_click(cast[ptr ListBox00](self.impl), gboolean(single))

proc `activateOnSingleClick=`*(self: ListBox; single: bool) =
  gtk_list_box_set_activate_on_single_click(cast[ptr ListBox00](self.impl), gboolean(single))

proc gtk_list_box_set_adjustment(self: ptr ListBox00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setAdjustment*(self: ListBox; adjustment: Adjustment = nil) =
  gtk_list_box_set_adjustment(cast[ptr ListBox00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `adjustment=`*(self: ListBox; adjustment: Adjustment = nil) =
  gtk_list_box_set_adjustment(cast[ptr ListBox00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_list_box_set_placeholder(self: ptr ListBox00; placeholder: ptr Widget00) {.
    importc, libprag.}

proc setPlaceholder*(self: ListBox; placeholder: Widget = nil) =
  gtk_list_box_set_placeholder(cast[ptr ListBox00](self.impl), if placeholder.isNil: nil else: cast[ptr Widget00](placeholder.impl))

proc `placeholder=`*(self: ListBox; placeholder: Widget = nil) =
  gtk_list_box_set_placeholder(cast[ptr ListBox00](self.impl), if placeholder.isNil: nil else: cast[ptr Widget00](placeholder.impl))

proc gtk_list_box_unselect_all(self: ptr ListBox00) {.
    importc, libprag.}

proc unselectAll*(self: ListBox) =
  gtk_list_box_unselect_all(cast[ptr ListBox00](self.impl))

proc gtk_list_box_unselect_row(self: ptr ListBox00; row: ptr ListBoxRow00) {.
    importc, libprag.}

proc unselectRow*(self: ListBox; row: ListBoxRow) =
  gtk_list_box_unselect_row(cast[ptr ListBox00](self.impl), cast[ptr ListBoxRow00](row.impl))

type
  Expander* = ref object of Bin
  Expander00* = object of Bin00

proc gtk_expander_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Expander()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: Expander;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc gtk_expander_new(label: cstring): ptr Expander00 {.
    importc, libprag.}

proc newExpander*(label: cstring = nil): Expander =
  let gobj = gtk_expander_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newExpander*(tdesc: typedesc; label: cstring = nil): tdesc =
  assert(result is Expander)
  let gobj = gtk_expander_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initExpander*[T](result: var T; label: cstring = nil) {.deprecated.} =
  assert(result is Expander)
  let gobj = gtk_expander_new(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_new_with_mnemonic(label: cstring): ptr Expander00 {.
    importc, libprag.}

proc newExpanderWithMnemonic*(label: cstring = nil): Expander =
  let gobj = gtk_expander_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newExpanderWithMnemonic*(tdesc: typedesc; label: cstring = nil): tdesc =
  assert(result is Expander)
  let gobj = gtk_expander_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initExpanderWithMnemonic*[T](result: var T; label: cstring = nil) {.deprecated.} =
  assert(result is Expander)
  let gobj = gtk_expander_new_with_mnemonic(label)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_get_expanded(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getExpanded*(self: Expander): bool =
  toBool(gtk_expander_get_expanded(cast[ptr Expander00](self.impl)))

proc expanded*(self: Expander): bool =
  toBool(gtk_expander_get_expanded(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_label(self: ptr Expander00): cstring {.
    importc, libprag.}

proc getLabel*(self: Expander): string =
  let resul0 = gtk_expander_get_label(cast[ptr Expander00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: Expander): string =
  let resul0 = gtk_expander_get_label(cast[ptr Expander00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_expander_get_label_fill(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getLabelFill*(self: Expander): bool =
  toBool(gtk_expander_get_label_fill(cast[ptr Expander00](self.impl)))

proc labelFill*(self: Expander): bool =
  toBool(gtk_expander_get_label_fill(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_label_widget(self: ptr Expander00): ptr Widget00 {.
    importc, libprag.}

proc getLabelWidget*(self: Expander): Widget =
  let gobj = gtk_expander_get_label_widget(cast[ptr Expander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc labelWidget*(self: Expander): Widget =
  let gobj = gtk_expander_get_label_widget(cast[ptr Expander00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_expander_get_resize_toplevel(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getResizeToplevel*(self: Expander): bool =
  toBool(gtk_expander_get_resize_toplevel(cast[ptr Expander00](self.impl)))

proc resizeToplevel*(self: Expander): bool =
  toBool(gtk_expander_get_resize_toplevel(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_spacing(self: ptr Expander00): int32 {.
    importc, libprag.}

proc getSpacing*(self: Expander): int =
  int(gtk_expander_get_spacing(cast[ptr Expander00](self.impl)))

proc spacing*(self: Expander): int =
  int(gtk_expander_get_spacing(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_use_markup(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getUseMarkup*(self: Expander): bool =
  toBool(gtk_expander_get_use_markup(cast[ptr Expander00](self.impl)))

proc useMarkup*(self: Expander): bool =
  toBool(gtk_expander_get_use_markup(cast[ptr Expander00](self.impl)))

proc gtk_expander_get_use_underline(self: ptr Expander00): gboolean {.
    importc, libprag.}

proc getUseUnderline*(self: Expander): bool =
  toBool(gtk_expander_get_use_underline(cast[ptr Expander00](self.impl)))

proc useUnderline*(self: Expander): bool =
  toBool(gtk_expander_get_use_underline(cast[ptr Expander00](self.impl)))

proc gtk_expander_set_expanded(self: ptr Expander00; expanded: gboolean) {.
    importc, libprag.}

proc setExpanded*(self: Expander; expanded: bool = true) =
  gtk_expander_set_expanded(cast[ptr Expander00](self.impl), gboolean(expanded))

proc `expanded=`*(self: Expander; expanded: bool) =
  gtk_expander_set_expanded(cast[ptr Expander00](self.impl), gboolean(expanded))

proc gtk_expander_set_label(self: ptr Expander00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: Expander; label: cstring = nil) =
  gtk_expander_set_label(cast[ptr Expander00](self.impl), label)

proc `label=`*(self: Expander; label: cstring = nil) =
  gtk_expander_set_label(cast[ptr Expander00](self.impl), label)

proc gtk_expander_set_label_fill(self: ptr Expander00; labelFill: gboolean) {.
    importc, libprag.}

proc setLabelFill*(self: Expander; labelFill: bool = true) =
  gtk_expander_set_label_fill(cast[ptr Expander00](self.impl), gboolean(labelFill))

proc `labelFill=`*(self: Expander; labelFill: bool) =
  gtk_expander_set_label_fill(cast[ptr Expander00](self.impl), gboolean(labelFill))

proc gtk_expander_set_label_widget(self: ptr Expander00; labelWidget: ptr Widget00) {.
    importc, libprag.}

proc setLabelWidget*(self: Expander; labelWidget: Widget = nil) =
  gtk_expander_set_label_widget(cast[ptr Expander00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc `labelWidget=`*(self: Expander; labelWidget: Widget = nil) =
  gtk_expander_set_label_widget(cast[ptr Expander00](self.impl), if labelWidget.isNil: nil else: cast[ptr Widget00](labelWidget.impl))

proc gtk_expander_set_resize_toplevel(self: ptr Expander00; resizeToplevel: gboolean) {.
    importc, libprag.}

proc setResizeToplevel*(self: Expander; resizeToplevel: bool = true) =
  gtk_expander_set_resize_toplevel(cast[ptr Expander00](self.impl), gboolean(resizeToplevel))

proc `resizeToplevel=`*(self: Expander; resizeToplevel: bool) =
  gtk_expander_set_resize_toplevel(cast[ptr Expander00](self.impl), gboolean(resizeToplevel))

proc gtk_expander_set_spacing(self: ptr Expander00; spacing: int32) {.
    importc, libprag.}

proc setSpacing*(self: Expander; spacing: int) =
  gtk_expander_set_spacing(cast[ptr Expander00](self.impl), int32(spacing))

proc `spacing=`*(self: Expander; spacing: int) =
  gtk_expander_set_spacing(cast[ptr Expander00](self.impl), int32(spacing))

proc gtk_expander_set_use_markup(self: ptr Expander00; useMarkup: gboolean) {.
    importc, libprag.}

proc setUseMarkup*(self: Expander; useMarkup: bool = true) =
  gtk_expander_set_use_markup(cast[ptr Expander00](self.impl), gboolean(useMarkup))

proc `useMarkup=`*(self: Expander; useMarkup: bool) =
  gtk_expander_set_use_markup(cast[ptr Expander00](self.impl), gboolean(useMarkup))

proc gtk_expander_set_use_underline(self: ptr Expander00; useUnderline: gboolean) {.
    importc, libprag.}

proc setUseUnderline*(self: Expander; useUnderline: bool = true) =
  gtk_expander_set_use_underline(cast[ptr Expander00](self.impl), gboolean(useUnderline))

proc `useUnderline=`*(self: Expander; useUnderline: bool) =
  gtk_expander_set_use_underline(cast[ptr Expander00](self.impl), gboolean(useUnderline))

type
  HSV* = ref object of Widget
  HSV00* = object of Widget00

proc gtk_hsv_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HSV()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: HSV;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scMove*(self: HSV;  p: proc (self: ptr HSV00; `object`: DirectionType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "move", cast[GCallback](p), xdata, nil, cf)

proc gtk_hsv_new(): ptr HSV00 {.
    importc, libprag.}

proc newHSV*(): HSV =
  let gobj = gtk_hsv_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newHSV*(tdesc: typedesc): tdesc =
  assert(result is HSV)
  let gobj = gtk_hsv_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initHSV*[T](result: var T) {.deprecated.} =
  assert(result is HSV)
  let gobj = gtk_hsv_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc toRgb*(h: cdouble; s: cdouble; v: cdouble; r: var cdouble; g: var cdouble;
    b: var cdouble) {.
    importc: "gtk_hsv_to_rgb", libprag.}

proc gtk_hsv_get_color(self: ptr HSV00; h: var cdouble; s: var cdouble; v: var cdouble) {.
    importc, libprag.}

proc getColor*(self: HSV; h: var cdouble; s: var cdouble; v: var cdouble) =
  gtk_hsv_get_color(cast[ptr HSV00](self.impl), h, s, v)

proc gtk_hsv_get_metrics(self: ptr HSV00; size: var int32; ringWidth: var int32) {.
    importc, libprag.}

proc getMetrics*(self: HSV; size: var int; ringWidth: var int) =
  var ringWidth_00: int32
  var size_00: int32
  gtk_hsv_get_metrics(cast[ptr HSV00](self.impl), size_00, ringWidth_00)
  if ringWidth.addr != nil:
    ringWidth = int(ringWidth_00)
  if size.addr != nil:
    size = int(size_00)

proc gtk_hsv_is_adjusting(self: ptr HSV00): gboolean {.
    importc, libprag.}

proc isAdjusting*(self: HSV): bool =
  toBool(gtk_hsv_is_adjusting(cast[ptr HSV00](self.impl)))

proc gtk_hsv_set_color(self: ptr HSV00; h: cdouble; s: cdouble; v: cdouble) {.
    importc, libprag.}

proc setColor*(self: HSV; h: cdouble; s: cdouble; v: cdouble) =
  gtk_hsv_set_color(cast[ptr HSV00](self.impl), h, s, v)

proc gtk_hsv_set_metrics(self: ptr HSV00; size: int32; ringWidth: int32) {.
    importc, libprag.}

proc setMetrics*(self: HSV; size: int; ringWidth: int) =
  gtk_hsv_set_metrics(cast[ptr HSV00](self.impl), int32(size), int32(ringWidth))

type
  PopoverMenu* = ref object of Popover
  PopoverMenu00* = object of Popover00

proc gtk_popover_menu_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PopoverMenu()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_popover_menu_new(): ptr PopoverMenu00 {.
    importc, libprag.}

proc newPopoverMenu*(): PopoverMenu =
  let gobj = gtk_popover_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPopoverMenu*(tdesc: typedesc): tdesc =
  assert(result is PopoverMenu)
  let gobj = gtk_popover_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPopoverMenu*[T](result: var T) {.deprecated.} =
  assert(result is PopoverMenu)
  let gobj = gtk_popover_menu_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_popover_menu_open_submenu(self: ptr PopoverMenu00; name: cstring) {.
    importc, libprag.}

proc openSubmenu*(self: PopoverMenu; name: cstring) =
  gtk_popover_menu_open_submenu(cast[ptr PopoverMenu00](self.impl), name)

type
  LevelBar* = ref object of Widget
  LevelBar00* = object of Widget00

proc gtk_level_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LevelBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scOffsetChanged*(self: LevelBar;  p: proc (self: ptr LevelBar00; name: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "offset-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_level_bar_new(): ptr LevelBar00 {.
    importc, libprag.}

proc newLevelBar*(): LevelBar =
  let gobj = gtk_level_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLevelBar*(tdesc: typedesc): tdesc =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLevelBar*[T](result: var T) {.deprecated.} =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_level_bar_new_for_interval(minValue: cdouble; maxValue: cdouble): ptr LevelBar00 {.
    importc, libprag.}

proc newLevelBarForInterval*(minValue: cdouble; maxValue: cdouble): LevelBar =
  let gobj = gtk_level_bar_new_for_interval(minValue, maxValue)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLevelBarForInterval*(tdesc: typedesc; minValue: cdouble; maxValue: cdouble): tdesc =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new_for_interval(minValue, maxValue)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLevelBarForInterval*[T](result: var T; minValue: cdouble; maxValue: cdouble) {.deprecated.} =
  assert(result is LevelBar)
  let gobj = gtk_level_bar_new_for_interval(minValue, maxValue)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_level_bar_add_offset_value(self: ptr LevelBar00; name: cstring;
    value: cdouble) {.
    importc, libprag.}

proc addOffsetValue*(self: LevelBar; name: cstring; value: cdouble) =
  gtk_level_bar_add_offset_value(cast[ptr LevelBar00](self.impl), name, value)

proc gtk_level_bar_get_inverted(self: ptr LevelBar00): gboolean {.
    importc, libprag.}

proc getInverted*(self: LevelBar): bool =
  toBool(gtk_level_bar_get_inverted(cast[ptr LevelBar00](self.impl)))

proc inverted*(self: LevelBar): bool =
  toBool(gtk_level_bar_get_inverted(cast[ptr LevelBar00](self.impl)))

proc gtk_level_bar_get_max_value(self: ptr LevelBar00): cdouble {.
    importc, libprag.}

proc getMaxValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_max_value(cast[ptr LevelBar00](self.impl))

proc maxValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_max_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_get_min_value(self: ptr LevelBar00): cdouble {.
    importc, libprag.}

proc getMinValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_min_value(cast[ptr LevelBar00](self.impl))

proc minValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_min_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_get_offset_value(self: ptr LevelBar00; name: cstring;
    value: var cdouble): gboolean {.
    importc, libprag.}

proc getOffsetValue*(self: LevelBar; name: cstring = nil;
    value: var cdouble): bool =
  toBool(gtk_level_bar_get_offset_value(cast[ptr LevelBar00](self.impl), name, value))

proc gtk_level_bar_get_value(self: ptr LevelBar00): cdouble {.
    importc, libprag.}

proc getValue*(self: LevelBar): cdouble =
  gtk_level_bar_get_value(cast[ptr LevelBar00](self.impl))

proc value*(self: LevelBar): cdouble =
  gtk_level_bar_get_value(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_remove_offset_value(self: ptr LevelBar00; name: cstring) {.
    importc, libprag.}

proc removeOffsetValue*(self: LevelBar; name: cstring = nil) =
  gtk_level_bar_remove_offset_value(cast[ptr LevelBar00](self.impl), name)

proc gtk_level_bar_set_inverted(self: ptr LevelBar00; inverted: gboolean) {.
    importc, libprag.}

proc setInverted*(self: LevelBar; inverted: bool = true) =
  gtk_level_bar_set_inverted(cast[ptr LevelBar00](self.impl), gboolean(inverted))

proc `inverted=`*(self: LevelBar; inverted: bool) =
  gtk_level_bar_set_inverted(cast[ptr LevelBar00](self.impl), gboolean(inverted))

proc gtk_level_bar_set_max_value(self: ptr LevelBar00; value: cdouble) {.
    importc, libprag.}

proc setMaxValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_max_value(cast[ptr LevelBar00](self.impl), value)

proc `maxValue=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_max_value(cast[ptr LevelBar00](self.impl), value)

proc gtk_level_bar_set_min_value(self: ptr LevelBar00; value: cdouble) {.
    importc, libprag.}

proc setMinValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_min_value(cast[ptr LevelBar00](self.impl), value)

proc `minValue=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_min_value(cast[ptr LevelBar00](self.impl), value)

proc gtk_level_bar_set_value(self: ptr LevelBar00; value: cdouble) {.
    importc, libprag.}

proc setValue*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_value(cast[ptr LevelBar00](self.impl), value)

proc `value=`*(self: LevelBar; value: cdouble) =
  gtk_level_bar_set_value(cast[ptr LevelBar00](self.impl), value)

type
  InfoBar* = ref object of Box
  InfoBar00* = object of Box00

proc gtk_info_bar_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(InfoBar()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scClose*(self: InfoBar;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "close", cast[GCallback](p), xdata, nil, cf)

proc scResponse*(self: InfoBar;  p: proc (self: ptr InfoBar00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cf)

proc gtk_info_bar_new(): ptr InfoBar00 {.
    importc, libprag.}

proc newInfoBar*(): InfoBar =
  let gobj = gtk_info_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newInfoBar*(tdesc: typedesc): tdesc =
  assert(result is InfoBar)
  let gobj = gtk_info_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initInfoBar*[T](result: var T) {.deprecated.} =
  assert(result is InfoBar)
  let gobj = gtk_info_bar_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_add_action_widget(self: ptr InfoBar00; child: ptr Widget00;
    responseId: int32) {.
    importc, libprag.}

proc addActionWidget*(self: InfoBar; child: Widget; responseId: int) =
  gtk_info_bar_add_action_widget(cast[ptr InfoBar00](self.impl), cast[ptr Widget00](child.impl), int32(responseId))

proc gtk_info_bar_add_button(self: ptr InfoBar00; buttonText: cstring; responseId: int32): ptr Button00 {.
    importc, libprag.}

proc addButton*(self: InfoBar; buttonText: cstring; responseId: int): Button =
  let gobj = gtk_info_bar_add_button(cast[ptr InfoBar00](self.impl), buttonText, int32(responseId))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_get_action_area(self: ptr InfoBar00): ptr Box00 {.
    importc, libprag.}

proc getActionArea*(self: InfoBar): Box =
  let gobj = gtk_info_bar_get_action_area(cast[ptr InfoBar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc actionArea*(self: InfoBar): Box =
  let gobj = gtk_info_bar_get_action_area(cast[ptr InfoBar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_get_content_area(self: ptr InfoBar00): ptr Box00 {.
    importc, libprag.}

proc getContentArea*(self: InfoBar): Box =
  let gobj = gtk_info_bar_get_content_area(cast[ptr InfoBar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc contentArea*(self: InfoBar): Box =
  let gobj = gtk_info_bar_get_content_area(cast[ptr InfoBar00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_info_bar_get_revealed(self: ptr InfoBar00): gboolean {.
    importc, libprag.}

proc getRevealed*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_revealed(cast[ptr InfoBar00](self.impl)))

proc revealed*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_revealed(cast[ptr InfoBar00](self.impl)))

proc gtk_info_bar_get_show_close_button(self: ptr InfoBar00): gboolean {.
    importc, libprag.}

proc getShowCloseButton*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_show_close_button(cast[ptr InfoBar00](self.impl)))

proc showCloseButton*(self: InfoBar): bool =
  toBool(gtk_info_bar_get_show_close_button(cast[ptr InfoBar00](self.impl)))

proc gtk_info_bar_response(self: ptr InfoBar00; responseId: int32) {.
    importc, libprag.}

proc response*(self: InfoBar; responseId: int) =
  gtk_info_bar_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc gtk_info_bar_set_default_response(self: ptr InfoBar00; responseId: int32) {.
    importc, libprag.}

proc setDefaultResponse*(self: InfoBar; responseId: int) =
  gtk_info_bar_set_default_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc `defaultResponse=`*(self: InfoBar; responseId: int) =
  gtk_info_bar_set_default_response(cast[ptr InfoBar00](self.impl), int32(responseId))

proc gtk_info_bar_set_response_sensitive(self: ptr InfoBar00; responseId: int32;
    setting: gboolean) {.
    importc, libprag.}

proc setResponseSensitive*(self: InfoBar; responseId: int;
    setting: bool) =
  gtk_info_bar_set_response_sensitive(cast[ptr InfoBar00](self.impl), int32(responseId), gboolean(setting))

proc gtk_info_bar_set_revealed(self: ptr InfoBar00; revealed: gboolean) {.
    importc, libprag.}

proc setRevealed*(self: InfoBar; revealed: bool = true) =
  gtk_info_bar_set_revealed(cast[ptr InfoBar00](self.impl), gboolean(revealed))

proc `revealed=`*(self: InfoBar; revealed: bool) =
  gtk_info_bar_set_revealed(cast[ptr InfoBar00](self.impl), gboolean(revealed))

proc gtk_info_bar_set_show_close_button(self: ptr InfoBar00; setting: gboolean) {.
    importc, libprag.}

proc setShowCloseButton*(self: InfoBar; setting: bool = true) =
  gtk_info_bar_set_show_close_button(cast[ptr InfoBar00](self.impl), gboolean(setting))

proc `showCloseButton=`*(self: InfoBar; setting: bool) =
  gtk_info_bar_set_show_close_button(cast[ptr InfoBar00](self.impl), gboolean(setting))

type
  Revealer* = ref object of Bin
  Revealer00* = object of Bin00

proc gtk_revealer_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Revealer()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_revealer_new(): ptr Revealer00 {.
    importc, libprag.}

proc newRevealer*(): Revealer =
  let gobj = gtk_revealer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRevealer*(tdesc: typedesc): tdesc =
  assert(result is Revealer)
  let gobj = gtk_revealer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRevealer*[T](result: var T) {.deprecated.} =
  assert(result is Revealer)
  let gobj = gtk_revealer_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_revealer_get_child_revealed(self: ptr Revealer00): gboolean {.
    importc, libprag.}

proc getChildRevealed*(self: Revealer): bool =
  toBool(gtk_revealer_get_child_revealed(cast[ptr Revealer00](self.impl)))

proc childRevealed*(self: Revealer): bool =
  toBool(gtk_revealer_get_child_revealed(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_get_reveal_child(self: ptr Revealer00): gboolean {.
    importc, libprag.}

proc getRevealChild*(self: Revealer): bool =
  toBool(gtk_revealer_get_reveal_child(cast[ptr Revealer00](self.impl)))

proc revealChild*(self: Revealer): bool =
  toBool(gtk_revealer_get_reveal_child(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_get_transition_duration(self: ptr Revealer00): uint32 {.
    importc, libprag.}

proc getTransitionDuration*(self: Revealer): int =
  int(gtk_revealer_get_transition_duration(cast[ptr Revealer00](self.impl)))

proc transitionDuration*(self: Revealer): int =
  int(gtk_revealer_get_transition_duration(cast[ptr Revealer00](self.impl)))

proc gtk_revealer_set_reveal_child(self: ptr Revealer00; revealChild: gboolean) {.
    importc, libprag.}

proc setRevealChild*(self: Revealer; revealChild: bool = true) =
  gtk_revealer_set_reveal_child(cast[ptr Revealer00](self.impl), gboolean(revealChild))

proc `revealChild=`*(self: Revealer; revealChild: bool) =
  gtk_revealer_set_reveal_child(cast[ptr Revealer00](self.impl), gboolean(revealChild))

proc gtk_revealer_set_transition_duration(self: ptr Revealer00; duration: uint32) {.
    importc, libprag.}

proc setTransitionDuration*(self: Revealer; duration: int) =
  gtk_revealer_set_transition_duration(cast[ptr Revealer00](self.impl), uint32(duration))

proc `transitionDuration=`*(self: Revealer; duration: int) =
  gtk_revealer_set_transition_duration(cast[ptr Revealer00](self.impl), uint32(duration))

type
  RecentFilter* = ref object of gobject.InitiallyUnowned
  RecentFilter00* = object of gobject.InitiallyUnowned00

proc gtk_recent_filter_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RecentFilter()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_recent_filter_new(): ptr RecentFilter00 {.
    importc, libprag.}

proc newRecentFilter*(): RecentFilter =
  let gobj = gtk_recent_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newRecentFilter*(tdesc: typedesc): tdesc =
  assert(result is RecentFilter)
  let gobj = gtk_recent_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initRecentFilter*[T](result: var T) {.deprecated.} =
  assert(result is RecentFilter)
  let gobj = gtk_recent_filter_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_filter_add_age(self: ptr RecentFilter00; days: int32) {.
    importc, libprag.}

proc addAge*(self: RecentFilter; days: int) =
  gtk_recent_filter_add_age(cast[ptr RecentFilter00](self.impl), int32(days))

proc gtk_recent_filter_add_application(self: ptr RecentFilter00; application: cstring) {.
    importc, libprag.}

proc addApplication*(self: RecentFilter; application: cstring) =
  gtk_recent_filter_add_application(cast[ptr RecentFilter00](self.impl), application)

proc gtk_recent_filter_add_group(self: ptr RecentFilter00; group: cstring) {.
    importc, libprag.}

proc addGroup*(self: RecentFilter; group: cstring) =
  gtk_recent_filter_add_group(cast[ptr RecentFilter00](self.impl), group)

proc gtk_recent_filter_add_mime_type(self: ptr RecentFilter00; mimeType: cstring) {.
    importc, libprag.}

proc addMimeType*(self: RecentFilter; mimeType: cstring) =
  gtk_recent_filter_add_mime_type(cast[ptr RecentFilter00](self.impl), mimeType)

proc gtk_recent_filter_add_pattern(self: ptr RecentFilter00; pattern: cstring) {.
    importc, libprag.}

proc addPattern*(self: RecentFilter; pattern: cstring) =
  gtk_recent_filter_add_pattern(cast[ptr RecentFilter00](self.impl), pattern)

proc gtk_recent_filter_add_pixbuf_formats(self: ptr RecentFilter00) {.
    importc, libprag.}

proc addPixbufFormats*(self: RecentFilter) =
  gtk_recent_filter_add_pixbuf_formats(cast[ptr RecentFilter00](self.impl))

proc gtk_recent_filter_get_name(self: ptr RecentFilter00): cstring {.
    importc, libprag.}

proc getName*(self: RecentFilter): string =
  let resul0 = gtk_recent_filter_get_name(cast[ptr RecentFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc name*(self: RecentFilter): string =
  let resul0 = gtk_recent_filter_get_name(cast[ptr RecentFilter00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_recent_filter_set_name(self: ptr RecentFilter00; name: cstring) {.
    importc, libprag.}

proc setName*(self: RecentFilter; name: cstring) =
  gtk_recent_filter_set_name(cast[ptr RecentFilter00](self.impl), name)

proc `name=`*(self: RecentFilter; name: cstring) =
  gtk_recent_filter_set_name(cast[ptr RecentFilter00](self.impl), name)

type
  Layout* = ref object of Container
  Layout00* = object of Container00

proc gtk_layout_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Layout()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_layout_new(hadjustment: ptr Adjustment00; vadjustment: ptr Adjustment00): ptr Layout00 {.
    importc, libprag.}

proc newLayout*(hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): Layout =
  let gobj = gtk_layout_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newLayout*(tdesc: typedesc; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil): tdesc =
  assert(result is Layout)
  let gobj = gtk_layout_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initLayout*[T](result: var T; hadjustment: Adjustment = nil; vadjustment: Adjustment = nil) {.deprecated.} =
  assert(result is Layout)
  let gobj = gtk_layout_new(if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_get_bin_window(self: ptr Layout00): ptr gdk.Window00 {.
    importc, libprag.}

proc getBinWindow*(self: Layout): gdk.Window =
  let gobj = gtk_layout_get_bin_window(cast[ptr Layout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc binWindow*(self: Layout): gdk.Window =
  let gobj = gtk_layout_get_bin_window(cast[ptr Layout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_get_hadjustment(self: ptr Layout00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_hadjustment(cast[ptr Layout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_hadjustment(cast[ptr Layout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_get_size(self: ptr Layout00; width: var uint32; height: var uint32) {.
    importc, libprag.}

proc getSize*(self: Layout; width: var int = cast[var int](nil);
    height: var int = cast[var int](nil)) =
  var width_00: uint32
  var height_00: uint32
  gtk_layout_get_size(cast[ptr Layout00](self.impl), width_00, height_00)
  if width.addr != nil:
    width = int(width_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_layout_get_vadjustment(self: ptr Layout00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_vadjustment(cast[ptr Layout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: Layout): Adjustment =
  let gobj = gtk_layout_get_vadjustment(cast[ptr Layout00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_layout_move(self: ptr Layout00; childWidget: ptr Widget00; x: int32;
    y: int32) {.
    importc, libprag.}

proc move*(self: Layout; childWidget: Widget; x: int; y: int) =
  gtk_layout_move(cast[ptr Layout00](self.impl), cast[ptr Widget00](childWidget.impl), int32(x), int32(y))

proc gtk_layout_put(self: ptr Layout00; childWidget: ptr Widget00; x: int32;
    y: int32) {.
    importc, libprag.}

proc put*(self: Layout; childWidget: Widget; x: int; y: int) =
  gtk_layout_put(cast[ptr Layout00](self.impl), cast[ptr Widget00](childWidget.impl), int32(x), int32(y))

proc gtk_layout_set_hadjustment(self: ptr Layout00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: Layout; adjustment: Adjustment = nil) =
  gtk_layout_set_hadjustment(cast[ptr Layout00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `hadjustment=`*(self: Layout; adjustment: Adjustment = nil) =
  gtk_layout_set_hadjustment(cast[ptr Layout00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_layout_set_size(self: ptr Layout00; width: uint32; height: uint32) {.
    importc, libprag.}

proc setSize*(self: Layout; width: int; height: int) =
  gtk_layout_set_size(cast[ptr Layout00](self.impl), uint32(width), uint32(height))

proc gtk_layout_set_vadjustment(self: ptr Layout00; adjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: Layout; adjustment: Adjustment = nil) =
  gtk_layout_set_vadjustment(cast[ptr Layout00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc `vadjustment=`*(self: Layout; adjustment: Adjustment = nil) =
  gtk_layout_set_vadjustment(cast[ptr Layout00](self.impl), if adjustment.isNil: nil else: cast[ptr Adjustment00](adjustment.impl))

proc gtk_buildable_add_child(self: ptr Buildable00; builder: ptr Builder00;
    child: ptr gobject.Object00; `type`: cstring) {.
    importc, libprag.}

proc addChild*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder; child: gobject.Object; `type`: cstring = nil) =
  gtk_buildable_add_child(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), cast[ptr gobject.Object00](child.impl), `type`)

proc gtk_buildable_construct_child(self: ptr Buildable00; builder: ptr Builder00;
    name: cstring): ptr gobject.Object00 {.
    importc, libprag.}

proc constructChild*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder; name: cstring): gobject.Object =
  let gobj = gtk_buildable_construct_child(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), name)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_buildable_custom_finished(self: ptr Buildable00; builder: ptr Builder00;
    child: ptr gobject.Object00; tagname: cstring; data: pointer) {.
    importc, libprag.}

proc customFinished*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder; child: gobject.Object = nil; tagname: cstring; data: pointer) =
  gtk_buildable_custom_finished(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), if child.isNil: nil else: cast[ptr gobject.Object00](child.impl), tagname, data)

proc gtk_buildable_custom_tag_end(self: ptr Buildable00; builder: ptr Builder00;
    child: ptr gobject.Object00; tagname: cstring; data: pointer) {.
    importc, libprag.}

proc customTagEnd*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder; child: gobject.Object = nil; tagname: cstring; data: pointer) =
  gtk_buildable_custom_tag_end(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), if child.isNil: nil else: cast[ptr gobject.Object00](child.impl), tagname, data)

proc gtk_buildable_custom_tag_start(self: ptr Buildable00; builder: ptr Builder00;
    child: ptr gobject.Object00; tagname: cstring; parser: var glib.MarkupParser;
    data: var pointer): gboolean {.
    importc, libprag.}

proc customTagStart*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder; child: gobject.Object = nil; tagname: cstring; parser: var glib.MarkupParser;
    data: var pointer): bool =
  toBool(gtk_buildable_custom_tag_start(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), if child.isNil: nil else: cast[ptr gobject.Object00](child.impl), tagname, parser, data))

proc gtk_buildable_get_internal_child(self: ptr Buildable00; builder: ptr Builder00;
    childname: cstring): ptr gobject.Object00 {.
    importc, libprag.}

proc getInternalChild*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder; childname: cstring): gobject.Object =
  let gobj = gtk_buildable_get_internal_child(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), childname)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gobject.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_buildable_get_name(self: ptr Buildable00): cstring {.
    importc, libprag.}

proc buildableGetName*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction): string =
  result = $gtk_buildable_get_name(cast[ptr Buildable00](self.impl))

proc gtk_buildable_parser_finished(self: ptr Buildable00; builder: ptr Builder00) {.
    importc, libprag.}

proc parserFinished*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder) =
  gtk_buildable_parser_finished(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl))

proc gtk_buildable_set_buildable_property(self: ptr Buildable00; builder: ptr Builder00;
    name: cstring; value: gobject.Value) {.
    importc, libprag.}

proc setBuildableProperty*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    builder: Builder; name: cstring; value: gobject.Value) =
  gtk_buildable_set_buildable_property(cast[ptr Buildable00](self.impl), cast[ptr Builder00](builder.impl), name, value)

proc gtk_buildable_set_name(self: ptr Buildable00; name: cstring) {.
    importc, libprag.}

proc buildableSetName*(self: Buildable | IconView | Spinner | Box | Viewport | ShortcutLabel | TearoffMenuItem | FileFilter | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | Label | TreeViewColumn | OffscreenWindow | ComboBoxText | HScale | MenuBar | Statusbar | ToolPalette | FileChooserButton | CheckButton | CellView | ToggleToolButton | IconFactory | Toolbar | ModelButton | ShortcutsWindow | DrawingArea | RadioAction | HScrollbar | SpinButton | ScaleButton | CellArea | VScrollbar | StackSidebar | Plug | MenuShell | ListStore | FontSelectionDialog | UIManager | ShortcutsSection | ColorSelection | ButtonBox | PlacesSidebar | Table | TextView | Window | Notebook | Widget | VSeparator | StackSwitcher | SeparatorToolItem | Image | Misc | HPaned | Separator | AppChooserButton | ScrolledWindow | Switch | VButtonBox | FontSelection | AspectFrame | HBox | EntryCompletion | Paned | CellAreaBox | ActionGroup | Overlay | AboutDialog | ActionBar | RecentChooserWidget | ToolItem | Grid | ProgressBar | HSeparator | Menu | HandleBox | Socket | Entry | RadioToolButton | SearchEntry | Dialog | AppChooserDialog | ListBoxRow | ColorButton | Scale | Stack | FileChooserWidget | RadioButton | FileChooserDialog | Bin | LinkButton | AccelLabel | Frame | ImageMenuItem | Arrow | MenuToolButton | FontChooserDialog | MessageDialog | RecentChooserDialog | Calendar | Scrollbar | HeaderBar | RecentAction | SearchBar | ToggleButton | Invisible | TreeView | Popover | ColorChooserDialog | ColorChooserWidget | EventBox | VScale | ShortcutsShortcut | LockButton | TreeStore | ColorSelectionDialog | ComboBox | CheckMenuItem | MenuItem | Fixed | TextTagTable | Alignment | GLArea | AppChooserWidget | RadioMenuItem | Container | ToolItemGroup | HButtonBox | SizeGroup | VolumeButton | RecentChooserMenu | FontButton | SeparatorMenuItem | ListBox | Expander | HSV | Button | PopoverMenu | MenuButton | LevelBar | Action | Range | FlowBoxChild | InfoBar | Revealer | ToolButton | RecentFilter | ApplicationWindow | Assistant | Layout | ToggleAction;
    name: cstring) =
  gtk_buildable_set_name(cast[ptr Buildable00](self.impl), name)

type
  RecentFilterFlag* {.size: sizeof(cint), pure.} = enum
    uri = 0
    displayName = 1
    mimeType = 2
    application = 3
    group = 4
    age = 5

  RecentFilterFlags* {.size: sizeof(cint).} = set[RecentFilterFlag]

type
  RecentFilterInfo* {.pure, byRef.} = object
    contains*: RecentFilterFlags
    uri*: cstring
    displayName*: cstring
    mimeType*: cstring
    applications*: ptr cstring
    groups*: ptr cstring
    age*: int32

proc gtk_recent_filter_filter(self: ptr RecentFilter00; filterInfo: RecentFilterInfo): gboolean {.
    importc, libprag.}

proc filter*(self: RecentFilter; filterInfo: RecentFilterInfo): bool =
  toBool(gtk_recent_filter_filter(cast[ptr RecentFilter00](self.impl), filterInfo))

proc gtk_recent_filter_get_needed(self: ptr RecentFilter00): RecentFilterFlags {.
    importc, libprag.}

proc getNeeded*(self: RecentFilter): RecentFilterFlags =
  gtk_recent_filter_get_needed(cast[ptr RecentFilter00](self.impl))

proc needed*(self: RecentFilter): RecentFilterFlags =
  gtk_recent_filter_get_needed(cast[ptr RecentFilter00](self.impl))

type
  RevealerTransitionType* {.size: sizeof(cint), pure.} = enum
    none = 0
    crossfade = 1
    slideRight = 2
    slideLeft = 3
    slideUp = 4
    slideDown = 5

proc gtk_revealer_get_transition_type(self: ptr Revealer00): RevealerTransitionType {.
    importc, libprag.}

proc getTransitionType*(self: Revealer): RevealerTransitionType =
  gtk_revealer_get_transition_type(cast[ptr Revealer00](self.impl))

proc transitionType*(self: Revealer): RevealerTransitionType =
  gtk_revealer_get_transition_type(cast[ptr Revealer00](self.impl))

proc gtk_revealer_set_transition_type(self: ptr Revealer00; transition: RevealerTransitionType) {.
    importc, libprag.}

proc setTransitionType*(self: Revealer; transition: RevealerTransitionType) =
  gtk_revealer_set_transition_type(cast[ptr Revealer00](self.impl), transition)

proc `transitionType=`*(self: Revealer; transition: RevealerTransitionType) =
  gtk_revealer_set_transition_type(cast[ptr Revealer00](self.impl), transition)

type
  MessageType* {.size: sizeof(cint), pure.} = enum
    info = 0
    warning = 1
    question = 2
    error = 3
    other = 4

proc gtk_info_bar_get_message_type(self: ptr InfoBar00): MessageType {.
    importc, libprag.}

proc getMessageType*(self: InfoBar): MessageType =
  gtk_info_bar_get_message_type(cast[ptr InfoBar00](self.impl))

proc messageType*(self: InfoBar): MessageType =
  gtk_info_bar_get_message_type(cast[ptr InfoBar00](self.impl))

proc gtk_info_bar_set_message_type(self: ptr InfoBar00; messageType: MessageType) {.
    importc, libprag.}

proc setMessageType*(self: InfoBar; messageType: MessageType) =
  gtk_info_bar_set_message_type(cast[ptr InfoBar00](self.impl), messageType)

proc `messageType=`*(self: InfoBar; messageType: MessageType) =
  gtk_info_bar_set_message_type(cast[ptr InfoBar00](self.impl), messageType)

type
  LevelBarMode* {.size: sizeof(cint), pure.} = enum
    continuous = 0
    discrete = 1

proc gtk_level_bar_get_mode(self: ptr LevelBar00): LevelBarMode {.
    importc, libprag.}

proc getMode*(self: LevelBar): LevelBarMode =
  gtk_level_bar_get_mode(cast[ptr LevelBar00](self.impl))

proc mode*(self: LevelBar): LevelBarMode =
  gtk_level_bar_get_mode(cast[ptr LevelBar00](self.impl))

proc gtk_level_bar_set_mode(self: ptr LevelBar00; mode: LevelBarMode) {.
    importc, libprag.}

proc setMode*(self: LevelBar; mode: LevelBarMode) =
  gtk_level_bar_set_mode(cast[ptr LevelBar00](self.impl), mode)

proc `mode=`*(self: LevelBar; mode: LevelBarMode) =
  gtk_level_bar_set_mode(cast[ptr LevelBar00](self.impl), mode)

type
  PackDirection* {.size: sizeof(cint), pure.} = enum
    ltr = 0
    rtl = 1
    ttb = 2
    btt = 3

proc gtk_menu_bar_get_child_pack_direction(self: ptr MenuBar00): PackDirection {.
    importc, libprag.}

proc getChildPackDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_child_pack_direction(cast[ptr MenuBar00](self.impl))

proc childPackDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_child_pack_direction(cast[ptr MenuBar00](self.impl))

proc gtk_menu_bar_get_pack_direction(self: ptr MenuBar00): PackDirection {.
    importc, libprag.}

proc getPackDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_pack_direction(cast[ptr MenuBar00](self.impl))

proc packDirection*(self: MenuBar): PackDirection =
  gtk_menu_bar_get_pack_direction(cast[ptr MenuBar00](self.impl))

proc gtk_menu_bar_set_child_pack_direction(self: ptr MenuBar00; childPackDir: PackDirection) {.
    importc, libprag.}

proc setChildPackDirection*(self: MenuBar; childPackDir: PackDirection) =
  gtk_menu_bar_set_child_pack_direction(cast[ptr MenuBar00](self.impl), childPackDir)

proc `childPackDirection=`*(self: MenuBar; childPackDir: PackDirection) =
  gtk_menu_bar_set_child_pack_direction(cast[ptr MenuBar00](self.impl), childPackDir)

proc gtk_menu_bar_set_pack_direction(self: ptr MenuBar00; packDir: PackDirection) {.
    importc, libprag.}

proc setPackDirection*(self: MenuBar; packDir: PackDirection) =
  gtk_menu_bar_set_pack_direction(cast[ptr MenuBar00](self.impl), packDir)

proc `packDirection=`*(self: MenuBar; packDir: PackDirection) =
  gtk_menu_bar_set_pack_direction(cast[ptr MenuBar00](self.impl), packDir)

type
  TreeViewColumnSizing* {.size: sizeof(cint), pure.} = enum
    growOnly = 0
    autosize = 1
    fixed = 2

proc gtk_tree_view_column_get_sizing(self: ptr TreeViewColumn00): TreeViewColumnSizing {.
    importc, libprag.}

proc getSizing*(self: TreeViewColumn): TreeViewColumnSizing =
  gtk_tree_view_column_get_sizing(cast[ptr TreeViewColumn00](self.impl))

proc sizing*(self: TreeViewColumn): TreeViewColumnSizing =
  gtk_tree_view_column_get_sizing(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_sizing(self: ptr TreeViewColumn00; `type`: TreeViewColumnSizing) {.
    importc, libprag.}

proc setSizing*(self: TreeViewColumn; `type`: TreeViewColumnSizing) =
  gtk_tree_view_column_set_sizing(cast[ptr TreeViewColumn00](self.impl), `type`)

proc `sizing=`*(self: TreeViewColumn; `type`: TreeViewColumnSizing) =
  gtk_tree_view_column_set_sizing(cast[ptr TreeViewColumn00](self.impl), `type`)

type
  SortType* {.size: sizeof(cint), pure.} = enum
    ascending = 0
    descending = 1

proc gtk_tree_view_column_get_sort_order(self: ptr TreeViewColumn00): SortType {.
    importc, libprag.}

proc getSortOrder*(self: TreeViewColumn): SortType =
  gtk_tree_view_column_get_sort_order(cast[ptr TreeViewColumn00](self.impl))

proc sortOrder*(self: TreeViewColumn): SortType =
  gtk_tree_view_column_get_sort_order(cast[ptr TreeViewColumn00](self.impl))

proc gtk_tree_view_column_set_sort_order(self: ptr TreeViewColumn00; order: SortType) {.
    importc, libprag.}

proc setSortOrder*(self: TreeViewColumn; order: SortType) =
  gtk_tree_view_column_set_sort_order(cast[ptr TreeViewColumn00](self.impl), order)

proc `sortOrder=`*(self: TreeViewColumn; order: SortType) =
  gtk_tree_view_column_set_sort_order(cast[ptr TreeViewColumn00](self.impl), order)

type
  FileFilterFlag* {.size: sizeof(cint), pure.} = enum
    filename = 0
    uri = 1
    displayName = 2
    mimeType = 3

  FileFilterFlags* {.size: sizeof(cint).} = set[FileFilterFlag]

type
  FileFilterInfo* {.pure, byRef.} = object
    contains*: FileFilterFlags
    filename*: cstring
    uri*: cstring
    displayName*: cstring
    mimeType*: cstring

proc gtk_file_filter_filter(self: ptr FileFilter00; filterInfo: FileFilterInfo): gboolean {.
    importc, libprag.}

proc filter*(self: FileFilter; filterInfo: FileFilterInfo): bool =
  toBool(gtk_file_filter_filter(cast[ptr FileFilter00](self.impl), filterInfo))

proc gtk_file_filter_get_needed(self: ptr FileFilter00): FileFilterFlags {.
    importc, libprag.}

proc getNeeded*(self: FileFilter): FileFilterFlags =
  gtk_file_filter_get_needed(cast[ptr FileFilter00](self.impl))

proc needed*(self: FileFilter): FileFilterFlags =
  gtk_file_filter_get_needed(cast[ptr FileFilter00](self.impl))

type
  IconViewDropPosition* {.size: sizeof(cint), pure.} = enum
    noDrop = 0
    dropInto = 1
    dropLeft = 2
    dropRight = 3
    dropAbove = 4
    dropBelow = 5

proc gtk_icon_view_get_dest_item_at_pos(self: ptr IconView00; dragX: int32;
    dragY: int32; path: var ptr TreePath00; pos: var IconViewDropPosition): gboolean {.
    importc, libprag.}

proc getDestItemAtPos*(self: IconView; dragX: int; dragY: int;
    path: var TreePath = cast[var TreePath](nil); pos: var IconViewDropPosition = cast[var IconViewDropPosition](nil)): bool =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  toBool(gtk_icon_view_get_dest_item_at_pos(cast[ptr IconView00](self.impl), int32(dragX), int32(dragY), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos))

proc gtk_icon_view_get_drag_dest_item(self: ptr IconView00; path: var ptr TreePath00;
    pos: var IconViewDropPosition) {.
    importc, libprag.}

proc getDragDestItem*(self: IconView; path: var TreePath = cast[var TreePath](nil);
    pos: var IconViewDropPosition = cast[var IconViewDropPosition](nil)) =
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  gtk_icon_view_get_drag_dest_item(cast[ptr IconView00](self.impl), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl), pos)

proc gtk_icon_view_set_drag_dest_item(self: ptr IconView00; path: ptr TreePath00;
    pos: IconViewDropPosition) {.
    importc, libprag.}

proc setDragDestItem*(self: IconView; path: TreePath = nil;
    pos: IconViewDropPosition) =
  gtk_icon_view_set_drag_dest_item(cast[ptr IconView00](self.impl), if path.isNil: nil else: cast[ptr TreePath00](path.impl), pos)

type
  SelectionMode* {.size: sizeof(cint), pure.} = enum
    none = 0
    single = 1
    browse = 2
    multiple = 3

proc gtk_icon_view_get_selection_mode(self: ptr IconView00): SelectionMode {.
    importc, libprag.}

proc getSelectionMode*(self: IconView): SelectionMode =
  gtk_icon_view_get_selection_mode(cast[ptr IconView00](self.impl))

proc selectionMode*(self: IconView): SelectionMode =
  gtk_icon_view_get_selection_mode(cast[ptr IconView00](self.impl))

proc gtk_icon_view_set_selection_mode(self: ptr IconView00; mode: SelectionMode) {.
    importc, libprag.}

proc setSelectionMode*(self: IconView; mode: SelectionMode) =
  gtk_icon_view_set_selection_mode(cast[ptr IconView00](self.impl), mode)

proc `selectionMode=`*(self: IconView; mode: SelectionMode) =
  gtk_icon_view_set_selection_mode(cast[ptr IconView00](self.impl), mode)

proc gtk_flow_box_get_selection_mode(self: ptr FlowBox00): SelectionMode {.
    importc, libprag.}

proc getSelectionMode*(self: FlowBox): SelectionMode =
  gtk_flow_box_get_selection_mode(cast[ptr FlowBox00](self.impl))

proc selectionMode*(self: FlowBox): SelectionMode =
  gtk_flow_box_get_selection_mode(cast[ptr FlowBox00](self.impl))

proc gtk_flow_box_set_selection_mode(self: ptr FlowBox00; mode: SelectionMode) {.
    importc, libprag.}

proc setSelectionMode*(self: FlowBox; mode: SelectionMode) =
  gtk_flow_box_set_selection_mode(cast[ptr FlowBox00](self.impl), mode)

proc `selectionMode=`*(self: FlowBox; mode: SelectionMode) =
  gtk_flow_box_set_selection_mode(cast[ptr FlowBox00](self.impl), mode)

proc gtk_tree_selection_get_mode(self: ptr TreeSelection00): SelectionMode {.
    importc, libprag.}

proc getMode*(self: TreeSelection): SelectionMode =
  gtk_tree_selection_get_mode(cast[ptr TreeSelection00](self.impl))

proc mode*(self: TreeSelection): SelectionMode =
  gtk_tree_selection_get_mode(cast[ptr TreeSelection00](self.impl))

proc gtk_tree_selection_set_mode(self: ptr TreeSelection00; `type`: SelectionMode) {.
    importc, libprag.}

proc setMode*(self: TreeSelection; `type`: SelectionMode) =
  gtk_tree_selection_set_mode(cast[ptr TreeSelection00](self.impl), `type`)

proc `mode=`*(self: TreeSelection; `type`: SelectionMode) =
  gtk_tree_selection_set_mode(cast[ptr TreeSelection00](self.impl), `type`)

proc gtk_list_box_get_selection_mode(self: ptr ListBox00): SelectionMode {.
    importc, libprag.}

proc getSelectionMode*(self: ListBox): SelectionMode =
  gtk_list_box_get_selection_mode(cast[ptr ListBox00](self.impl))

proc selectionMode*(self: ListBox): SelectionMode =
  gtk_list_box_get_selection_mode(cast[ptr ListBox00](self.impl))

proc gtk_list_box_set_selection_mode(self: ptr ListBox00; mode: SelectionMode) {.
    importc, libprag.}

proc setSelectionMode*(self: ListBox; mode: SelectionMode) =
  gtk_list_box_set_selection_mode(cast[ptr ListBox00](self.impl), mode)

proc `selectionMode=`*(self: ListBox; mode: SelectionMode) =
  gtk_list_box_set_selection_mode(cast[ptr ListBox00](self.impl), mode)

type
  BuilderConnectFunc* = proc (builder: ptr Builder00; `object`: ptr gobject.Object00; signalName: cstring;
    handlerName: cstring; connectObject: ptr gobject.Object00; flags: gobject.ConnectFlags;
    userData: pointer) {.cdecl.}

proc gtk_builder_connect_signals_full(self: ptr Builder00; `func`: BuilderConnectFunc;
    userData: pointer) {.
    importc, libprag.}

proc connectSignalsFull*(self: Builder; `func`: BuilderConnectFunc;
    userData: pointer) =
  gtk_builder_connect_signals_full(cast[ptr Builder00](self.impl), `func`, userData)

type
  BuilderError* {.size: sizeof(cint), pure.} = enum
    invalidTypeFunction = 0
    unhandledTag = 1
    missingAttribute = 2
    invalidAttribute = 3
    invalidTag = 4
    missingPropertyValue = 5
    invalidValue = 6
    versionMismatch = 7
    duplicateId = 8
    objectTypeRefused = 9
    templateMismatch = 10
    invalidProperty = 11
    invalidSignal = 12
    invalidId = 13

type
  ButtonRole* {.size: sizeof(cint), pure.} = enum
    normal = 0
    check = 1
    radio = 2

type
  ButtonsType* {.size: sizeof(cint), pure.} = enum
    none = 0
    ok = 1
    close = 2
    cancel = 3
    yesNo = 4
    okCancel = 5

type
  CalendarDetailFunc* = proc (calendar: ptr Calendar00; year: uint32; month: uint32; day: uint32;
    userData: pointer): cstring {.cdecl.}

proc gtk_calendar_set_detail_func(self: ptr Calendar00; `func`: CalendarDetailFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setDetailFunc*(self: Calendar; `func`: CalendarDetailFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_calendar_set_detail_func(cast[ptr Calendar00](self.impl), `func`, data, destroy)

type
  Callback* = proc (widget: ptr Widget00; data: pointer) {.cdecl.}

proc gtk_container_forall(self: ptr Container00; callback: Callback; callbackData: pointer) {.
    importc, libprag.}

proc forall*(self: Container; callback: Callback; callbackData: pointer) =
  gtk_container_forall(cast[ptr Container00](self.impl), callback, callbackData)

proc gtk_container_foreach(self: ptr Container00; callback: Callback; callbackData: pointer) {.
    importc, libprag.}

proc foreach*(self: Container; callback: Callback; callbackData: pointer) =
  gtk_container_foreach(cast[ptr Container00](self.impl), callback, callbackData)

proc gtk_builder_add_callback_symbol(self: ptr Builder00; callbackName: cstring;
    callbackSymbol: Callback) {.
    importc, libprag.}

proc addCallbackSymbol*(self: Builder; callbackName: cstring;
    callbackSymbol: Callback) =
  gtk_builder_add_callback_symbol(cast[ptr Builder00](self.impl), callbackName, callbackSymbol)

type
  CellAccessibleParent00* = object of gobject.Object00
  CellAccessibleParent* = ref object of gobject.Object

proc gtk_cell_accessible_parent_activate(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00) {.
    importc, libprag.}

proc activate*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible) =
  gtk_cell_accessible_parent_activate(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_edit(self: ptr CellAccessibleParent00; cell: ptr CellAccessible00) {.
    importc, libprag.}

proc edit*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible) =
  gtk_cell_accessible_parent_edit(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_expand_collapse(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00) {.
    importc, libprag.}

proc expandCollapse*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible) =
  gtk_cell_accessible_parent_expand_collapse(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_get_cell_area(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00; cellRect: var gdk.Rectangle) {.
    importc, libprag.}

proc getCellArea*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible; cellRect: var gdk.Rectangle) =
  gtk_cell_accessible_parent_get_cell_area(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), cellRect)

proc gtk_cell_accessible_parent_get_cell_extents(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00; x: var int32; y: var int32; width: var int32;
    height: var int32; coordType: atk.CoordType) {.
    importc, libprag.}

proc getCellExtents*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible; x: var int; y: var int; width: var int; height: var int;
    coordType: atk.CoordType) =
  var width_00: int32
  var y_00: int32
  var x_00: int32
  var height_00: int32
  gtk_cell_accessible_parent_get_cell_extents(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), x_00, y_00, width_00, height_00, coordType)
  if width.addr != nil:
    width = int(width_00)
  if y.addr != nil:
    y = int(y_00)
  if x.addr != nil:
    x = int(x_00)
  if height.addr != nil:
    height = int(height_00)

proc gtk_cell_accessible_parent_get_cell_position(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00; row: var int32; column: var int32) {.
    importc, libprag.}

proc getCellPosition*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible; row: var int; column: var int) =
  var row_00: int32
  var column_00: int32
  gtk_cell_accessible_parent_get_cell_position(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), row_00, column_00)
  if row.addr != nil:
    row = int(row_00)
  if column.addr != nil:
    column = int(column_00)

proc gtk_cell_accessible_parent_get_child_index(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00): int32 {.
    importc, libprag.}

proc getChildIndex*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible): int =
  int(gtk_cell_accessible_parent_get_child_index(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl)))

proc gtk_cell_accessible_parent_get_column_header_cells(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00): ptr PtrArray00 {.
    importc, libprag.}

proc getColumnHeaderCells*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible): ptr PtrArray00 =
  gtk_cell_accessible_parent_get_column_header_cells(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_get_renderer_state(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00): CellRendererState {.
    importc, libprag.}

proc getRendererState*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible): CellRendererState =
  gtk_cell_accessible_parent_get_renderer_state(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_get_row_header_cells(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00): ptr PtrArray00 {.
    importc, libprag.}

proc getRowHeaderCells*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible): ptr PtrArray00 =
  gtk_cell_accessible_parent_get_row_header_cells(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl))

proc gtk_cell_accessible_parent_grab_focus(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00): gboolean {.
    importc, libprag.}

proc grabFocus*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible): bool =
  toBool(gtk_cell_accessible_parent_grab_focus(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl)))

proc gtk_cell_accessible_parent_update_relationset(self: ptr CellAccessibleParent00;
    cell: ptr CellAccessible00; relationset: ptr atk.RelationSet00) {.
    importc, libprag.}

proc updateRelationset*(self: CellAccessibleParent | TreeViewAccessible;
    cell: CellAccessible; relationset: atk.RelationSet) =
  gtk_cell_accessible_parent_update_relationset(cast[ptr CellAccessibleParent00](self.impl), cast[ptr CellAccessible00](cell.impl), cast[ptr atk.RelationSet00](relationset.impl))

type
  CellAllocCallback* = proc (renderer: ptr CellRenderer00; cellArea: gdk.Rectangle; cellBackground: gdk.Rectangle;
    data: pointer): gboolean {.cdecl.}

proc gtk_cell_area_foreach_alloc(self: ptr CellArea00; context: ptr CellAreaContext00;
    widget: ptr Widget00; cellArea: gdk.Rectangle; backgroundArea: gdk.Rectangle;
    callback: CellAllocCallback; callbackData: pointer) {.
    importc, libprag.}

proc foreachAlloc*(self: CellArea; context: CellAreaContext;
    widget: Widget; cellArea: gdk.Rectangle; backgroundArea: gdk.Rectangle;
    callback: CellAllocCallback; callbackData: pointer) =
  gtk_cell_area_foreach_alloc(cast[ptr CellArea00](self.impl), cast[ptr CellAreaContext00](context.impl), cast[ptr Widget00](widget.impl), cellArea, backgroundArea, callback, callbackData)

type
  CellCallback* = proc (renderer: ptr CellRenderer00; data: pointer): gboolean {.cdecl.}

proc gtk_cell_area_foreach(self: ptr CellArea00; callback: CellCallback;
    callbackData: pointer) {.
    importc, libprag.}

proc foreach*(self: CellArea; callback: CellCallback; callbackData: pointer) =
  gtk_cell_area_foreach(cast[ptr CellArea00](self.impl), callback, callbackData)

type
  CellLayout00* = object of gobject.Object00
  CellLayout* = ref object of gobject.Object

proc gtk_cell_layout_add_attribute(self: ptr CellLayout00; cell: ptr CellRenderer00;
    attribute: cstring; column: int32) {.
    importc, libprag.}

proc addAttribute*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox;
    cell: CellRenderer; attribute: cstring; column: int) =
  gtk_cell_layout_add_attribute(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), attribute, int32(column))

proc gtk_cell_layout_clear(self: ptr CellLayout00) {.
    importc, libprag.}

proc clear*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox) =
  gtk_cell_layout_clear(cast[ptr CellLayout00](self.impl))

proc gtk_cell_layout_clear_attributes(self: ptr CellLayout00; cell: ptr CellRenderer00) {.
    importc, libprag.}

proc clearAttributes*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox;
    cell: CellRenderer) =
  gtk_cell_layout_clear_attributes(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl))

proc gtk_cell_layout_get_area(self: ptr CellLayout00): ptr CellArea00 {.
    importc, libprag.}

proc getArea*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox): CellArea =
  let gobj = gtk_cell_layout_get_area(cast[ptr CellLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc area*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox): CellArea =
  let gobj = gtk_cell_layout_get_area(cast[ptr CellLayout00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_layout_get_cells(self: ptr CellLayout00): ptr glib.List {.
    importc, libprag.}

proc getCells*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox): seq[CellRenderer] =
  let resul0 = gtk_cell_layout_get_cells(cast[ptr CellLayout00](self.impl))
  result = glistObjects2seq(CellRenderer, resul0, false)
  g_list_free(resul0)

proc cells*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox): seq[CellRenderer] =
  let resul0 = gtk_cell_layout_get_cells(cast[ptr CellLayout00](self.impl))
  result = glistObjects2seq(CellRenderer, resul0, false)
  g_list_free(resul0)

proc gtk_cell_layout_pack_end(self: ptr CellLayout00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packEnd*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox;
    cell: CellRenderer; expand: bool) =
  gtk_cell_layout_pack_end(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_cell_layout_pack_start(self: ptr CellLayout00; cell: ptr CellRenderer00;
    expand: gboolean) {.
    importc, libprag.}

proc packStart*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox;
    cell: CellRenderer; expand: bool) =
  gtk_cell_layout_pack_start(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), gboolean(expand))

proc gtk_cell_layout_reorder(self: ptr CellLayout00; cell: ptr CellRenderer00;
    position: int32) {.
    importc, libprag.}

proc reorder*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox;
    cell: CellRenderer; position: int) =
  gtk_cell_layout_reorder(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), int32(position))

type
  CellLayoutDataFunc* = proc (cellLayout: ptr CellLayout00; cell: ptr CellRenderer00; treeModel: ptr TreeModel00;
    iter: TreeIter; data: pointer) {.cdecl.}

proc gtk_cell_layout_set_cell_data_func(self: ptr CellLayout00; cell: ptr CellRenderer00;
    `func`: CellLayoutDataFunc; funcData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setCellDataFunc*(self: CellLayout | IconView | TreeViewColumn | ComboBoxText | CellView | CellArea | AppChooserButton | EntryCompletion | CellAreaBox | ComboBox;
    cell: CellRenderer; `func`: CellLayoutDataFunc; funcData: pointer; destroy: DestroyNotify) =
  gtk_cell_layout_set_cell_data_func(cast[ptr CellLayout00](self.impl), cast[ptr CellRenderer00](cell.impl), `func`, funcData, destroy)

type
  CellRendererText* = ref object of CellRenderer
  CellRendererText00* = object of CellRenderer00

proc gtk_cell_renderer_text_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererText()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEdited*(self: CellRendererText;  p: proc (self: ptr CellRendererText00; path: cstring; newText: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "edited", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_text_new(): ptr CellRendererText00 {.
    importc, libprag.}

proc newCellRendererText*(): CellRendererText =
  let gobj = gtk_cell_renderer_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererText*(tdesc: typedesc): tdesc =
  assert(result is CellRendererText)
  let gobj = gtk_cell_renderer_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererText*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererText)
  let gobj = gtk_cell_renderer_text_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_renderer_text_set_fixed_height_from_font(self: ptr CellRendererText00;
    numberOfRows: int32) {.
    importc, libprag.}

proc setFixedHeightFromFont*(self: CellRendererText;
    numberOfRows: int) =
  gtk_cell_renderer_text_set_fixed_height_from_font(cast[ptr CellRendererText00](self.impl), int32(numberOfRows))

proc `fixedHeightFromFont=`*(self: CellRendererText;
    numberOfRows: int) =
  gtk_cell_renderer_text_set_fixed_height_from_font(cast[ptr CellRendererText00](self.impl), int32(numberOfRows))

type
  CellRendererAccel* = ref object of CellRendererText
  CellRendererAccel00* = object of CellRendererText00

proc gtk_cell_renderer_accel_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererAccel()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAccelCleared*(self: CellRendererAccel;  p: proc (self: ptr CellRendererAccel00; pathString: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accel-cleared", cast[GCallback](p), xdata, nil, cf)

proc scAccelEdited*(self: CellRendererAccel;  p: proc (self: ptr CellRendererAccel00; pathString: cstring; accelKey: uint32; accelMods: gdk.ModifierType;
    hardwareKeycode: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "accel-edited", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_accel_new(): ptr CellRendererAccel00 {.
    importc, libprag.}

proc newCellRendererAccel*(): CellRendererAccel =
  let gobj = gtk_cell_renderer_accel_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererAccel*(tdesc: typedesc): tdesc =
  assert(result is CellRendererAccel)
  let gobj = gtk_cell_renderer_accel_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererAccel*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererAccel)
  let gobj = gtk_cell_renderer_accel_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererAccelMode* {.size: sizeof(cint), pure.} = enum
    gtk = 0
    other = 1

type
  CellRendererCombo* = ref object of CellRendererText
  CellRendererCombo00* = object of CellRendererText00

proc gtk_cell_renderer_combo_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererCombo()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: CellRendererCombo;  p: proc (self: ptr CellRendererCombo00; pathString: cstring; newIter: TreeIter; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_combo_new(): ptr CellRendererCombo00 {.
    importc, libprag.}

proc newCellRendererCombo*(): CellRendererCombo =
  let gobj = gtk_cell_renderer_combo_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererCombo*(tdesc: typedesc): tdesc =
  assert(result is CellRendererCombo)
  let gobj = gtk_cell_renderer_combo_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererCombo*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererCombo)
  let gobj = gtk_cell_renderer_combo_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererMode* {.size: sizeof(cint), pure.} = enum
    inert = 0
    activatable = 1
    editable = 2

type
  CellRendererPixbuf* = ref object of CellRenderer
  CellRendererPixbuf00* = object of CellRenderer00

proc gtk_cell_renderer_pixbuf_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererPixbuf()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_pixbuf_new(): ptr CellRendererPixbuf00 {.
    importc, libprag.}

proc newCellRendererPixbuf*(): CellRendererPixbuf =
  let gobj = gtk_cell_renderer_pixbuf_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererPixbuf*(tdesc: typedesc): tdesc =
  assert(result is CellRendererPixbuf)
  let gobj = gtk_cell_renderer_pixbuf_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererPixbuf*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererPixbuf)
  let gobj = gtk_cell_renderer_pixbuf_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererProgress* = ref object of CellRenderer
  CellRendererProgress00* = object of CellRenderer00

proc gtk_cell_renderer_progress_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererProgress()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_progress_new(): ptr CellRendererProgress00 {.
    importc, libprag.}

proc newCellRendererProgress*(): CellRendererProgress =
  let gobj = gtk_cell_renderer_progress_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererProgress*(tdesc: typedesc): tdesc =
  assert(result is CellRendererProgress)
  let gobj = gtk_cell_renderer_progress_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererProgress*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererProgress)
  let gobj = gtk_cell_renderer_progress_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererSpin* = ref object of CellRendererText
  CellRendererSpin00* = object of CellRendererText00

proc gtk_cell_renderer_spin_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererSpin()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_spin_new(): ptr CellRendererSpin00 {.
    importc, libprag.}

proc newCellRendererSpin*(): CellRendererSpin =
  let gobj = gtk_cell_renderer_spin_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererSpin*(tdesc: typedesc): tdesc =
  assert(result is CellRendererSpin)
  let gobj = gtk_cell_renderer_spin_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererSpin*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererSpin)
  let gobj = gtk_cell_renderer_spin_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererSpinner* = ref object of CellRenderer
  CellRendererSpinner00* = object of CellRenderer00

proc gtk_cell_renderer_spinner_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererSpinner()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_cell_renderer_spinner_new(): ptr CellRendererSpinner00 {.
    importc, libprag.}

proc newCellRendererSpinner*(): CellRendererSpinner =
  let gobj = gtk_cell_renderer_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererSpinner*(tdesc: typedesc): tdesc =
  assert(result is CellRendererSpinner)
  let gobj = gtk_cell_renderer_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererSpinner*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererSpinner)
  let gobj = gtk_cell_renderer_spinner_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  CellRendererToggle* = ref object of CellRenderer
  CellRendererToggle00* = object of CellRenderer00

proc gtk_cell_renderer_toggle_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(CellRendererToggle()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scToggled*(self: CellRendererToggle;  p: proc (self: ptr CellRendererToggle00; path: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "toggled", cast[GCallback](p), xdata, nil, cf)

proc gtk_cell_renderer_toggle_new(): ptr CellRendererToggle00 {.
    importc, libprag.}

proc newCellRendererToggle*(): CellRendererToggle =
  let gobj = gtk_cell_renderer_toggle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newCellRendererToggle*(tdesc: typedesc): tdesc =
  assert(result is CellRendererToggle)
  let gobj = gtk_cell_renderer_toggle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initCellRendererToggle*[T](result: var T) {.deprecated.} =
  assert(result is CellRendererToggle)
  let gobj = gtk_cell_renderer_toggle_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_cell_renderer_toggle_get_activatable(self: ptr CellRendererToggle00): gboolean {.
    importc, libprag.}

proc getActivatable*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_activatable(cast[ptr CellRendererToggle00](self.impl)))

proc activatable*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_activatable(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_get_active(self: ptr CellRendererToggle00): gboolean {.
    importc, libprag.}

proc getActive*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_active(cast[ptr CellRendererToggle00](self.impl)))

proc active*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_active(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_get_radio(self: ptr CellRendererToggle00): gboolean {.
    importc, libprag.}

proc getRadio*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_radio(cast[ptr CellRendererToggle00](self.impl)))

proc radio*(self: CellRendererToggle): bool =
  toBool(gtk_cell_renderer_toggle_get_radio(cast[ptr CellRendererToggle00](self.impl)))

proc gtk_cell_renderer_toggle_set_activatable(self: ptr CellRendererToggle00;
    setting: gboolean) {.
    importc, libprag.}

proc setActivatable*(self: CellRendererToggle; setting: bool = true) =
  gtk_cell_renderer_toggle_set_activatable(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc `activatable=`*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_activatable(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc gtk_cell_renderer_toggle_set_active(self: ptr CellRendererToggle00;
    setting: gboolean) {.
    importc, libprag.}

proc setActive*(self: CellRendererToggle; setting: bool = true) =
  gtk_cell_renderer_toggle_set_active(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc `active=`*(self: CellRendererToggle; setting: bool) =
  gtk_cell_renderer_toggle_set_active(cast[ptr CellRendererToggle00](self.impl), gboolean(setting))

proc gtk_cell_renderer_toggle_set_radio(self: ptr CellRendererToggle00; radio: gboolean) {.
    importc, libprag.}

proc setRadio*(self: CellRendererToggle; radio: bool = true) =
  gtk_cell_renderer_toggle_set_radio(cast[ptr CellRendererToggle00](self.impl), gboolean(radio))

proc `radio=`*(self: CellRendererToggle; radio: bool) =
  gtk_cell_renderer_toggle_set_radio(cast[ptr CellRendererToggle00](self.impl), gboolean(radio))

type
  ClipboardClearFunc* = proc (clipboard: ptr Clipboard00; userDataOrOwner: pointer) {.cdecl.}

type
  ClipboardGetFunc* = proc (clipboard: ptr Clipboard00; selectionData: ptr SelectionData00; info: uint32;
    userDataOrOwner: pointer) {.cdecl.}

type
  ClipboardImageReceivedFunc* = proc (clipboard: ptr Clipboard00; pixbuf: ptr gdkpixbuf.Pixbuf00; data: pointer) {.cdecl.}

proc gtk_clipboard_request_image(self: ptr Clipboard00; callback: ClipboardImageReceivedFunc;
    userData: pointer) {.
    importc, libprag.}

proc requestImage*(self: Clipboard; callback: ClipboardImageReceivedFunc;
    userData: pointer) =
  gtk_clipboard_request_image(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ClipboardReceivedFunc* = proc (clipboard: ptr Clipboard00; selectionData: ptr SelectionData00; data: pointer) {.cdecl.}

proc gtk_clipboard_request_contents(self: ptr Clipboard00; target: ptr gdk.Atom00;
    callback: ClipboardReceivedFunc; userData: pointer) {.
    importc, libprag.}

proc requestContents*(self: Clipboard; target: gdk.Atom; callback: ClipboardReceivedFunc;
    userData: pointer) =
  gtk_clipboard_request_contents(cast[ptr Clipboard00](self.impl), cast[ptr gdk.Atom00](target.impl), callback, userData)

type
  ClipboardRichTextReceivedFunc* = proc (clipboard: ptr Clipboard00; format: ptr gdk.Atom00; text: cstring;
    length: uint64; data: pointer) {.cdecl.}

proc gtk_clipboard_request_rich_text(self: ptr Clipboard00; buffer: ptr TextBuffer00;
    callback: ClipboardRichTextReceivedFunc; userData: pointer) {.
    importc, libprag.}

proc requestRichText*(self: Clipboard; buffer: TextBuffer;
    callback: ClipboardRichTextReceivedFunc; userData: pointer) =
  gtk_clipboard_request_rich_text(cast[ptr Clipboard00](self.impl), cast[ptr TextBuffer00](buffer.impl), callback, userData)

type
  ClipboardTargetsReceivedFunc* = proc (clipboard: ptr Clipboard00; atoms: ptr ptr gdk.Atom00; nAtoms: int32;
    data: pointer) {.cdecl.}

proc gtk_clipboard_request_targets(self: ptr Clipboard00; callback: ClipboardTargetsReceivedFunc;
    userData: pointer) {.
    importc, libprag.}

proc requestTargets*(self: Clipboard; callback: ClipboardTargetsReceivedFunc;
    userData: pointer) =
  gtk_clipboard_request_targets(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ClipboardTextReceivedFunc* = proc (clipboard: ptr Clipboard00; text: cstring; data: pointer) {.cdecl.}

proc gtk_clipboard_request_text(self: ptr Clipboard00; callback: ClipboardTextReceivedFunc;
    userData: pointer) {.
    importc, libprag.}

proc requestText*(self: Clipboard; callback: ClipboardTextReceivedFunc;
    userData: pointer) =
  gtk_clipboard_request_text(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ClipboardURIReceivedFunc* = proc (clipboard: ptr Clipboard00; uris: ptr cstring; data: pointer) {.cdecl.}

proc gtk_clipboard_request_uris(self: ptr Clipboard00; callback: ClipboardURIReceivedFunc;
    userData: pointer) {.
    importc, libprag.}

proc requestUris*(self: Clipboard; callback: ClipboardURIReceivedFunc;
    userData: pointer) =
  gtk_clipboard_request_uris(cast[ptr Clipboard00](self.impl), callback, userData)

type
  ColorChooser00* = object of gobject.Object00
  ColorChooser* = ref object of gobject.Object

proc scColorActivated*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget;  p: proc (self: ptr ColorChooser00; color: gdk.RGBA; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "color-activated", cast[GCallback](p), xdata, nil, cf)

proc gtk_color_chooser_add_palette(self: ptr ColorChooser00; orientation: Orientation;
    colorsPerLine: int32; nColors: int32; colors: ptr gdk.RGBA) {.
    importc, libprag.}

proc addPalette*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget;
    orientation: Orientation; colorsPerLine: int; nColors: int; colors: ptr gdk.RGBA) =
  gtk_color_chooser_add_palette(cast[ptr ColorChooser00](self.impl), orientation, int32(colorsPerLine), int32(nColors), colors)

proc gtk_color_chooser_get_rgba(self: ptr ColorChooser00; color: var gdk.RGBA) {.
    importc, libprag.}

proc getRgba*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget;
    color: var gdk.RGBA) =
  gtk_color_chooser_get_rgba(cast[ptr ColorChooser00](self.impl), color)

proc getRgba*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget): gdk.RGBA =
  gtk_color_chooser_get_rgba(cast[ptr ColorChooser00](self.impl), result)

proc gtk_color_chooser_get_use_alpha(self: ptr ColorChooser00): gboolean {.
    importc, libprag.}

proc getUseAlpha*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget): bool =
  toBool(gtk_color_chooser_get_use_alpha(cast[ptr ColorChooser00](self.impl)))

proc useAlpha*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget): bool =
  toBool(gtk_color_chooser_get_use_alpha(cast[ptr ColorChooser00](self.impl)))

proc gtk_color_chooser_set_rgba(self: ptr ColorChooser00; color: gdk.RGBA) {.
    importc, libprag.}

proc setRgba*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget;
    color: gdk.RGBA) =
  gtk_color_chooser_set_rgba(cast[ptr ColorChooser00](self.impl), color)

proc `rgba=`*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget;
    color: gdk.RGBA) =
  gtk_color_chooser_set_rgba(cast[ptr ColorChooser00](self.impl), color)

proc gtk_color_chooser_set_use_alpha(self: ptr ColorChooser00; useAlpha: gboolean) {.
    importc, libprag.}

proc setUseAlpha*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget;
    useAlpha: bool = true) =
  gtk_color_chooser_set_use_alpha(cast[ptr ColorChooser00](self.impl), gboolean(useAlpha))

proc `useAlpha=`*(self: ColorChooser | ColorButton | ColorChooserDialog | ColorChooserWidget;
    useAlpha: bool) =
  gtk_color_chooser_set_use_alpha(cast[ptr ColorChooser00](self.impl), gboolean(useAlpha))

type
  ColorSelectionChangePaletteFunc* = proc (colors: ptr gdk.Color; nColors: int32) {.cdecl.}

type
  ColorSelectionChangePaletteWithScreenFunc* = proc (screen: ptr gdk.Screen00; colors: ptr gdk.Color; nColors: int32) {.cdecl.}

type
  CssProviderError* {.size: sizeof(cint), pure.} = enum
    failed = 0
    syntax = 1
    `import` = 2
    name = 3
    deprecated = 4
    unknownValue = 5

type
  DebugFlag* {.size: sizeof(cint), pure.} = enum
    misc = 1
    plugsocket = 2
    text = 4
    tree = 8
    updates = 16
    keybindings = 32
    multihead = 64
    modules = 128
    geometry = 256
    icontheme = 512
    printing = 1024
    builder = 2048
    sizeRequest = 4096
    noCssCache = 8192
    baselines = 16384
    pixelCache = 32768
    noPixelCache = 65536
    interactive = 131072
    touchscreen = 262144
    actions = 524288
    resize = 1048576
    layout = 2097152

type
  Editable00* = object of gobject.Object00
  Editable* = ref object of gobject.Object

proc scChanged*(self: Editable | SpinButton | Entry | SearchEntry;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc scDeleteText*(self: Editable | SpinButton | Entry | SearchEntry;  p: proc (self: ptr Editable00; startPos: int32; endPos: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-text", cast[GCallback](p), xdata, nil, cf)

proc scInsertText*(self: Editable | SpinButton | Entry | SearchEntry;  p: proc (self: ptr Editable00; newText: cstring; newTextLength: int32; position: var int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "insert-text", cast[GCallback](p), xdata, nil, cf)

proc gtk_editable_copy_clipboard(self: ptr Editable00) {.
    importc, libprag.}

proc copyClipboard*(self: Editable | SpinButton | Entry | SearchEntry) =
  gtk_editable_copy_clipboard(cast[ptr Editable00](self.impl))

proc gtk_editable_cut_clipboard(self: ptr Editable00) {.
    importc, libprag.}

proc cutClipboard*(self: Editable | SpinButton | Entry | SearchEntry) =
  gtk_editable_cut_clipboard(cast[ptr Editable00](self.impl))

proc gtk_editable_delete_selection(self: ptr Editable00) {.
    importc, libprag.}

proc deleteSelection*(self: Editable | SpinButton | Entry | SearchEntry) =
  gtk_editable_delete_selection(cast[ptr Editable00](self.impl))

proc gtk_editable_delete_text(self: ptr Editable00; startPos: int32; endPos: int32) {.
    importc, libprag.}

proc deleteText*(self: Editable | SpinButton | Entry | SearchEntry;
    startPos: int; endPos: int) =
  gtk_editable_delete_text(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))

proc gtk_editable_get_chars(self: ptr Editable00; startPos: int32; endPos: int32): cstring {.
    importc, libprag.}

proc getChars*(self: Editable | SpinButton | Entry | SearchEntry;
    startPos: int; endPos: int): string =
  let resul0 = gtk_editable_get_chars(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))
  result = $resul0
  cogfree(resul0)

proc gtk_editable_get_editable(self: ptr Editable00): gboolean {.
    importc, libprag.}

proc getEditable*(self: Editable | SpinButton | Entry | SearchEntry): bool =
  toBool(gtk_editable_get_editable(cast[ptr Editable00](self.impl)))

proc editable*(self: Editable | SpinButton | Entry | SearchEntry): bool =
  toBool(gtk_editable_get_editable(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_position(self: ptr Editable00): int32 {.
    importc, libprag.}

proc getPosition*(self: Editable | SpinButton | Entry | SearchEntry): int =
  int(gtk_editable_get_position(cast[ptr Editable00](self.impl)))

proc position*(self: Editable | SpinButton | Entry | SearchEntry): int =
  int(gtk_editable_get_position(cast[ptr Editable00](self.impl)))

proc gtk_editable_get_selection_bounds(self: ptr Editable00; startPos: var int32;
    endPos: var int32): gboolean {.
    importc, libprag.}

proc getSelectionBounds*(self: Editable | SpinButton | Entry | SearchEntry;
    startPos: var int = cast[var int](nil); endPos: var int = cast[var int](nil)): bool =
  var endPos_00: int32
  var startPos_00: int32
  result = toBool(gtk_editable_get_selection_bounds(cast[ptr Editable00](self.impl), startPos_00, endPos_00))
  if endPos.addr != nil:
    endPos = int(endPos_00)
  if startPos.addr != nil:
    startPos = int(startPos_00)

proc gtk_editable_insert_text(self: ptr Editable00; newText: cstring; newTextLength: int32;
    position: var int32) {.
    importc, libprag.}

proc insertText*(self: Editable | SpinButton | Entry | SearchEntry;
    newText: cstring; newTextLength: int; position: var int) =
  var position_00 = int32(position)
  gtk_editable_insert_text(cast[ptr Editable00](self.impl), newText, int32(newTextLength), position_00)
  position = int(position_00)

proc gtk_editable_paste_clipboard(self: ptr Editable00) {.
    importc, libprag.}

proc pasteClipboard*(self: Editable | SpinButton | Entry | SearchEntry) =
  gtk_editable_paste_clipboard(cast[ptr Editable00](self.impl))

proc gtk_editable_select_region(self: ptr Editable00; startPos: int32; endPos: int32) {.
    importc, libprag.}

proc selectRegion*(self: Editable | SpinButton | Entry | SearchEntry;
    startPos: int; endPos: int) =
  gtk_editable_select_region(cast[ptr Editable00](self.impl), int32(startPos), int32(endPos))

proc gtk_editable_set_editable(self: ptr Editable00; isEditable: gboolean) {.
    importc, libprag.}

proc setEditable*(self: Editable | SpinButton | Entry | SearchEntry;
    isEditable: bool = true) =
  gtk_editable_set_editable(cast[ptr Editable00](self.impl), gboolean(isEditable))

proc `editable=`*(self: Editable | SpinButton | Entry | SearchEntry;
    isEditable: bool) =
  gtk_editable_set_editable(cast[ptr Editable00](self.impl), gboolean(isEditable))

proc gtk_editable_set_position(self: ptr Editable00; position: int32) {.
    importc, libprag.}

proc setPosition*(self: Editable | SpinButton | Entry | SearchEntry;
    position: int) =
  gtk_editable_set_position(cast[ptr Editable00](self.impl), int32(position))

proc `position=`*(self: Editable | SpinButton | Entry | SearchEntry;
    position: int) =
  gtk_editable_set_position(cast[ptr Editable00](self.impl), int32(position))

type
  EntryCompletionMatchFunc* = proc (completion: ptr EntryCompletion00; key: cstring; iter: TreeIter; userData: pointer): gboolean {.cdecl.}

proc gtk_entry_completion_set_match_func(self: ptr EntryCompletion00; `func`: EntryCompletionMatchFunc;
    funcData: pointer; funcNotify: DestroyNotify) {.
    importc, libprag.}

proc setMatchFunc*(self: EntryCompletion; `func`: EntryCompletionMatchFunc;
    funcData: pointer; funcNotify: DestroyNotify) =
  gtk_entry_completion_set_match_func(cast[ptr EntryCompletion00](self.impl), `func`, funcData, funcNotify)

type
  EventController* = ref object of gobject.Object
  EventController00* = object of gobject.Object00

proc gtk_event_controller_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventController()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_event_controller_get_widget(self: ptr EventController00): ptr Widget00 {.
    importc, libprag.}

proc getWidget*(self: EventController): Widget =
  let gobj = gtk_event_controller_get_widget(cast[ptr EventController00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc widget*(self: EventController): Widget =
  let gobj = gtk_event_controller_get_widget(cast[ptr EventController00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_handle_event(self: ptr EventController00; event: ptr gdk.Event00): gboolean {.
    importc, libprag.}

proc handleEvent*(self: EventController; event: gdk.Event): bool =
  toBool(gtk_event_controller_handle_event(cast[ptr EventController00](self.impl), cast[ptr gdk.Event00](event.impl)))

proc gtk_event_controller_reset(self: ptr EventController00) {.
    importc, libprag.}

proc reset*(self: EventController) =
  gtk_event_controller_reset(cast[ptr EventController00](self.impl))

type
  PropagationPhase* {.size: sizeof(cint), pure.} = enum
    none = 0
    capture = 1
    bubble = 2
    target = 3

proc gtk_event_controller_get_propagation_phase(self: ptr EventController00): PropagationPhase {.
    importc, libprag.}

proc getPropagationPhase*(self: EventController): PropagationPhase =
  gtk_event_controller_get_propagation_phase(cast[ptr EventController00](self.impl))

proc propagationPhase*(self: EventController): PropagationPhase =
  gtk_event_controller_get_propagation_phase(cast[ptr EventController00](self.impl))

proc gtk_event_controller_set_propagation_phase(self: ptr EventController00;
    phase: PropagationPhase) {.
    importc, libprag.}

proc setPropagationPhase*(self: EventController; phase: PropagationPhase) =
  gtk_event_controller_set_propagation_phase(cast[ptr EventController00](self.impl), phase)

proc `propagationPhase=`*(self: EventController; phase: PropagationPhase) =
  gtk_event_controller_set_propagation_phase(cast[ptr EventController00](self.impl), phase)

type
  EventControllerKey* = ref object of EventController
  EventControllerKey00* = object of EventController00

proc gtk_event_controller_key_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerKey()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scFocusIn*(self: EventControllerKey;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-in", cast[GCallback](p), xdata, nil, cf)

proc scFocusOut*(self: EventControllerKey;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "focus-out", cast[GCallback](p), xdata, nil, cf)

proc scImUpdate*(self: EventControllerKey;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "im-update", cast[GCallback](p), xdata, nil, cf)

proc scKeyPressed*(self: EventControllerKey;  p: proc (self: ptr EventControllerKey00; keyval: uint32; keycode: uint32; state: gdk.ModifierType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "key-pressed", cast[GCallback](p), xdata, nil, cf)

proc scKeyReleased*(self: EventControllerKey;  p: proc (self: ptr EventControllerKey00; keyval: uint32; keycode: uint32; state: gdk.ModifierType; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "key-released", cast[GCallback](p), xdata, nil, cf)

proc scModifiers*(self: EventControllerKey;  p: proc (self: ptr EventControllerKey00; `object`: gdk.ModifierType; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "modifiers", cast[GCallback](p), xdata, nil, cf)

proc gtk_event_controller_key_new(widget: ptr Widget00): ptr EventControllerKey00 {.
    importc, libprag.}

proc newEventControllerKey*(widget: Widget): EventControllerKey =
  let gobj = gtk_event_controller_key_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerKey*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is EventControllerKey)
  let gobj = gtk_event_controller_key_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerKey*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is EventControllerKey)
  let gobj = gtk_event_controller_key_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_key_forward(self: ptr EventControllerKey00; widget: ptr Widget00): gboolean {.
    importc, libprag.}

proc forward*(self: EventControllerKey; widget: Widget): bool =
  toBool(gtk_event_controller_key_forward(cast[ptr EventControllerKey00](self.impl), cast[ptr Widget00](widget.impl)))

proc gtk_event_controller_key_get_group(self: ptr EventControllerKey00): uint32 {.
    importc, libprag.}

proc getGroup*(self: EventControllerKey): int =
  int(gtk_event_controller_key_get_group(cast[ptr EventControllerKey00](self.impl)))

proc group*(self: EventControllerKey): int =
  int(gtk_event_controller_key_get_group(cast[ptr EventControllerKey00](self.impl)))

type
  IMContext* = ref object of gobject.Object
  IMContext00* = object of gobject.Object00

proc gtk_im_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IMContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCommit*(self: IMContext;  p: proc (self: ptr IMContext00; str: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "commit", cast[GCallback](p), xdata, nil, cf)

proc scDeleteSurrounding*(self: IMContext;  p: proc (self: ptr IMContext00; offset: int32; nChars: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "delete-surrounding", cast[GCallback](p), xdata, nil, cf)

proc scPreeditChanged*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-changed", cast[GCallback](p), xdata, nil, cf)

proc scPreeditEnd*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-end", cast[GCallback](p), xdata, nil, cf)

proc scPreeditStart*(self: IMContext;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preedit-start", cast[GCallback](p), xdata, nil, cf)

proc scRetrieveSurrounding*(self: IMContext;  p: proc (self: ptr IMContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "retrieve-surrounding", cast[GCallback](p), xdata, nil, cf)

proc gtk_im_context_delete_surrounding(self: ptr IMContext00; offset: int32;
    nChars: int32): gboolean {.
    importc, libprag.}

proc deleteSurrounding*(self: IMContext; offset: int; nChars: int): bool =
  toBool(gtk_im_context_delete_surrounding(cast[ptr IMContext00](self.impl), int32(offset), int32(nChars)))

proc gtk_im_context_filter_keypress(self: ptr IMContext00; event: ptr gdk.EventKey00): gboolean {.
    importc, libprag.}

proc filterKeypress*(self: IMContext; event: gdk.EventKey): bool =
  toBool(gtk_im_context_filter_keypress(cast[ptr IMContext00](self.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_im_context_focus_in(self: ptr IMContext00) {.
    importc, libprag.}

proc focusIn*(self: IMContext) =
  gtk_im_context_focus_in(cast[ptr IMContext00](self.impl))

proc gtk_im_context_focus_out(self: ptr IMContext00) {.
    importc, libprag.}

proc focusOut*(self: IMContext) =
  gtk_im_context_focus_out(cast[ptr IMContext00](self.impl))

proc gtk_im_context_get_preedit_string(self: ptr IMContext00; str: var cstring;
    attrs: var ptr pango.AttrList00; cursorPos: var int32) {.
    importc, libprag.}

proc getPreeditString*(self: IMContext; str: var string;
    attrs: var pango.AttrList; cursorPos: var int) =
  fnew(attrs, gBoxedFreePangoAttrList)
  var cursorPos_00: int32
  var str_00: cstring
  gtk_im_context_get_preedit_string(cast[ptr IMContext00](self.impl), str_00, cast[var ptr pango.AttrList00](addr attrs.impl), cursorPos_00)
  if cursorPos.addr != nil:
    cursorPos = int(cursorPos_00)
  if str.addr != nil:
    str = $(str_00)

proc gtk_im_context_get_surrounding(self: ptr IMContext00; text: var cstring;
    cursorIndex: var int32): gboolean {.
    importc, libprag.}

proc getSurrounding*(self: IMContext; text: var string; cursorIndex: var int): bool =
  var text_00: cstring
  var cursorIndex_00: int32
  result = toBool(gtk_im_context_get_surrounding(cast[ptr IMContext00](self.impl), text_00, cursorIndex_00))
  if text.addr != nil:
    text = $(text_00)
  if cursorIndex.addr != nil:
    cursorIndex = int(cursorIndex_00)

proc gtk_im_context_reset(self: ptr IMContext00) {.
    importc, libprag.}

proc reset*(self: IMContext) =
  gtk_im_context_reset(cast[ptr IMContext00](self.impl))

proc gtk_im_context_set_client_window(self: ptr IMContext00; window: ptr gdk.Window00) {.
    importc, libprag.}

proc setClientWindow*(self: IMContext; window: gdk.Window = nil) =
  gtk_im_context_set_client_window(cast[ptr IMContext00](self.impl), if window.isNil: nil else: cast[ptr gdk.Window00](window.impl))

proc `clientWindow=`*(self: IMContext; window: gdk.Window = nil) =
  gtk_im_context_set_client_window(cast[ptr IMContext00](self.impl), if window.isNil: nil else: cast[ptr gdk.Window00](window.impl))

proc gtk_im_context_set_cursor_location(self: ptr IMContext00; area: gdk.Rectangle) {.
    importc, libprag.}

proc setCursorLocation*(self: IMContext; area: gdk.Rectangle) =
  gtk_im_context_set_cursor_location(cast[ptr IMContext00](self.impl), area)

proc `cursorLocation=`*(self: IMContext; area: gdk.Rectangle) =
  gtk_im_context_set_cursor_location(cast[ptr IMContext00](self.impl), area)

proc gtk_im_context_set_surrounding(self: ptr IMContext00; text: cstring;
    len: int32; cursorIndex: int32) {.
    importc, libprag.}

proc setSurrounding*(self: IMContext; text: cstring; len: int;
    cursorIndex: int) =
  gtk_im_context_set_surrounding(cast[ptr IMContext00](self.impl), text, int32(len), int32(cursorIndex))

proc gtk_im_context_set_use_preedit(self: ptr IMContext00; usePreedit: gboolean) {.
    importc, libprag.}

proc setUsePreedit*(self: IMContext; usePreedit: bool = true) =
  gtk_im_context_set_use_preedit(cast[ptr IMContext00](self.impl), gboolean(usePreedit))

proc `usePreedit=`*(self: IMContext; usePreedit: bool) =
  gtk_im_context_set_use_preedit(cast[ptr IMContext00](self.impl), gboolean(usePreedit))

proc gtk_event_controller_key_get_im_context(self: ptr EventControllerKey00): ptr IMContext00 {.
    importc, libprag.}

proc getImContext*(self: EventControllerKey): IMContext =
  let gobj = gtk_event_controller_key_get_im_context(cast[ptr EventControllerKey00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc imContext*(self: EventControllerKey): IMContext =
  let gobj = gtk_event_controller_key_get_im_context(cast[ptr EventControllerKey00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_key_set_im_context(self: ptr EventControllerKey00;
    imContext: ptr IMContext00) {.
    importc, libprag.}

proc setImContext*(self: EventControllerKey; imContext: IMContext) =
  gtk_event_controller_key_set_im_context(cast[ptr EventControllerKey00](self.impl), cast[ptr IMContext00](imContext.impl))

proc `imContext=`*(self: EventControllerKey; imContext: IMContext) =
  gtk_event_controller_key_set_im_context(cast[ptr EventControllerKey00](self.impl), cast[ptr IMContext00](imContext.impl))

type
  EventControllerMotion* = ref object of EventController
  EventControllerMotion00* = object of EventController00

proc gtk_event_controller_motion_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerMotion()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scEnter*(self: EventControllerMotion;  p: proc (self: ptr EventControllerMotion00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "enter", cast[GCallback](p), xdata, nil, cf)

proc scLeave*(self: EventControllerMotion;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "leave", cast[GCallback](p), xdata, nil, cf)

proc scMotion*(self: EventControllerMotion;  p: proc (self: ptr EventControllerMotion00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "motion", cast[GCallback](p), xdata, nil, cf)

proc gtk_event_controller_motion_new(widget: ptr Widget00): ptr EventControllerMotion00 {.
    importc, libprag.}

proc newEventControllerMotion*(widget: Widget): EventControllerMotion =
  let gobj = gtk_event_controller_motion_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerMotion*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is EventControllerMotion)
  let gobj = gtk_event_controller_motion_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerMotion*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is EventControllerMotion)
  let gobj = gtk_event_controller_motion_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  EventControllerScroll* = ref object of EventController
  EventControllerScroll00* = object of EventController00

proc gtk_event_controller_scroll_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(EventControllerScroll()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDecelerate*(self: EventControllerScroll;  p: proc (self: ptr EventControllerScroll00; velX: cdouble; velY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "decelerate", cast[GCallback](p), xdata, nil, cf)

proc scScroll*(self: EventControllerScroll;  p: proc (self: ptr EventControllerScroll00; dx: cdouble; dy: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll", cast[GCallback](p), xdata, nil, cf)

proc scScrollBegin*(self: EventControllerScroll;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-begin", cast[GCallback](p), xdata, nil, cf)

proc scScrollEnd*(self: EventControllerScroll;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-end", cast[GCallback](p), xdata, nil, cf)

type
  EventControllerScrollFlags* {.size: sizeof(cint), pure.} = enum
    none = 0
    vertical = 1
    horizontal = 2
    bothAxes = 3
    discrete = 4
    kinetic = 8

proc gtk_event_controller_scroll_new(widget: ptr Widget00; flags: EventControllerScrollFlags): ptr EventControllerScroll00 {.
    importc, libprag.}

proc newEventControllerScroll*(widget: Widget; flags: EventControllerScrollFlags): EventControllerScroll =
  let gobj = gtk_event_controller_scroll_new(cast[ptr Widget00](widget.impl), flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newEventControllerScroll*(tdesc: typedesc; widget: Widget; flags: EventControllerScrollFlags): tdesc =
  assert(result is EventControllerScroll)
  let gobj = gtk_event_controller_scroll_new(cast[ptr Widget00](widget.impl), flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initEventControllerScroll*[T](result: var T; widget: Widget; flags: EventControllerScrollFlags) {.deprecated.} =
  assert(result is EventControllerScroll)
  let gobj = gtk_event_controller_scroll_new(cast[ptr Widget00](widget.impl), flags)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_event_controller_scroll_get_flags(self: ptr EventControllerScroll00): EventControllerScrollFlags {.
    importc, libprag.}

proc getFlags*(self: EventControllerScroll): EventControllerScrollFlags =
  gtk_event_controller_scroll_get_flags(cast[ptr EventControllerScroll00](self.impl))

proc flags*(self: EventControllerScroll): EventControllerScrollFlags =
  gtk_event_controller_scroll_get_flags(cast[ptr EventControllerScroll00](self.impl))

proc gtk_event_controller_scroll_set_flags(self: ptr EventControllerScroll00;
    flags: EventControllerScrollFlags) {.
    importc, libprag.}

proc setFlags*(self: EventControllerScroll; flags: EventControllerScrollFlags) =
  gtk_event_controller_scroll_set_flags(cast[ptr EventControllerScroll00](self.impl), flags)

proc `flags=`*(self: EventControllerScroll; flags: EventControllerScrollFlags) =
  gtk_event_controller_scroll_set_flags(cast[ptr EventControllerScroll00](self.impl), flags)

type
  EventSequenceState* {.size: sizeof(cint), pure.} = enum
    none = 0
    claimed = 1
    denied = 2

type
  ExpanderStyle* {.size: sizeof(cint), pure.} = enum
    collapsed = 0
    semiCollapsed = 1
    semiExpanded = 2
    expanded = 3

type
  FileChooserConfirmation* {.size: sizeof(cint), pure.} = enum
    confirm = 0
    acceptFilename = 1
    selectAgain = 2

type
  NativeDialog* = ref object of gobject.Object
  NativeDialog00* = object of gobject.Object00

proc gtk_native_dialog_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NativeDialog()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scResponse*(self: NativeDialog;  p: proc (self: ptr NativeDialog00; responseId: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "response", cast[GCallback](p), xdata, nil, cf)

proc gtk_native_dialog_destroy(self: ptr NativeDialog00) {.
    importc, libprag.}

proc destroy*(self: NativeDialog) =
  gtk_native_dialog_destroy(cast[ptr NativeDialog00](self.impl))

proc gtk_native_dialog_get_modal(self: ptr NativeDialog00): gboolean {.
    importc, libprag.}

proc getModal*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_modal(cast[ptr NativeDialog00](self.impl)))

proc modal*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_modal(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_get_title(self: ptr NativeDialog00): cstring {.
    importc, libprag.}

proc getTitle*(self: NativeDialog): string =
  let resul0 = gtk_native_dialog_get_title(cast[ptr NativeDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc title*(self: NativeDialog): string =
  let resul0 = gtk_native_dialog_get_title(cast[ptr NativeDialog00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_native_dialog_get_transient_for(self: ptr NativeDialog00): ptr Window00 {.
    importc, libprag.}

proc getTransientFor*(self: NativeDialog): Window =
  let gobj = gtk_native_dialog_get_transient_for(cast[ptr NativeDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc transientFor*(self: NativeDialog): Window =
  let gobj = gtk_native_dialog_get_transient_for(cast[ptr NativeDialog00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_native_dialog_get_visible(self: ptr NativeDialog00): gboolean {.
    importc, libprag.}

proc getVisible*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_visible(cast[ptr NativeDialog00](self.impl)))

proc visible*(self: NativeDialog): bool =
  toBool(gtk_native_dialog_get_visible(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_hide(self: ptr NativeDialog00) {.
    importc, libprag.}

proc hide*(self: NativeDialog) =
  gtk_native_dialog_hide(cast[ptr NativeDialog00](self.impl))

proc gtk_native_dialog_run(self: ptr NativeDialog00): int32 {.
    importc, libprag.}

proc run*(self: NativeDialog): int =
  int(gtk_native_dialog_run(cast[ptr NativeDialog00](self.impl)))

proc gtk_native_dialog_set_modal(self: ptr NativeDialog00; modal: gboolean) {.
    importc, libprag.}

proc setModal*(self: NativeDialog; modal: bool = true) =
  gtk_native_dialog_set_modal(cast[ptr NativeDialog00](self.impl), gboolean(modal))

proc `modal=`*(self: NativeDialog; modal: bool) =
  gtk_native_dialog_set_modal(cast[ptr NativeDialog00](self.impl), gboolean(modal))

proc gtk_native_dialog_set_title(self: ptr NativeDialog00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: NativeDialog; title: cstring) =
  gtk_native_dialog_set_title(cast[ptr NativeDialog00](self.impl), title)

proc `title=`*(self: NativeDialog; title: cstring) =
  gtk_native_dialog_set_title(cast[ptr NativeDialog00](self.impl), title)

proc gtk_native_dialog_set_transient_for(self: ptr NativeDialog00; parent: ptr Window00) {.
    importc, libprag.}

proc setTransientFor*(self: NativeDialog; parent: Window = nil) =
  gtk_native_dialog_set_transient_for(cast[ptr NativeDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc `transientFor=`*(self: NativeDialog; parent: Window = nil) =
  gtk_native_dialog_set_transient_for(cast[ptr NativeDialog00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc gtk_native_dialog_show(self: ptr NativeDialog00) {.
    importc, libprag.}

proc show*(self: NativeDialog) =
  gtk_native_dialog_show(cast[ptr NativeDialog00](self.impl))

type
  FileChooserNative* = ref object of NativeDialog
  FileChooserNative00* = object of NativeDialog00

proc gtk_file_chooser_native_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FileChooserNative()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_file_chooser_native_new(title: cstring; parent: ptr Window00; action: FileChooserAction;
    acceptLabel: cstring; cancelLabel: cstring): ptr FileChooserNative00 {.
    importc, libprag.}

proc newFileChooserNative*(title: cstring = nil; parent: Window = nil;
    action: FileChooserAction; acceptLabel: cstring = nil; cancelLabel: cstring = nil): FileChooserNative =
  let gobj = gtk_file_chooser_native_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action, acceptLabel, cancelLabel)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newFileChooserNative*(tdesc: typedesc; title: cstring = nil; parent: Window = nil;
    action: FileChooserAction; acceptLabel: cstring = nil; cancelLabel: cstring = nil): tdesc =
  assert(result is FileChooserNative)
  let gobj = gtk_file_chooser_native_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action, acceptLabel, cancelLabel)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserNative*[T](result: var T; title: cstring = nil; parent: Window = nil;
    action: FileChooserAction; acceptLabel: cstring = nil; cancelLabel: cstring = nil) {.deprecated.} =
  assert(result is FileChooserNative)
  let gobj = gtk_file_chooser_native_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action, acceptLabel, cancelLabel)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_native_get_accept_label(self: ptr FileChooserNative00): cstring {.
    importc, libprag.}

proc getAcceptLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_accept_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc acceptLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_accept_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_chooser_native_get_cancel_label(self: ptr FileChooserNative00): cstring {.
    importc, libprag.}

proc getCancelLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_cancel_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc cancelLabel*(self: FileChooserNative): string =
  let resul0 = gtk_file_chooser_native_get_cancel_label(cast[ptr FileChooserNative00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_file_chooser_native_set_accept_label(self: ptr FileChooserNative00;
    acceptLabel: cstring) {.
    importc, libprag.}

proc setAcceptLabel*(self: FileChooserNative; acceptLabel: cstring = nil) =
  gtk_file_chooser_native_set_accept_label(cast[ptr FileChooserNative00](self.impl), acceptLabel)

proc `acceptLabel=`*(self: FileChooserNative; acceptLabel: cstring = nil) =
  gtk_file_chooser_native_set_accept_label(cast[ptr FileChooserNative00](self.impl), acceptLabel)

proc gtk_file_chooser_native_set_cancel_label(self: ptr FileChooserNative00;
    cancelLabel: cstring) {.
    importc, libprag.}

proc setCancelLabel*(self: FileChooserNative; cancelLabel: cstring = nil) =
  gtk_file_chooser_native_set_cancel_label(cast[ptr FileChooserNative00](self.impl), cancelLabel)

proc `cancelLabel=`*(self: FileChooserNative; cancelLabel: cstring = nil) =
  gtk_file_chooser_native_set_cancel_label(cast[ptr FileChooserNative00](self.impl), cancelLabel)

type
  FileChooser00* = object of gobject.Object00
  FileChooser* = ref object of gobject.Object

proc scConfirmOverwrite*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;  p: proc (self: ptr FileChooser00; xdata: pointer): FileChooserConfirmation {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "confirm-overwrite", cast[GCallback](p), xdata, nil, cf)

proc scCurrentFolderChanged*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "current-folder-changed", cast[GCallback](p), xdata, nil, cf)

proc scFileActivated*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "file-activated", cast[GCallback](p), xdata, nil, cf)

proc scSelectionChanged*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-changed", cast[GCallback](p), xdata, nil, cf)

proc scUpdatePreview*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "update-preview", cast[GCallback](p), xdata, nil, cf)

proc gtk_file_chooser_add_choice(self: ptr FileChooser00; id: cstring; label: cstring;
    options: ptr cstring; optionLabels: ptr cstring) {.
    importc, libprag.}

proc addChoice*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    id: cstring; label: cstring; options: openArray[string]; optionLabels: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var fs469n232x: array[256, pointer]
  var fs469n232: cstringArray = cast[cstringArray](addr fs469n232x)
  gtk_file_chooser_add_choice(cast[ptr FileChooser00](self.impl), id, label, seq2CstringArray(options, fs469n23), seq2CstringArray(optionLabels, fs469n232))

proc gtk_file_chooser_add_filter(self: ptr FileChooser00; filter: ptr FileFilter00) {.
    importc, libprag.}

proc addFilter*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filter: FileFilter) =
  gtk_file_chooser_add_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](g_object_ref(filter.impl)))

proc gtk_file_chooser_add_shortcut_folder(self: ptr FileChooser00; folder: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addShortcutFolder*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    folder: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_add_shortcut_folder(cast[ptr FileChooser00](self.impl), folder, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_add_shortcut_folder_uri(self: ptr FileChooser00; uri: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc addShortcutFolderUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    uri: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_add_shortcut_folder_uri(cast[ptr FileChooser00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_get_action(self: ptr FileChooser00): FileChooserAction {.
    importc, libprag.}

proc getAction*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): FileChooserAction =
  gtk_file_chooser_get_action(cast[ptr FileChooser00](self.impl))

proc action*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): FileChooserAction =
  gtk_file_chooser_get_action(cast[ptr FileChooser00](self.impl))

proc gtk_file_chooser_get_choice(self: ptr FileChooser00; id: cstring): cstring {.
    importc, libprag.}

proc getChoice*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    id: cstring): string =
  result = $gtk_file_chooser_get_choice(cast[ptr FileChooser00](self.impl), id)

proc gtk_file_chooser_get_create_folders(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getCreateFolders*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_create_folders(cast[ptr FileChooser00](self.impl)))

proc createFolders*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_create_folders(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_current_folder(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getCurrentFolder*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_current_folder(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc currentFolder*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_current_folder(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_current_folder_file(self: ptr FileChooser00): ptr gio.GFile00 {.
    importc, libprag.}

proc getCurrentFolderFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): gio.GFile =
  let gobj = gtk_file_chooser_get_current_folder_file(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc currentFolderFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): gio.GFile =
  let gobj = gtk_file_chooser_get_current_folder_file(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_current_folder_uri(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getCurrentFolderUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_current_folder_uri(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc currentFolderUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_current_folder_uri(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_current_name(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getCurrentName*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_current_name(cast[ptr FileChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc currentName*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_current_name(cast[ptr FileChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_do_overwrite_confirmation(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getDoOverwriteConfirmation*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_do_overwrite_confirmation(cast[ptr FileChooser00](self.impl)))

proc doOverwriteConfirmation*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_do_overwrite_confirmation(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_extra_widget(self: ptr FileChooser00): ptr Widget00 {.
    importc, libprag.}

proc getExtraWidget*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): Widget =
  let gobj = gtk_file_chooser_get_extra_widget(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc extraWidget*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): Widget =
  let gobj = gtk_file_chooser_get_extra_widget(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_file(self: ptr FileChooser00): ptr gio.GFile00 {.
    importc, libprag.}

proc getFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): gio.GFile =
  let gobj = gtk_file_chooser_get_file(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc file*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): gio.GFile =
  let gobj = gtk_file_chooser_get_file(cast[ptr FileChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_filename(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getFilename*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_filename(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc filename*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_filename(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_filenames(self: ptr FileChooser00): ptr glib.SList {.
    importc, libprag.}

proc getFilenames*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[cstring] =
  let resul0 = gtk_file_chooser_get_filenames(cast[ptr FileChooser00](self.impl))
  g_slist_free(resul0)

proc filenames*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[cstring] =
  let resul0 = gtk_file_chooser_get_filenames(cast[ptr FileChooser00](self.impl))
  g_slist_free(resul0)

proc gtk_file_chooser_get_files(self: ptr FileChooser00): ptr glib.SList {.
    importc, libprag.}

proc getFiles*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[gio.GFile] =
  let resul0 = gtk_file_chooser_get_files(cast[ptr FileChooser00](self.impl))
  result = gslistObjects2seq(gio.GFile, resul0, true)
  g_slist_free(resul0)

proc files*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[gio.GFile] =
  let resul0 = gtk_file_chooser_get_files(cast[ptr FileChooser00](self.impl))
  result = gslistObjects2seq(gio.GFile, resul0, true)
  g_slist_free(resul0)

proc gtk_file_chooser_get_filter(self: ptr FileChooser00): ptr FileFilter00 {.
    importc, libprag.}

proc getFilter*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): FileFilter =
  let gobj = gtk_file_chooser_get_filter(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filter*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): FileFilter =
  let gobj = gtk_file_chooser_get_filter(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_local_only(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getLocalOnly*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_local_only(cast[ptr FileChooser00](self.impl)))

proc localOnly*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_local_only(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_preview_file(self: ptr FileChooser00): ptr gio.GFile00 {.
    importc, libprag.}

proc getPreviewFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): gio.GFile =
  let gobj = gtk_file_chooser_get_preview_file(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc previewFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): gio.GFile =
  let gobj = gtk_file_chooser_get_preview_file(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_preview_filename(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getPreviewFilename*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_preview_filename(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc previewFilename*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_preview_filename(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_preview_uri(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getPreviewUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_preview_uri(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc previewUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_preview_uri(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_preview_widget(self: ptr FileChooser00): ptr Widget00 {.
    importc, libprag.}

proc getPreviewWidget*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): Widget =
  let gobj = gtk_file_chooser_get_preview_widget(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc previewWidget*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): Widget =
  let gobj = gtk_file_chooser_get_preview_widget(cast[ptr FileChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_file_chooser_get_preview_widget_active(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getPreviewWidgetActive*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_preview_widget_active(cast[ptr FileChooser00](self.impl)))

proc previewWidgetActive*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_preview_widget_active(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_select_multiple(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getSelectMultiple*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_select_multiple(cast[ptr FileChooser00](self.impl)))

proc selectMultiple*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_select_multiple(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_show_hidden(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getShowHidden*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_show_hidden(cast[ptr FileChooser00](self.impl)))

proc showHidden*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_show_hidden(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_get_uri(self: ptr FileChooser00): cstring {.
    importc, libprag.}

proc getUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_uri(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc uri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): string =
  let resul0 = gtk_file_chooser_get_uri(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_file_chooser_get_uris(self: ptr FileChooser00): ptr glib.SList {.
    importc, libprag.}

proc getUris*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[cstring] =
  let resul0 = gtk_file_chooser_get_uris(cast[ptr FileChooser00](self.impl))
  g_slist_free(resul0)

proc uris*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[cstring] =
  let resul0 = gtk_file_chooser_get_uris(cast[ptr FileChooser00](self.impl))
  g_slist_free(resul0)

proc gtk_file_chooser_get_use_preview_label(self: ptr FileChooser00): gboolean {.
    importc, libprag.}

proc getUsePreviewLabel*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_use_preview_label(cast[ptr FileChooser00](self.impl)))

proc usePreviewLabel*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): bool =
  toBool(gtk_file_chooser_get_use_preview_label(cast[ptr FileChooser00](self.impl)))

proc gtk_file_chooser_list_filters(self: ptr FileChooser00): ptr glib.SList {.
    importc, libprag.}

proc listFilters*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[FileFilter] =
  let resul0 = gtk_file_chooser_list_filters(cast[ptr FileChooser00](self.impl))
  result = gslistObjects2seq(FileFilter, resul0, false)
  g_slist_free(resul0)

proc gtk_file_chooser_list_shortcut_folder_uris(self: ptr FileChooser00): ptr glib.SList {.
    importc, libprag.}

proc listShortcutFolderUris*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[cstring] =
  let resul0 = gtk_file_chooser_list_shortcut_folder_uris(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  g_slist_free(resul0)

proc gtk_file_chooser_list_shortcut_folders(self: ptr FileChooser00): ptr glib.SList {.
    importc, libprag.}

proc listShortcutFolders*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog): seq[cstring] =
  let resul0 = gtk_file_chooser_list_shortcut_folders(cast[ptr FileChooser00](self.impl))
  if resul0.isNil:
    return
  g_slist_free(resul0)

proc gtk_file_chooser_remove_choice(self: ptr FileChooser00; id: cstring) {.
    importc, libprag.}

proc removeChoice*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    id: cstring) =
  gtk_file_chooser_remove_choice(cast[ptr FileChooser00](self.impl), id)

proc gtk_file_chooser_remove_filter(self: ptr FileChooser00; filter: ptr FileFilter00) {.
    importc, libprag.}

proc removeFilter*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filter: FileFilter) =
  gtk_file_chooser_remove_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](filter.impl))

proc gtk_file_chooser_remove_shortcut_folder(self: ptr FileChooser00; folder: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc removeShortcutFolder*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    folder: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_remove_shortcut_folder(cast[ptr FileChooser00](self.impl), folder, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_remove_shortcut_folder_uri(self: ptr FileChooser00;
    uri: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc removeShortcutFolderUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    uri: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_remove_shortcut_folder_uri(cast[ptr FileChooser00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_select_all(self: ptr FileChooser00) {.
    importc, libprag.}

proc selectAll*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog) =
  gtk_file_chooser_select_all(cast[ptr FileChooser00](self.impl))

proc gtk_file_chooser_select_file(self: ptr FileChooser00; file: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc selectFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    file: gio.GFile): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_select_file(cast[ptr FileChooser00](self.impl), cast[ptr gio.GFile00](file.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_select_filename(self: ptr FileChooser00; filename: cstring): gboolean {.
    importc, libprag.}

proc selectFilename*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filename: cstring): bool =
  toBool(gtk_file_chooser_select_filename(cast[ptr FileChooser00](self.impl), filename))

proc gtk_file_chooser_select_uri(self: ptr FileChooser00; uri: cstring): gboolean {.
    importc, libprag.}

proc selectUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    uri: cstring): bool =
  toBool(gtk_file_chooser_select_uri(cast[ptr FileChooser00](self.impl), uri))

proc gtk_file_chooser_set_action(self: ptr FileChooser00; action: FileChooserAction) {.
    importc, libprag.}

proc setAction*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    action: FileChooserAction) =
  gtk_file_chooser_set_action(cast[ptr FileChooser00](self.impl), action)

proc `action=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    action: FileChooserAction) =
  gtk_file_chooser_set_action(cast[ptr FileChooser00](self.impl), action)

proc gtk_file_chooser_set_choice(self: ptr FileChooser00; id: cstring; option: cstring) {.
    importc, libprag.}

proc setChoice*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    id: cstring; option: cstring) =
  gtk_file_chooser_set_choice(cast[ptr FileChooser00](self.impl), id, option)

proc gtk_file_chooser_set_create_folders(self: ptr FileChooser00; createFolders: gboolean) {.
    importc, libprag.}

proc setCreateFolders*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    createFolders: bool = true) =
  gtk_file_chooser_set_create_folders(cast[ptr FileChooser00](self.impl), gboolean(createFolders))

proc `createFolders=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    createFolders: bool) =
  gtk_file_chooser_set_create_folders(cast[ptr FileChooser00](self.impl), gboolean(createFolders))

proc gtk_file_chooser_set_current_folder(self: ptr FileChooser00; filename: cstring): gboolean {.
    importc, libprag.}

proc setCurrentFolder*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filename: cstring): bool =
  toBool(gtk_file_chooser_set_current_folder(cast[ptr FileChooser00](self.impl), filename))

proc gtk_file_chooser_set_current_folder_file(self: ptr FileChooser00; file: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setCurrentFolderFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    file: gio.GFile): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_set_current_folder_file(cast[ptr FileChooser00](self.impl), cast[ptr gio.GFile00](file.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_set_current_folder_uri(self: ptr FileChooser00; uri: cstring): gboolean {.
    importc, libprag.}

proc setCurrentFolderUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    uri: cstring): bool =
  toBool(gtk_file_chooser_set_current_folder_uri(cast[ptr FileChooser00](self.impl), uri))

proc gtk_file_chooser_set_current_name(self: ptr FileChooser00; name: cstring) {.
    importc, libprag.}

proc setCurrentName*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    name: cstring) =
  gtk_file_chooser_set_current_name(cast[ptr FileChooser00](self.impl), name)

proc `currentName=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    name: cstring) =
  gtk_file_chooser_set_current_name(cast[ptr FileChooser00](self.impl), name)

proc gtk_file_chooser_set_do_overwrite_confirmation(self: ptr FileChooser00;
    doOverwriteConfirmation: gboolean) {.
    importc, libprag.}

proc setDoOverwriteConfirmation*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    doOverwriteConfirmation: bool = true) =
  gtk_file_chooser_set_do_overwrite_confirmation(cast[ptr FileChooser00](self.impl), gboolean(doOverwriteConfirmation))

proc `doOverwriteConfirmation=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    doOverwriteConfirmation: bool) =
  gtk_file_chooser_set_do_overwrite_confirmation(cast[ptr FileChooser00](self.impl), gboolean(doOverwriteConfirmation))

proc gtk_file_chooser_set_extra_widget(self: ptr FileChooser00; extraWidget: ptr Widget00) {.
    importc, libprag.}

proc setExtraWidget*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    extraWidget: Widget) =
  gtk_file_chooser_set_extra_widget(cast[ptr FileChooser00](self.impl), cast[ptr Widget00](extraWidget.impl))

proc `extraWidget=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    extraWidget: Widget) =
  gtk_file_chooser_set_extra_widget(cast[ptr FileChooser00](self.impl), cast[ptr Widget00](extraWidget.impl))

proc gtk_file_chooser_set_file(self: ptr FileChooser00; file: ptr gio.GFile00;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    file: gio.GFile): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_file_chooser_set_file(cast[ptr FileChooser00](self.impl), cast[ptr gio.GFile00](file.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_file_chooser_set_filename(self: ptr FileChooser00; filename: cstring): gboolean {.
    importc, libprag.}

proc setFilename*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filename: cstring): bool =
  toBool(gtk_file_chooser_set_filename(cast[ptr FileChooser00](self.impl), filename))

proc gtk_file_chooser_set_filter(self: ptr FileChooser00; filter: ptr FileFilter00) {.
    importc, libprag.}

proc setFilter*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filter: FileFilter) =
  gtk_file_chooser_set_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](filter.impl))

proc `filter=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filter: FileFilter) =
  gtk_file_chooser_set_filter(cast[ptr FileChooser00](self.impl), cast[ptr FileFilter00](filter.impl))

proc gtk_file_chooser_set_local_only(self: ptr FileChooser00; localOnly: gboolean) {.
    importc, libprag.}

proc setLocalOnly*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    localOnly: bool = true) =
  gtk_file_chooser_set_local_only(cast[ptr FileChooser00](self.impl), gboolean(localOnly))

proc `localOnly=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    localOnly: bool) =
  gtk_file_chooser_set_local_only(cast[ptr FileChooser00](self.impl), gboolean(localOnly))

proc gtk_file_chooser_set_preview_widget(self: ptr FileChooser00; previewWidget: ptr Widget00) {.
    importc, libprag.}

proc setPreviewWidget*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    previewWidget: Widget) =
  gtk_file_chooser_set_preview_widget(cast[ptr FileChooser00](self.impl), cast[ptr Widget00](previewWidget.impl))

proc `previewWidget=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    previewWidget: Widget) =
  gtk_file_chooser_set_preview_widget(cast[ptr FileChooser00](self.impl), cast[ptr Widget00](previewWidget.impl))

proc gtk_file_chooser_set_preview_widget_active(self: ptr FileChooser00;
    active: gboolean) {.
    importc, libprag.}

proc setPreviewWidgetActive*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    active: bool = true) =
  gtk_file_chooser_set_preview_widget_active(cast[ptr FileChooser00](self.impl), gboolean(active))

proc `previewWidgetActive=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    active: bool) =
  gtk_file_chooser_set_preview_widget_active(cast[ptr FileChooser00](self.impl), gboolean(active))

proc gtk_file_chooser_set_select_multiple(self: ptr FileChooser00; selectMultiple: gboolean) {.
    importc, libprag.}

proc setSelectMultiple*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    selectMultiple: bool = true) =
  gtk_file_chooser_set_select_multiple(cast[ptr FileChooser00](self.impl), gboolean(selectMultiple))

proc `selectMultiple=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    selectMultiple: bool) =
  gtk_file_chooser_set_select_multiple(cast[ptr FileChooser00](self.impl), gboolean(selectMultiple))

proc gtk_file_chooser_set_show_hidden(self: ptr FileChooser00; showHidden: gboolean) {.
    importc, libprag.}

proc setShowHidden*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    showHidden: bool = true) =
  gtk_file_chooser_set_show_hidden(cast[ptr FileChooser00](self.impl), gboolean(showHidden))

proc `showHidden=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    showHidden: bool) =
  gtk_file_chooser_set_show_hidden(cast[ptr FileChooser00](self.impl), gboolean(showHidden))

proc gtk_file_chooser_set_uri(self: ptr FileChooser00; uri: cstring): gboolean {.
    importc, libprag.}

proc setUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    uri: cstring): bool =
  toBool(gtk_file_chooser_set_uri(cast[ptr FileChooser00](self.impl), uri))

proc gtk_file_chooser_set_use_preview_label(self: ptr FileChooser00; useLabel: gboolean) {.
    importc, libprag.}

proc setUsePreviewLabel*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    useLabel: bool = true) =
  gtk_file_chooser_set_use_preview_label(cast[ptr FileChooser00](self.impl), gboolean(useLabel))

proc `usePreviewLabel=`*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    useLabel: bool) =
  gtk_file_chooser_set_use_preview_label(cast[ptr FileChooser00](self.impl), gboolean(useLabel))

proc gtk_file_chooser_unselect_all(self: ptr FileChooser00) {.
    importc, libprag.}

proc unselectAll*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog) =
  gtk_file_chooser_unselect_all(cast[ptr FileChooser00](self.impl))

proc gtk_file_chooser_unselect_file(self: ptr FileChooser00; file: ptr gio.GFile00) {.
    importc, libprag.}

proc unselectFile*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    file: gio.GFile) =
  gtk_file_chooser_unselect_file(cast[ptr FileChooser00](self.impl), cast[ptr gio.GFile00](file.impl))

proc gtk_file_chooser_unselect_filename(self: ptr FileChooser00; filename: cstring) {.
    importc, libprag.}

proc unselectFilename*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    filename: cstring) =
  gtk_file_chooser_unselect_filename(cast[ptr FileChooser00](self.impl), filename)

proc gtk_file_chooser_unselect_uri(self: ptr FileChooser00; uri: cstring) {.
    importc, libprag.}

proc unselectUri*(self: FileChooser | FileChooserButton | FileChooserNative | FileChooserWidget | FileChooserDialog;
    uri: cstring) =
  gtk_file_chooser_unselect_uri(cast[ptr FileChooser00](self.impl), uri)

type
  FileChooserError* {.size: sizeof(cint), pure.} = enum
    nonexistent = 0
    badFilename = 1
    alreadyExists = 2
    incompleteHostname = 3

type
  FileFilterFunc* = proc (filterInfo: FileFilterInfo; data: pointer): gboolean {.cdecl.}

proc gtk_file_filter_add_custom(self: ptr FileFilter00; needed: FileFilterFlags;
    `func`: FileFilterFunc; data: pointer; notify: DestroyNotify) {.
    importc, libprag.}

proc addCustom*(self: FileFilter; needed: FileFilterFlags;
    `func`: FileFilterFunc; data: pointer; notify: DestroyNotify) =
  gtk_file_filter_add_custom(cast[ptr FileFilter00](self.impl), needed, `func`, data, notify)

type
  FixedChild00* {.pure.} = object
  FixedChild* = ref object
    impl*: ptr FixedChild00
    ignoreFinalizer*: bool

type
  FlowBoxAccessible* = ref object of ContainerAccessible
  FlowBoxAccessible00* = object of ContainerAccessible00

proc gtk_flow_box_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FlowBoxAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  FlowBoxChildAccessible* = ref object of ContainerAccessible
  FlowBoxChildAccessible00* = object of ContainerAccessible00

proc gtk_flow_box_child_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FlowBoxChildAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  FlowBoxCreateWidgetFunc* = proc (item: ptr gobject.Object00; userData: pointer): ptr Widget00 {.cdecl.}

proc gtk_flow_box_bind_model(self: ptr FlowBox00; model: ptr gio.ListModel00;
    createWidgetFunc: FlowBoxCreateWidgetFunc; userData: pointer; userDataFreeFunc: DestroyNotify) {.
    importc, libprag.}

proc bindModel*(self: FlowBox; model: gio.ListModel = nil; createWidgetFunc: FlowBoxCreateWidgetFunc;
    userData: pointer; userDataFreeFunc: DestroyNotify) =
  gtk_flow_box_bind_model(cast[ptr FlowBox00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl), createWidgetFunc, userData, userDataFreeFunc)

type
  FlowBoxFilterFunc* = proc (child: ptr FlowBoxChild00; userData: pointer): gboolean {.cdecl.}

proc gtk_flow_box_set_filter_func(self: ptr FlowBox00; filterFunc: FlowBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setFilterFunc*(self: FlowBox; filterFunc: FlowBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_flow_box_set_filter_func(cast[ptr FlowBox00](self.impl), filterFunc, userData, destroy)

type
  FlowBoxForeachFunc* = proc (box: ptr FlowBox00; child: ptr FlowBoxChild00; userData: pointer) {.cdecl.}

proc gtk_flow_box_selected_foreach(self: ptr FlowBox00; `func`: FlowBoxForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: FlowBox; `func`: FlowBoxForeachFunc;
    data: pointer) =
  gtk_flow_box_selected_foreach(cast[ptr FlowBox00](self.impl), `func`, data)

type
  FlowBoxSortFunc* = proc (child1: ptr FlowBoxChild00; child2: ptr FlowBoxChild00; userData: pointer): int32 {.cdecl.}

proc gtk_flow_box_set_sort_func(self: ptr FlowBox00; sortFunc: FlowBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: FlowBox; sortFunc: FlowBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_flow_box_set_sort_func(cast[ptr FlowBox00](self.impl), sortFunc, userData, destroy)

type
  FontChooser00* = object of gobject.Object00
  FontChooser* = ref object of gobject.Object

proc scFontActivated*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;  p: proc (self: ptr FontChooser00; fontname: cstring; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "font-activated", cast[GCallback](p), xdata, nil, cf)

proc gtk_font_chooser_get_font(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getFont*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_font(cast[ptr FontChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc font*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_font(cast[ptr FontChooser00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_font_desc(self: ptr FontChooser00): ptr pango.FontDescription00 {.
    importc, libprag.}

proc getFontDesc*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontDescription =
  let impl0 = gtk_font_chooser_get_font_desc(cast[ptr FontChooser00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = impl0

proc fontDesc*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontDescription =
  let impl0 = gtk_font_chooser_get_font_desc(cast[ptr FontChooser00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = impl0

proc gtk_font_chooser_get_font_face(self: ptr FontChooser00): ptr pango.FontFace00 {.
    importc, libprag.}

proc getFontFace*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontFace =
  let gobj = gtk_font_chooser_get_font_face(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontFace*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontFace =
  let gobj = gtk_font_chooser_get_font_face(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_family(self: ptr FontChooser00): ptr pango.FontFamily00 {.
    importc, libprag.}

proc getFontFamily*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontFamily =
  let gobj = gtk_font_chooser_get_font_family(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontFamily*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontFamily =
  let gobj = gtk_font_chooser_get_font_family(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_features(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getFontFeatures*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_font_features(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc fontFeatures*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_font_features(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_font_map(self: ptr FontChooser00): ptr pango.FontMap00 {.
    importc, libprag.}

proc getFontMap*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontMap =
  let gobj = gtk_font_chooser_get_font_map(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc fontMap*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): pango.FontMap =
  let gobj = gtk_font_chooser_get_font_map(cast[ptr FontChooser00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_font_chooser_get_font_size(self: ptr FontChooser00): int32 {.
    importc, libprag.}

proc getFontSize*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): int =
  int(gtk_font_chooser_get_font_size(cast[ptr FontChooser00](self.impl)))

proc fontSize*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): int =
  int(gtk_font_chooser_get_font_size(cast[ptr FontChooser00](self.impl)))

proc gtk_font_chooser_get_language(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getLanguage*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_language(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc language*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_language(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_preview_text(self: ptr FontChooser00): cstring {.
    importc, libprag.}

proc getPreviewText*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_preview_text(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc previewText*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): string =
  let resul0 = gtk_font_chooser_get_preview_text(cast[ptr FontChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_font_chooser_get_show_preview_entry(self: ptr FontChooser00): gboolean {.
    importc, libprag.}

proc getShowPreviewEntry*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): bool =
  toBool(gtk_font_chooser_get_show_preview_entry(cast[ptr FontChooser00](self.impl)))

proc showPreviewEntry*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): bool =
  toBool(gtk_font_chooser_get_show_preview_entry(cast[ptr FontChooser00](self.impl)))

proc gtk_font_chooser_set_font(self: ptr FontChooser00; fontname: cstring) {.
    importc, libprag.}

proc setFont*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    fontname: cstring) =
  gtk_font_chooser_set_font(cast[ptr FontChooser00](self.impl), fontname)

proc `font=`*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    fontname: cstring) =
  gtk_font_chooser_set_font(cast[ptr FontChooser00](self.impl), fontname)

proc gtk_font_chooser_set_font_desc(self: ptr FontChooser00; fontDesc: ptr pango.FontDescription00) {.
    importc, libprag.}

proc setFontDesc*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    fontDesc: pango.FontDescription) =
  gtk_font_chooser_set_font_desc(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc `fontDesc=`*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    fontDesc: pango.FontDescription) =
  gtk_font_chooser_set_font_desc(cast[ptr FontChooser00](self.impl), cast[ptr pango.FontDescription00](fontDesc.impl))

proc gtk_font_chooser_set_font_map(self: ptr FontChooser00; fontmap: ptr pango.FontMap00) {.
    importc, libprag.}

proc setFontMap*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    fontmap: pango.FontMap = nil) =
  gtk_font_chooser_set_font_map(cast[ptr FontChooser00](self.impl), if fontmap.isNil: nil else: cast[ptr pango.FontMap00](fontmap.impl))

proc `fontMap=`*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    fontmap: pango.FontMap = nil) =
  gtk_font_chooser_set_font_map(cast[ptr FontChooser00](self.impl), if fontmap.isNil: nil else: cast[ptr pango.FontMap00](fontmap.impl))

proc gtk_font_chooser_set_language(self: ptr FontChooser00; language: cstring) {.
    importc, libprag.}

proc setLanguage*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    language: cstring) =
  gtk_font_chooser_set_language(cast[ptr FontChooser00](self.impl), language)

proc `language=`*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    language: cstring) =
  gtk_font_chooser_set_language(cast[ptr FontChooser00](self.impl), language)

proc gtk_font_chooser_set_preview_text(self: ptr FontChooser00; text: cstring) {.
    importc, libprag.}

proc setPreviewText*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    text: cstring) =
  gtk_font_chooser_set_preview_text(cast[ptr FontChooser00](self.impl), text)

proc `previewText=`*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    text: cstring) =
  gtk_font_chooser_set_preview_text(cast[ptr FontChooser00](self.impl), text)

proc gtk_font_chooser_set_show_preview_entry(self: ptr FontChooser00; showPreviewEntry: gboolean) {.
    importc, libprag.}

proc setShowPreviewEntry*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    showPreviewEntry: bool = true) =
  gtk_font_chooser_set_show_preview_entry(cast[ptr FontChooser00](self.impl), gboolean(showPreviewEntry))

proc `showPreviewEntry=`*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    showPreviewEntry: bool) =
  gtk_font_chooser_set_show_preview_entry(cast[ptr FontChooser00](self.impl), gboolean(showPreviewEntry))

type
  FontChooserLevel* {.size: sizeof(cint), pure.} = enum
    family = 0
    style = 1
    size = 2
    variations = 4
    features = 8

proc gtk_font_chooser_get_level(self: ptr FontChooser00): FontChooserLevel {.
    importc, libprag.}

proc getLevel*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): FontChooserLevel =
  gtk_font_chooser_get_level(cast[ptr FontChooser00](self.impl))

proc level*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton): FontChooserLevel =
  gtk_font_chooser_get_level(cast[ptr FontChooser00](self.impl))

proc gtk_font_chooser_set_level(self: ptr FontChooser00; level: FontChooserLevel) {.
    importc, libprag.}

proc setLevel*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    level: FontChooserLevel) =
  gtk_font_chooser_set_level(cast[ptr FontChooser00](self.impl), level)

proc `level=`*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    level: FontChooserLevel) =
  gtk_font_chooser_set_level(cast[ptr FontChooser00](self.impl), level)

type
  FontFilterFunc* = proc (family: ptr pango.FontFamily00; face: ptr pango.FontFace00; data: pointer): gboolean {.cdecl.}

proc gtk_font_chooser_set_filter_func(self: ptr FontChooser00; filter: FontFilterFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setFilterFunc*(self: FontChooser | FontChooserWidget | FontChooserDialog | FontButton;
    filter: FontFilterFunc; userData: pointer; destroy: DestroyNotify) =
  gtk_font_chooser_set_filter_func(cast[ptr FontChooser00](self.impl), filter, userData, destroy)

type
  FrameAccessible* = ref object of ContainerAccessible
  FrameAccessible00* = object of ContainerAccessible00

proc gtk_frame_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(FrameAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  Gesture* = ref object of EventController
  Gesture00* = object of EventController00

proc gtk_gesture_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Gesture()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scBegin*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "begin", cast[GCallback](p), xdata, nil, cf)

proc scCancel*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancel", cast[GCallback](p), xdata, nil, cf)

proc scEnd*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "end", cast[GCallback](p), xdata, nil, cf)

proc scSequenceStateChanged*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk.EventSequence00; state: EventSequenceState; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "sequence-state-changed", cast[GCallback](p), xdata, nil, cf)

proc scUpdate*(self: Gesture;  p: proc (self: ptr Gesture00; sequence: ptr gdk.EventSequence00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "update", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_get_bounding_box(self: ptr Gesture00; rect: var gdk.Rectangle): gboolean {.
    importc, libprag.}

proc getBoundingBox*(self: Gesture; rect: var gdk.Rectangle): bool =
  toBool(gtk_gesture_get_bounding_box(cast[ptr Gesture00](self.impl), rect))

proc gtk_gesture_get_bounding_box_center(self: ptr Gesture00; x: var cdouble;
    y: var cdouble): gboolean {.
    importc, libprag.}

proc getBoundingBoxCenter*(self: Gesture; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_get_bounding_box_center(cast[ptr Gesture00](self.impl), x, y))

proc gtk_gesture_get_device(self: ptr Gesture00): ptr gdk.Device00 {.
    importc, libprag.}

proc getDevice*(self: Gesture): gdk.Device =
  let gobj = gtk_gesture_get_device(cast[ptr Gesture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc device*(self: Gesture): gdk.Device =
  let gobj = gtk_gesture_get_device(cast[ptr Gesture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_get_group(self: ptr Gesture00): ptr glib.List {.
    importc, libprag.}

proc getGroup*(self: Gesture): seq[Gesture] =
  let resul0 = gtk_gesture_get_group(cast[ptr Gesture00](self.impl))
  result = glistObjects2seq(Gesture, resul0, false)
  g_list_free(resul0)

proc group*(self: Gesture): seq[Gesture] =
  let resul0 = gtk_gesture_get_group(cast[ptr Gesture00](self.impl))
  result = glistObjects2seq(Gesture, resul0, false)
  g_list_free(resul0)

proc gtk_gesture_get_last_event(self: ptr Gesture00; sequence: ptr gdk.EventSequence00): ptr gdk.Event00 {.
    importc, libprag.}

proc getLastEvent*(self: Gesture; sequence: gdk.EventSequence = nil): gdk.Event =
  let impl0 = gtk_gesture_get_last_event(cast[ptr Gesture00](self.impl), if sequence.isNil: nil else: cast[ptr gdk.EventSequence00](sequence.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEvent)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gdk_event_get_type(), impl0))

proc gtk_gesture_get_last_updated_sequence(self: ptr Gesture00): ptr gdk.EventSequence00 {.
    importc, libprag.}

proc getLastUpdatedSequence*(self: Gesture): gdk.EventSequence =
  let impl0 = gtk_gesture_get_last_updated_sequence(cast[ptr Gesture00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gdk_event_sequence_get_type(), impl0))

proc lastUpdatedSequence*(self: Gesture): gdk.EventSequence =
  let impl0 = gtk_gesture_get_last_updated_sequence(cast[ptr Gesture00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gdk_event_sequence_get_type(), impl0))

proc gtk_gesture_get_point(self: ptr Gesture00; sequence: ptr gdk.EventSequence00;
    x: var cdouble; y: var cdouble): gboolean {.
    importc, libprag.}

proc getPoint*(self: Gesture; sequence: gdk.EventSequence = nil;
    x: var cdouble = cast[var cdouble](nil); y: var cdouble = cast[var cdouble](nil)): bool =
  toBool(gtk_gesture_get_point(cast[ptr Gesture00](self.impl), if sequence.isNil: nil else: cast[ptr gdk.EventSequence00](sequence.impl), x, y))

proc gtk_gesture_get_sequence_state(self: ptr Gesture00; sequence: ptr gdk.EventSequence00): EventSequenceState {.
    importc, libprag.}

proc getSequenceState*(self: Gesture; sequence: gdk.EventSequence): EventSequenceState =
  gtk_gesture_get_sequence_state(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl))

proc gtk_gesture_get_sequences(self: ptr Gesture00): ptr glib.List {.
    importc, libprag.}

proc getSequences*(self: Gesture): seq[gdk.EventSequence] =
  let resul0 = gtk_gesture_get_sequences(cast[ptr Gesture00](self.impl))
  result = glistStructs2seq[gdk.EventSequence](resul0, true)
  g_list_free(resul0)

proc sequences*(self: Gesture): seq[gdk.EventSequence] =
  let resul0 = gtk_gesture_get_sequences(cast[ptr Gesture00](self.impl))
  result = glistStructs2seq[gdk.EventSequence](resul0, true)
  g_list_free(resul0)

proc gtk_gesture_get_window(self: ptr Gesture00): ptr gdk.Window00 {.
    importc, libprag.}

proc getWindow*(self: Gesture): gdk.Window =
  let gobj = gtk_gesture_get_window(cast[ptr Gesture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc window*(self: Gesture): gdk.Window =
  let gobj = gtk_gesture_get_window(cast[ptr Gesture00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_group(self: ptr Gesture00; gesture: ptr Gesture00) {.
    importc, libprag.}

proc group*(self: Gesture; gesture: Gesture) =
  gtk_gesture_group(cast[ptr Gesture00](self.impl), cast[ptr Gesture00](gesture.impl))

proc gtk_gesture_handles_sequence(self: ptr Gesture00; sequence: ptr gdk.EventSequence00): gboolean {.
    importc, libprag.}

proc handlesSequence*(self: Gesture; sequence: gdk.EventSequence = nil): bool =
  toBool(gtk_gesture_handles_sequence(cast[ptr Gesture00](self.impl), if sequence.isNil: nil else: cast[ptr gdk.EventSequence00](sequence.impl)))

proc gtk_gesture_is_active(self: ptr Gesture00): gboolean {.
    importc, libprag.}

proc isActive*(self: Gesture): bool =
  toBool(gtk_gesture_is_active(cast[ptr Gesture00](self.impl)))

proc gtk_gesture_is_grouped_with(self: ptr Gesture00; other: ptr Gesture00): gboolean {.
    importc, libprag.}

proc isGroupedWith*(self: Gesture; other: Gesture): bool =
  toBool(gtk_gesture_is_grouped_with(cast[ptr Gesture00](self.impl), cast[ptr Gesture00](other.impl)))

proc gtk_gesture_is_recognized(self: ptr Gesture00): gboolean {.
    importc, libprag.}

proc isRecognized*(self: Gesture): bool =
  toBool(gtk_gesture_is_recognized(cast[ptr Gesture00](self.impl)))

proc gtk_gesture_set_sequence_state(self: ptr Gesture00; sequence: ptr gdk.EventSequence00;
    state: EventSequenceState): gboolean {.
    importc, libprag.}

proc setSequenceState*(self: Gesture; sequence: gdk.EventSequence;
    state: EventSequenceState): bool =
  toBool(gtk_gesture_set_sequence_state(cast[ptr Gesture00](self.impl), cast[ptr gdk.EventSequence00](sequence.impl), state))

proc gtk_gesture_set_state(self: ptr Gesture00; state: EventSequenceState): gboolean {.
    importc, libprag.}

proc setState*(self: Gesture; state: EventSequenceState): bool =
  toBool(gtk_gesture_set_state(cast[ptr Gesture00](self.impl), state))

proc gtk_gesture_set_window(self: ptr Gesture00; window: ptr gdk.Window00) {.
    importc, libprag.}

proc setWindow*(self: Gesture; window: gdk.Window = nil) =
  gtk_gesture_set_window(cast[ptr Gesture00](self.impl), if window.isNil: nil else: cast[ptr gdk.Window00](window.impl))

proc `window=`*(self: Gesture; window: gdk.Window = nil) =
  gtk_gesture_set_window(cast[ptr Gesture00](self.impl), if window.isNil: nil else: cast[ptr gdk.Window00](window.impl))

proc gtk_gesture_ungroup(self: ptr Gesture00) {.
    importc, libprag.}

proc ungroup*(self: Gesture) =
  gtk_gesture_ungroup(cast[ptr Gesture00](self.impl))

type
  GestureSingle* = ref object of Gesture
  GestureSingle00* = object of Gesture00

proc gtk_gesture_single_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureSingle()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_gesture_single_get_button(self: ptr GestureSingle00): uint32 {.
    importc, libprag.}

proc getButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_button(cast[ptr GestureSingle00](self.impl)))

proc button*(self: GestureSingle): int =
  int(gtk_gesture_single_get_button(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_current_button(self: ptr GestureSingle00): uint32 {.
    importc, libprag.}

proc getCurrentButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_current_button(cast[ptr GestureSingle00](self.impl)))

proc currentButton*(self: GestureSingle): int =
  int(gtk_gesture_single_get_current_button(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_current_sequence(self: ptr GestureSingle00): ptr gdk.EventSequence00 {.
    importc, libprag.}

proc getCurrentSequence*(self: GestureSingle): gdk.EventSequence =
  let impl0 = gtk_gesture_single_get_current_sequence(cast[ptr GestureSingle00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = impl0

proc currentSequence*(self: GestureSingle): gdk.EventSequence =
  let impl0 = gtk_gesture_single_get_current_sequence(cast[ptr GestureSingle00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEventSequence)
  result.impl = impl0

proc gtk_gesture_single_get_exclusive(self: ptr GestureSingle00): gboolean {.
    importc, libprag.}

proc getExclusive*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_exclusive(cast[ptr GestureSingle00](self.impl)))

proc exclusive*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_exclusive(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_get_touch_only(self: ptr GestureSingle00): gboolean {.
    importc, libprag.}

proc getTouchOnly*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_touch_only(cast[ptr GestureSingle00](self.impl)))

proc touchOnly*(self: GestureSingle): bool =
  toBool(gtk_gesture_single_get_touch_only(cast[ptr GestureSingle00](self.impl)))

proc gtk_gesture_single_set_button(self: ptr GestureSingle00; button: uint32) {.
    importc, libprag.}

proc setButton*(self: GestureSingle; button: int) =
  gtk_gesture_single_set_button(cast[ptr GestureSingle00](self.impl), uint32(button))

proc `button=`*(self: GestureSingle; button: int) =
  gtk_gesture_single_set_button(cast[ptr GestureSingle00](self.impl), uint32(button))

proc gtk_gesture_single_set_exclusive(self: ptr GestureSingle00; exclusive: gboolean) {.
    importc, libprag.}

proc setExclusive*(self: GestureSingle; exclusive: bool = true) =
  gtk_gesture_single_set_exclusive(cast[ptr GestureSingle00](self.impl), gboolean(exclusive))

proc `exclusive=`*(self: GestureSingle; exclusive: bool) =
  gtk_gesture_single_set_exclusive(cast[ptr GestureSingle00](self.impl), gboolean(exclusive))

proc gtk_gesture_single_set_touch_only(self: ptr GestureSingle00; touchOnly: gboolean) {.
    importc, libprag.}

proc setTouchOnly*(self: GestureSingle; touchOnly: bool = true) =
  gtk_gesture_single_set_touch_only(cast[ptr GestureSingle00](self.impl), gboolean(touchOnly))

proc `touchOnly=`*(self: GestureSingle; touchOnly: bool) =
  gtk_gesture_single_set_touch_only(cast[ptr GestureSingle00](self.impl), gboolean(touchOnly))

type
  GestureDrag* = ref object of GestureSingle
  GestureDrag00* = object of GestureSingle00

proc gtk_gesture_drag_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureDrag()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDragBegin*(self: GestureDrag;  p: proc (self: ptr GestureDrag00; startX: cdouble; startY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-begin", cast[GCallback](p), xdata, nil, cf)

proc scDragEnd*(self: GestureDrag;  p: proc (self: ptr GestureDrag00; offsetX: cdouble; offsetY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-end", cast[GCallback](p), xdata, nil, cf)

proc scDragUpdate*(self: GestureDrag;  p: proc (self: ptr GestureDrag00; offsetX: cdouble; offsetY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "drag-update", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_drag_new(widget: ptr Widget00): ptr GestureDrag00 {.
    importc, libprag.}

proc newGestureDrag*(widget: Widget): GestureDrag =
  let gobj = gtk_gesture_drag_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureDrag*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is GestureDrag)
  let gobj = gtk_gesture_drag_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureDrag*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is GestureDrag)
  let gobj = gtk_gesture_drag_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_drag_get_offset(self: ptr GestureDrag00; x: var cdouble;
    y: var cdouble): gboolean {.
    importc, libprag.}

proc getOffset*(self: GestureDrag; x: var cdouble; y: var cdouble): bool =
  toBool(gtk_gesture_drag_get_offset(cast[ptr GestureDrag00](self.impl), x, y))

proc gtk_gesture_drag_get_start_point(self: ptr GestureDrag00; x: var cdouble;
    y: var cdouble): gboolean {.
    importc, libprag.}

proc getStartPoint*(self: GestureDrag; x: var cdouble;
    y: var cdouble): bool =
  toBool(gtk_gesture_drag_get_start_point(cast[ptr GestureDrag00](self.impl), x, y))

type
  GestureLongPress* = ref object of GestureSingle
  GestureLongPress00* = object of GestureSingle00

proc gtk_gesture_long_press_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureLongPress()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scCancelled*(self: GestureLongPress;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "cancelled", cast[GCallback](p), xdata, nil, cf)

proc scPressed*(self: GestureLongPress;  p: proc (self: ptr GestureLongPress00; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_long_press_new(widget: ptr Widget00): ptr GestureLongPress00 {.
    importc, libprag.}

proc newGestureLongPress*(widget: Widget): GestureLongPress =
  let gobj = gtk_gesture_long_press_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureLongPress*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is GestureLongPress)
  let gobj = gtk_gesture_long_press_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureLongPress*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is GestureLongPress)
  let gobj = gtk_gesture_long_press_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  GestureMultiPress* = ref object of GestureSingle
  GestureMultiPress00* = object of GestureSingle00

proc gtk_gesture_multi_press_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureMultiPress()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scPressed*(self: GestureMultiPress;  p: proc (self: ptr GestureMultiPress00; nPress: int32; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pressed", cast[GCallback](p), xdata, nil, cf)

proc scReleased*(self: GestureMultiPress;  p: proc (self: ptr GestureMultiPress00; nPress: int32; x: cdouble; y: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "released", cast[GCallback](p), xdata, nil, cf)

proc scStopped*(self: GestureMultiPress;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "stopped", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_multi_press_new(widget: ptr Widget00): ptr GestureMultiPress00 {.
    importc, libprag.}

proc newGestureMultiPress*(widget: Widget): GestureMultiPress =
  let gobj = gtk_gesture_multi_press_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureMultiPress*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is GestureMultiPress)
  let gobj = gtk_gesture_multi_press_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureMultiPress*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is GestureMultiPress)
  let gobj = gtk_gesture_multi_press_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_multi_press_get_area(self: ptr GestureMultiPress00; rect: var gdk.Rectangle): gboolean {.
    importc, libprag.}

proc getArea*(self: GestureMultiPress; rect: var gdk.Rectangle): bool =
  toBool(gtk_gesture_multi_press_get_area(cast[ptr GestureMultiPress00](self.impl), rect))

proc gtk_gesture_multi_press_set_area(self: ptr GestureMultiPress00; rect: gdk.Rectangle) {.
    importc, libprag.}

proc setArea*(self: GestureMultiPress; rect: gdk.Rectangle = cast[var gdk.Rectangle](nil)) =
  gtk_gesture_multi_press_set_area(cast[ptr GestureMultiPress00](self.impl), rect)

proc `area=`*(self: GestureMultiPress; rect: gdk.Rectangle = cast[var gdk.Rectangle](nil)) =
  gtk_gesture_multi_press_set_area(cast[ptr GestureMultiPress00](self.impl), rect)

type
  PanDirection* {.size: sizeof(cint), pure.} = enum
    left = 0
    right = 1
    up = 2
    down = 3

type
  GesturePan* = ref object of GestureDrag
  GesturePan00* = object of GestureDrag00

proc gtk_gesture_pan_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GesturePan()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scPan*(self: GesturePan;  p: proc (self: ptr GesturePan00; direction: PanDirection; offset: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "pan", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_pan_new(widget: ptr Widget00; orientation: Orientation): ptr GesturePan00 {.
    importc, libprag.}

proc newGesturePan*(widget: Widget; orientation: Orientation): GesturePan =
  let gobj = gtk_gesture_pan_new(cast[ptr Widget00](widget.impl), orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGesturePan*(tdesc: typedesc; widget: Widget; orientation: Orientation): tdesc =
  assert(result is GesturePan)
  let gobj = gtk_gesture_pan_new(cast[ptr Widget00](widget.impl), orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGesturePan*[T](result: var T; widget: Widget; orientation: Orientation) {.deprecated.} =
  assert(result is GesturePan)
  let gobj = gtk_gesture_pan_new(cast[ptr Widget00](widget.impl), orientation)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_pan_get_orientation(self: ptr GesturePan00): Orientation {.
    importc, libprag.}

proc getOrientation*(self: GesturePan): Orientation =
  gtk_gesture_pan_get_orientation(cast[ptr GesturePan00](self.impl))

proc orientation*(self: GesturePan): Orientation =
  gtk_gesture_pan_get_orientation(cast[ptr GesturePan00](self.impl))

proc gtk_gesture_pan_set_orientation(self: ptr GesturePan00; orientation: Orientation) {.
    importc, libprag.}

proc setOrientation*(self: GesturePan; orientation: Orientation) =
  gtk_gesture_pan_set_orientation(cast[ptr GesturePan00](self.impl), orientation)

proc `orientation=`*(self: GesturePan; orientation: Orientation) =
  gtk_gesture_pan_set_orientation(cast[ptr GesturePan00](self.impl), orientation)

type
  GestureRotate* = ref object of Gesture
  GestureRotate00* = object of Gesture00

proc gtk_gesture_rotate_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureRotate()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scAngleChanged*(self: GestureRotate;  p: proc (self: ptr GestureRotate00; angle: cdouble; angleDelta: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "angle-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_rotate_new(widget: ptr Widget00): ptr GestureRotate00 {.
    importc, libprag.}

proc newGestureRotate*(widget: Widget): GestureRotate =
  let gobj = gtk_gesture_rotate_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureRotate*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is GestureRotate)
  let gobj = gtk_gesture_rotate_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureRotate*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is GestureRotate)
  let gobj = gtk_gesture_rotate_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_rotate_get_angle_delta(self: ptr GestureRotate00): cdouble {.
    importc, libprag.}

proc getAngleDelta*(self: GestureRotate): cdouble =
  gtk_gesture_rotate_get_angle_delta(cast[ptr GestureRotate00](self.impl))

proc angleDelta*(self: GestureRotate): cdouble =
  gtk_gesture_rotate_get_angle_delta(cast[ptr GestureRotate00](self.impl))

type
  GestureStylus* = ref object of GestureSingle
  GestureStylus00* = object of GestureSingle00

proc gtk_gesture_stylus_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureStylus()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scDown*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; `object`: cdouble; p0: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "down", cast[GCallback](p), xdata, nil, cf)

proc scMotion*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; `object`: cdouble; p0: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "motion", cast[GCallback](p), xdata, nil, cf)

proc scProximity*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; `object`: cdouble; p0: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "proximity", cast[GCallback](p), xdata, nil, cf)

proc scUp*(self: GestureStylus;  p: proc (self: ptr GestureStylus00; `object`: cdouble; p0: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "up", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_stylus_new(widget: ptr Widget00): ptr GestureStylus00 {.
    importc, libprag.}

proc newGestureStylus*(widget: Widget): GestureStylus =
  let gobj = gtk_gesture_stylus_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureStylus*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is GestureStylus)
  let gobj = gtk_gesture_stylus_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureStylus*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is GestureStylus)
  let gobj = gtk_gesture_stylus_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_stylus_get_axes(self: ptr GestureStylus00; axes: ptr gdk.AxisUse;
    values: var ptr cdouble): gboolean {.
    importc, libprag.}

proc getAxes*(self: GestureStylus; axes: ptr gdk.AxisUse;
    values: var ptr cdouble): bool =
  toBool(gtk_gesture_stylus_get_axes(cast[ptr GestureStylus00](self.impl), axes, values))

proc gtk_gesture_stylus_get_axis(self: ptr GestureStylus00; axis: gdk.AxisUse;
    value: var cdouble): gboolean {.
    importc, libprag.}

proc getAxis*(self: GestureStylus; axis: gdk.AxisUse;
    value: var cdouble): bool =
  toBool(gtk_gesture_stylus_get_axis(cast[ptr GestureStylus00](self.impl), axis, value))

proc gtk_gesture_stylus_get_device_tool(self: ptr GestureStylus00): ptr gdk.DeviceTool00 {.
    importc, libprag.}

proc getDeviceTool*(self: GestureStylus): gdk.DeviceTool =
  let gobj = gtk_gesture_stylus_get_device_tool(cast[ptr GestureStylus00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc deviceTool*(self: GestureStylus): gdk.DeviceTool =
  let gobj = gtk_gesture_stylus_get_device_tool(cast[ptr GestureStylus00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  GestureSwipe* = ref object of GestureSingle
  GestureSwipe00* = object of GestureSingle00

proc gtk_gesture_swipe_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureSwipe()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scSwipe*(self: GestureSwipe;  p: proc (self: ptr GestureSwipe00; velocityX: cdouble; velocityY: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "swipe", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_swipe_new(widget: ptr Widget00): ptr GestureSwipe00 {.
    importc, libprag.}

proc newGestureSwipe*(widget: Widget): GestureSwipe =
  let gobj = gtk_gesture_swipe_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureSwipe*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is GestureSwipe)
  let gobj = gtk_gesture_swipe_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureSwipe*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is GestureSwipe)
  let gobj = gtk_gesture_swipe_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_swipe_get_velocity(self: ptr GestureSwipe00; velocityX: var cdouble;
    velocityY: var cdouble): gboolean {.
    importc, libprag.}

proc getVelocity*(self: GestureSwipe; velocityX: var cdouble;
    velocityY: var cdouble): bool =
  toBool(gtk_gesture_swipe_get_velocity(cast[ptr GestureSwipe00](self.impl), velocityX, velocityY))

type
  GestureZoom* = ref object of Gesture
  GestureZoom00* = object of Gesture00

proc gtk_gesture_zoom_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(GestureZoom()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scScaleChanged*(self: GestureZoom;  p: proc (self: ptr GestureZoom00; scale: cdouble; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scale-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_gesture_zoom_new(widget: ptr Widget00): ptr GestureZoom00 {.
    importc, libprag.}

proc newGestureZoom*(widget: Widget): GestureZoom =
  let gobj = gtk_gesture_zoom_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newGestureZoom*(tdesc: typedesc; widget: Widget): tdesc =
  assert(result is GestureZoom)
  let gobj = gtk_gesture_zoom_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initGestureZoom*[T](result: var T; widget: Widget) {.deprecated.} =
  assert(result is GestureZoom)
  let gobj = gtk_gesture_zoom_new(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_gesture_zoom_get_scale_delta(self: ptr GestureZoom00): cdouble {.
    importc, libprag.}

proc getScaleDelta*(self: GestureZoom): cdouble =
  gtk_gesture_zoom_get_scale_delta(cast[ptr GestureZoom00](self.impl))

proc scaleDelta*(self: GestureZoom): cdouble =
  gtk_gesture_zoom_get_scale_delta(cast[ptr GestureZoom00](self.impl))

type
  Gradient00* {.pure.} = object
  Gradient* = ref object
    impl*: ptr Gradient00
    ignoreFinalizer*: bool

proc gtk_gradient_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkGradient*(self: Gradient) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_gradient_get_type(), cast[ptr Gradient00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(Gradient()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_gradient_get_type(), cast[ptr Gradient00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var Gradient) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkGradient)

proc gtk_gradient_unref(self: ptr Gradient00) {.
    importc, libprag.}

proc unref*(self: Gradient) =
  gtk_gradient_unref(cast[ptr Gradient00](self.impl))

proc finalizerunref*(self: Gradient) =
  if not self.ignoreFinalizer:
    gtk_gradient_unref(cast[ptr Gradient00](self.impl))

proc gtk_gradient_new_radial(x0: cdouble; y0: cdouble; radius0: cdouble;
    x1: cdouble; y1: cdouble; radius1: cdouble): ptr Gradient00 {.
    importc, libprag.}

proc newGradientRadial*(x0: cdouble; y0: cdouble; radius0: cdouble;
    x1: cdouble; y1: cdouble; radius1: cdouble): Gradient {.deprecated.}  =
  fnew(result, gBoxedFreeGtkGradient)
  result.impl = gtk_gradient_new_radial(x0, y0, radius0, x1, y1, radius1)

proc newGradientRadial*(tdesc: typedesc; x0: cdouble; y0: cdouble; radius0: cdouble;
    x1: cdouble; y1: cdouble; radius1: cdouble): tdesc {.deprecated.}  =
  assert(result is Gradient)
  fnew(result, gBoxedFreeGtkGradient)
  result.impl = gtk_gradient_new_radial(x0, y0, radius0, x1, y1, radius1)

proc initGradientRadial*[T](result: var T; x0: cdouble; y0: cdouble; radius0: cdouble;
    x1: cdouble; y1: cdouble; radius1: cdouble) {.deprecated.} =
  assert(result is Gradient)
  fnew(result, gBoxedFreeGtkGradient)
  result.impl = gtk_gradient_new_radial(x0, y0, radius0, x1, y1, radius1)

proc gtk_gradient_add_color_stop(self: ptr Gradient00; offset: cdouble; color: ptr SymbolicColor00) {.
    importc, libprag.}

proc addColorStop*(self: Gradient; offset: cdouble; color: SymbolicColor) =
  gtk_gradient_add_color_stop(cast[ptr Gradient00](self.impl), offset, cast[ptr SymbolicColor00](color.impl))

proc gtk_gradient_ref(self: ptr Gradient00): ptr Gradient00 {.
    importc, libprag.}

proc `ref`*(self: Gradient): Gradient =
  fnew(result, gBoxedFreeGtkGradient)
  result.impl = gtk_gradient_ref(cast[ptr Gradient00](self.impl))

proc gtk_gradient_resolve(self: ptr Gradient00; props: ptr StyleProperties00;
    resolvedGradient: var ptr cairo.Pattern00): gboolean {.
    importc, libprag.}

proc resolve*(self: Gradient; props: StyleProperties; resolvedGradient: var cairo.Pattern): bool =
  fnew(resolvedGradient, gBoxedFreeCairoPattern)
  toBool(gtk_gradient_resolve(cast[ptr Gradient00](self.impl), cast[ptr StyleProperties00](props.impl), cast[var ptr cairo.Pattern00](addr resolvedGradient.impl)))

proc gtk_gradient_resolve_for_context(self: ptr Gradient00; context: ptr StyleContext00): ptr cairo.Pattern00 {.
    importc, libprag.}

proc resolveForContext*(self: Gradient; context: StyleContext): cairo.Pattern =
  fnew(result, gBoxedFreeCairoPattern)
  result.impl = gtk_gradient_resolve_for_context(cast[ptr Gradient00](self.impl), cast[ptr StyleContext00](context.impl))

proc gtk_gradient_to_string(self: ptr Gradient00): cstring {.
    importc, libprag.}

proc toString*(self: Gradient): string =
  let resul0 = gtk_gradient_to_string(cast[ptr Gradient00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_gradient_new_linear(x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble): ptr Gradient00 {.
    importc, libprag.}

proc newGradientLinear*(x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble): Gradient {.deprecated.}  =
  fnew(result, gBoxedFreeGtkGradient)
  result.impl = gtk_gradient_new_linear(x0, y0, x1, y1)

proc newGradientLinear*(tdesc: typedesc; x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble): tdesc {.deprecated.}  =
  assert(result is Gradient)
  fnew(result, gBoxedFreeGtkGradient)
  result.impl = gtk_gradient_new_linear(x0, y0, x1, y1)

proc initGradientLinear*[T](result: var T; x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble) {.deprecated.} =
  assert(result is Gradient)
  fnew(result, gBoxedFreeGtkGradient)
  result.impl = gtk_gradient_new_linear(x0, y0, x1, y1)

type
  HeaderBarAccessible* = ref object of ContainerAccessible
  HeaderBarAccessible00* = object of ContainerAccessible00

proc gtk_header_bar_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(HeaderBarAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  IMContextInfo* {.pure, byRef.} = object
    contextId*: cstring
    contextName*: cstring
    domain*: cstring
    domainDirname*: cstring
    defaultLocales*: cstring

type
  IMContextSimple* = ref object of IMContext
  IMContextSimple00* = object of IMContext00

proc gtk_im_context_simple_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IMContextSimple()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_im_context_simple_new(): ptr IMContextSimple00 {.
    importc, libprag.}

proc newIMContextSimple*(): IMContextSimple =
  let gobj = gtk_im_context_simple_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIMContextSimple*(tdesc: typedesc): tdesc =
  assert(result is IMContextSimple)
  let gobj = gtk_im_context_simple_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIMContextSimple*[T](result: var T) {.deprecated.} =
  assert(result is IMContextSimple)
  let gobj = gtk_im_context_simple_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_im_context_simple_add_compose_file(self: ptr IMContextSimple00;
    composeFile: cstring) {.
    importc, libprag.}

proc addComposeFile*(self: IMContextSimple; composeFile: cstring) =
  gtk_im_context_simple_add_compose_file(cast[ptr IMContextSimple00](self.impl), composeFile)

type
  IMMulticontext* = ref object of IMContext
  IMMulticontext00* = object of IMContext00

proc gtk_im_multicontext_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IMMulticontext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_im_multicontext_new(): ptr IMMulticontext00 {.
    importc, libprag.}

proc newIMMulticontext*(): IMMulticontext =
  let gobj = gtk_im_multicontext_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIMMulticontext*(tdesc: typedesc): tdesc =
  assert(result is IMMulticontext)
  let gobj = gtk_im_multicontext_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIMMulticontext*[T](result: var T) {.deprecated.} =
  assert(result is IMMulticontext)
  let gobj = gtk_im_multicontext_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_im_multicontext_append_menuitems(self: ptr IMMulticontext00; menushell: ptr MenuShell00) {.
    importc, libprag.}

proc appendMenuitems*(self: IMMulticontext; menushell: MenuShell) =
  gtk_im_multicontext_append_menuitems(cast[ptr IMMulticontext00](self.impl), cast[ptr MenuShell00](menushell.impl))

proc gtk_im_multicontext_get_context_id(self: ptr IMMulticontext00): cstring {.
    importc, libprag.}

proc getContextId*(self: IMMulticontext): string =
  result = $gtk_im_multicontext_get_context_id(cast[ptr IMMulticontext00](self.impl))

proc contextId*(self: IMMulticontext): string =
  result = $gtk_im_multicontext_get_context_id(cast[ptr IMMulticontext00](self.impl))

proc gtk_im_multicontext_set_context_id(self: ptr IMMulticontext00; contextId: cstring) {.
    importc, libprag.}

proc setContextId*(self: IMMulticontext; contextId: cstring) =
  gtk_im_multicontext_set_context_id(cast[ptr IMMulticontext00](self.impl), contextId)

proc `contextId=`*(self: IMMulticontext; contextId: cstring) =
  gtk_im_multicontext_set_context_id(cast[ptr IMMulticontext00](self.impl), contextId)

type
  IMPreeditStyle* {.size: sizeof(cint), pure.} = enum
    nothing = 0
    callback = 1
    none = 2

type
  IMStatusStyle* {.size: sizeof(cint), pure.} = enum
    nothing = 0
    callback = 1
    none = 2

const INPUT_ERROR* = -1'i32

const INTERFACE_AGE* = 20'i32

type
  IconInfo* = ref object of gobject.Object
  IconInfo00* = object of gobject.Object00

proc gtk_icon_info_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconInfo()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_icon_info_get_attach_points(self: ptr IconInfo00; points: var ptr gdk.Point;
    nPoints: var int32): gboolean {.
    importc, libprag.}

proc getAttachPoints*(self: IconInfo; points: var ptr gdk.Point = cast[var ptr gdk.Point](nil);
    nPoints: var int = cast[var int](nil)): bool =
  var nPoints_00: int32
  result = toBool(gtk_icon_info_get_attach_points(cast[ptr IconInfo00](self.impl), points, nPoints_00))
  if nPoints.addr != nil:
    nPoints = int(nPoints_00)

proc gtk_icon_info_get_base_scale(self: ptr IconInfo00): int32 {.
    importc, libprag.}

proc getBaseScale*(self: IconInfo): int =
  int(gtk_icon_info_get_base_scale(cast[ptr IconInfo00](self.impl)))

proc baseScale*(self: IconInfo): int =
  int(gtk_icon_info_get_base_scale(cast[ptr IconInfo00](self.impl)))

proc gtk_icon_info_get_base_size(self: ptr IconInfo00): int32 {.
    importc, libprag.}

proc getBaseSize*(self: IconInfo): int =
  int(gtk_icon_info_get_base_size(cast[ptr IconInfo00](self.impl)))

proc baseSize*(self: IconInfo): int =
  int(gtk_icon_info_get_base_size(cast[ptr IconInfo00](self.impl)))

proc gtk_icon_info_get_builtin_pixbuf(self: ptr IconInfo00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getBuiltinPixbuf*(self: IconInfo): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_info_get_builtin_pixbuf(cast[ptr IconInfo00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc builtinPixbuf*(self: IconInfo): gdkpixbuf.Pixbuf =
  let gobj = gtk_icon_info_get_builtin_pixbuf(cast[ptr IconInfo00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_info_get_display_name(self: ptr IconInfo00): cstring {.
    importc, libprag.}

proc getDisplayName*(self: IconInfo): string =
  result = $gtk_icon_info_get_display_name(cast[ptr IconInfo00](self.impl))

proc displayName*(self: IconInfo): string =
  result = $gtk_icon_info_get_display_name(cast[ptr IconInfo00](self.impl))

proc gtk_icon_info_get_embedded_rect(self: ptr IconInfo00; rectangle: var gdk.Rectangle): gboolean {.
    importc, libprag.}

proc getEmbeddedRect*(self: IconInfo; rectangle: var gdk.Rectangle): bool =
  toBool(gtk_icon_info_get_embedded_rect(cast[ptr IconInfo00](self.impl), rectangle))

proc gtk_icon_info_get_filename(self: ptr IconInfo00): cstring {.
    importc, libprag.}

proc getFilename*(self: IconInfo): string =
  let resul0 = gtk_icon_info_get_filename(cast[ptr IconInfo00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc filename*(self: IconInfo): string =
  let resul0 = gtk_icon_info_get_filename(cast[ptr IconInfo00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_icon_info_is_symbolic(self: ptr IconInfo00): gboolean {.
    importc, libprag.}

proc isSymbolic*(self: IconInfo): bool =
  toBool(gtk_icon_info_is_symbolic(cast[ptr IconInfo00](self.impl)))

proc gtk_icon_info_load_icon(self: ptr IconInfo00; error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadIcon*(self: IconInfo): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  let gobj = gtk_icon_info_load_icon(cast[ptr IconInfo00](self.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_info_load_icon_async(self: ptr IconInfo00; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc loadIconAsync*(self: IconInfo; cancellable: gio.Cancellable = nil;
    callback: AsyncReadyCallback; userData: pointer) =
  gtk_icon_info_load_icon_async(cast[ptr IconInfo00](self.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_icon_info_load_icon_finish(self: ptr IconInfo00; res: ptr gio.AsyncResult00;
    error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadIconFinish*(self: IconInfo; res: gio.AsyncResult): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  let gobj = gtk_icon_info_load_icon_finish(cast[ptr IconInfo00](self.impl), cast[ptr gio.AsyncResult00](res.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_info_load_surface(self: ptr IconInfo00; forWindow: ptr gdk.Window00;
    error: ptr ptr glib.Error = nil): ptr cairo.Surface00 {.
    importc, libprag.}

proc loadSurface*(self: IconInfo; forWindow: gdk.Window = nil): cairo.Surface =
  var gerror: ptr glib.Error
  let impl0 = gtk_icon_info_load_surface(cast[ptr IconInfo00](self.impl), if forWindow.isNil: nil else: cast[ptr gdk.Window00](forWindow.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = impl0

proc gtk_icon_info_load_symbolic(self: ptr IconInfo00; fg: gdk.RGBA; successColor: gdk.RGBA;
    warningColor: gdk.RGBA; errorColor: gdk.RGBA; wasSymbolic: var gboolean;
    error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadSymbolic*(self: IconInfo; fg: gdk.RGBA; successColor: gdk.RGBA = cast[var gdk.RGBA](nil);
    warningColor: gdk.RGBA = cast[var gdk.RGBA](nil); errorColor: gdk.RGBA = cast[var gdk.RGBA](nil);
    wasSymbolic: var bool = cast[var bool](nil)): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  var wasSymbolic_00: gboolean
  let gobj = gtk_icon_info_load_symbolic(cast[ptr IconInfo00](self.impl), fg, successColor, warningColor, errorColor, wasSymbolic_00, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  if wasSymbolic.addr != nil:
    wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_async(self: ptr IconInfo00; fg: gdk.RGBA;
    successColor: gdk.RGBA; warningColor: gdk.RGBA; errorColor: gdk.RGBA; cancellable: ptr gio.Cancellable00;
    callback: AsyncReadyCallback; userData: pointer) {.
    importc, libprag.}

proc loadSymbolicAsync*(self: IconInfo; fg: gdk.RGBA; successColor: gdk.RGBA = cast[var gdk.RGBA](nil);
    warningColor: gdk.RGBA = cast[var gdk.RGBA](nil); errorColor: gdk.RGBA = cast[var gdk.RGBA](nil);
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_icon_info_load_symbolic_async(cast[ptr IconInfo00](self.impl), fg, successColor, warningColor, errorColor, if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_icon_info_load_symbolic_finish(self: ptr IconInfo00; res: ptr gio.AsyncResult00;
    wasSymbolic: var gboolean; error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadSymbolicFinish*(self: IconInfo; res: gio.AsyncResult;
    wasSymbolic: var bool = cast[var bool](nil)): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  var wasSymbolic_00: gboolean
  let gobj = gtk_icon_info_load_symbolic_finish(cast[ptr IconInfo00](self.impl), cast[ptr gio.AsyncResult00](res.impl), wasSymbolic_00, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  if wasSymbolic.addr != nil:
    wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_for_context(self: ptr IconInfo00; context: ptr StyleContext00;
    wasSymbolic: var gboolean; error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadSymbolicForContext*(self: IconInfo; context: StyleContext;
    wasSymbolic: var bool = cast[var bool](nil)): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  var wasSymbolic_00: gboolean
  let gobj = gtk_icon_info_load_symbolic_for_context(cast[ptr IconInfo00](self.impl), cast[ptr StyleContext00](context.impl), wasSymbolic_00, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  if wasSymbolic.addr != nil:
    wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_for_context_async(self: ptr IconInfo00;
    context: ptr StyleContext00; cancellable: ptr gio.Cancellable00; callback: AsyncReadyCallback;
    userData: pointer) {.
    importc, libprag.}

proc loadSymbolicForContextAsync*(self: IconInfo; context: StyleContext;
    cancellable: gio.Cancellable = nil; callback: AsyncReadyCallback; userData: pointer) =
  gtk_icon_info_load_symbolic_for_context_async(cast[ptr IconInfo00](self.impl), cast[ptr StyleContext00](context.impl), if cancellable.isNil: nil else: cast[ptr gio.Cancellable00](cancellable.impl), callback, userData)

proc gtk_icon_info_load_symbolic_for_context_finish(self: ptr IconInfo00;
    res: ptr gio.AsyncResult00; wasSymbolic: var gboolean; error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadSymbolicForContextFinish*(self: IconInfo; res: gio.AsyncResult;
    wasSymbolic: var bool = cast[var bool](nil)): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  var wasSymbolic_00: gboolean
  let gobj = gtk_icon_info_load_symbolic_for_context_finish(cast[ptr IconInfo00](self.impl), cast[ptr gio.AsyncResult00](res.impl), wasSymbolic_00, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  if wasSymbolic.addr != nil:
    wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_load_symbolic_for_style(self: ptr IconInfo00; style: ptr Style00;
    state: StateType; wasSymbolic: var gboolean; error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadSymbolicForStyle*(self: IconInfo; style: Style;
    state: StateType; wasSymbolic: var bool = cast[var bool](nil)): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  var wasSymbolic_00: gboolean
  let gobj = gtk_icon_info_load_symbolic_for_style(cast[ptr IconInfo00](self.impl), cast[ptr Style00](style.impl), state, wasSymbolic_00, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  if wasSymbolic.addr != nil:
    wasSymbolic = toBool(wasSymbolic_00)

proc gtk_icon_info_set_raw_coordinates(self: ptr IconInfo00; rawCoordinates: gboolean) {.
    importc, libprag.}

proc setRawCoordinates*(self: IconInfo; rawCoordinates: bool = true) =
  gtk_icon_info_set_raw_coordinates(cast[ptr IconInfo00](self.impl), gboolean(rawCoordinates))

proc `rawCoordinates=`*(self: IconInfo; rawCoordinates: bool) =
  gtk_icon_info_set_raw_coordinates(cast[ptr IconInfo00](self.impl), gboolean(rawCoordinates))

type
  IconTheme* = ref object of gobject.Object
  IconTheme00* = object of gobject.Object00

proc gtk_icon_theme_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconTheme()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scChanged*(self: IconTheme;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_icon_theme_new(): ptr IconTheme00 {.
    importc, libprag.}

proc newIconTheme*(): IconTheme =
  let gobj = gtk_icon_theme_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconTheme*(tdesc: typedesc): tdesc =
  assert(result is IconTheme)
  let gobj = gtk_icon_theme_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconTheme*[T](result: var T) {.deprecated.} =
  assert(result is IconTheme)
  let gobj = gtk_icon_theme_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_add_builtin_icon(iconName: cstring; size: int32; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc addBuiltinIcon*(iconName: cstring; size: int; pixbuf: gdkpixbuf.Pixbuf) =
  gtk_icon_theme_add_builtin_icon(iconName, int32(size), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_icon_theme_get_default(): ptr IconTheme00 {.
    importc, libprag.}

proc getDefaultIconTheme*(): IconTheme =
  let gobj = gtk_icon_theme_get_default()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_get_for_screen(screen: ptr gdk.Screen00): ptr IconTheme00 {.
    importc, libprag.}

proc getIconThemeForScreen*(screen: gdk.Screen): IconTheme =
  let gobj = gtk_icon_theme_get_for_screen(cast[ptr gdk.Screen00](screen.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_add_resource_path(self: ptr IconTheme00; path: cstring) {.
    importc, libprag.}

proc addResourcePath*(self: IconTheme; path: cstring) =
  gtk_icon_theme_add_resource_path(cast[ptr IconTheme00](self.impl), path)

proc gtk_icon_theme_append_search_path(self: ptr IconTheme00; path: cstring) {.
    importc, libprag.}

proc appendSearchPath*(self: IconTheme; path: cstring) =
  gtk_icon_theme_append_search_path(cast[ptr IconTheme00](self.impl), path)

proc gtk_icon_theme_get_example_icon_name(self: ptr IconTheme00): cstring {.
    importc, libprag.}

proc getExampleIconName*(self: IconTheme): string =
  let resul0 = gtk_icon_theme_get_example_icon_name(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc exampleIconName*(self: IconTheme): string =
  let resul0 = gtk_icon_theme_get_example_icon_name(cast[ptr IconTheme00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_icon_theme_get_icon_sizes(self: ptr IconTheme00; iconName: cstring): ptr int32 {.
    importc, libprag.}

proc getIconSizes*(self: IconTheme; iconName: cstring): seq[int32] =
  let resul0 = gtk_icon_theme_get_icon_sizes(cast[ptr IconTheme00](self.impl), iconName)
  result = int32ArrayZT2seq(resul0)
  cogfree(resul0)

proc gtk_icon_theme_get_search_path(self: ptr IconTheme00; path: var ptr cstring;
    nElements: var int32) {.
    importc, libprag.}

proc getSearchPath*(self: IconTheme; path: var seq[string] = cast[var seq[string]](nil);
    nElements: var int) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var path_00 = seq2CstringArray(path, fs469n23)
  var nElements_00: int32
  gtk_icon_theme_get_search_path(cast[ptr IconTheme00](self.impl), path_00, nElements_00)
  if path.addr != nil:
    path = cstringArrayToSeq(path_00)
  if nElements.addr != nil:
    nElements = int(nElements_00)

proc gtk_icon_theme_has_icon(self: ptr IconTheme00; iconName: cstring): gboolean {.
    importc, libprag.}

proc hasIcon*(self: IconTheme; iconName: cstring): bool =
  toBool(gtk_icon_theme_has_icon(cast[ptr IconTheme00](self.impl), iconName))

proc gtk_icon_theme_list_contexts(self: ptr IconTheme00): ptr glib.List {.
    importc, libprag.}

proc listContexts*(self: IconTheme): seq[cstring] =
  let resul0 = gtk_icon_theme_list_contexts(cast[ptr IconTheme00](self.impl))
  g_list_free(resul0)

proc gtk_icon_theme_list_icons(self: ptr IconTheme00; context: cstring): ptr glib.List {.
    importc, libprag.}

proc listIcons*(self: IconTheme; context: cstring = nil): seq[cstring] =
  let resul0 = gtk_icon_theme_list_icons(cast[ptr IconTheme00](self.impl), context)
  g_list_free(resul0)

proc gtk_icon_theme_prepend_search_path(self: ptr IconTheme00; path: cstring) {.
    importc, libprag.}

proc prependSearchPath*(self: IconTheme; path: cstring) =
  gtk_icon_theme_prepend_search_path(cast[ptr IconTheme00](self.impl), path)

proc gtk_icon_theme_rescan_if_needed(self: ptr IconTheme00): gboolean {.
    importc, libprag.}

proc rescanIfNeeded*(self: IconTheme): bool =
  toBool(gtk_icon_theme_rescan_if_needed(cast[ptr IconTheme00](self.impl)))

proc gtk_icon_theme_set_custom_theme(self: ptr IconTheme00; themeName: cstring) {.
    importc, libprag.}

proc setCustomTheme*(self: IconTheme; themeName: cstring = nil) =
  gtk_icon_theme_set_custom_theme(cast[ptr IconTheme00](self.impl), themeName)

proc `customTheme=`*(self: IconTheme; themeName: cstring = nil) =
  gtk_icon_theme_set_custom_theme(cast[ptr IconTheme00](self.impl), themeName)

proc gtk_icon_theme_set_screen(self: ptr IconTheme00; screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc setScreen*(self: IconTheme; screen: gdk.Screen) =
  gtk_icon_theme_set_screen(cast[ptr IconTheme00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: IconTheme; screen: gdk.Screen) =
  gtk_icon_theme_set_screen(cast[ptr IconTheme00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_icon_theme_set_search_path(self: ptr IconTheme00; path: ptr cstring;
    nElements: int32) {.
    importc, libprag.}

proc setSearchPath*(self: IconTheme; path: openArray[string];
    nElements: int) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_icon_theme_set_search_path(cast[ptr IconTheme00](self.impl), seq2CstringArray(path, fs469n23), int32(nElements))

proc gtk_icon_info_new_for_pixbuf(iconTheme: ptr IconTheme00; pixbuf: ptr gdkpixbuf.Pixbuf00): ptr IconInfo00 {.
    importc, libprag.}

proc newIconInfoForPixbuf*(iconTheme: IconTheme; pixbuf: gdkpixbuf.Pixbuf): IconInfo =
  let gobj = gtk_icon_info_new_for_pixbuf(cast[ptr IconTheme00](iconTheme.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newIconInfoForPixbuf*(tdesc: typedesc; iconTheme: IconTheme; pixbuf: gdkpixbuf.Pixbuf): tdesc =
  assert(result is IconInfo)
  let gobj = gtk_icon_info_new_for_pixbuf(cast[ptr IconTheme00](iconTheme.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initIconInfoForPixbuf*[T](result: var T; iconTheme: IconTheme; pixbuf: gdkpixbuf.Pixbuf) {.deprecated.} =
  assert(result is IconInfo)
  let gobj = gtk_icon_info_new_for_pixbuf(cast[ptr IconTheme00](iconTheme.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  IconLookupFlag* {.size: sizeof(cint), pure.} = enum
    noSvg = 0
    forceSvg = 1
    useBuiltin = 2
    genericFallback = 3
    forceSize = 4
    forceRegular = 5
    forceSymbolic = 6
    dirLtr = 7
    dirRtl = 8

  IconLookupFlags* {.size: sizeof(cint).} = set[IconLookupFlag]

proc gtk_icon_theme_choose_icon(self: ptr IconTheme00; iconNames: ptr cstring;
    size: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc, libprag.}

proc chooseIcon*(self: IconTheme; iconNames: openArray[string];
    size: int; flags: IconLookupFlags): IconInfo =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  let gobj = gtk_icon_theme_choose_icon(cast[ptr IconTheme00](self.impl), seq2CstringArray(iconNames, fs469n23), int32(size), flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_choose_icon_for_scale(self: ptr IconTheme00; iconNames: ptr cstring;
    size: int32; scale: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc, libprag.}

proc chooseIconForScale*(self: IconTheme; iconNames: openArray[string];
    size: int; scale: int; flags: IconLookupFlags): IconInfo =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  let gobj = gtk_icon_theme_choose_icon_for_scale(cast[ptr IconTheme00](self.impl), seq2CstringArray(iconNames, fs469n23), int32(size), int32(scale), flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_load_icon(self: ptr IconTheme00; iconName: cstring; size: int32;
    flags: IconLookupFlags; error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadIcon*(self: IconTheme; iconName: cstring; size: int;
    flags: IconLookupFlags): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  let gobj = gtk_icon_theme_load_icon(cast[ptr IconTheme00](self.impl), iconName, int32(size), flags, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_load_icon_for_scale(self: ptr IconTheme00; iconName: cstring;
    size: int32; scale: int32; flags: IconLookupFlags; error: ptr ptr glib.Error = nil): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc loadIconForScale*(self: IconTheme; iconName: cstring;
    size: int; scale: int; flags: IconLookupFlags): gdkpixbuf.Pixbuf =
  var gerror: ptr glib.Error
  let gobj = gtk_icon_theme_load_icon_for_scale(cast[ptr IconTheme00](self.impl), iconName, int32(size), int32(scale), flags, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_load_surface(self: ptr IconTheme00; iconName: cstring;
    size: int32; scale: int32; forWindow: ptr gdk.Window00; flags: IconLookupFlags;
    error: ptr ptr glib.Error = nil): ptr cairo.Surface00 {.
    importc, libprag.}

proc loadSurface*(self: IconTheme; iconName: cstring; size: int;
    scale: int; forWindow: gdk.Window = nil; flags: IconLookupFlags): cairo.Surface =
  var gerror: ptr glib.Error
  let impl0 = gtk_icon_theme_load_surface(cast[ptr IconTheme00](self.impl), iconName, int32(size), int32(scale), if forWindow.isNil: nil else: cast[ptr gdk.Window00](forWindow.impl), flags, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeCairoSurface)
  result.impl = impl0

proc gtk_icon_theme_lookup_by_gicon(self: ptr IconTheme00; icon: ptr gio.Icon00;
    size: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc, libprag.}

proc lookupByGicon*(self: IconTheme; icon: gio.Icon; size: int;
    flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_by_gicon(cast[ptr IconTheme00](self.impl), cast[ptr gio.Icon00](icon.impl), int32(size), flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_lookup_by_gicon_for_scale(self: ptr IconTheme00; icon: ptr gio.Icon00;
    size: int32; scale: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc, libprag.}

proc lookupByGiconForScale*(self: IconTheme; icon: gio.Icon;
    size: int; scale: int; flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_by_gicon_for_scale(cast[ptr IconTheme00](self.impl), cast[ptr gio.Icon00](icon.impl), int32(size), int32(scale), flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_lookup_icon(self: ptr IconTheme00; iconName: cstring;
    size: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc, libprag.}

proc lookupIcon*(self: IconTheme; iconName: cstring; size: int;
    flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_icon(cast[ptr IconTheme00](self.impl), iconName, int32(size), flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_icon_theme_lookup_icon_for_scale(self: ptr IconTheme00; iconName: cstring;
    size: int32; scale: int32; flags: IconLookupFlags): ptr IconInfo00 {.
    importc, libprag.}

proc lookupIconForScale*(self: IconTheme; iconName: cstring;
    size: int; scale: int; flags: IconLookupFlags): IconInfo =
  let gobj = gtk_icon_theme_lookup_icon_for_scale(cast[ptr IconTheme00](self.impl), iconName, int32(size), int32(scale), flags)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

type
  IconThemeError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    failed = 1

type
  IconViewAccessible* = ref object of ContainerAccessible
  IconViewAccessible00* = object of ContainerAccessible00

proc gtk_icon_view_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(IconViewAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  IconViewForeachFunc* = proc (iconView: ptr IconView00; path: ptr TreePath00; data: pointer) {.cdecl.}

proc gtk_icon_view_selected_foreach(self: ptr IconView00; `func`: IconViewForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: IconView; `func`: IconViewForeachFunc;
    data: pointer) =
  gtk_icon_view_selected_foreach(cast[ptr IconView00](self.impl), `func`, data)

type
  KeySnoopFunc* = proc (grabWidget: ptr Widget00; event: ptr gdk.EventKey00; funcData: pointer): int32 {.cdecl.}

const LEVEL_BAR_OFFSET_FULL* = "full"

const LEVEL_BAR_OFFSET_HIGH* = "high"

const LEVEL_BAR_OFFSET_LOW* = "low"

type
  LabelAccessible* = ref object of WidgetAccessible
  LabelAccessible00* = object of WidgetAccessible00

proc gtk_label_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LabelAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  LabelSelectionInfo00* {.pure.} = object
  LabelSelectionInfo* = ref object
    impl*: ptr LabelSelectionInfo00
    ignoreFinalizer*: bool

type
  LevelBarAccessible* = ref object of WidgetAccessible
  LevelBarAccessible00* = object of WidgetAccessible00

proc gtk_level_bar_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(LevelBarAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ListBoxAccessible* = ref object of ContainerAccessible
  ListBoxAccessible00* = object of ContainerAccessible00

proc gtk_list_box_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListBoxAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ListBoxCreateWidgetFunc* = proc (item: ptr gobject.Object00; userData: pointer): ptr Widget00 {.cdecl.}

proc gtk_list_box_bind_model(self: ptr ListBox00; model: ptr gio.ListModel00;
    createWidgetFunc: ListBoxCreateWidgetFunc; userData: pointer; userDataFreeFunc: DestroyNotify) {.
    importc, libprag.}

proc bindModel*(self: ListBox; model: gio.ListModel = nil; createWidgetFunc: ListBoxCreateWidgetFunc;
    userData: pointer; userDataFreeFunc: DestroyNotify) =
  gtk_list_box_bind_model(cast[ptr ListBox00](self.impl), if model.isNil: nil else: cast[ptr gio.ListModel00](model.impl), createWidgetFunc, userData, userDataFreeFunc)

type
  ListBoxFilterFunc* = proc (row: ptr ListBoxRow00; userData: pointer): gboolean {.cdecl.}

proc gtk_list_box_set_filter_func(self: ptr ListBox00; filterFunc: ListBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setFilterFunc*(self: ListBox; filterFunc: ListBoxFilterFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_list_box_set_filter_func(cast[ptr ListBox00](self.impl), filterFunc, userData, destroy)

type
  ListBoxForeachFunc* = proc (box: ptr ListBox00; row: ptr ListBoxRow00; userData: pointer) {.cdecl.}

proc gtk_list_box_selected_foreach(self: ptr ListBox00; `func`: ListBoxForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: ListBox; `func`: ListBoxForeachFunc;
    data: pointer) =
  gtk_list_box_selected_foreach(cast[ptr ListBox00](self.impl), `func`, data)

type
  ListBoxRowAccessible* = ref object of ContainerAccessible
  ListBoxRowAccessible00* = object of ContainerAccessible00

proc gtk_list_box_row_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ListBoxRowAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ListBoxSortFunc* = proc (row1: ptr ListBoxRow00; row2: ptr ListBoxRow00; userData: pointer): int32 {.cdecl.}

proc gtk_list_box_set_sort_func(self: ptr ListBox00; sortFunc: ListBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: ListBox; sortFunc: ListBoxSortFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_list_box_set_sort_func(cast[ptr ListBox00](self.impl), sortFunc, userData, destroy)

type
  ListBoxUpdateHeaderFunc* = proc (row: ptr ListBoxRow00; before: ptr ListBoxRow00; userData: pointer) {.cdecl.}

proc gtk_list_box_set_header_func(self: ptr ListBox00; updateHeader: ListBoxUpdateHeaderFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setHeaderFunc*(self: ListBox; updateHeader: ListBoxUpdateHeaderFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_list_box_set_header_func(cast[ptr ListBox00](self.impl), updateHeader, userData, destroy)

const MAJOR_VERSION* = 3'i32

const MAX_COMPOSE_LEN* = 7'i32

const MICRO_VERSION* = 24'i32

const MINOR_VERSION* = 24'i32

type
  MenuShellAccessible* = ref object of ContainerAccessible
  MenuShellAccessible00* = object of ContainerAccessible00

proc gtk_menu_shell_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuShellAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  MenuAccessible* = ref object of MenuShellAccessible
  MenuAccessible00* = object of MenuShellAccessible00

proc gtk_menu_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MenuAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  MenuDetachFunc* = proc (attachWidget: ptr Widget00; menu: ptr Menu00) {.cdecl.}

proc gtk_menu_attach_to_widget(self: ptr Menu00; attachWidget: ptr Widget00;
    detacher: MenuDetachFunc) {.
    importc, libprag.}

proc attachToWidget*(self: Menu; attachWidget: Widget; detacher: MenuDetachFunc) =
  gtk_menu_attach_to_widget(cast[ptr Menu00](self.impl), cast[ptr Widget00](attachWidget.impl), detacher)

type
  MenuPositionFunc* = proc (menu: ptr Menu00; x: var int32; y: var int32; pushIn: var gboolean;
    userData: pointer) {.cdecl.}

proc gtk_menu_popup(self: ptr Menu00; parentMenuShell: ptr Widget00; parentMenuItem: ptr Widget00;
    `func`: MenuPositionFunc; data: pointer; button: uint32; activateTime: uint32) {.
    importc, libprag.}

proc popup*(self: Menu; parentMenuShell: Widget = nil; parentMenuItem: Widget = nil;
    `func`: MenuPositionFunc; data: pointer; button: int; activateTime: int) =
  gtk_menu_popup(cast[ptr Menu00](self.impl), if parentMenuShell.isNil: nil else: cast[ptr Widget00](parentMenuShell.impl), if parentMenuItem.isNil: nil else: cast[ptr Widget00](parentMenuItem.impl), `func`, data, uint32(button), uint32(activateTime))

proc gtk_menu_popup_for_device(self: ptr Menu00; device: ptr gdk.Device00;
    parentMenuShell: ptr Widget00; parentMenuItem: ptr Widget00; `func`: MenuPositionFunc;
    data: pointer; destroy: DestroyNotify; button: uint32; activateTime: uint32) {.
    importc, libprag.}

proc popupForDevice*(self: Menu; device: gdk.Device = nil; parentMenuShell: Widget = nil;
    parentMenuItem: Widget = nil; `func`: MenuPositionFunc; data: pointer;
    destroy: DestroyNotify; button: int; activateTime: int) =
  gtk_menu_popup_for_device(cast[ptr Menu00](self.impl), if device.isNil: nil else: cast[ptr gdk.Device00](device.impl), if parentMenuShell.isNil: nil else: cast[ptr Widget00](parentMenuShell.impl), if parentMenuItem.isNil: nil else: cast[ptr Widget00](parentMenuItem.impl), `func`, data, destroy, uint32(button), uint32(activateTime))

type
  ModuleDisplayInitFunc* = proc (display: ptr gdk.Display00) {.cdecl.}

type
  ModuleInitFunc* = proc (argc: ptr int32; argv: ptr cstring) {.cdecl.}

type
  MountOperation* = ref object of gio.MountOperation
  MountOperation00* = object of gio.MountOperation00

proc gtk_mount_operation_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(MountOperation()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_mount_operation_new(parent: ptr Window00): ptr MountOperation00 {.
    importc, libprag.}

proc newMountOperation*(parent: Window = nil): MountOperation =
  let gobj = gtk_mount_operation_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newMountOperation*(tdesc: typedesc; parent: Window = nil): tdesc =
  assert(result is MountOperation)
  let gobj = gtk_mount_operation_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initMountOperation*[T](result: var T; parent: Window = nil) {.deprecated.} =
  assert(result is MountOperation)
  let gobj = gtk_mount_operation_new(if parent.isNil: nil else: cast[ptr Window00](parent.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_get_parent(self: ptr MountOperation00): ptr Window00 {.
    importc, libprag.}

proc getParent*(self: MountOperation): Window =
  let gobj = gtk_mount_operation_get_parent(cast[ptr MountOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc parent*(self: MountOperation): Window =
  let gobj = gtk_mount_operation_get_parent(cast[ptr MountOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_get_screen(self: ptr MountOperation00): ptr gdk.Screen00 {.
    importc, libprag.}

proc getScreen*(self: MountOperation): gdk.Screen =
  let gobj = gtk_mount_operation_get_screen(cast[ptr MountOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: MountOperation): gdk.Screen =
  let gobj = gtk_mount_operation_get_screen(cast[ptr MountOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_mount_operation_is_showing(self: ptr MountOperation00): gboolean {.
    importc, libprag.}

proc isShowing*(self: MountOperation): bool =
  toBool(gtk_mount_operation_is_showing(cast[ptr MountOperation00](self.impl)))

proc gtk_mount_operation_set_parent(self: ptr MountOperation00; parent: ptr Window00) {.
    importc, libprag.}

proc setParent*(self: MountOperation; parent: Window = nil) =
  gtk_mount_operation_set_parent(cast[ptr MountOperation00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc `parent=`*(self: MountOperation; parent: Window = nil) =
  gtk_mount_operation_set_parent(cast[ptr MountOperation00](self.impl), if parent.isNil: nil else: cast[ptr Window00](parent.impl))

proc gtk_mount_operation_set_screen(self: ptr MountOperation00; screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc setScreen*(self: MountOperation; screen: gdk.Screen) =
  gtk_mount_operation_set_screen(cast[ptr MountOperation00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: MountOperation; screen: gdk.Screen) =
  gtk_mount_operation_set_screen(cast[ptr MountOperation00](self.impl), cast[ptr gdk.Screen00](screen.impl))

type
  NotebookAccessible* = ref object of ContainerAccessible
  NotebookAccessible00* = object of ContainerAccessible00

proc gtk_notebook_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NotebookAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  NotebookPageAccessible* = ref object of atk.Object
  NotebookPageAccessible00* = object of atk.Object00

proc gtk_notebook_page_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NotebookPageAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_notebook_page_accessible_new(notebook: ptr NotebookAccessible00;
    child: ptr Widget00): ptr NotebookPageAccessible00 {.
    importc, libprag.}

proc newNotebookPageAccessible*(notebook: NotebookAccessible; child: Widget): NotebookPageAccessible =
  let gobj = gtk_notebook_page_accessible_new(cast[ptr NotebookAccessible00](notebook.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newNotebookPageAccessible*(tdesc: typedesc; notebook: NotebookAccessible; child: Widget): tdesc =
  assert(result is NotebookPageAccessible)
  let gobj = gtk_notebook_page_accessible_new(cast[ptr NotebookAccessible00](notebook.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initNotebookPageAccessible*[T](result: var T; notebook: NotebookAccessible; child: Widget) {.deprecated.} =
  assert(result is NotebookPageAccessible)
  let gobj = gtk_notebook_page_accessible_new(cast[ptr NotebookAccessible00](notebook.impl), cast[ptr Widget00](child.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_notebook_page_accessible_invalidate(self: ptr NotebookPageAccessible00) {.
    importc, libprag.}

proc invalidate*(self: NotebookPageAccessible) =
  gtk_notebook_page_accessible_invalidate(cast[ptr NotebookPageAccessible00](self.impl))

type
  NumberUpLayout* {.size: sizeof(cint), pure.} = enum
    lrtb = 0
    lrbt = 1
    rltb = 2
    rlbt = 3
    tblr = 4
    tbrl = 5
    btlr = 6
    btrl = 7

type
  NumerableIcon* = ref object of gio.EmblemedIcon
  NumerableIcon00* = object of gio.EmblemedIcon00

proc gtk_numerable_icon_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(NumerableIcon()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_numerable_icon_new(baseIcon: ptr gio.Icon00): ptr gio.Icon00 {.
    importc, libprag.}

proc newNumerableIcon*(baseIcon: gio.Icon): gio.Icon =
  let gobj = gtk_numerable_icon_new(cast[ptr gio.Icon00](baseIcon.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_numerable_icon_new_with_style_context(baseIcon: ptr gio.Icon00;
    context: ptr StyleContext00): ptr gio.Icon00 {.
    importc, libprag.}

proc newNumerableIconWithStyleContext*(baseIcon: gio.Icon; context: StyleContext): gio.Icon =
  let gobj = gtk_numerable_icon_new_with_style_context(cast[ptr gio.Icon00](baseIcon.impl), cast[ptr StyleContext00](context.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_numerable_icon_get_background_gicon(self: ptr NumerableIcon00): ptr gio.Icon00 {.
    importc, libprag.}

proc getBackgroundGicon*(self: NumerableIcon): gio.Icon =
  let gobj = gtk_numerable_icon_get_background_gicon(cast[ptr NumerableIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc backgroundGicon*(self: NumerableIcon): gio.Icon =
  let gobj = gtk_numerable_icon_get_background_gicon(cast[ptr NumerableIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_numerable_icon_get_background_icon_name(self: ptr NumerableIcon00): cstring {.
    importc, libprag.}

proc getBackgroundIconName*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_background_icon_name(cast[ptr NumerableIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc backgroundIconName*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_background_icon_name(cast[ptr NumerableIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_numerable_icon_get_count(self: ptr NumerableIcon00): int32 {.
    importc, libprag.}

proc getCount*(self: NumerableIcon): int =
  int(gtk_numerable_icon_get_count(cast[ptr NumerableIcon00](self.impl)))

proc count*(self: NumerableIcon): int =
  int(gtk_numerable_icon_get_count(cast[ptr NumerableIcon00](self.impl)))

proc gtk_numerable_icon_get_label(self: ptr NumerableIcon00): cstring {.
    importc, libprag.}

proc getLabel*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_label(cast[ptr NumerableIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc label*(self: NumerableIcon): string =
  let resul0 = gtk_numerable_icon_get_label(cast[ptr NumerableIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_numerable_icon_get_style_context(self: ptr NumerableIcon00): ptr StyleContext00 {.
    importc, libprag.}

proc getStyleContext*(self: NumerableIcon): StyleContext =
  let gobj = gtk_numerable_icon_get_style_context(cast[ptr NumerableIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc styleContext*(self: NumerableIcon): StyleContext =
  let gobj = gtk_numerable_icon_get_style_context(cast[ptr NumerableIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_numerable_icon_set_background_gicon(self: ptr NumerableIcon00; icon: ptr gio.Icon00) {.
    importc, libprag.}

proc setBackgroundGicon*(self: NumerableIcon; icon: gio.Icon = nil) =
  gtk_numerable_icon_set_background_gicon(cast[ptr NumerableIcon00](self.impl), if icon.isNil: nil else: cast[ptr gio.Icon00](icon.impl))

proc `backgroundGicon=`*(self: NumerableIcon; icon: gio.Icon = nil) =
  gtk_numerable_icon_set_background_gicon(cast[ptr NumerableIcon00](self.impl), if icon.isNil: nil else: cast[ptr gio.Icon00](icon.impl))

proc gtk_numerable_icon_set_background_icon_name(self: ptr NumerableIcon00;
    iconName: cstring) {.
    importc, libprag.}

proc setBackgroundIconName*(self: NumerableIcon; iconName: cstring = nil) =
  gtk_numerable_icon_set_background_icon_name(cast[ptr NumerableIcon00](self.impl), iconName)

proc `backgroundIconName=`*(self: NumerableIcon; iconName: cstring = nil) =
  gtk_numerable_icon_set_background_icon_name(cast[ptr NumerableIcon00](self.impl), iconName)

proc gtk_numerable_icon_set_count(self: ptr NumerableIcon00; count: int32) {.
    importc, libprag.}

proc setCount*(self: NumerableIcon; count: int) =
  gtk_numerable_icon_set_count(cast[ptr NumerableIcon00](self.impl), int32(count))

proc `count=`*(self: NumerableIcon; count: int) =
  gtk_numerable_icon_set_count(cast[ptr NumerableIcon00](self.impl), int32(count))

proc gtk_numerable_icon_set_label(self: ptr NumerableIcon00; label: cstring) {.
    importc, libprag.}

proc setLabel*(self: NumerableIcon; label: cstring = nil) =
  gtk_numerable_icon_set_label(cast[ptr NumerableIcon00](self.impl), label)

proc `label=`*(self: NumerableIcon; label: cstring = nil) =
  gtk_numerable_icon_set_label(cast[ptr NumerableIcon00](self.impl), label)

proc gtk_numerable_icon_set_style_context(self: ptr NumerableIcon00; style: ptr StyleContext00) {.
    importc, libprag.}

proc setStyleContext*(self: NumerableIcon; style: StyleContext) =
  gtk_numerable_icon_set_style_context(cast[ptr NumerableIcon00](self.impl), cast[ptr StyleContext00](style.impl))

proc `styleContext=`*(self: NumerableIcon; style: StyleContext) =
  gtk_numerable_icon_set_style_context(cast[ptr NumerableIcon00](self.impl), cast[ptr StyleContext00](style.impl))

type
  Orientable00* = object of gobject.Object00
  Orientable* = ref object of gobject.Object

proc gtk_orientable_get_orientation(self: ptr Orientable00): Orientation {.
    importc, libprag.}

proc getOrientation*(self: Orientable | Box | ShortcutLabel | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | HScale | Statusbar | ToolPalette | FileChooserButton | CellView | Toolbar | HScrollbar | SpinButton | ScaleButton | VScrollbar | CellRendererProgress | ShortcutsSection | ColorSelection | ButtonBox | VSeparator | StackSwitcher | HPaned | Separator | VButtonBox | FontSelection | HBox | Paned | CellAreaBox | RecentChooserWidget | Grid | ProgressBar | HSeparator | Scale | FileChooserWidget | Scrollbar | ColorChooserWidget | VScale | ShortcutsShortcut | AppChooserWidget | HButtonBox | VolumeButton | LevelBar | Range | InfoBar): Orientation =
  gtk_orientable_get_orientation(cast[ptr Orientable00](self.impl))

proc orientation*(self: Orientable | Box | ShortcutLabel | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | HScale | Statusbar | ToolPalette | FileChooserButton | CellView | Toolbar | HScrollbar | SpinButton | ScaleButton | VScrollbar | CellRendererProgress | ShortcutsSection | ColorSelection | ButtonBox | VSeparator | StackSwitcher | HPaned | Separator | VButtonBox | FontSelection | HBox | Paned | CellAreaBox | RecentChooserWidget | Grid | ProgressBar | HSeparator | Scale | FileChooserWidget | Scrollbar | ColorChooserWidget | VScale | ShortcutsShortcut | AppChooserWidget | HButtonBox | VolumeButton | LevelBar | Range | InfoBar): Orientation =
  gtk_orientable_get_orientation(cast[ptr Orientable00](self.impl))

proc gtk_orientable_set_orientation(self: ptr Orientable00; orientation: Orientation) {.
    importc, libprag.}

proc setOrientation*(self: Orientable | Box | ShortcutLabel | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | HScale | Statusbar | ToolPalette | FileChooserButton | CellView | Toolbar | HScrollbar | SpinButton | ScaleButton | VScrollbar | CellRendererProgress | ShortcutsSection | ColorSelection | ButtonBox | VSeparator | StackSwitcher | HPaned | Separator | VButtonBox | FontSelection | HBox | Paned | CellAreaBox | RecentChooserWidget | Grid | ProgressBar | HSeparator | Scale | FileChooserWidget | Scrollbar | ColorChooserWidget | VScale | ShortcutsShortcut | AppChooserWidget | HButtonBox | VolumeButton | LevelBar | Range | InfoBar;
    orientation: Orientation) =
  gtk_orientable_set_orientation(cast[ptr Orientable00](self.impl), orientation)

proc `orientation=`*(self: Orientable | Box | ShortcutLabel | ShortcutsGroup | FlowBox | VPaned | VBox | FontChooserWidget | HScale | Statusbar | ToolPalette | FileChooserButton | CellView | Toolbar | HScrollbar | SpinButton | ScaleButton | VScrollbar | CellRendererProgress | ShortcutsSection | ColorSelection | ButtonBox | VSeparator | StackSwitcher | HPaned | Separator | VButtonBox | FontSelection | HBox | Paned | CellAreaBox | RecentChooserWidget | Grid | ProgressBar | HSeparator | Scale | FileChooserWidget | Scrollbar | ColorChooserWidget | VScale | ShortcutsShortcut | AppChooserWidget | HButtonBox | VolumeButton | LevelBar | Range | InfoBar;
    orientation: Orientation) =
  gtk_orientable_set_orientation(cast[ptr Orientable00](self.impl), orientation)

const PAPER_NAME_A3* = "iso_a3"

const PAPER_NAME_A4* = "iso_a4"

const PAPER_NAME_A5* = "iso_a5"

const PAPER_NAME_B5* = "iso_b5"

const PAPER_NAME_EXECUTIVE* = "na_executive"

const PAPER_NAME_LEGAL* = "na_legal"

const PAPER_NAME_LETTER* = "na_letter"

const PATH_PRIO_MASK* = 15'i32

const PRINT_SETTINGS_COLLATE* = "collate"

const PRINT_SETTINGS_DEFAULT_SOURCE* = "default-source"

const PRINT_SETTINGS_DITHER* = "dither"

const PRINT_SETTINGS_DUPLEX* = "duplex"

const PRINT_SETTINGS_FINISHINGS* = "finishings"

const PRINT_SETTINGS_MEDIA_TYPE* = "media-type"

const PRINT_SETTINGS_NUMBER_UP* = "number-up"

const PRINT_SETTINGS_NUMBER_UP_LAYOUT* = "number-up-layout"

const PRINT_SETTINGS_N_COPIES* = "n-copies"

const PRINT_SETTINGS_ORIENTATION* = "orientation"

const PRINT_SETTINGS_OUTPUT_BASENAME* = "output-basename"

const PRINT_SETTINGS_OUTPUT_BIN* = "output-bin"

const PRINT_SETTINGS_OUTPUT_DIR* = "output-dir"

const PRINT_SETTINGS_OUTPUT_FILE_FORMAT* = "output-file-format"

const PRINT_SETTINGS_OUTPUT_URI* = "output-uri"

const PRINT_SETTINGS_PAGE_RANGES* = "page-ranges"

const PRINT_SETTINGS_PAGE_SET* = "page-set"

const PRINT_SETTINGS_PAPER_FORMAT* = "paper-format"

const PRINT_SETTINGS_PAPER_HEIGHT* = "paper-height"

const PRINT_SETTINGS_PAPER_WIDTH* = "paper-width"

const PRINT_SETTINGS_PRINTER* = "printer"

const PRINT_SETTINGS_PRINTER_LPI* = "printer-lpi"

const PRINT_SETTINGS_PRINT_PAGES* = "print-pages"

const PRINT_SETTINGS_QUALITY* = "quality"

const PRINT_SETTINGS_RESOLUTION* = "resolution"

const PRINT_SETTINGS_RESOLUTION_X* = "resolution-x"

const PRINT_SETTINGS_RESOLUTION_Y* = "resolution-y"

const PRINT_SETTINGS_REVERSE* = "reverse"

const PRINT_SETTINGS_SCALE* = "scale"

const PRINT_SETTINGS_USE_COLOR* = "use-color"

const PRINT_SETTINGS_WIN32_DRIVER_EXTRA* = "win32-driver-extra"

const PRINT_SETTINGS_WIN32_DRIVER_VERSION* = "win32-driver-version"

const PRIORITY_RESIZE* = 110'i32

type
  PadActionType* {.size: sizeof(cint), pure.} = enum
    button = 0
    ring = 1
    strip = 2

type
  PadActionEntry* {.pure, byRef.} = object
    `type`*: PadActionType
    index*: int32
    mode*: int32
    label*: cstring
    actionName*: cstring

type
  PadController* = ref object of EventController
  PadController00* = object of EventController00

proc gtk_pad_controller_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PadController()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_pad_controller_new(window: ptr Window00; group: ptr gio.ActionGroup00;
    pad: ptr gdk.Device00): ptr PadController00 {.
    importc, libprag.}

proc newPadController*(window: Window; group: gio.ActionGroup | gio.SimpleActionGroup;
    pad: gdk.Device = nil): PadController =
  let gobj = gtk_pad_controller_new(cast[ptr Window00](window.impl), cast[ptr gio.ActionGroup00](group.impl), if pad.isNil: nil else: cast[ptr gdk.Device00](pad.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPadController*(tdesc: typedesc; window: Window; group: gio.ActionGroup | gio.SimpleActionGroup;
    pad: gdk.Device = nil): tdesc =
  assert(result is PadController)
  let gobj = gtk_pad_controller_new(cast[ptr Window00](window.impl), cast[ptr gio.ActionGroup00](group.impl), if pad.isNil: nil else: cast[ptr gdk.Device00](pad.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPadController*[T](result: var T; window: Window; group: gio.ActionGroup | gio.SimpleActionGroup;
    pad: gdk.Device = nil) {.deprecated.} =
  assert(result is PadController)
  let gobj = gtk_pad_controller_new(cast[ptr Window00](window.impl), cast[ptr gio.ActionGroup00](group.impl), if pad.isNil: nil else: cast[ptr gdk.Device00](pad.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_pad_controller_set_action(self: ptr PadController00; `type`: PadActionType;
    index: int32; mode: int32; label: cstring; actionName: cstring) {.
    importc, libprag.}

proc setAction*(self: PadController; `type`: PadActionType;
    index: int; mode: int; label: cstring; actionName: cstring) =
  gtk_pad_controller_set_action(cast[ptr PadController00](self.impl), `type`, int32(index), int32(mode), label, actionName)

proc gtk_pad_controller_set_action_entries(self: ptr PadController00; entries: ptr PadActionEntry;
    nEntries: int32) {.
    importc, libprag.}

proc setActionEntries*(self: PadController; entries: ptr PadActionEntry;
    nEntries: int) =
  gtk_pad_controller_set_action_entries(cast[ptr PadController00](self.impl), entries, int32(nEntries))

type
  PageOrientation* {.size: sizeof(cint), pure.} = enum
    portrait = 0
    landscape = 1
    reversePortrait = 2
    reverseLandscape = 3

type
  PageRange* {.pure, byRef.} = object
    start*: int32
    `end`*: int32

proc seq2PageRangeArray(s: openarray[PageRange]; a: var cstringArray):  ptr PageRange =
  assert s.high < 256
  let x = cast[ptr UncheckedArray[ptr PageRange]](a)
  for i in 0 .. s.high:
    x[i] = unsafeaddr(s[i])
  return cast[ptr PageRange](x)

proc pageRangeArrayToSeq(s: ptr PageRange; n: int):  seq[PageRange] =
  let a = cast[ptr UncheckedArray[ptr PageRange]](s)
  for i in 0 ..< n:
    result.add(a[i][])
  cogfree(s)



type
  PageSet* {.size: sizeof(cint), pure.} = enum
    all = 0
    even = 1
    odd = 2

type
  PageSetup* = ref object of gobject.Object
  PageSetup00* = object of gobject.Object00

proc gtk_page_setup_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PageSetup()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_page_setup_new(): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetup*(): PageSetup =
  let gobj = gtk_page_setup_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetup*(tdesc: typedesc): tdesc =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetup*[T](result: var T) {.deprecated.} =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_file(fileName: cstring; error: ptr ptr glib.Error = nil): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetupFromFile*(fileName: cstring): PageSetup =
  var gerror: ptr glib.Error
  let gobj = gtk_page_setup_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetupFromFile*(tdesc: typedesc; fileName: cstring): tdesc =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromFile*[T](result: var T; fileName: cstring) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_gvariant(variant: ptr glib.Variant00): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetupFromGvariant*(variant: glib.Variant): PageSetup =
  let gobj = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetupFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_new_from_key_file(keyFile: ptr glib.KeyFile00; groupName: cstring;
    error: ptr ptr glib.Error = nil): ptr PageSetup00 {.
    importc, libprag.}

proc newPageSetupFromKeyFile*(keyFile: glib.KeyFile; groupName: cstring = nil): PageSetup =
  var gerror: ptr glib.Error
  let gobj = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPageSetupFromKeyFile*(tdesc: typedesc; keyFile: glib.KeyFile; groupName: cstring = nil): tdesc =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPageSetupFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: cstring = nil) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PageSetup)
  let gobj = gtk_page_setup_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_copy(self: ptr PageSetup00): ptr PageSetup00 {.
    importc, libprag.}

proc copy*(self: PageSetup): PageSetup =
  let gobj = gtk_page_setup_copy(cast[ptr PageSetup00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_page_setup_get_orientation(self: ptr PageSetup00): PageOrientation {.
    importc, libprag.}

proc getOrientation*(self: PageSetup): PageOrientation =
  gtk_page_setup_get_orientation(cast[ptr PageSetup00](self.impl))

proc orientation*(self: PageSetup): PageOrientation =
  gtk_page_setup_get_orientation(cast[ptr PageSetup00](self.impl))

proc gtk_page_setup_load_file(self: ptr PageSetup00; fileName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadFile*(self: PageSetup; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_page_setup_load_file(cast[ptr PageSetup00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_page_setup_load_key_file(self: ptr PageSetup00; keyFile: ptr glib.KeyFile00;
    groupName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadKeyFile*(self: PageSetup; keyFile: glib.KeyFile;
    groupName: cstring = nil): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_page_setup_load_key_file(cast[ptr PageSetup00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_page_setup_set_orientation(self: ptr PageSetup00; orientation: PageOrientation) {.
    importc, libprag.}

proc setOrientation*(self: PageSetup; orientation: PageOrientation) =
  gtk_page_setup_set_orientation(cast[ptr PageSetup00](self.impl), orientation)

proc `orientation=`*(self: PageSetup; orientation: PageOrientation) =
  gtk_page_setup_set_orientation(cast[ptr PageSetup00](self.impl), orientation)

proc gtk_page_setup_to_file(self: ptr PageSetup00; fileName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc toFile*(self: PageSetup; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_page_setup_to_file(cast[ptr PageSetup00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_page_setup_to_gvariant(self: ptr PageSetup00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: PageSetup): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_page_setup_to_gvariant(cast[ptr PageSetup00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_page_setup_to_key_file(self: ptr PageSetup00; keyFile: ptr glib.KeyFile00;
    groupName: cstring) {.
    importc, libprag.}

proc toKeyFile*(self: PageSetup; keyFile: glib.KeyFile; groupName: cstring = nil) =
  gtk_page_setup_to_key_file(cast[ptr PageSetup00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName)

type
  PaperSize00* {.pure.} = object
  PaperSize* = ref object
    impl*: ptr PaperSize00
    ignoreFinalizer*: bool

proc gtk_paper_size_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkPaperSize*(self: PaperSize) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_paper_size_get_type(), cast[ptr PaperSize00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PaperSize()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_paper_size_get_type(), cast[ptr PaperSize00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var PaperSize) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkPaperSize)

proc gtk_paper_size_free(self: ptr PaperSize00) {.
    importc, libprag.}

proc free*(self: PaperSize) =
  gtk_paper_size_free(cast[ptr PaperSize00](self.impl))

proc finalizerfree*(self: PaperSize) =
  if not self.ignoreFinalizer:
    gtk_paper_size_free(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_new_from_gvariant(variant: ptr glib.Variant00): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromGvariant*(variant: glib.Variant): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc newPaperSizeFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc initPaperSizeFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))

proc gtk_paper_size_new_from_ipp(ippName: cstring; width: cdouble; height: cdouble): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromIpp*(ippName: cstring; width: cdouble; height: cdouble): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ipp(ippName, width, height)

proc newPaperSizeFromIpp*(tdesc: typedesc; ippName: cstring; width: cdouble; height: cdouble): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ipp(ippName, width, height)

proc initPaperSizeFromIpp*[T](result: var T; ippName: cstring; width: cdouble; height: cdouble) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ipp(ippName, width, height)

proc gtk_paper_size_new_from_key_file(keyFile: ptr glib.KeyFile00; groupName: cstring;
    error: ptr ptr glib.Error = nil): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromKeyFile*(keyFile: glib.KeyFile; groupName: cstring = nil): PaperSize =
  var gerror: ptr glib.Error
  let impl0 = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc newPaperSizeFromKeyFile*(tdesc: typedesc; keyFile: glib.KeyFile; groupName: cstring = nil): tdesc =
  var gerror: ptr glib.Error
  assert(result is PaperSize)
  let impl0 = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc initPaperSizeFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: cstring = nil) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PaperSize)
  let impl0 = gtk_paper_size_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = impl0

proc gtk_paper_size_new_from_ppd(ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeFromPpd*(ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ppd(ppdName, ppdDisplayName, width, height)

proc newPaperSizeFromPpd*(tdesc: typedesc; ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ppd(ppdName, ppdDisplayName, width, height)

proc initPaperSizeFromPpd*[T](result: var T; ppdName: cstring; ppdDisplayName: cstring;
    width: cdouble; height: cdouble) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_from_ppd(ppdName, ppdDisplayName, width, height)

proc gtk_paper_size_copy(self: ptr PaperSize00): ptr PaperSize00 {.
    importc, libprag.}

proc copy*(self: PaperSize): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_copy(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_new(name: cstring): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSize*(name: cstring = nil): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new(name)

proc newPaperSize*(tdesc: typedesc; name: cstring = nil): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new(name)

proc initPaperSize*[T](result: var T; name: cstring = nil) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new(name)

proc gtk_paper_size_get_display_name(self: ptr PaperSize00): cstring {.
    importc, libprag.}

proc getDisplayName*(self: PaperSize): string =
  result = $gtk_paper_size_get_display_name(cast[ptr PaperSize00](self.impl))

proc displayName*(self: PaperSize): string =
  result = $gtk_paper_size_get_display_name(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_get_name(self: ptr PaperSize00): cstring {.
    importc, libprag.}

proc getName*(self: PaperSize): string =
  result = $gtk_paper_size_get_name(cast[ptr PaperSize00](self.impl))

proc name*(self: PaperSize): string =
  result = $gtk_paper_size_get_name(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_get_ppd_name(self: ptr PaperSize00): cstring {.
    importc, libprag.}

proc getPpdName*(self: PaperSize): string =
  result = $gtk_paper_size_get_ppd_name(cast[ptr PaperSize00](self.impl))

proc ppdName*(self: PaperSize): string =
  result = $gtk_paper_size_get_ppd_name(cast[ptr PaperSize00](self.impl))

proc gtk_paper_size_is_custom(self: ptr PaperSize00): gboolean {.
    importc, libprag.}

proc isCustom*(self: PaperSize): bool =
  toBool(gtk_paper_size_is_custom(cast[ptr PaperSize00](self.impl)))

proc gtk_paper_size_is_equal(self: ptr PaperSize00; size2: ptr PaperSize00): gboolean {.
    importc, libprag.}

proc isEqual*(self: PaperSize; size2: PaperSize): bool =
  toBool(gtk_paper_size_is_equal(cast[ptr PaperSize00](self.impl), cast[ptr PaperSize00](size2.impl)))

proc gtk_paper_size_is_ipp(self: ptr PaperSize00): gboolean {.
    importc, libprag.}

proc isIpp*(self: PaperSize): bool =
  toBool(gtk_paper_size_is_ipp(cast[ptr PaperSize00](self.impl)))

proc gtk_paper_size_to_gvariant(self: ptr PaperSize00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: PaperSize): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_paper_size_to_gvariant(cast[ptr PaperSize00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_paper_size_to_key_file(self: ptr PaperSize00; keyFile: ptr glib.KeyFile00;
    groupName: cstring) {.
    importc, libprag.}

proc toKeyFile*(self: PaperSize; keyFile: glib.KeyFile; groupName: cstring) =
  gtk_paper_size_to_key_file(cast[ptr PaperSize00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName)

proc gtk_paper_size_get_default(): cstring {.
    importc, libprag.}

proc getDefaultPaperSize*(): string =
  result = $gtk_paper_size_get_default()

proc gtk_paper_size_get_paper_sizes(includeCustom: gboolean): ptr glib.List {.
    importc, libprag.}

proc getPaperSizes*(includeCustom: bool): seq[PaperSize] =
  let resul0 = gtk_paper_size_get_paper_sizes(gboolean(includeCustom))
  result = glistStructs2seq[PaperSize](resul0, false)
  g_list_free(resul0)

proc paperSizes*(includeCustom: bool): seq[PaperSize] =
  let resul0 = gtk_paper_size_get_paper_sizes(gboolean(includeCustom))
  result = glistStructs2seq[PaperSize](resul0, false)
  g_list_free(resul0)

proc gtk_page_setup_get_paper_size(self: ptr PageSetup00): ptr PaperSize00 {.
    importc, libprag.}

proc getPaperSize*(self: PageSetup): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_page_setup_get_paper_size(cast[ptr PageSetup00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_paper_size_get_type(), result.impl))

proc paperSize*(self: PageSetup): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_page_setup_get_paper_size(cast[ptr PageSetup00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_paper_size_get_type(), result.impl))

proc gtk_page_setup_set_paper_size(self: ptr PageSetup00; size: ptr PaperSize00) {.
    importc, libprag.}

proc setPaperSize*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc `paperSize=`*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc gtk_page_setup_set_paper_size_and_default_margins(self: ptr PageSetup00;
    size: ptr PaperSize00) {.
    importc, libprag.}

proc setPaperSizeAndDefaultMargins*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size_and_default_margins(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

proc `paperSizeAndDefaultMargins=`*(self: PageSetup; size: PaperSize) =
  gtk_page_setup_set_paper_size_and_default_margins(cast[ptr PageSetup00](self.impl), cast[ptr PaperSize00](size.impl))

type
  Unit* {.size: sizeof(cint), pure.} = enum
    none = 0
    points = 1
    inch = 2
    mm = 3

proc gtk_page_setup_get_bottom_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getBottomMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_bottom_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_left_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getLeftMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_left_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_page_height(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPageHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_height(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_page_width(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPageWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_page_width(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_paper_height(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperHeight*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_height(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_paper_width(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperWidth*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_paper_width(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_right_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getRightMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_right_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_get_top_margin(self: ptr PageSetup00; unit: Unit): cdouble {.
    importc, libprag.}

proc getTopMargin*(self: PageSetup; unit: Unit): cdouble =
  gtk_page_setup_get_top_margin(cast[ptr PageSetup00](self.impl), unit)

proc gtk_page_setup_set_bottom_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setBottomMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_bottom_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_left_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setLeftMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_left_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_right_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setRightMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_right_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_page_setup_set_top_margin(self: ptr PageSetup00; margin: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setTopMargin*(self: PageSetup; margin: cdouble; unit: Unit) =
  gtk_page_setup_set_top_margin(cast[ptr PageSetup00](self.impl), margin, unit)

proc gtk_paper_size_new_custom(name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit): ptr PaperSize00 {.
    importc, libprag.}

proc newPaperSizeCustom*(name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_custom(name, displayName, width, height, unit)

proc newPaperSizeCustom*(tdesc: typedesc; name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit): tdesc =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_custom(name, displayName, width, height, unit)

proc initPaperSizeCustom*[T](result: var T; name: cstring; displayName: cstring; width: cdouble;
    height: cdouble; unit: Unit) {.deprecated.} =
  assert(result is PaperSize)
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_paper_size_new_custom(name, displayName, width, height, unit)

proc gtk_paper_size_get_default_bottom_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultBottomMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_bottom_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_left_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultLeftMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_left_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_right_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultRightMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_right_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_default_top_margin(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getDefaultTopMargin*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_default_top_margin(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_height(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getHeight*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_height(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_get_width(self: ptr PaperSize00; unit: Unit): cdouble {.
    importc, libprag.}

proc getWidth*(self: PaperSize; unit: Unit): cdouble =
  gtk_paper_size_get_width(cast[ptr PaperSize00](self.impl), unit)

proc gtk_paper_size_set_size(self: ptr PaperSize00; width: cdouble; height: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setSize*(self: PaperSize; width: cdouble; height: cdouble;
    unit: Unit) =
  gtk_paper_size_set_size(cast[ptr PaperSize00](self.impl), width, height, unit)

type
  PageSetupDoneFunc* = proc (pageSetup: ptr PageSetup00; data: pointer) {.cdecl.}

type
  PanedAccessible* = ref object of ContainerAccessible
  PanedAccessible00* = object of ContainerAccessible00

proc gtk_paned_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PanedAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  PopoverAccessible* = ref object of ContainerAccessible
  PopoverAccessible00* = object of ContainerAccessible00

proc gtk_popover_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PopoverAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  PrintContext* = ref object of gobject.Object
  PrintContext00* = object of gobject.Object00

proc gtk_print_context_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintContext()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_print_context_create_pango_context(self: ptr PrintContext00): ptr pango.Context00 {.
    importc, libprag.}

proc createPangoContext*(self: PrintContext): pango.Context =
  let gobj = gtk_print_context_create_pango_context(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_create_pango_layout(self: ptr PrintContext00): ptr pango.Layout00 {.
    importc, libprag.}

proc createPangoLayout*(self: PrintContext): pango.Layout =
  let gobj = gtk_print_context_create_pango_layout(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_cairo_context(self: ptr PrintContext00): ptr cairo.Context00 {.
    importc, libprag.}

proc getCairoContext*(self: PrintContext): cairo.Context =
  fnew(result, gBoxedFreeCairoContext)
  result.impl = gtk_print_context_get_cairo_context(cast[ptr PrintContext00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_context_get_type(), result.impl))

proc cairoContext*(self: PrintContext): cairo.Context =
  fnew(result, gBoxedFreeCairoContext)
  result.impl = gtk_print_context_get_cairo_context(cast[ptr PrintContext00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(cairo_gobject_context_get_type(), result.impl))

proc gtk_print_context_get_dpi_x(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getDpiX*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_x(cast[ptr PrintContext00](self.impl))

proc dpiX*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_x(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_dpi_y(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getDpiY*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_y(cast[ptr PrintContext00](self.impl))

proc dpiY*(self: PrintContext): cdouble =
  gtk_print_context_get_dpi_y(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_hard_margins(self: ptr PrintContext00; top: var cdouble;
    bottom: var cdouble; left: var cdouble; right: var cdouble): gboolean {.
    importc, libprag.}

proc getHardMargins*(self: PrintContext; top: var cdouble;
    bottom: var cdouble; left: var cdouble; right: var cdouble): bool =
  toBool(gtk_print_context_get_hard_margins(cast[ptr PrintContext00](self.impl), top, bottom, left, right))

proc gtk_print_context_get_height(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getHeight*(self: PrintContext): cdouble =
  gtk_print_context_get_height(cast[ptr PrintContext00](self.impl))

proc height*(self: PrintContext): cdouble =
  gtk_print_context_get_height(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_get_page_setup(self: ptr PrintContext00): ptr PageSetup00 {.
    importc, libprag.}

proc getPageSetup*(self: PrintContext): PageSetup =
  let gobj = gtk_print_context_get_page_setup(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pageSetup*(self: PrintContext): PageSetup =
  let gobj = gtk_print_context_get_page_setup(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_pango_fontmap(self: ptr PrintContext00): ptr pango.FontMap00 {.
    importc, libprag.}

proc getPangoFontmap*(self: PrintContext): pango.FontMap =
  let gobj = gtk_print_context_get_pango_fontmap(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pangoFontmap*(self: PrintContext): pango.FontMap =
  let gobj = gtk_print_context_get_pango_fontmap(cast[ptr PrintContext00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, pango.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_context_get_width(self: ptr PrintContext00): cdouble {.
    importc, libprag.}

proc getWidth*(self: PrintContext): cdouble =
  gtk_print_context_get_width(cast[ptr PrintContext00](self.impl))

proc width*(self: PrintContext): cdouble =
  gtk_print_context_get_width(cast[ptr PrintContext00](self.impl))

proc gtk_print_context_set_cairo_context(self: ptr PrintContext00; cr: ptr cairo.Context00;
    dpiX: cdouble; dpiY: cdouble) {.
    importc, libprag.}

proc setCairoContext*(self: PrintContext; cr: cairo.Context;
    dpiX: cdouble; dpiY: cdouble) =
  gtk_print_context_set_cairo_context(cast[ptr PrintContext00](self.impl), cast[ptr cairo.Context00](cr.impl), dpiX, dpiY)

type
  PrintDuplex* {.size: sizeof(cint), pure.} = enum
    simplex = 0
    horizontal = 1
    vertical = 2

type
  PrintError* {.size: sizeof(cint), pure.} = enum
    general = 0
    internalError = 1
    nomem = 2
    invalidFile = 3

type
  PrintOperationResult* {.size: sizeof(cint), pure.} = enum
    error = 0
    apply = 1
    cancel = 2
    inProgress = 3

type
  PrintSettings* = ref object of gobject.Object
  PrintSettings00* = object of gobject.Object00

proc gtk_print_settings_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintSettings()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_print_settings_new(): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettings*(): PrintSettings =
  let gobj = gtk_print_settings_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettings*(tdesc: typedesc): tdesc =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettings*[T](result: var T) {.deprecated.} =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_file(fileName: cstring; error: ptr ptr glib.Error = nil): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettingsFromFile*(fileName: cstring): PrintSettings =
  var gerror: ptr glib.Error
  let gobj = gtk_print_settings_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettingsFromFile*(tdesc: typedesc; fileName: cstring): tdesc =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromFile*[T](result: var T; fileName: cstring) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_file(fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_gvariant(variant: ptr glib.Variant00): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettingsFromGvariant*(variant: glib.Variant): PrintSettings =
  let gobj = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettingsFromGvariant*(tdesc: typedesc; variant: glib.Variant): tdesc =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromGvariant*[T](result: var T; variant: glib.Variant) {.deprecated.} =
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_gvariant(cast[ptr glib.Variant00](variant.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_new_from_key_file(keyFile: ptr glib.KeyFile00; groupName: cstring;
    error: ptr ptr glib.Error = nil): ptr PrintSettings00 {.
    importc, libprag.}

proc newPrintSettingsFromKeyFile*(keyFile: glib.KeyFile; groupName: cstring = nil): PrintSettings =
  var gerror: ptr glib.Error
  let gobj = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintSettingsFromKeyFile*(tdesc: typedesc; keyFile: glib.KeyFile; groupName: cstring = nil): tdesc =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintSettingsFromKeyFile*[T](result: var T; keyFile: glib.KeyFile; groupName: cstring = nil) {.deprecated.} =
  var gerror: ptr glib.Error
  assert(result is PrintSettings)
  let gobj = gtk_print_settings_new_from_key_file(cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_copy(self: ptr PrintSettings00): ptr PrintSettings00 {.
    importc, libprag.}

proc copy*(self: PrintSettings): PrintSettings =
  let gobj = gtk_print_settings_copy(cast[ptr PrintSettings00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_settings_get(self: ptr PrintSettings00; key: cstring): cstring {.
    importc, libprag.}

proc getPrintSettings*(self: PrintSettings; key: cstring): string =
  result = $gtk_print_settings_get(cast[ptr PrintSettings00](self.impl), key)

proc gtk_print_settings_get_bool(self: ptr PrintSettings00; key: cstring): gboolean {.
    importc, libprag.}

proc getBool*(self: PrintSettings; key: cstring): bool =
  toBool(gtk_print_settings_get_bool(cast[ptr PrintSettings00](self.impl), key))

proc gtk_print_settings_get_collate(self: ptr PrintSettings00): gboolean {.
    importc, libprag.}

proc getCollate*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_collate(cast[ptr PrintSettings00](self.impl)))

proc collate*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_collate(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_default_source(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getDefaultSource*(self: PrintSettings): string =
  result = $gtk_print_settings_get_default_source(cast[ptr PrintSettings00](self.impl))

proc defaultSource*(self: PrintSettings): string =
  result = $gtk_print_settings_get_default_source(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_dither(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getDither*(self: PrintSettings): string =
  result = $gtk_print_settings_get_dither(cast[ptr PrintSettings00](self.impl))

proc dither*(self: PrintSettings): string =
  result = $gtk_print_settings_get_dither(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_double(self: ptr PrintSettings00; key: cstring): cdouble {.
    importc, libprag.}

proc getDouble*(self: PrintSettings; key: cstring): cdouble =
  gtk_print_settings_get_double(cast[ptr PrintSettings00](self.impl), key)

proc gtk_print_settings_get_double_with_default(self: ptr PrintSettings00;
    key: cstring; def: cdouble): cdouble {.
    importc, libprag.}

proc getDoubleWithDefault*(self: PrintSettings; key: cstring;
    def: cdouble): cdouble =
  gtk_print_settings_get_double_with_default(cast[ptr PrintSettings00](self.impl), key, def)

proc gtk_print_settings_get_duplex(self: ptr PrintSettings00): PrintDuplex {.
    importc, libprag.}

proc getDuplex*(self: PrintSettings): PrintDuplex =
  gtk_print_settings_get_duplex(cast[ptr PrintSettings00](self.impl))

proc duplex*(self: PrintSettings): PrintDuplex =
  gtk_print_settings_get_duplex(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_finishings(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getFinishings*(self: PrintSettings): string =
  result = $gtk_print_settings_get_finishings(cast[ptr PrintSettings00](self.impl))

proc finishings*(self: PrintSettings): string =
  result = $gtk_print_settings_get_finishings(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_int(self: ptr PrintSettings00; key: cstring): int32 {.
    importc, libprag.}

proc getInt*(self: PrintSettings; key: cstring): int =
  int(gtk_print_settings_get_int(cast[ptr PrintSettings00](self.impl), key))

proc gtk_print_settings_get_int_with_default(self: ptr PrintSettings00; key: cstring;
    def: int32): int32 {.
    importc, libprag.}

proc getIntWithDefault*(self: PrintSettings; key: cstring;
    def: int): int =
  int(gtk_print_settings_get_int_with_default(cast[ptr PrintSettings00](self.impl), key, int32(def)))

proc gtk_print_settings_get_length(self: ptr PrintSettings00; key: cstring;
    unit: Unit): cdouble {.
    importc, libprag.}

proc getLength*(self: PrintSettings; key: cstring; unit: Unit): cdouble =
  gtk_print_settings_get_length(cast[ptr PrintSettings00](self.impl), key, unit)

proc gtk_print_settings_get_media_type(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getMediaType*(self: PrintSettings): string =
  result = $gtk_print_settings_get_media_type(cast[ptr PrintSettings00](self.impl))

proc mediaType*(self: PrintSettings): string =
  result = $gtk_print_settings_get_media_type(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_n_copies(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getNCopies*(self: PrintSettings): int =
  int(gtk_print_settings_get_n_copies(cast[ptr PrintSettings00](self.impl)))

proc nCopies*(self: PrintSettings): int =
  int(gtk_print_settings_get_n_copies(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_number_up(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getNumberUp*(self: PrintSettings): int =
  int(gtk_print_settings_get_number_up(cast[ptr PrintSettings00](self.impl)))

proc numberUp*(self: PrintSettings): int =
  int(gtk_print_settings_get_number_up(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_number_up_layout(self: ptr PrintSettings00): NumberUpLayout {.
    importc, libprag.}

proc getNumberUpLayout*(self: PrintSettings): NumberUpLayout =
  gtk_print_settings_get_number_up_layout(cast[ptr PrintSettings00](self.impl))

proc numberUpLayout*(self: PrintSettings): NumberUpLayout =
  gtk_print_settings_get_number_up_layout(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_orientation(self: ptr PrintSettings00): PageOrientation {.
    importc, libprag.}

proc getOrientation*(self: PrintSettings): PageOrientation =
  gtk_print_settings_get_orientation(cast[ptr PrintSettings00](self.impl))

proc orientation*(self: PrintSettings): PageOrientation =
  gtk_print_settings_get_orientation(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_output_bin(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getOutputBin*(self: PrintSettings): string =
  result = $gtk_print_settings_get_output_bin(cast[ptr PrintSettings00](self.impl))

proc outputBin*(self: PrintSettings): string =
  result = $gtk_print_settings_get_output_bin(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_page_ranges(self: ptr PrintSettings00; numRanges: var int32): ptr PageRange {.
    importc, libprag.}

proc getPageRanges*(self: PrintSettings; numRanges: var int): seq[PageRange] =
  var numRanges_00: int32
  let resul0 = gtk_print_settings_get_page_ranges(cast[ptr PrintSettings00](self.impl), numRanges_00)
  result = pageRangeArrayToSeq(resul0, numRanges_00.int)
  cogfree(resul0)
  if numRanges.addr != nil:
    numRanges = int(numRanges_00)

proc gtk_print_settings_get_page_set(self: ptr PrintSettings00): PageSet {.
    importc, libprag.}

proc getPageSet*(self: PrintSettings): PageSet =
  gtk_print_settings_get_page_set(cast[ptr PrintSettings00](self.impl))

proc pageSet*(self: PrintSettings): PageSet =
  gtk_print_settings_get_page_set(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_paper_height(self: ptr PrintSettings00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperHeight*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_height(cast[ptr PrintSettings00](self.impl), unit)

proc gtk_print_settings_get_paper_size(self: ptr PrintSettings00): ptr PaperSize00 {.
    importc, libprag.}

proc getPaperSize*(self: PrintSettings): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_print_settings_get_paper_size(cast[ptr PrintSettings00](self.impl))

proc paperSize*(self: PrintSettings): PaperSize =
  fnew(result, gBoxedFreeGtkPaperSize)
  result.impl = gtk_print_settings_get_paper_size(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_paper_width(self: ptr PrintSettings00; unit: Unit): cdouble {.
    importc, libprag.}

proc getPaperWidth*(self: PrintSettings; unit: Unit): cdouble =
  gtk_print_settings_get_paper_width(cast[ptr PrintSettings00](self.impl), unit)

proc gtk_print_settings_get_printer(self: ptr PrintSettings00): cstring {.
    importc, libprag.}

proc getPrinter*(self: PrintSettings): string =
  result = $gtk_print_settings_get_printer(cast[ptr PrintSettings00](self.impl))

proc printer*(self: PrintSettings): string =
  result = $gtk_print_settings_get_printer(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_printer_lpi(self: ptr PrintSettings00): cdouble {.
    importc, libprag.}

proc getPrinterLpi*(self: PrintSettings): cdouble =
  gtk_print_settings_get_printer_lpi(cast[ptr PrintSettings00](self.impl))

proc printerLpi*(self: PrintSettings): cdouble =
  gtk_print_settings_get_printer_lpi(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_resolution(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getResolution*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution(cast[ptr PrintSettings00](self.impl)))

proc resolution*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_resolution_x(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getResolutionX*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_x(cast[ptr PrintSettings00](self.impl)))

proc resolutionX*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_x(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_resolution_y(self: ptr PrintSettings00): int32 {.
    importc, libprag.}

proc getResolutionY*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_y(cast[ptr PrintSettings00](self.impl)))

proc resolutionY*(self: PrintSettings): int =
  int(gtk_print_settings_get_resolution_y(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_reverse(self: ptr PrintSettings00): gboolean {.
    importc, libprag.}

proc getReverse*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_reverse(cast[ptr PrintSettings00](self.impl)))

proc reverse*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_reverse(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_get_scale(self: ptr PrintSettings00): cdouble {.
    importc, libprag.}

proc getScale*(self: PrintSettings): cdouble =
  gtk_print_settings_get_scale(cast[ptr PrintSettings00](self.impl))

proc scale*(self: PrintSettings): cdouble =
  gtk_print_settings_get_scale(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_get_use_color(self: ptr PrintSettings00): gboolean {.
    importc, libprag.}

proc getUseColor*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_use_color(cast[ptr PrintSettings00](self.impl)))

proc useColor*(self: PrintSettings): bool =
  toBool(gtk_print_settings_get_use_color(cast[ptr PrintSettings00](self.impl)))

proc gtk_print_settings_has_key(self: ptr PrintSettings00; key: cstring): gboolean {.
    importc, libprag.}

proc hasKey*(self: PrintSettings; key: cstring): bool =
  toBool(gtk_print_settings_has_key(cast[ptr PrintSettings00](self.impl), key))

proc gtk_print_settings_load_file(self: ptr PrintSettings00; fileName: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadFile*(self: PrintSettings; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_settings_load_file(cast[ptr PrintSettings00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_settings_load_key_file(self: ptr PrintSettings00; keyFile: ptr glib.KeyFile00;
    groupName: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc loadKeyFile*(self: PrintSettings; keyFile: glib.KeyFile;
    groupName: cstring = nil): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_settings_load_key_file(cast[ptr PrintSettings00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_settings_set(self: ptr PrintSettings00; key: cstring; value: cstring) {.
    importc, libprag.}

proc set*(self: PrintSettings; key: cstring; value: cstring = nil) =
  gtk_print_settings_set(cast[ptr PrintSettings00](self.impl), key, value)

proc gtk_print_settings_set_bool(self: ptr PrintSettings00; key: cstring;
    value: gboolean) {.
    importc, libprag.}

proc setBool*(self: PrintSettings; key: cstring; value: bool) =
  gtk_print_settings_set_bool(cast[ptr PrintSettings00](self.impl), key, gboolean(value))

proc gtk_print_settings_set_collate(self: ptr PrintSettings00; collate: gboolean) {.
    importc, libprag.}

proc setCollate*(self: PrintSettings; collate: bool = true) =
  gtk_print_settings_set_collate(cast[ptr PrintSettings00](self.impl), gboolean(collate))

proc `collate=`*(self: PrintSettings; collate: bool) =
  gtk_print_settings_set_collate(cast[ptr PrintSettings00](self.impl), gboolean(collate))

proc gtk_print_settings_set_default_source(self: ptr PrintSettings00; defaultSource: cstring) {.
    importc, libprag.}

proc setDefaultSource*(self: PrintSettings; defaultSource: cstring) =
  gtk_print_settings_set_default_source(cast[ptr PrintSettings00](self.impl), defaultSource)

proc `defaultSource=`*(self: PrintSettings; defaultSource: cstring) =
  gtk_print_settings_set_default_source(cast[ptr PrintSettings00](self.impl), defaultSource)

proc gtk_print_settings_set_dither(self: ptr PrintSettings00; dither: cstring) {.
    importc, libprag.}

proc setDither*(self: PrintSettings; dither: cstring) =
  gtk_print_settings_set_dither(cast[ptr PrintSettings00](self.impl), dither)

proc `dither=`*(self: PrintSettings; dither: cstring) =
  gtk_print_settings_set_dither(cast[ptr PrintSettings00](self.impl), dither)

proc gtk_print_settings_set_double(self: ptr PrintSettings00; key: cstring;
    value: cdouble) {.
    importc, libprag.}

proc setDouble*(self: PrintSettings; key: cstring; value: cdouble) =
  gtk_print_settings_set_double(cast[ptr PrintSettings00](self.impl), key, value)

proc gtk_print_settings_set_duplex(self: ptr PrintSettings00; duplex: PrintDuplex) {.
    importc, libprag.}

proc setDuplex*(self: PrintSettings; duplex: PrintDuplex) =
  gtk_print_settings_set_duplex(cast[ptr PrintSettings00](self.impl), duplex)

proc `duplex=`*(self: PrintSettings; duplex: PrintDuplex) =
  gtk_print_settings_set_duplex(cast[ptr PrintSettings00](self.impl), duplex)

proc gtk_print_settings_set_finishings(self: ptr PrintSettings00; finishings: cstring) {.
    importc, libprag.}

proc setFinishings*(self: PrintSettings; finishings: cstring) =
  gtk_print_settings_set_finishings(cast[ptr PrintSettings00](self.impl), finishings)

proc `finishings=`*(self: PrintSettings; finishings: cstring) =
  gtk_print_settings_set_finishings(cast[ptr PrintSettings00](self.impl), finishings)

proc gtk_print_settings_set_int(self: ptr PrintSettings00; key: cstring;
    value: int32) {.
    importc, libprag.}

proc setInt*(self: PrintSettings; key: cstring; value: int) =
  gtk_print_settings_set_int(cast[ptr PrintSettings00](self.impl), key, int32(value))

proc gtk_print_settings_set_length(self: ptr PrintSettings00; key: cstring;
    value: cdouble; unit: Unit) {.
    importc, libprag.}

proc setLength*(self: PrintSettings; key: cstring; value: cdouble;
    unit: Unit) =
  gtk_print_settings_set_length(cast[ptr PrintSettings00](self.impl), key, value, unit)

proc gtk_print_settings_set_media_type(self: ptr PrintSettings00; mediaType: cstring) {.
    importc, libprag.}

proc setMediaType*(self: PrintSettings; mediaType: cstring) =
  gtk_print_settings_set_media_type(cast[ptr PrintSettings00](self.impl), mediaType)

proc `mediaType=`*(self: PrintSettings; mediaType: cstring) =
  gtk_print_settings_set_media_type(cast[ptr PrintSettings00](self.impl), mediaType)

proc gtk_print_settings_set_n_copies(self: ptr PrintSettings00; numCopies: int32) {.
    importc, libprag.}

proc setNCopies*(self: PrintSettings; numCopies: int) =
  gtk_print_settings_set_n_copies(cast[ptr PrintSettings00](self.impl), int32(numCopies))

proc `nCopies=`*(self: PrintSettings; numCopies: int) =
  gtk_print_settings_set_n_copies(cast[ptr PrintSettings00](self.impl), int32(numCopies))

proc gtk_print_settings_set_number_up(self: ptr PrintSettings00; numberUp: int32) {.
    importc, libprag.}

proc setNumberUp*(self: PrintSettings; numberUp: int) =
  gtk_print_settings_set_number_up(cast[ptr PrintSettings00](self.impl), int32(numberUp))

proc `numberUp=`*(self: PrintSettings; numberUp: int) =
  gtk_print_settings_set_number_up(cast[ptr PrintSettings00](self.impl), int32(numberUp))

proc gtk_print_settings_set_number_up_layout(self: ptr PrintSettings00; numberUpLayout: NumberUpLayout) {.
    importc, libprag.}

proc setNumberUpLayout*(self: PrintSettings; numberUpLayout: NumberUpLayout) =
  gtk_print_settings_set_number_up_layout(cast[ptr PrintSettings00](self.impl), numberUpLayout)

proc `numberUpLayout=`*(self: PrintSettings; numberUpLayout: NumberUpLayout) =
  gtk_print_settings_set_number_up_layout(cast[ptr PrintSettings00](self.impl), numberUpLayout)

proc gtk_print_settings_set_orientation(self: ptr PrintSettings00; orientation: PageOrientation) {.
    importc, libprag.}

proc setOrientation*(self: PrintSettings; orientation: PageOrientation) =
  gtk_print_settings_set_orientation(cast[ptr PrintSettings00](self.impl), orientation)

proc `orientation=`*(self: PrintSettings; orientation: PageOrientation) =
  gtk_print_settings_set_orientation(cast[ptr PrintSettings00](self.impl), orientation)

proc gtk_print_settings_set_output_bin(self: ptr PrintSettings00; outputBin: cstring) {.
    importc, libprag.}

proc setOutputBin*(self: PrintSettings; outputBin: cstring) =
  gtk_print_settings_set_output_bin(cast[ptr PrintSettings00](self.impl), outputBin)

proc `outputBin=`*(self: PrintSettings; outputBin: cstring) =
  gtk_print_settings_set_output_bin(cast[ptr PrintSettings00](self.impl), outputBin)

proc gtk_print_settings_set_page_ranges(self: ptr PrintSettings00; pageRanges: ptr PageRange;
    numRanges: int32) {.
    importc, libprag.}

proc setPageRanges*(self: PrintSettings; pageRanges: seq[PageRange]) =
  let numRanges = int(pageRanges.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_print_settings_set_page_ranges(cast[ptr PrintSettings00](self.impl), seq2PageRangeArray(pageRanges, fs469n23), int32(numRanges))

proc gtk_print_settings_set_page_set(self: ptr PrintSettings00; pageSet: PageSet) {.
    importc, libprag.}

proc setPageSet*(self: PrintSettings; pageSet: PageSet) =
  gtk_print_settings_set_page_set(cast[ptr PrintSettings00](self.impl), pageSet)

proc `pageSet=`*(self: PrintSettings; pageSet: PageSet) =
  gtk_print_settings_set_page_set(cast[ptr PrintSettings00](self.impl), pageSet)

proc gtk_print_settings_set_paper_height(self: ptr PrintSettings00; height: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setPaperHeight*(self: PrintSettings; height: cdouble;
    unit: Unit) =
  gtk_print_settings_set_paper_height(cast[ptr PrintSettings00](self.impl), height, unit)

proc gtk_print_settings_set_paper_size(self: ptr PrintSettings00; paperSize: ptr PaperSize00) {.
    importc, libprag.}

proc setPaperSize*(self: PrintSettings; paperSize: PaperSize) =
  gtk_print_settings_set_paper_size(cast[ptr PrintSettings00](self.impl), cast[ptr PaperSize00](paperSize.impl))

proc `paperSize=`*(self: PrintSettings; paperSize: PaperSize) =
  gtk_print_settings_set_paper_size(cast[ptr PrintSettings00](self.impl), cast[ptr PaperSize00](paperSize.impl))

proc gtk_print_settings_set_paper_width(self: ptr PrintSettings00; width: cdouble;
    unit: Unit) {.
    importc, libprag.}

proc setPaperWidth*(self: PrintSettings; width: cdouble;
    unit: Unit) =
  gtk_print_settings_set_paper_width(cast[ptr PrintSettings00](self.impl), width, unit)

proc gtk_print_settings_set_printer(self: ptr PrintSettings00; printer: cstring) {.
    importc, libprag.}

proc setPrinter*(self: PrintSettings; printer: cstring) =
  gtk_print_settings_set_printer(cast[ptr PrintSettings00](self.impl), printer)

proc `printer=`*(self: PrintSettings; printer: cstring) =
  gtk_print_settings_set_printer(cast[ptr PrintSettings00](self.impl), printer)

proc gtk_print_settings_set_printer_lpi(self: ptr PrintSettings00; lpi: cdouble) {.
    importc, libprag.}

proc setPrinterLpi*(self: PrintSettings; lpi: cdouble) =
  gtk_print_settings_set_printer_lpi(cast[ptr PrintSettings00](self.impl), lpi)

proc `printerLpi=`*(self: PrintSettings; lpi: cdouble) =
  gtk_print_settings_set_printer_lpi(cast[ptr PrintSettings00](self.impl), lpi)

proc gtk_print_settings_set_resolution(self: ptr PrintSettings00; resolution: int32) {.
    importc, libprag.}

proc setResolution*(self: PrintSettings; resolution: int) =
  gtk_print_settings_set_resolution(cast[ptr PrintSettings00](self.impl), int32(resolution))

proc `resolution=`*(self: PrintSettings; resolution: int) =
  gtk_print_settings_set_resolution(cast[ptr PrintSettings00](self.impl), int32(resolution))

proc gtk_print_settings_set_resolution_xy(self: ptr PrintSettings00; resolutionX: int32;
    resolutionY: int32) {.
    importc, libprag.}

proc setResolutionXy*(self: PrintSettings; resolutionX: int;
    resolutionY: int) =
  gtk_print_settings_set_resolution_xy(cast[ptr PrintSettings00](self.impl), int32(resolutionX), int32(resolutionY))

proc gtk_print_settings_set_reverse(self: ptr PrintSettings00; reverse: gboolean) {.
    importc, libprag.}

proc setReverse*(self: PrintSettings; reverse: bool = true) =
  gtk_print_settings_set_reverse(cast[ptr PrintSettings00](self.impl), gboolean(reverse))

proc `reverse=`*(self: PrintSettings; reverse: bool) =
  gtk_print_settings_set_reverse(cast[ptr PrintSettings00](self.impl), gboolean(reverse))

proc gtk_print_settings_set_scale(self: ptr PrintSettings00; scale: cdouble) {.
    importc, libprag.}

proc setScale*(self: PrintSettings; scale: cdouble) =
  gtk_print_settings_set_scale(cast[ptr PrintSettings00](self.impl), scale)

proc `scale=`*(self: PrintSettings; scale: cdouble) =
  gtk_print_settings_set_scale(cast[ptr PrintSettings00](self.impl), scale)

proc gtk_print_settings_set_use_color(self: ptr PrintSettings00; useColor: gboolean) {.
    importc, libprag.}

proc setUseColor*(self: PrintSettings; useColor: bool = true) =
  gtk_print_settings_set_use_color(cast[ptr PrintSettings00](self.impl), gboolean(useColor))

proc `useColor=`*(self: PrintSettings; useColor: bool) =
  gtk_print_settings_set_use_color(cast[ptr PrintSettings00](self.impl), gboolean(useColor))

proc gtk_print_settings_to_file(self: ptr PrintSettings00; fileName: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc toFile*(self: PrintSettings; fileName: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_settings_to_file(cast[ptr PrintSettings00](self.impl), fileName, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_print_settings_to_gvariant(self: ptr PrintSettings00): ptr glib.Variant00 {.
    importc, libprag.}

proc toGvariant*(self: PrintSettings): glib.Variant =
  fnew(result, finalizerunref)
  result.impl = gtk_print_settings_to_gvariant(cast[ptr PrintSettings00](self.impl))
  result.ignoreFinalizer = true # GVariant

proc gtk_print_settings_to_key_file(self: ptr PrintSettings00; keyFile: ptr glib.KeyFile00;
    groupName: cstring) {.
    importc, libprag.}

proc toKeyFile*(self: PrintSettings; keyFile: glib.KeyFile;
    groupName: cstring = nil) =
  gtk_print_settings_to_key_file(cast[ptr PrintSettings00](self.impl), cast[ptr glib.KeyFile00](keyFile.impl), groupName)

proc gtk_print_settings_unset(self: ptr PrintSettings00; key: cstring) {.
    importc, libprag.}

proc unset*(self: PrintSettings; key: cstring) =
  gtk_print_settings_unset(cast[ptr PrintSettings00](self.impl), key)
type

  PrintOperationPreview00* = object of gobject.Object00
  PrintOperationPreview* = ref object of gobject.Object

  PrintOperation* = ref object of gobject.Object
  PrintOperation00* = object of gobject.Object00

proc gtk_print_operation_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(PrintOperation()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scGotPageSize*(self: PrintOperationPreview | PrintOperation;  p: proc (self: ptr PrintOperationPreview00; context: ptr PrintContext00; pageSetup: ptr PageSetup00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "got-page-size", cast[GCallback](p), xdata, nil, cf)

proc scReady*(self: PrintOperationPreview | PrintOperation;  p: proc (self: ptr PrintOperationPreview00; context: ptr PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "ready", cast[GCallback](p), xdata, nil, cf)

proc scBeginPrint*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "begin-print", cast[GCallback](p), xdata, nil, cf)

proc scCreateCustomWidget*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; xdata: pointer): gobject.Object00 {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "create-custom-widget", cast[GCallback](p), xdata, nil, cf)

proc scCustomWidgetApply*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; widget: ptr Widget00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "custom-widget-apply", cast[GCallback](p), xdata, nil, cf)

proc scDone*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; resu: PrintOperationResult; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "done", cast[GCallback](p), xdata, nil, cf)

proc scDrawPage*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; pageNr: int32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "draw-page", cast[GCallback](p), xdata, nil, cf)

proc scEndPrint*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "end-print", cast[GCallback](p), xdata, nil, cf)

proc scPaginate*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "paginate", cast[GCallback](p), xdata, nil, cf)

proc scPreview*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; preview: ptr PrintOperationPreview00; context: ptr PrintContext00;
    parent: ptr Window00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "preview", cast[GCallback](p), xdata, nil, cf)

proc scRequestPageSetup*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; context: ptr PrintContext00; pageNr: int32; setup: ptr PageSetup00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "request-page-setup", cast[GCallback](p), xdata, nil, cf)

proc scStatusChanged*(self: PrintOperation;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "status-changed", cast[GCallback](p), xdata, nil, cf)

proc scUpdateCustomWidget*(self: PrintOperation;  p: proc (self: ptr PrintOperation00; widget: ptr Widget00; setup: ptr PageSetup00; settings: ptr PrintSettings00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "update-custom-widget", cast[GCallback](p), xdata, nil, cf)

proc gtk_print_operation_preview_end_preview(self: ptr PrintOperationPreview00) {.
    importc, libprag.}

proc endPreview*(self: PrintOperationPreview | PrintOperation) =
  gtk_print_operation_preview_end_preview(cast[ptr PrintOperationPreview00](self.impl))

proc gtk_print_operation_preview_is_selected(self: ptr PrintOperationPreview00;
    pageNr: int32): gboolean {.
    importc, libprag.}

proc isSelected*(self: PrintOperationPreview | PrintOperation;
    pageNr: int): bool =
  toBool(gtk_print_operation_preview_is_selected(cast[ptr PrintOperationPreview00](self.impl), int32(pageNr)))

proc gtk_print_operation_preview_render_page(self: ptr PrintOperationPreview00;
    pageNr: int32) {.
    importc, libprag.}

proc renderPage*(self: PrintOperationPreview | PrintOperation;
    pageNr: int) =
  gtk_print_operation_preview_render_page(cast[ptr PrintOperationPreview00](self.impl), int32(pageNr))

proc gtk_print_operation_new(): ptr PrintOperation00 {.
    importc, libprag.}

proc newPrintOperation*(): PrintOperation =
  let gobj = gtk_print_operation_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newPrintOperation*(tdesc: typedesc): tdesc =
  assert(result is PrintOperation)
  let gobj = gtk_print_operation_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initPrintOperation*[T](result: var T) {.deprecated.} =
  assert(result is PrintOperation)
  let gobj = gtk_print_operation_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_cancel(self: ptr PrintOperation00) {.
    importc, libprag.}

proc cancel*(self: PrintOperation) =
  gtk_print_operation_cancel(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_draw_page_finish(self: ptr PrintOperation00) {.
    importc, libprag.}

proc drawPageFinish*(self: PrintOperation) =
  gtk_print_operation_draw_page_finish(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_get_default_page_setup(self: ptr PrintOperation00): ptr PageSetup00 {.
    importc, libprag.}

proc getDefaultPageSetup*(self: PrintOperation): PageSetup =
  let gobj = gtk_print_operation_get_default_page_setup(cast[ptr PrintOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc defaultPageSetup*(self: PrintOperation): PageSetup =
  let gobj = gtk_print_operation_get_default_page_setup(cast[ptr PrintOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_get_embed_page_setup(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc getEmbedPageSetup*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_embed_page_setup(cast[ptr PrintOperation00](self.impl)))

proc embedPageSetup*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_embed_page_setup(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_error(self: ptr PrintOperation00; error: ptr ptr glib.Error = nil) {.
    importc, libprag.}

proc getError*(self: PrintOperation) =
  var gerror: ptr glib.Error
  gtk_print_operation_get_error(cast[ptr PrintOperation00](self.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)

proc gtk_print_operation_get_has_selection(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc getHasSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_has_selection(cast[ptr PrintOperation00](self.impl)))

proc hasSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_has_selection(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_n_pages_to_print(self: ptr PrintOperation00): int32 {.
    importc, libprag.}

proc getNPagesToPrint*(self: PrintOperation): int =
  int(gtk_print_operation_get_n_pages_to_print(cast[ptr PrintOperation00](self.impl)))

proc nPagesToPrint*(self: PrintOperation): int =
  int(gtk_print_operation_get_n_pages_to_print(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_get_print_settings(self: ptr PrintOperation00): ptr PrintSettings00 {.
    importc, libprag.}

proc getPrintSettings*(self: PrintOperation): PrintSettings =
  let gobj = gtk_print_operation_get_print_settings(cast[ptr PrintOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc printSettings*(self: PrintOperation): PrintSettings =
  let gobj = gtk_print_operation_get_print_settings(cast[ptr PrintOperation00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_operation_get_status_string(self: ptr PrintOperation00): cstring {.
    importc, libprag.}

proc getStatusString*(self: PrintOperation): string =
  result = $gtk_print_operation_get_status_string(cast[ptr PrintOperation00](self.impl))

proc statusString*(self: PrintOperation): string =
  result = $gtk_print_operation_get_status_string(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_get_support_selection(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc getSupportSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_support_selection(cast[ptr PrintOperation00](self.impl)))

proc supportSelection*(self: PrintOperation): bool =
  toBool(gtk_print_operation_get_support_selection(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_is_finished(self: ptr PrintOperation00): gboolean {.
    importc, libprag.}

proc isFinished*(self: PrintOperation): bool =
  toBool(gtk_print_operation_is_finished(cast[ptr PrintOperation00](self.impl)))

proc gtk_print_operation_set_allow_async(self: ptr PrintOperation00; allowAsync: gboolean) {.
    importc, libprag.}

proc setAllowAsync*(self: PrintOperation; allowAsync: bool = true) =
  gtk_print_operation_set_allow_async(cast[ptr PrintOperation00](self.impl), gboolean(allowAsync))

proc `allowAsync=`*(self: PrintOperation; allowAsync: bool) =
  gtk_print_operation_set_allow_async(cast[ptr PrintOperation00](self.impl), gboolean(allowAsync))

proc gtk_print_operation_set_current_page(self: ptr PrintOperation00; currentPage: int32) {.
    importc, libprag.}

proc setCurrentPage*(self: PrintOperation; currentPage: int) =
  gtk_print_operation_set_current_page(cast[ptr PrintOperation00](self.impl), int32(currentPage))

proc `currentPage=`*(self: PrintOperation; currentPage: int) =
  gtk_print_operation_set_current_page(cast[ptr PrintOperation00](self.impl), int32(currentPage))

proc gtk_print_operation_set_custom_tab_label(self: ptr PrintOperation00;
    label: cstring) {.
    importc, libprag.}

proc setCustomTabLabel*(self: PrintOperation; label: cstring = nil) =
  gtk_print_operation_set_custom_tab_label(cast[ptr PrintOperation00](self.impl), label)

proc `customTabLabel=`*(self: PrintOperation; label: cstring = nil) =
  gtk_print_operation_set_custom_tab_label(cast[ptr PrintOperation00](self.impl), label)

proc gtk_print_operation_set_default_page_setup(self: ptr PrintOperation00;
    defaultPageSetup: ptr PageSetup00) {.
    importc, libprag.}

proc setDefaultPageSetup*(self: PrintOperation; defaultPageSetup: PageSetup = nil) =
  gtk_print_operation_set_default_page_setup(cast[ptr PrintOperation00](self.impl), if defaultPageSetup.isNil: nil else: cast[ptr PageSetup00](defaultPageSetup.impl))

proc `defaultPageSetup=`*(self: PrintOperation; defaultPageSetup: PageSetup = nil) =
  gtk_print_operation_set_default_page_setup(cast[ptr PrintOperation00](self.impl), if defaultPageSetup.isNil: nil else: cast[ptr PageSetup00](defaultPageSetup.impl))

proc gtk_print_operation_set_defer_drawing(self: ptr PrintOperation00) {.
    importc, libprag.}

proc setDeferDrawing*(self: PrintOperation) =
  gtk_print_operation_set_defer_drawing(cast[ptr PrintOperation00](self.impl))

proc gtk_print_operation_set_embed_page_setup(self: ptr PrintOperation00;
    embed: gboolean) {.
    importc, libprag.}

proc setEmbedPageSetup*(self: PrintOperation; embed: bool = true) =
  gtk_print_operation_set_embed_page_setup(cast[ptr PrintOperation00](self.impl), gboolean(embed))

proc `embedPageSetup=`*(self: PrintOperation; embed: bool) =
  gtk_print_operation_set_embed_page_setup(cast[ptr PrintOperation00](self.impl), gboolean(embed))

proc gtk_print_operation_set_export_filename(self: ptr PrintOperation00;
    filename: cstring) {.
    importc, libprag.}

proc setExportFilename*(self: PrintOperation; filename: cstring) =
  gtk_print_operation_set_export_filename(cast[ptr PrintOperation00](self.impl), filename)

proc `exportFilename=`*(self: PrintOperation; filename: cstring) =
  gtk_print_operation_set_export_filename(cast[ptr PrintOperation00](self.impl), filename)

proc gtk_print_operation_set_has_selection(self: ptr PrintOperation00; hasSelection: gboolean) {.
    importc, libprag.}

proc setHasSelection*(self: PrintOperation; hasSelection: bool = true) =
  gtk_print_operation_set_has_selection(cast[ptr PrintOperation00](self.impl), gboolean(hasSelection))

proc `hasSelection=`*(self: PrintOperation; hasSelection: bool) =
  gtk_print_operation_set_has_selection(cast[ptr PrintOperation00](self.impl), gboolean(hasSelection))

proc gtk_print_operation_set_job_name(self: ptr PrintOperation00; jobName: cstring) {.
    importc, libprag.}

proc setJobName*(self: PrintOperation; jobName: cstring) =
  gtk_print_operation_set_job_name(cast[ptr PrintOperation00](self.impl), jobName)

proc `jobName=`*(self: PrintOperation; jobName: cstring) =
  gtk_print_operation_set_job_name(cast[ptr PrintOperation00](self.impl), jobName)

proc gtk_print_operation_set_n_pages(self: ptr PrintOperation00; nPages: int32) {.
    importc, libprag.}

proc setNPages*(self: PrintOperation; nPages: int) =
  gtk_print_operation_set_n_pages(cast[ptr PrintOperation00](self.impl), int32(nPages))

proc `nPages=`*(self: PrintOperation; nPages: int) =
  gtk_print_operation_set_n_pages(cast[ptr PrintOperation00](self.impl), int32(nPages))

proc gtk_print_operation_set_print_settings(self: ptr PrintOperation00; printSettings: ptr PrintSettings00) {.
    importc, libprag.}

proc setPrintSettings*(self: PrintOperation; printSettings: PrintSettings = nil) =
  gtk_print_operation_set_print_settings(cast[ptr PrintOperation00](self.impl), if printSettings.isNil: nil else: cast[ptr PrintSettings00](printSettings.impl))

proc `printSettings=`*(self: PrintOperation; printSettings: PrintSettings = nil) =
  gtk_print_operation_set_print_settings(cast[ptr PrintOperation00](self.impl), if printSettings.isNil: nil else: cast[ptr PrintSettings00](printSettings.impl))

proc gtk_print_operation_set_show_progress(self: ptr PrintOperation00; showProgress: gboolean) {.
    importc, libprag.}

proc setShowProgress*(self: PrintOperation; showProgress: bool = true) =
  gtk_print_operation_set_show_progress(cast[ptr PrintOperation00](self.impl), gboolean(showProgress))

proc `showProgress=`*(self: PrintOperation; showProgress: bool) =
  gtk_print_operation_set_show_progress(cast[ptr PrintOperation00](self.impl), gboolean(showProgress))

proc gtk_print_operation_set_support_selection(self: ptr PrintOperation00;
    supportSelection: gboolean) {.
    importc, libprag.}

proc setSupportSelection*(self: PrintOperation; supportSelection: bool = true) =
  gtk_print_operation_set_support_selection(cast[ptr PrintOperation00](self.impl), gboolean(supportSelection))

proc `supportSelection=`*(self: PrintOperation; supportSelection: bool) =
  gtk_print_operation_set_support_selection(cast[ptr PrintOperation00](self.impl), gboolean(supportSelection))

proc gtk_print_operation_set_track_print_status(self: ptr PrintOperation00;
    trackStatus: gboolean) {.
    importc, libprag.}

proc setTrackPrintStatus*(self: PrintOperation; trackStatus: bool = true) =
  gtk_print_operation_set_track_print_status(cast[ptr PrintOperation00](self.impl), gboolean(trackStatus))

proc `trackPrintStatus=`*(self: PrintOperation; trackStatus: bool) =
  gtk_print_operation_set_track_print_status(cast[ptr PrintOperation00](self.impl), gboolean(trackStatus))

proc gtk_print_operation_set_unit(self: ptr PrintOperation00; unit: Unit) {.
    importc, libprag.}

proc setUnit*(self: PrintOperation; unit: Unit) =
  gtk_print_operation_set_unit(cast[ptr PrintOperation00](self.impl), unit)

proc `unit=`*(self: PrintOperation; unit: Unit) =
  gtk_print_operation_set_unit(cast[ptr PrintOperation00](self.impl), unit)

proc gtk_print_operation_set_use_full_page(self: ptr PrintOperation00; fullPage: gboolean) {.
    importc, libprag.}

proc setUseFullPage*(self: PrintOperation; fullPage: bool = true) =
  gtk_print_operation_set_use_full_page(cast[ptr PrintOperation00](self.impl), gboolean(fullPage))

proc `useFullPage=`*(self: PrintOperation; fullPage: bool) =
  gtk_print_operation_set_use_full_page(cast[ptr PrintOperation00](self.impl), gboolean(fullPage))

type
  PrintPages* {.size: sizeof(cint), pure.} = enum
    all = 0
    current = 1
    ranges = 2
    selection = 3

proc gtk_print_settings_get_print_pages(self: ptr PrintSettings00): PrintPages {.
    importc, libprag.}

proc getPrintPages*(self: PrintSettings): PrintPages =
  gtk_print_settings_get_print_pages(cast[ptr PrintSettings00](self.impl))

proc printPages*(self: PrintSettings): PrintPages =
  gtk_print_settings_get_print_pages(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_print_pages(self: ptr PrintSettings00; pages: PrintPages) {.
    importc, libprag.}

proc setPrintPages*(self: PrintSettings; pages: PrintPages) =
  gtk_print_settings_set_print_pages(cast[ptr PrintSettings00](self.impl), pages)

proc `printPages=`*(self: PrintSettings; pages: PrintPages) =
  gtk_print_settings_set_print_pages(cast[ptr PrintSettings00](self.impl), pages)

type
  PrintQuality* {.size: sizeof(cint), pure.} = enum
    low = 0
    normal = 1
    high = 2
    draft = 3

proc gtk_print_settings_get_quality(self: ptr PrintSettings00): PrintQuality {.
    importc, libprag.}

proc getQuality*(self: PrintSettings): PrintQuality =
  gtk_print_settings_get_quality(cast[ptr PrintSettings00](self.impl))

proc quality*(self: PrintSettings): PrintQuality =
  gtk_print_settings_get_quality(cast[ptr PrintSettings00](self.impl))

proc gtk_print_settings_set_quality(self: ptr PrintSettings00; quality: PrintQuality) {.
    importc, libprag.}

proc setQuality*(self: PrintSettings; quality: PrintQuality) =
  gtk_print_settings_set_quality(cast[ptr PrintSettings00](self.impl), quality)

proc `quality=`*(self: PrintSettings; quality: PrintQuality) =
  gtk_print_settings_set_quality(cast[ptr PrintSettings00](self.impl), quality)

type
  PrintStatus* {.size: sizeof(cint), pure.} = enum
    initial = 0
    preparing = 1
    generatingData = 2
    sendingData = 3
    pending = 4
    pendingIssue = 5
    printing = 6
    finished = 7
    finishedAborted = 8

proc gtk_print_operation_get_status(self: ptr PrintOperation00): PrintStatus {.
    importc, libprag.}

proc getStatus*(self: PrintOperation): PrintStatus =
  gtk_print_operation_get_status(cast[ptr PrintOperation00](self.impl))

proc status*(self: PrintOperation): PrintStatus =
  gtk_print_operation_get_status(cast[ptr PrintOperation00](self.impl))

type
  PrintOperationAction* {.size: sizeof(cint), pure.} = enum
    printDialog = 0
    print = 1
    preview = 2
    `export` = 3

proc gtk_print_operation_run(self: ptr PrintOperation00; action: PrintOperationAction;
    parent: ptr Window00; error: ptr ptr glib.Error = nil): PrintOperationResult {.
    importc, libprag.}

proc run*(self: PrintOperation; action: PrintOperationAction;
    parent: Window = nil): PrintOperationResult =
  var gerror: ptr glib.Error
  let resul0 = gtk_print_operation_run(cast[ptr PrintOperation00](self.impl), action, if parent.isNil: nil else: cast[ptr Window00](parent.impl), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = resul0

type
  PrintSettingsFunc* = proc (key: cstring; value: cstring; userData: pointer) {.cdecl.}

proc gtk_print_settings_foreach(self: ptr PrintSettings00; `func`: PrintSettingsFunc;
    userData: pointer) {.
    importc, libprag.}

proc foreach*(self: PrintSettings; `func`: PrintSettingsFunc;
    userData: pointer) =
  gtk_print_settings_foreach(cast[ptr PrintSettings00](self.impl), `func`, userData)

type
  ProgressBarAccessible* = ref object of WidgetAccessible
  ProgressBarAccessible00* = object of WidgetAccessible00

proc gtk_progress_bar_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ProgressBarAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  RadioActionEntry00* {.pure.} = object
  RadioActionEntry* = ref object
    impl*: ptr RadioActionEntry00
    ignoreFinalizer*: bool

type
  RangeAccessible* = ref object of WidgetAccessible
  RangeAccessible00* = object of WidgetAccessible00

proc gtk_range_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(RangeAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  RcContext00* {.pure.} = object
  RcContext* = ref object
    impl*: ptr RcContext00
    ignoreFinalizer*: bool

type
  RcFlag* {.size: sizeof(cint), pure.} = enum
    fg = 0
    bg = 1
    text = 2
    base = 3

  RcFlags* {.size: sizeof(cint).} = set[RcFlag]

type
  RcProperty* {.pure, byRef.} = object
    typeName*: uint32
    propertyName*: uint32
    origin*: cstring
    value*: gobject.Value

proc gtk_rc_property_parse_border(pspec: ptr gobject.ParamSpec00; gstring: glib.String;
    propertyValue: gobject.Value): gboolean {.
    importc, libprag.}

proc parseBorder*(pspec: gobject.ParamSpec; gstring: glib.String;
    propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_border(cast[ptr gobject.ParamSpec00](pspec.impl), gstring, propertyValue))

proc gtk_rc_property_parse_color(pspec: ptr gobject.ParamSpec00; gstring: glib.String;
    propertyValue: gobject.Value): gboolean {.
    importc, libprag.}

proc parseColor*(pspec: gobject.ParamSpec; gstring: glib.String;
    propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_color(cast[ptr gobject.ParamSpec00](pspec.impl), gstring, propertyValue))

proc gtk_rc_property_parse_enum(pspec: ptr gobject.ParamSpec00; gstring: glib.String;
    propertyValue: gobject.Value): gboolean {.
    importc, libprag.}

proc parseEnum*(pspec: gobject.ParamSpec; gstring: glib.String;
    propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_enum(cast[ptr gobject.ParamSpec00](pspec.impl), gstring, propertyValue))

proc gtk_rc_property_parse_flags(pspec: ptr gobject.ParamSpec00; gstring: glib.String;
    propertyValue: gobject.Value): gboolean {.
    importc, libprag.}

proc parseFlags*(pspec: gobject.ParamSpec; gstring: glib.String;
    propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_flags(cast[ptr gobject.ParamSpec00](pspec.impl), gstring, propertyValue))

proc gtk_rc_property_parse_requisition(pspec: ptr gobject.ParamSpec00; gstring: glib.String;
    propertyValue: gobject.Value): gboolean {.
    importc, libprag.}

proc parseRequisition*(pspec: gobject.ParamSpec; gstring: glib.String;
    propertyValue: gobject.Value): bool =
  toBool(gtk_rc_property_parse_requisition(cast[ptr gobject.ParamSpec00](pspec.impl), gstring, propertyValue))

type
  RcPropertyParser* = proc (pspec: ptr gobject.ParamSpec00; rcString: glib.String; propertyValue: gobject.Value): gboolean {.cdecl.}

proc gtk_settings_install_property_parser(pspec: ptr gobject.ParamSpec00;
    parser: RcPropertyParser) {.
    importc, libprag.}

proc installPropertyParser*(pspec: gobject.ParamSpec; parser: RcPropertyParser) =
  gtk_settings_install_property_parser(cast[ptr gobject.ParamSpec00](pspec.impl), parser)

type
  RcTokenType* {.size: sizeof(cint), pure.} = enum
    invalid = 270
    `include` = 271
    normal = 272
    active = 273
    prelight = 274
    selected = 275
    insensitive = 276
    fg = 277
    bg = 278
    text = 279
    base = 280
    xthickness = 281
    ythickness = 282
    font = 283
    fontset = 284
    fontName = 285
    bgPixmap = 286
    pixmapPath = 287
    style = 288
    binding = 289
    `bind` = 290
    widget = 291
    widgetClass = 292
    class = 293
    lowest = 294
    gtk = 295
    application = 296
    theme = 297
    rc = 298
    highest = 299
    engine = 300
    modulePath = 301
    imModulePath = 302
    imModuleFile = 303
    stock = 304
    ltr = 305
    rtl = 306
    color = 307
    unbind = 308
    last = 309

type
  RecentChooser00* = object of gobject.Object00
  RecentChooser* = ref object of gobject.Object

proc scItemActivated*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "item-activated", cast[GCallback](p), xdata, nil, cf)

proc scSelectionChanged*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "selection-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_recent_chooser_add_filter(self: ptr RecentChooser00; filter: ptr RecentFilter00) {.
    importc, libprag.}

proc addFilter*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    filter: RecentFilter) =
  gtk_recent_chooser_add_filter(cast[ptr RecentChooser00](self.impl), cast[ptr RecentFilter00](filter.impl))

proc gtk_recent_chooser_get_current_item(self: ptr RecentChooser00): ptr RecentInfo00 {.
    importc, libprag.}

proc getCurrentItem*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): RecentInfo =
  fnew(result, gBoxedFreeGtkRecentInfo)
  result.impl = gtk_recent_chooser_get_current_item(cast[ptr RecentChooser00](self.impl))

proc currentItem*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): RecentInfo =
  fnew(result, gBoxedFreeGtkRecentInfo)
  result.impl = gtk_recent_chooser_get_current_item(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_get_current_uri(self: ptr RecentChooser00): cstring {.
    importc, libprag.}

proc getCurrentUri*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): string =
  let resul0 = gtk_recent_chooser_get_current_uri(cast[ptr RecentChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc currentUri*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): string =
  let resul0 = gtk_recent_chooser_get_current_uri(cast[ptr RecentChooser00](self.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_recent_chooser_get_filter(self: ptr RecentChooser00): ptr RecentFilter00 {.
    importc, libprag.}

proc getFilter*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): RecentFilter =
  let gobj = gtk_recent_chooser_get_filter(cast[ptr RecentChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc filter*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): RecentFilter =
  let gobj = gtk_recent_chooser_get_filter(cast[ptr RecentChooser00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_recent_chooser_get_items(self: ptr RecentChooser00): ptr glib.List {.
    importc, libprag.}

proc getItems*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): seq[RecentInfo] =
  let resul0 = gtk_recent_chooser_get_items(cast[ptr RecentChooser00](self.impl))
  result = glistStructs2seq[RecentInfo](resul0, false)
  g_list_free(resul0)

proc items*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): seq[RecentInfo] =
  let resul0 = gtk_recent_chooser_get_items(cast[ptr RecentChooser00](self.impl))
  result = glistStructs2seq[RecentInfo](resul0, false)
  g_list_free(resul0)

proc gtk_recent_chooser_get_limit(self: ptr RecentChooser00): int32 {.
    importc, libprag.}

proc getLimit*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): int =
  int(gtk_recent_chooser_get_limit(cast[ptr RecentChooser00](self.impl)))

proc limit*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): int =
  int(gtk_recent_chooser_get_limit(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_local_only(self: ptr RecentChooser00): gboolean {.
    importc, libprag.}

proc getLocalOnly*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_local_only(cast[ptr RecentChooser00](self.impl)))

proc localOnly*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_local_only(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_select_multiple(self: ptr RecentChooser00): gboolean {.
    importc, libprag.}

proc getSelectMultiple*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_select_multiple(cast[ptr RecentChooser00](self.impl)))

proc selectMultiple*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_select_multiple(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_icons(self: ptr RecentChooser00): gboolean {.
    importc, libprag.}

proc getShowIcons*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_icons(cast[ptr RecentChooser00](self.impl)))

proc showIcons*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_icons(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_not_found(self: ptr RecentChooser00): gboolean {.
    importc, libprag.}

proc getShowNotFound*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_not_found(cast[ptr RecentChooser00](self.impl)))

proc showNotFound*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_not_found(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_private(self: ptr RecentChooser00): gboolean {.
    importc, libprag.}

proc getShowPrivate*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_private(cast[ptr RecentChooser00](self.impl)))

proc showPrivate*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_private(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_show_tips(self: ptr RecentChooser00): gboolean {.
    importc, libprag.}

proc getShowTips*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_tips(cast[ptr RecentChooser00](self.impl)))

proc showTips*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): bool =
  toBool(gtk_recent_chooser_get_show_tips(cast[ptr RecentChooser00](self.impl)))

proc gtk_recent_chooser_get_uris(self: ptr RecentChooser00; length: var uint64): ptr cstring {.
    importc, libprag.}

proc getUris*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    length: var uint64 = cast[var uint64](nil)): seq[string] =
  let resul0 = gtk_recent_chooser_get_uris(cast[ptr RecentChooser00](self.impl), length)
  if resul0.isNil:
    return
  result = cstringArrayToSeq(resul0)
  g_strfreev(resul0)

proc gtk_recent_chooser_list_filters(self: ptr RecentChooser00): ptr glib.SList {.
    importc, libprag.}

proc listFilters*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): seq[RecentFilter] =
  let resul0 = gtk_recent_chooser_list_filters(cast[ptr RecentChooser00](self.impl))
  result = gslistObjects2seq(RecentFilter, resul0, false)
  g_slist_free(resul0)

proc gtk_recent_chooser_remove_filter(self: ptr RecentChooser00; filter: ptr RecentFilter00) {.
    importc, libprag.}

proc removeFilter*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    filter: RecentFilter) =
  gtk_recent_chooser_remove_filter(cast[ptr RecentChooser00](self.impl), cast[ptr RecentFilter00](filter.impl))

proc gtk_recent_chooser_select_all(self: ptr RecentChooser00) {.
    importc, libprag.}

proc selectAll*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu) =
  gtk_recent_chooser_select_all(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_select_uri(self: ptr RecentChooser00; uri: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc selectUri*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    uri: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_chooser_select_uri(cast[ptr RecentChooser00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_recent_chooser_set_current_uri(self: ptr RecentChooser00; uri: cstring;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc setCurrentUri*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    uri: cstring): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_recent_chooser_set_current_uri(cast[ptr RecentChooser00](self.impl), uri, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_recent_chooser_set_filter(self: ptr RecentChooser00; filter: ptr RecentFilter00) {.
    importc, libprag.}

proc setFilter*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    filter: RecentFilter = nil) =
  gtk_recent_chooser_set_filter(cast[ptr RecentChooser00](self.impl), if filter.isNil: nil else: cast[ptr RecentFilter00](filter.impl))

proc `filter=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    filter: RecentFilter = nil) =
  gtk_recent_chooser_set_filter(cast[ptr RecentChooser00](self.impl), if filter.isNil: nil else: cast[ptr RecentFilter00](filter.impl))

proc gtk_recent_chooser_set_limit(self: ptr RecentChooser00; limit: int32) {.
    importc, libprag.}

proc setLimit*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    limit: int) =
  gtk_recent_chooser_set_limit(cast[ptr RecentChooser00](self.impl), int32(limit))

proc `limit=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    limit: int) =
  gtk_recent_chooser_set_limit(cast[ptr RecentChooser00](self.impl), int32(limit))

proc gtk_recent_chooser_set_local_only(self: ptr RecentChooser00; localOnly: gboolean) {.
    importc, libprag.}

proc setLocalOnly*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    localOnly: bool = true) =
  gtk_recent_chooser_set_local_only(cast[ptr RecentChooser00](self.impl), gboolean(localOnly))

proc `localOnly=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    localOnly: bool) =
  gtk_recent_chooser_set_local_only(cast[ptr RecentChooser00](self.impl), gboolean(localOnly))

proc gtk_recent_chooser_set_select_multiple(self: ptr RecentChooser00; selectMultiple: gboolean) {.
    importc, libprag.}

proc setSelectMultiple*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    selectMultiple: bool = true) =
  gtk_recent_chooser_set_select_multiple(cast[ptr RecentChooser00](self.impl), gboolean(selectMultiple))

proc `selectMultiple=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    selectMultiple: bool) =
  gtk_recent_chooser_set_select_multiple(cast[ptr RecentChooser00](self.impl), gboolean(selectMultiple))

proc gtk_recent_chooser_set_show_icons(self: ptr RecentChooser00; showIcons: gboolean) {.
    importc, libprag.}

proc setShowIcons*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showIcons: bool = true) =
  gtk_recent_chooser_set_show_icons(cast[ptr RecentChooser00](self.impl), gboolean(showIcons))

proc `showIcons=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showIcons: bool) =
  gtk_recent_chooser_set_show_icons(cast[ptr RecentChooser00](self.impl), gboolean(showIcons))

proc gtk_recent_chooser_set_show_not_found(self: ptr RecentChooser00; showNotFound: gboolean) {.
    importc, libprag.}

proc setShowNotFound*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showNotFound: bool = true) =
  gtk_recent_chooser_set_show_not_found(cast[ptr RecentChooser00](self.impl), gboolean(showNotFound))

proc `showNotFound=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showNotFound: bool) =
  gtk_recent_chooser_set_show_not_found(cast[ptr RecentChooser00](self.impl), gboolean(showNotFound))

proc gtk_recent_chooser_set_show_private(self: ptr RecentChooser00; showPrivate: gboolean) {.
    importc, libprag.}

proc setShowPrivate*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showPrivate: bool = true) =
  gtk_recent_chooser_set_show_private(cast[ptr RecentChooser00](self.impl), gboolean(showPrivate))

proc `showPrivate=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showPrivate: bool) =
  gtk_recent_chooser_set_show_private(cast[ptr RecentChooser00](self.impl), gboolean(showPrivate))

proc gtk_recent_chooser_set_show_tips(self: ptr RecentChooser00; showTips: gboolean) {.
    importc, libprag.}

proc setShowTips*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showTips: bool = true) =
  gtk_recent_chooser_set_show_tips(cast[ptr RecentChooser00](self.impl), gboolean(showTips))

proc `showTips=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    showTips: bool) =
  gtk_recent_chooser_set_show_tips(cast[ptr RecentChooser00](self.impl), gboolean(showTips))

proc gtk_recent_chooser_unselect_all(self: ptr RecentChooser00) {.
    importc, libprag.}

proc unselectAll*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu) =
  gtk_recent_chooser_unselect_all(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_unselect_uri(self: ptr RecentChooser00; uri: cstring) {.
    importc, libprag.}

proc unselectUri*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    uri: cstring) =
  gtk_recent_chooser_unselect_uri(cast[ptr RecentChooser00](self.impl), uri)

type
  RecentSortType* {.size: sizeof(cint), pure.} = enum
    none = 0
    mru = 1
    lru = 2
    custom = 3

proc gtk_recent_chooser_get_sort_type(self: ptr RecentChooser00): RecentSortType {.
    importc, libprag.}

proc getSortType*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): RecentSortType =
  gtk_recent_chooser_get_sort_type(cast[ptr RecentChooser00](self.impl))

proc sortType*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu): RecentSortType =
  gtk_recent_chooser_get_sort_type(cast[ptr RecentChooser00](self.impl))

proc gtk_recent_chooser_set_sort_type(self: ptr RecentChooser00; sortType: RecentSortType) {.
    importc, libprag.}

proc setSortType*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    sortType: RecentSortType) =
  gtk_recent_chooser_set_sort_type(cast[ptr RecentChooser00](self.impl), sortType)

proc `sortType=`*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    sortType: RecentSortType) =
  gtk_recent_chooser_set_sort_type(cast[ptr RecentChooser00](self.impl), sortType)

type
  RecentChooserError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    invalidUri = 1

type
  RecentFilterFunc* = proc (filterInfo: RecentFilterInfo; userData: pointer): gboolean {.cdecl.}

proc gtk_recent_filter_add_custom(self: ptr RecentFilter00; needed: RecentFilterFlags;
    `func`: RecentFilterFunc; data: pointer; dataDestroy: DestroyNotify) {.
    importc, libprag.}

proc addCustom*(self: RecentFilter; needed: RecentFilterFlags;
    `func`: RecentFilterFunc; data: pointer; dataDestroy: DestroyNotify) =
  gtk_recent_filter_add_custom(cast[ptr RecentFilter00](self.impl), needed, `func`, data, dataDestroy)

type
  RecentManagerError* {.size: sizeof(cint), pure.} = enum
    notFound = 0
    invalidUri = 1
    invalidEncoding = 2
    notRegistered = 3
    read = 4
    write = 5
    unknown = 6

type
  RecentSortFunc* = proc (a: ptr RecentInfo00; b: ptr RecentInfo00; userData: pointer): int32 {.cdecl.}

proc gtk_recent_chooser_set_sort_func(self: ptr RecentChooser00; sortFunc: RecentSortFunc;
    sortData: pointer; dataDestroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: RecentChooser | RecentChooserWidget | RecentChooserDialog | RecentAction | RecentChooserMenu;
    sortFunc: RecentSortFunc; sortData: pointer; dataDestroy: DestroyNotify) =
  gtk_recent_chooser_set_sort_func(cast[ptr RecentChooser00](self.impl), sortFunc, sortData, dataDestroy)

type
  RequestedSize* {.pure, byRef.} = object
    data*: pointer
    minimumSize*: int32
    naturalSize*: int32

type
  ResponseType* {.size: sizeof(cint), pure.} = enum
    help = -11
    apply = -10
    no = -9
    yes = -8
    close = -7
    cancel = -6
    ok = -5
    deleteEvent = -4
    accept = -3
    reject = -2
    none = -1

const STOCK_ABOUT* = "gtk-about"

const STOCK_ADD* = "gtk-add"

const STOCK_APPLY* = "gtk-apply"

const STOCK_BOLD* = "gtk-bold"

const STOCK_CANCEL* = "gtk-cancel"

const STOCK_CAPS_LOCK_WARNING* = "gtk-caps-lock-warning"

const STOCK_CDROM* = "gtk-cdrom"

const STOCK_CLEAR* = "gtk-clear"

const STOCK_CLOSE* = "gtk-close"

const STOCK_COLOR_PICKER* = "gtk-color-picker"

const STOCK_CONNECT* = "gtk-connect"

const STOCK_CONVERT* = "gtk-convert"

const STOCK_COPY* = "gtk-copy"

const STOCK_CUT* = "gtk-cut"

const STOCK_DELETE* = "gtk-delete"

const STOCK_DIALOG_AUTHENTICATION* = "gtk-dialog-authentication"

const STOCK_DIALOG_ERROR* = "gtk-dialog-error"

const STOCK_DIALOG_INFO* = "gtk-dialog-info"

const STOCK_DIALOG_QUESTION* = "gtk-dialog-question"

const STOCK_DIALOG_WARNING* = "gtk-dialog-warning"

const STOCK_DIRECTORY* = "gtk-directory"

const STOCK_DISCARD* = "gtk-discard"

const STOCK_DISCONNECT* = "gtk-disconnect"

const STOCK_DND* = "gtk-dnd"

const STOCK_DND_MULTIPLE* = "gtk-dnd-multiple"

const STOCK_EDIT* = "gtk-edit"

const STOCK_EXECUTE* = "gtk-execute"

const STOCK_FILE* = "gtk-file"

const STOCK_FIND* = "gtk-find"

const STOCK_FIND_AND_REPLACE* = "gtk-find-and-replace"

const STOCK_FLOPPY* = "gtk-floppy"

const STOCK_FULLSCREEN* = "gtk-fullscreen"

const STOCK_GOTO_BOTTOM* = "gtk-goto-bottom"

const STOCK_GOTO_FIRST* = "gtk-goto-first"

const STOCK_GOTO_LAST* = "gtk-goto-last"

const STOCK_GOTO_TOP* = "gtk-goto-top"

const STOCK_GO_BACK* = "gtk-go-back"

const STOCK_GO_DOWN* = "gtk-go-down"

const STOCK_GO_FORWARD* = "gtk-go-forward"

const STOCK_GO_UP* = "gtk-go-up"

const STOCK_HARDDISK* = "gtk-harddisk"

const STOCK_HELP* = "gtk-help"

const STOCK_HOME* = "gtk-home"

const STOCK_INDENT* = "gtk-indent"

const STOCK_INDEX* = "gtk-index"

const STOCK_INFO* = "gtk-info"

const STOCK_ITALIC* = "gtk-italic"

const STOCK_JUMP_TO* = "gtk-jump-to"

const STOCK_JUSTIFY_CENTER* = "gtk-justify-center"

const STOCK_JUSTIFY_FILL* = "gtk-justify-fill"

const STOCK_JUSTIFY_LEFT* = "gtk-justify-left"

const STOCK_JUSTIFY_RIGHT* = "gtk-justify-right"

const STOCK_LEAVE_FULLSCREEN* = "gtk-leave-fullscreen"

const STOCK_MEDIA_FORWARD* = "gtk-media-forward"

const STOCK_MEDIA_NEXT* = "gtk-media-next"

const STOCK_MEDIA_PAUSE* = "gtk-media-pause"

const STOCK_MEDIA_PLAY* = "gtk-media-play"

const STOCK_MEDIA_PREVIOUS* = "gtk-media-previous"

const STOCK_MEDIA_RECORD* = "gtk-media-record"

const STOCK_MEDIA_REWIND* = "gtk-media-rewind"

const STOCK_MEDIA_STOP* = "gtk-media-stop"

const STOCK_MISSING_IMAGE* = "gtk-missing-image"

const STOCK_NETWORK* = "gtk-network"

const STOCK_NEW* = "gtk-new"

const STOCK_NO* = "gtk-no"

const STOCK_OK* = "gtk-ok"

const STOCK_OPEN* = "gtk-open"

const STOCK_ORIENTATION_LANDSCAPE* = "gtk-orientation-landscape"

const STOCK_ORIENTATION_PORTRAIT* = "gtk-orientation-portrait"

const STOCK_ORIENTATION_REVERSE_LANDSCAPE* = "gtk-orientation-reverse-landscape"

const STOCK_ORIENTATION_REVERSE_PORTRAIT* = "gtk-orientation-reverse-portrait"

const STOCK_PAGE_SETUP* = "gtk-page-setup"

const STOCK_PASTE* = "gtk-paste"

const STOCK_PREFERENCES* = "gtk-preferences"

const STOCK_PRINT* = "gtk-print"

const STOCK_PRINT_ERROR* = "gtk-print-error"

const STOCK_PRINT_PAUSED* = "gtk-print-paused"

const STOCK_PRINT_PREVIEW* = "gtk-print-preview"

const STOCK_PRINT_REPORT* = "gtk-print-report"

const STOCK_PRINT_WARNING* = "gtk-print-warning"

const STOCK_PROPERTIES* = "gtk-properties"

const STOCK_QUIT* = "gtk-quit"

const STOCK_REDO* = "gtk-redo"

const STOCK_REFRESH* = "gtk-refresh"

const STOCK_REMOVE* = "gtk-remove"

const STOCK_REVERT_TO_SAVED* = "gtk-revert-to-saved"

const STOCK_SAVE* = "gtk-save"

const STOCK_SAVE_AS* = "gtk-save-as"

const STOCK_SELECT_ALL* = "gtk-select-all"

const STOCK_SELECT_COLOR* = "gtk-select-color"

const STOCK_SELECT_FONT* = "gtk-select-font"

const STOCK_SORT_ASCENDING* = "gtk-sort-ascending"

const STOCK_SORT_DESCENDING* = "gtk-sort-descending"

const STOCK_SPELL_CHECK* = "gtk-spell-check"

const STOCK_STOP* = "gtk-stop"

const STOCK_STRIKETHROUGH* = "gtk-strikethrough"

const STOCK_UNDELETE* = "gtk-undelete"

const STOCK_UNDERLINE* = "gtk-underline"

const STOCK_UNDO* = "gtk-undo"

const STOCK_UNINDENT* = "gtk-unindent"

const STOCK_YES* = "gtk-yes"

const STOCK_ZOOM_100* = "gtk-zoom-100"

const STOCK_ZOOM_FIT* = "gtk-zoom-fit"

const STOCK_ZOOM_IN* = "gtk-zoom-in"

const STOCK_ZOOM_OUT* = "gtk-zoom-out"

const STYLE_CLASS_ACCELERATOR* = "accelerator"

const STYLE_CLASS_ARROW* = "arrow"

const STYLE_CLASS_BACKGROUND* = "background"

const STYLE_CLASS_BOTTOM* = "bottom"

const STYLE_CLASS_BUTTON* = "button"

const STYLE_CLASS_CALENDAR* = "calendar"

const STYLE_CLASS_CELL* = "cell"

const STYLE_CLASS_CHECK* = "check"

const STYLE_CLASS_COMBOBOX_ENTRY* = "combobox-entry"

const STYLE_CLASS_CONTEXT_MENU* = "context-menu"

const STYLE_CLASS_CSD* = "csd"

const STYLE_CLASS_CURSOR_HANDLE* = "cursor-handle"

const STYLE_CLASS_DEFAULT* = "default"

const STYLE_CLASS_DESTRUCTIVE_ACTION* = "destructive-action"

const STYLE_CLASS_DIM_LABEL* = "dim-label"

const STYLE_CLASS_DND* = "dnd"

const STYLE_CLASS_DOCK* = "dock"

const STYLE_CLASS_ENTRY* = "entry"

const STYLE_CLASS_ERROR* = "error"

const STYLE_CLASS_EXPANDER* = "expander"

const STYLE_CLASS_FLAT* = "flat"

const STYLE_CLASS_FRAME* = "frame"

const STYLE_CLASS_GRIP* = "grip"

const STYLE_CLASS_HEADER* = "header"

const STYLE_CLASS_HIGHLIGHT* = "highlight"

const STYLE_CLASS_HORIZONTAL* = "horizontal"

const STYLE_CLASS_IMAGE* = "image"

const STYLE_CLASS_INFO* = "info"

const STYLE_CLASS_INLINE_TOOLBAR* = "inline-toolbar"

const STYLE_CLASS_INSERTION_CURSOR* = "insertion-cursor"

const STYLE_CLASS_LABEL* = "label"

const STYLE_CLASS_LEFT* = "left"

const STYLE_CLASS_LEVEL_BAR* = "level-bar"

const STYLE_CLASS_LINKED* = "linked"

const STYLE_CLASS_LIST* = "list"

const STYLE_CLASS_LIST_ROW* = "list-row"

const STYLE_CLASS_MARK* = "mark"

const STYLE_CLASS_MENU* = "menu"

const STYLE_CLASS_MENUBAR* = "menubar"

const STYLE_CLASS_MENUITEM* = "menuitem"

const STYLE_CLASS_MESSAGE_DIALOG* = "message-dialog"

const STYLE_CLASS_MONOSPACE* = "monospace"

const STYLE_CLASS_NEEDS_ATTENTION* = "needs-attention"

const STYLE_CLASS_NOTEBOOK* = "notebook"

const STYLE_CLASS_OSD* = "osd"

const STYLE_CLASS_OVERSHOOT* = "overshoot"

const STYLE_CLASS_PANE_SEPARATOR* = "pane-separator"

const STYLE_CLASS_PAPER* = "paper"

const STYLE_CLASS_POPOVER* = "popover"

const STYLE_CLASS_POPUP* = "popup"

const STYLE_CLASS_PRIMARY_TOOLBAR* = "primary-toolbar"

const STYLE_CLASS_PROGRESSBAR* = "progressbar"

const STYLE_CLASS_PULSE* = "pulse"

const STYLE_CLASS_QUESTION* = "question"

const STYLE_CLASS_RADIO* = "radio"

const STYLE_CLASS_RAISED* = "raised"

const STYLE_CLASS_READ_ONLY* = "read-only"

const STYLE_CLASS_RIGHT* = "right"

const STYLE_CLASS_RUBBERBAND* = "rubberband"

const STYLE_CLASS_SCALE* = "scale"

const STYLE_CLASS_SCALE_HAS_MARKS_ABOVE* = "scale-has-marks-above"

const STYLE_CLASS_SCALE_HAS_MARKS_BELOW* = "scale-has-marks-below"

const STYLE_CLASS_SCROLLBAR* = "scrollbar"

const STYLE_CLASS_SCROLLBARS_JUNCTION* = "scrollbars-junction"

const STYLE_CLASS_SEPARATOR* = "separator"

const STYLE_CLASS_SIDEBAR* = "sidebar"

const STYLE_CLASS_SLIDER* = "slider"

const STYLE_CLASS_SPINBUTTON* = "spinbutton"

const STYLE_CLASS_SPINNER* = "spinner"

const STYLE_CLASS_STATUSBAR* = "statusbar"

const STYLE_CLASS_SUBTITLE* = "subtitle"

const STYLE_CLASS_SUGGESTED_ACTION* = "suggested-action"

const STYLE_CLASS_TITLE* = "title"

const STYLE_CLASS_TITLEBAR* = "titlebar"

const STYLE_CLASS_TOOLBAR* = "toolbar"

const STYLE_CLASS_TOOLTIP* = "tooltip"

const STYLE_CLASS_TOP* = "top"

const STYLE_CLASS_TOUCH_SELECTION* = "touch-selection"

const STYLE_CLASS_TROUGH* = "trough"

const STYLE_CLASS_UNDERSHOOT* = "undershoot"

const STYLE_CLASS_VERTICAL* = "vertical"

const STYLE_CLASS_VIEW* = "view"

const STYLE_CLASS_WARNING* = "warning"

const STYLE_CLASS_WIDE* = "wide"

const STYLE_PROPERTY_BACKGROUND_COLOR* = "background-color"

const STYLE_PROPERTY_BACKGROUND_IMAGE* = "background-image"

const STYLE_PROPERTY_BORDER_COLOR* = "border-color"

const STYLE_PROPERTY_BORDER_RADIUS* = "border-radius"

const STYLE_PROPERTY_BORDER_STYLE* = "border-style"

const STYLE_PROPERTY_BORDER_WIDTH* = "border-width"

const STYLE_PROPERTY_COLOR* = "color"

const STYLE_PROPERTY_FONT* = "font"

const STYLE_PROPERTY_MARGIN* = "margin"

const STYLE_PROPERTY_PADDING* = "padding"

const STYLE_PROVIDER_PRIORITY_APPLICATION* = 600'i32

const STYLE_PROVIDER_PRIORITY_FALLBACK* = 1'i32

const STYLE_PROVIDER_PRIORITY_SETTINGS* = 400'i32

const STYLE_PROVIDER_PRIORITY_THEME* = 200'i32

const STYLE_PROVIDER_PRIORITY_USER* = 800'i32

const STYLE_REGION_COLUMN* = "column"

const STYLE_REGION_COLUMN_HEADER* = "column-header"

const STYLE_REGION_ROW* = "row"

const STYLE_REGION_TAB* = "tab"

type
  ScaleAccessible* = ref object of RangeAccessible
  ScaleAccessible00* = object of RangeAccessible00

proc gtk_scale_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScaleAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  Scrollable00* = object of gobject.Object00
  Scrollable* = ref object of gobject.Object

proc gtk_scrollable_get_border(self: ptr Scrollable00; border: var Border): gboolean {.
    importc, libprag.}

proc getBorder*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    border: var Border): bool =
  toBool(gtk_scrollable_get_border(cast[ptr Scrollable00](self.impl), border))

proc gtk_scrollable_get_hadjustment(self: ptr Scrollable00): ptr Adjustment00 {.
    importc, libprag.}

proc getHadjustment*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): Adjustment =
  let gobj = gtk_scrollable_get_hadjustment(cast[ptr Scrollable00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc hadjustment*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): Adjustment =
  let gobj = gtk_scrollable_get_hadjustment(cast[ptr Scrollable00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollable_get_vadjustment(self: ptr Scrollable00): ptr Adjustment00 {.
    importc, libprag.}

proc getVadjustment*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): Adjustment =
  let gobj = gtk_scrollable_get_vadjustment(cast[ptr Scrollable00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc vadjustment*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): Adjustment =
  let gobj = gtk_scrollable_get_vadjustment(cast[ptr Scrollable00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_scrollable_set_hadjustment(self: ptr Scrollable00; hadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setHadjustment*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    hadjustment: Adjustment = nil) =
  gtk_scrollable_set_hadjustment(cast[ptr Scrollable00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc `hadjustment=`*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    hadjustment: Adjustment = nil) =
  gtk_scrollable_set_hadjustment(cast[ptr Scrollable00](self.impl), if hadjustment.isNil: nil else: cast[ptr Adjustment00](hadjustment.impl))

proc gtk_scrollable_set_vadjustment(self: ptr Scrollable00; vadjustment: ptr Adjustment00) {.
    importc, libprag.}

proc setVadjustment*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    vadjustment: Adjustment = nil) =
  gtk_scrollable_set_vadjustment(cast[ptr Scrollable00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

proc `vadjustment=`*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    vadjustment: Adjustment = nil) =
  gtk_scrollable_set_vadjustment(cast[ptr Scrollable00](self.impl), if vadjustment.isNil: nil else: cast[ptr Adjustment00](vadjustment.impl))

type
  ScrollablePolicy* {.size: sizeof(cint), pure.} = enum
    minimum = 0
    natural = 1

proc gtk_scrollable_get_hscroll_policy(self: ptr Scrollable00): ScrollablePolicy {.
    importc, libprag.}

proc getHscrollPolicy*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): ScrollablePolicy =
  gtk_scrollable_get_hscroll_policy(cast[ptr Scrollable00](self.impl))

proc hscrollPolicy*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): ScrollablePolicy =
  gtk_scrollable_get_hscroll_policy(cast[ptr Scrollable00](self.impl))

proc gtk_scrollable_get_vscroll_policy(self: ptr Scrollable00): ScrollablePolicy {.
    importc, libprag.}

proc getVscrollPolicy*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): ScrollablePolicy =
  gtk_scrollable_get_vscroll_policy(cast[ptr Scrollable00](self.impl))

proc vscrollPolicy*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout): ScrollablePolicy =
  gtk_scrollable_get_vscroll_policy(cast[ptr Scrollable00](self.impl))

proc gtk_scrollable_set_hscroll_policy(self: ptr Scrollable00; policy: ScrollablePolicy) {.
    importc, libprag.}

proc setHscrollPolicy*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_hscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc `hscrollPolicy=`*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_hscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc gtk_scrollable_set_vscroll_policy(self: ptr Scrollable00; policy: ScrollablePolicy) {.
    importc, libprag.}

proc setVscrollPolicy*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_vscroll_policy(cast[ptr Scrollable00](self.impl), policy)

proc `vscrollPolicy=`*(self: Scrollable | IconView | Viewport | ToolPalette | TextView | TreeView | Layout;
    policy: ScrollablePolicy) =
  gtk_scrollable_set_vscroll_policy(cast[ptr Scrollable00](self.impl), policy)

type
  ScrolledWindowAccessible* = ref object of ContainerAccessible
  ScrolledWindowAccessible00* = object of ContainerAccessible00

proc gtk_scrolled_window_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ScrolledWindowAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  ShortcutType* {.size: sizeof(cint), pure.} = enum
    accelerator = 0
    gesturePinch = 1
    gestureStretch = 2
    gestureRotateClockwise = 3
    gestureRotateCounterclockwise = 4
    gestureTwoFingerSwipeLeft = 5
    gestureTwoFingerSwipeRight = 6
    gesture = 7

type
  SocketAccessible* = ref object of ContainerAccessible
  SocketAccessible00* = object of ContainerAccessible00

proc gtk_socket_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(SocketAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_socket_accessible_embed(self: ptr SocketAccessible00; path: cstring) {.
    importc, libprag.}

proc embed*(self: SocketAccessible; path: cstring) =
  gtk_socket_accessible_embed(cast[ptr SocketAccessible00](self.impl), path)

type
  StackAccessible* = ref object of ContainerAccessible
  StackAccessible00* = object of ContainerAccessible00

proc gtk_stack_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StackAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  StatusIcon* = ref object of gobject.Object
  StatusIcon00* = object of gobject.Object00

proc gtk_status_icon_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StatusIcon()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc scActivate*(self: StatusIcon;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "activate", cast[GCallback](p), xdata, nil, cf)

proc scButtonPressEvent*(self: StatusIcon;  p: proc (self: ptr StatusIcon00; event: ptr gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "button-press-event", cast[GCallback](p), xdata, nil, cf)

proc scButtonReleaseEvent*(self: StatusIcon;  p: proc (self: ptr StatusIcon00; event: ptr gdk.EventButton00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "button-release-event", cast[GCallback](p), xdata, nil, cf)

proc scPopupMenu*(self: StatusIcon;  p: proc (self: ptr StatusIcon00; button: uint32; activateTime: uint32; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "popup-menu", cast[GCallback](p), xdata, nil, cf)

proc scQueryTooltip*(self: StatusIcon;  p: proc (self: ptr StatusIcon00; x: int32; y: int32; keyboardMode: gboolean; tooltip: ptr Tooltip00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "query-tooltip", cast[GCallback](p), xdata, nil, cf)

proc scScrollEvent*(self: StatusIcon;  p: proc (self: ptr StatusIcon00; event: ptr gdk.EventScroll00; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "scroll-event", cast[GCallback](p), xdata, nil, cf)

proc scSizeChanged*(self: StatusIcon;  p: proc (self: ptr StatusIcon00; size: int32; xdata: pointer): gboolean {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "size-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_status_icon_new(): ptr StatusIcon00 {.
    importc, libprag.}

proc newStatusIcon*(): StatusIcon {.deprecated.}  =
  let gobj = gtk_status_icon_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusIcon*(tdesc: typedesc): tdesc {.deprecated.}  =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIcon*[T](result: var T) {.deprecated.} =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new()
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_file(filename: cstring): ptr StatusIcon00 {.
    importc, libprag.}

proc newStatusIconFromFile*(filename: cstring): StatusIcon {.deprecated.}  =
  let gobj = gtk_status_icon_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusIconFromFile*(tdesc: typedesc; filename: cstring): tdesc {.deprecated.}  =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromFile*[T](result: var T; filename: cstring) {.deprecated.} =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_file(filename)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_gicon(icon: ptr gio.Icon00): ptr StatusIcon00 {.
    importc, libprag.}

proc newStatusIconFromGicon*(icon: gio.Icon): StatusIcon {.deprecated.}  =
  let gobj = gtk_status_icon_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusIconFromGicon*(tdesc: typedesc; icon: gio.Icon): tdesc {.deprecated.}  =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromGicon*[T](result: var T; icon: gio.Icon) {.deprecated.} =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_gicon(cast[ptr gio.Icon00](icon.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_icon_name(iconName: cstring): ptr StatusIcon00 {.
    importc, libprag.}

proc newStatusIconFromIconName*(iconName: cstring): StatusIcon {.deprecated.}  =
  let gobj = gtk_status_icon_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusIconFromIconName*(tdesc: typedesc; iconName: cstring): tdesc {.deprecated.}  =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromIconName*[T](result: var T; iconName: cstring) {.deprecated.} =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_icon_name(iconName)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_pixbuf(pixbuf: ptr gdkpixbuf.Pixbuf00): ptr StatusIcon00 {.
    importc, libprag.}

proc newStatusIconFromPixbuf*(pixbuf: gdkpixbuf.Pixbuf): StatusIcon {.deprecated.}  =
  let gobj = gtk_status_icon_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusIconFromPixbuf*(tdesc: typedesc; pixbuf: gdkpixbuf.Pixbuf): tdesc {.deprecated.}  =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromPixbuf*[T](result: var T; pixbuf: gdkpixbuf.Pixbuf) {.deprecated.} =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_pixbuf(cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_new_from_stock(stockId: cstring): ptr StatusIcon00 {.
    importc, libprag.}

proc newStatusIconFromStock*(stockId: cstring): StatusIcon {.deprecated.}  =
  let gobj = gtk_status_icon_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc newStatusIconFromStock*(tdesc: typedesc; stockId: cstring): tdesc {.deprecated.}  =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initStatusIconFromStock*[T](result: var T; stockId: cstring) {.deprecated.} =
  assert(result is StatusIcon)
  let gobj = gtk_status_icon_new_from_stock(stockId)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_position_menu(menu: ptr Menu00; x: var int32; y: var int32;
    pushIn: var gboolean; userData: ptr StatusIcon00) {.
    importc, libprag.}

proc positionMenu*(menu: Menu; x: var int; y: var int; pushIn: var bool;
    userData: StatusIcon) =
  var y_00 = int32(y)
  var x_00 = int32(x)
  var pushIn_00: gboolean
  gtk_status_icon_position_menu(cast[ptr Menu00](menu.impl), x_00, y_00, pushIn_00, cast[ptr StatusIcon00](userData.impl))
  y = int(y_00)
  x = int(x_00)
  if pushIn.addr != nil:
    pushIn = toBool(pushIn_00)

proc gtk_status_icon_get_geometry(self: ptr StatusIcon00; screen: var ptr gdk.Screen00;
    area: var gdk.Rectangle; orientation: var Orientation): gboolean {.
    importc, libprag.}

proc getGeometry*(self: StatusIcon; screen: var gdk.Screen = cast[var gdk.Screen](nil);
    area: var gdk.Rectangle = cast[var gdk.Rectangle](nil); orientation: var Orientation = cast[var Orientation](nil)): bool =
  var tmpoutgobjectarg: ptr gdk.Screen00
  result = toBool(gtk_status_icon_get_geometry(cast[ptr StatusIcon00](self.impl), cast[var ptr gdk.Screen00](if addr(screen) == nil: nil else: addr tmpoutgobjectarg), area, orientation))
#  dothemagic(screen
  if addr(screen) != nil:
    screen = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      screen = cast[type(screen)](argqdata)
      assert(screen.impl == tmpoutgobjectarg)
    else:
      fnew(screen, gtk.finalizeGObject)
      screen.impl = tmpoutgobjectarg
      GC_ref(screen)
      if g_object_is_floating(screen.impl).int != 0:
        discard g_object_ref_sink(screen.impl)
      g_object_add_toggle_ref(screen.impl, toggleNotify, addr(screen[]))
      g_object_unref(screen.impl)
      assert(g_object_get_qdata(screen.impl, Quark) == nil)
      g_object_set_qdata(screen.impl, Quark, addr(screen[]))


proc gtk_status_icon_get_gicon(self: ptr StatusIcon00): ptr gio.Icon00 {.
    importc, libprag.}

proc getGicon*(self: StatusIcon): gio.Icon =
  let gobj = gtk_status_icon_get_gicon(cast[ptr StatusIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gicon*(self: StatusIcon): gio.Icon =
  let gobj = gtk_status_icon_get_gicon(cast[ptr StatusIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_get_has_tooltip(self: ptr StatusIcon00): gboolean {.
    importc, libprag.}

proc getHasTooltip*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_has_tooltip(cast[ptr StatusIcon00](self.impl)))

proc hasTooltip*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_has_tooltip(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_get_icon_name(self: ptr StatusIcon00): cstring {.
    importc, libprag.}

proc getIconName*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_icon_name(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc iconName*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_icon_name(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_status_icon_get_pixbuf(self: ptr StatusIcon00): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc getPixbuf*(self: StatusIcon): gdkpixbuf.Pixbuf =
  let gobj = gtk_status_icon_get_pixbuf(cast[ptr StatusIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc pixbuf*(self: StatusIcon): gdkpixbuf.Pixbuf =
  let gobj = gtk_status_icon_get_pixbuf(cast[ptr StatusIcon00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_get_screen(self: ptr StatusIcon00): ptr gdk.Screen00 {.
    importc, libprag.}

proc getScreen*(self: StatusIcon): gdk.Screen =
  let gobj = gtk_status_icon_get_screen(cast[ptr StatusIcon00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: StatusIcon): gdk.Screen =
  let gobj = gtk_status_icon_get_screen(cast[ptr StatusIcon00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_status_icon_get_size(self: ptr StatusIcon00): int32 {.
    importc, libprag.}

proc getSize*(self: StatusIcon): int =
  int(gtk_status_icon_get_size(cast[ptr StatusIcon00](self.impl)))

proc size*(self: StatusIcon): int =
  int(gtk_status_icon_get_size(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_get_stock(self: ptr StatusIcon00): cstring {.
    importc, libprag.}

proc getStock*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_stock(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc stock*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_stock(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_status_icon_get_storage_type(self: ptr StatusIcon00): ImageType {.
    importc, libprag.}

proc getStorageType*(self: StatusIcon): ImageType =
  gtk_status_icon_get_storage_type(cast[ptr StatusIcon00](self.impl))

proc storageType*(self: StatusIcon): ImageType =
  gtk_status_icon_get_storage_type(cast[ptr StatusIcon00](self.impl))

proc gtk_status_icon_get_title(self: ptr StatusIcon00): cstring {.
    importc, libprag.}

proc getTitle*(self: StatusIcon): string =
  result = $gtk_status_icon_get_title(cast[ptr StatusIcon00](self.impl))

proc title*(self: StatusIcon): string =
  result = $gtk_status_icon_get_title(cast[ptr StatusIcon00](self.impl))

proc gtk_status_icon_get_tooltip_markup(self: ptr StatusIcon00): cstring {.
    importc, libprag.}

proc getTooltipMarkup*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_markup(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc tooltipMarkup*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_markup(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_status_icon_get_tooltip_text(self: ptr StatusIcon00): cstring {.
    importc, libprag.}

proc getTooltipText*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_text(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc tooltipText*(self: StatusIcon): string =
  let resul0 = gtk_status_icon_get_tooltip_text(cast[ptr StatusIcon00](self.impl))
  if resul0.isNil:
    return
  result = $resul0
  cogfree(resul0)

proc gtk_status_icon_get_visible(self: ptr StatusIcon00): gboolean {.
    importc, libprag.}

proc getVisible*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_visible(cast[ptr StatusIcon00](self.impl)))

proc visible*(self: StatusIcon): bool =
  toBool(gtk_status_icon_get_visible(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_get_x11_window_id(self: ptr StatusIcon00): uint32 {.
    importc, libprag.}

proc getX11WindowId*(self: StatusIcon): int =
  int(gtk_status_icon_get_x11_window_id(cast[ptr StatusIcon00](self.impl)))

proc x11WindowId*(self: StatusIcon): int =
  int(gtk_status_icon_get_x11_window_id(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_is_embedded(self: ptr StatusIcon00): gboolean {.
    importc, libprag.}

proc isEmbedded*(self: StatusIcon): bool =
  toBool(gtk_status_icon_is_embedded(cast[ptr StatusIcon00](self.impl)))

proc gtk_status_icon_set_from_file(self: ptr StatusIcon00; filename: cstring) {.
    importc, libprag.}

proc setFromFile*(self: StatusIcon; filename: cstring) =
  gtk_status_icon_set_from_file(cast[ptr StatusIcon00](self.impl), filename)

proc `fromFile=`*(self: StatusIcon; filename: cstring) =
  gtk_status_icon_set_from_file(cast[ptr StatusIcon00](self.impl), filename)

proc gtk_status_icon_set_from_gicon(self: ptr StatusIcon00; icon: ptr gio.Icon00) {.
    importc, libprag.}

proc setFromGicon*(self: StatusIcon; icon: gio.Icon) =
  gtk_status_icon_set_from_gicon(cast[ptr StatusIcon00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc `fromGicon=`*(self: StatusIcon; icon: gio.Icon) =
  gtk_status_icon_set_from_gicon(cast[ptr StatusIcon00](self.impl), cast[ptr gio.Icon00](icon.impl))

proc gtk_status_icon_set_from_icon_name(self: ptr StatusIcon00; iconName: cstring) {.
    importc, libprag.}

proc setFromIconName*(self: StatusIcon; iconName: cstring) =
  gtk_status_icon_set_from_icon_name(cast[ptr StatusIcon00](self.impl), iconName)

proc `fromIconName=`*(self: StatusIcon; iconName: cstring) =
  gtk_status_icon_set_from_icon_name(cast[ptr StatusIcon00](self.impl), iconName)

proc gtk_status_icon_set_from_pixbuf(self: ptr StatusIcon00; pixbuf: ptr gdkpixbuf.Pixbuf00) {.
    importc, libprag.}

proc setFromPixbuf*(self: StatusIcon; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_status_icon_set_from_pixbuf(cast[ptr StatusIcon00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc `fromPixbuf=`*(self: StatusIcon; pixbuf: gdkpixbuf.Pixbuf = nil) =
  gtk_status_icon_set_from_pixbuf(cast[ptr StatusIcon00](self.impl), if pixbuf.isNil: nil else: cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl))

proc gtk_status_icon_set_from_stock(self: ptr StatusIcon00; stockId: cstring) {.
    importc, libprag.}

proc setFromStock*(self: StatusIcon; stockId: cstring) =
  gtk_status_icon_set_from_stock(cast[ptr StatusIcon00](self.impl), stockId)

proc `fromStock=`*(self: StatusIcon; stockId: cstring) =
  gtk_status_icon_set_from_stock(cast[ptr StatusIcon00](self.impl), stockId)

proc gtk_status_icon_set_has_tooltip(self: ptr StatusIcon00; hasTooltip: gboolean) {.
    importc, libprag.}

proc setHasTooltip*(self: StatusIcon; hasTooltip: bool = true) =
  gtk_status_icon_set_has_tooltip(cast[ptr StatusIcon00](self.impl), gboolean(hasTooltip))

proc `hasTooltip=`*(self: StatusIcon; hasTooltip: bool) =
  gtk_status_icon_set_has_tooltip(cast[ptr StatusIcon00](self.impl), gboolean(hasTooltip))

proc gtk_status_icon_set_name(self: ptr StatusIcon00; name: cstring) {.
    importc, libprag.}

proc setName*(self: StatusIcon; name: cstring) =
  gtk_status_icon_set_name(cast[ptr StatusIcon00](self.impl), name)

proc `name=`*(self: StatusIcon; name: cstring) =
  gtk_status_icon_set_name(cast[ptr StatusIcon00](self.impl), name)

proc gtk_status_icon_set_screen(self: ptr StatusIcon00; screen: ptr gdk.Screen00) {.
    importc, libprag.}

proc setScreen*(self: StatusIcon; screen: gdk.Screen) =
  gtk_status_icon_set_screen(cast[ptr StatusIcon00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc `screen=`*(self: StatusIcon; screen: gdk.Screen) =
  gtk_status_icon_set_screen(cast[ptr StatusIcon00](self.impl), cast[ptr gdk.Screen00](screen.impl))

proc gtk_status_icon_set_title(self: ptr StatusIcon00; title: cstring) {.
    importc, libprag.}

proc setTitle*(self: StatusIcon; title: cstring) =
  gtk_status_icon_set_title(cast[ptr StatusIcon00](self.impl), title)

proc `title=`*(self: StatusIcon; title: cstring) =
  gtk_status_icon_set_title(cast[ptr StatusIcon00](self.impl), title)

proc gtk_status_icon_set_tooltip_markup(self: ptr StatusIcon00; markup: cstring) {.
    importc, libprag.}

proc setTooltipMarkup*(self: StatusIcon; markup: cstring = nil) =
  gtk_status_icon_set_tooltip_markup(cast[ptr StatusIcon00](self.impl), markup)

proc `tooltipMarkup=`*(self: StatusIcon; markup: cstring = nil) =
  gtk_status_icon_set_tooltip_markup(cast[ptr StatusIcon00](self.impl), markup)

proc gtk_status_icon_set_tooltip_text(self: ptr StatusIcon00; text: cstring) {.
    importc, libprag.}

proc setTooltipText*(self: StatusIcon; text: cstring) =
  gtk_status_icon_set_tooltip_text(cast[ptr StatusIcon00](self.impl), text)

proc `tooltipText=`*(self: StatusIcon; text: cstring) =
  gtk_status_icon_set_tooltip_text(cast[ptr StatusIcon00](self.impl), text)

proc gtk_status_icon_set_visible(self: ptr StatusIcon00; visible: gboolean) {.
    importc, libprag.}

proc setVisible*(self: StatusIcon; visible: bool = true) =
  gtk_status_icon_set_visible(cast[ptr StatusIcon00](self.impl), gboolean(visible))

proc `visible=`*(self: StatusIcon; visible: bool) =
  gtk_status_icon_set_visible(cast[ptr StatusIcon00](self.impl), gboolean(visible))

type
  StatusbarAccessible* = ref object of ContainerAccessible
  StatusbarAccessible00* = object of ContainerAccessible00

proc gtk_statusbar_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(StatusbarAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  StockItem* {.pure, byRef.} = object
    stockId*: cstring
    label*: cstring
    modifier*: gdk.ModifierType
    keyval*: uint32
    translationDomain*: cstring

proc gtk_stock_item_free(self: StockItem) {.
    importc, libprag.}

proc free*(self: StockItem) =
  gtk_stock_item_free(self)

type
  StylePropertyParser* = proc (string: cstring; value: gobject.Value; error: ptr ptr glib.Error = nil): gboolean {.cdecl.}

const TEXT_VIEW_PRIORITY_VALIDATE* = 125'i32

const TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID* = -1'i32

const TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID* = -2'i32

type
  TableChild* {.pure, byRef.} = object
    widget*: ptr Widget00
    leftAttach*: uint16
    rightAttach*: uint16
    topAttach*: uint16
    bottomAttach*: uint16
    xpadding*: uint16
    ypadding*: uint16
    xexpand*: uint32
    yexpand*: uint32
    xshrink*: uint32
    yshrink*: uint32
    xfill*: uint32
    yfill*: uint32

type
  TableRowCol00* {.pure.} = object
  TableRowCol* = ref object
    impl*: ptr TableRowCol00
    ignoreFinalizer*: bool

type
  TargetFlag* {.size: sizeof(cint), pure.} = enum
    sameApp = 0
    sameWidget = 1
    otherApp = 2
    otherWidget = 3

  TargetFlags* {.size: sizeof(cint).} = set[TargetFlag]

type
  TargetPair* {.pure, byRef.} = object
    target*: ptr gdk.Atom00
    flags*: uint32
    info*: uint32

type
  TextAppearance00* {.pure.} = object
  TextAppearance* = ref object
    impl*: ptr TextAppearance00
    ignoreFinalizer*: bool

type
  TextBTree00* {.pure.} = object
  TextBTree* = ref object
    impl*: ptr TextBTree00
    ignoreFinalizer*: bool

type
  TextBufferDeserializeFunc* = proc (registerBuffer: ptr TextBuffer00; contentBuffer: ptr TextBuffer00;
    iter: TextIter; data: ptr uint8; length: uint64; createTags: gboolean;
    userData: pointer; error: ptr ptr glib.Error = nil): gboolean {.cdecl.}

proc gtk_text_buffer_register_deserialize_format(self: ptr TextBuffer00;
    mimeType: cstring; function: TextBufferDeserializeFunc; userData: pointer;
    userDataDestroy: DestroyNotify): ptr gdk.Atom00 {.
    importc, libprag.}

proc registerDeserializeFormat*(self: TextBuffer; mimeType: cstring;
    function: TextBufferDeserializeFunc; userData: pointer; userDataDestroy: DestroyNotify): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_deserialize_format(cast[ptr TextBuffer00](self.impl), mimeType, function, userData, userDataDestroy)
  result.ignoreFinalizer = true

type
  TextBufferSerializeFunc* = proc (registerBuffer: ptr TextBuffer00; contentBuffer: ptr TextBuffer00;
    start: TextIter; `end`: TextIter; length: ptr uint64; userData: pointer): ptr uint8 {.cdecl.}

proc gtk_text_buffer_register_serialize_format(self: ptr TextBuffer00; mimeType: cstring;
    function: TextBufferSerializeFunc; userData: pointer; userDataDestroy: DestroyNotify): ptr gdk.Atom00 {.
    importc, libprag.}

proc registerSerializeFormat*(self: TextBuffer; mimeType: cstring;
    function: TextBufferSerializeFunc; userData: pointer; userDataDestroy: DestroyNotify): gdk.Atom =
  new(result)
  result.impl = gtk_text_buffer_register_serialize_format(cast[ptr TextBuffer00](self.impl), mimeType, function, userData, userDataDestroy)
  result.ignoreFinalizer = true

type
  TextBufferTargetInfo* {.size: sizeof(cint), pure.} = enum
    text = -3
    richText = -2
    bufferContents = -1

type
  TextCharPredicate* = proc (ch: gunichar; userData: pointer): gboolean {.cdecl.}

proc gtk_text_iter_backward_find_char(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter): gboolean {.
    importc, libprag.}

proc backwardFindChar*(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_backward_find_char(self, pred, userData, limit))

proc gtk_text_iter_forward_find_char(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter): gboolean {.
    importc, libprag.}

proc forwardFindChar*(self: TextIter; pred: TextCharPredicate;
    userData: pointer; limit: TextIter = cast[var TextIter](nil)): bool =
  toBool(gtk_text_iter_forward_find_char(self, pred, userData, limit))

type
  TextTagTableForeach* = proc (tag: ptr TextTag00; data: pointer) {.cdecl.}

proc gtk_text_tag_table_foreach(self: ptr TextTagTable00; `func`: TextTagTableForeach;
    data: pointer) {.
    importc, libprag.}

proc foreach*(self: TextTagTable; `func`: TextTagTableForeach;
    data: pointer) =
  gtk_text_tag_table_foreach(cast[ptr TextTagTable00](self.impl), `func`, data)

type
  TextViewAccessible* = ref object of ContainerAccessible
  TextViewAccessible00* = object of ContainerAccessible00

proc gtk_text_view_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TextViewAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

type
  TextViewLayer* {.size: sizeof(cint), pure.} = enum
    below = 0
    above = 1
    belowText = 2
    aboveText = 3

type
  ThemeEngine00* {.pure.} = object
  ThemeEngine* = ref object
    impl*: ptr ThemeEngine00
    ignoreFinalizer*: bool

type
  ThemingEngine* = ref object of gobject.Object
  ThemingEngine00* = object of gobject.Object00

proc gtk_theming_engine_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ThemingEngine()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_theming_engine_load(name: cstring): ptr ThemingEngine00 {.
    importc, libprag.}

proc load*(name: cstring): ThemingEngine =
  let gobj = gtk_theming_engine_load(name)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_theming_engine_get_background_color(self: ptr ThemingEngine00; state: StateFlags;
    color: var gdk.RGBA) {.
    importc, libprag.}

proc getBackgroundColor*(self: ThemingEngine; state: StateFlags;
    color: var gdk.RGBA) =
  gtk_theming_engine_get_background_color(cast[ptr ThemingEngine00](self.impl), state, color)

proc gtk_theming_engine_get_border(self: ptr ThemingEngine00; state: StateFlags;
    border: var Border) {.
    importc, libprag.}

proc getBorder*(self: ThemingEngine; state: StateFlags;
    border: var Border) =
  gtk_theming_engine_get_border(cast[ptr ThemingEngine00](self.impl), state, border)

proc gtk_theming_engine_get_border_color(self: ptr ThemingEngine00; state: StateFlags;
    color: var gdk.RGBA) {.
    importc, libprag.}

proc getBorderColor*(self: ThemingEngine; state: StateFlags;
    color: var gdk.RGBA) =
  gtk_theming_engine_get_border_color(cast[ptr ThemingEngine00](self.impl), state, color)

proc gtk_theming_engine_get_color(self: ptr ThemingEngine00; state: StateFlags;
    color: var gdk.RGBA) {.
    importc, libprag.}

proc getColor*(self: ThemingEngine; state: StateFlags;
    color: var gdk.RGBA) =
  gtk_theming_engine_get_color(cast[ptr ThemingEngine00](self.impl), state, color)

proc gtk_theming_engine_get_direction(self: ptr ThemingEngine00): TextDirection {.
    importc, libprag.}

proc getDirection*(self: ThemingEngine): TextDirection =
  gtk_theming_engine_get_direction(cast[ptr ThemingEngine00](self.impl))

proc direction*(self: ThemingEngine): TextDirection =
  gtk_theming_engine_get_direction(cast[ptr ThemingEngine00](self.impl))

proc gtk_theming_engine_get_font(self: ptr ThemingEngine00; state: StateFlags): ptr pango.FontDescription00 {.
    importc, libprag.}

proc getFont*(self: ThemingEngine; state: StateFlags): pango.FontDescription =
  fnew(result, gBoxedFreePangoFontDescription)
  result.impl = gtk_theming_engine_get_font(cast[ptr ThemingEngine00](self.impl), state)
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_font_description_get_type(), result.impl))

proc gtk_theming_engine_get_junction_sides(self: ptr ThemingEngine00): JunctionSides {.
    importc, libprag.}

proc getJunctionSides*(self: ThemingEngine): JunctionSides =
  gtk_theming_engine_get_junction_sides(cast[ptr ThemingEngine00](self.impl))

proc junctionSides*(self: ThemingEngine): JunctionSides =
  gtk_theming_engine_get_junction_sides(cast[ptr ThemingEngine00](self.impl))

proc gtk_theming_engine_get_margin(self: ptr ThemingEngine00; state: StateFlags;
    margin: var Border) {.
    importc, libprag.}

proc getMargin*(self: ThemingEngine; state: StateFlags;
    margin: var Border) =
  gtk_theming_engine_get_margin(cast[ptr ThemingEngine00](self.impl), state, margin)

proc gtk_theming_engine_get_padding(self: ptr ThemingEngine00; state: StateFlags;
    padding: var Border) {.
    importc, libprag.}

proc getPadding*(self: ThemingEngine; state: StateFlags;
    padding: var Border) =
  gtk_theming_engine_get_padding(cast[ptr ThemingEngine00](self.impl), state, padding)

proc gtk_theming_engine_get_path(self: ptr ThemingEngine00): ptr WidgetPath00 {.
    importc, libprag.}

proc getPath*(self: ThemingEngine): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_theming_engine_get_path(cast[ptr ThemingEngine00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_widget_path_get_type(), result.impl))

proc path*(self: ThemingEngine): WidgetPath =
  fnew(result, gBoxedFreeGtkWidgetPath)
  result.impl = gtk_theming_engine_get_path(cast[ptr ThemingEngine00](self.impl))
  result.impl = cast[typeof(result.impl)](g_boxed_copy(gtk_widget_path_get_type(), result.impl))

proc gtk_theming_engine_get_property(self: ptr ThemingEngine00; property: cstring;
    state: StateFlags; value: var gobject.Value) {.
    importc, libprag.}

proc getProperty*(self: ThemingEngine; property: cstring;
    state: StateFlags; value: var gobject.Value) =
  gtk_theming_engine_get_property(cast[ptr ThemingEngine00](self.impl), property, state, value)

proc gtk_theming_engine_get_screen(self: ptr ThemingEngine00): ptr gdk.Screen00 {.
    importc, libprag.}

proc getScreen*(self: ThemingEngine): gdk.Screen =
  let gobj = gtk_theming_engine_get_screen(cast[ptr ThemingEngine00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc screen*(self: ThemingEngine): gdk.Screen =
  let gobj = gtk_theming_engine_get_screen(cast[ptr ThemingEngine00](self.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_theming_engine_get_state(self: ptr ThemingEngine00): StateFlags {.
    importc, libprag.}

proc getState*(self: ThemingEngine): StateFlags =
  gtk_theming_engine_get_state(cast[ptr ThemingEngine00](self.impl))

proc state*(self: ThemingEngine): StateFlags =
  gtk_theming_engine_get_state(cast[ptr ThemingEngine00](self.impl))

proc gtk_theming_engine_get_style_property(self: ptr ThemingEngine00; propertyName: cstring;
    value: var gobject.Value) {.
    importc, libprag.}

proc getStyleProperty*(self: ThemingEngine; propertyName: cstring;
    value: var gobject.Value) =
  gtk_theming_engine_get_style_property(cast[ptr ThemingEngine00](self.impl), propertyName, value)

proc gtk_theming_engine_has_class(self: ptr ThemingEngine00; styleClass: cstring): gboolean {.
    importc, libprag.}

proc hasClass*(self: ThemingEngine; styleClass: cstring): bool =
  toBool(gtk_theming_engine_has_class(cast[ptr ThemingEngine00](self.impl), styleClass))

proc gtk_theming_engine_has_region(self: ptr ThemingEngine00; styleRegion: cstring;
    flags: var RegionFlags): gboolean {.
    importc, libprag.}

proc hasRegion*(self: ThemingEngine; styleRegion: cstring;
    flags: var RegionFlags = cast[var RegionFlags](nil)): bool =
  toBool(gtk_theming_engine_has_region(cast[ptr ThemingEngine00](self.impl), styleRegion, flags))

proc gtk_theming_engine_lookup_color(self: ptr ThemingEngine00; colorName: cstring;
    color: var gdk.RGBA): gboolean {.
    importc, libprag.}

proc lookupColor*(self: ThemingEngine; colorName: cstring;
    color: var gdk.RGBA): bool =
  toBool(gtk_theming_engine_lookup_color(cast[ptr ThemingEngine00](self.impl), colorName, color))

proc gtk_theming_engine_state_is_running(self: ptr ThemingEngine00; state: StateType;
    progress: var cdouble): gboolean {.
    importc, libprag.}

proc stateIsRunning*(self: ThemingEngine; state: StateType;
    progress: var cdouble): bool =
  toBool(gtk_theming_engine_state_is_running(cast[ptr ThemingEngine00](self.impl), state, progress))

type
  TickCallback* = proc (widget: ptr Widget00; frameClock: ptr gdk.FrameClock00; userData: pointer): gboolean {.cdecl.}

proc gtk_widget_add_tick_callback(self: ptr Widget00; callback: TickCallback;
    userData: pointer; notify: DestroyNotify): uint32 {.
    importc, libprag.}

proc addTickCallback*(self: Widget; callback: TickCallback; userData: pointer;
    notify: DestroyNotify): int =
  int(gtk_widget_add_tick_callback(cast[ptr Widget00](self.impl), callback, userData, notify))

type
  ToggleActionEntry00* {.pure.} = object
  ToggleActionEntry* = ref object
    impl*: ptr ToggleActionEntry00
    ignoreFinalizer*: bool

type
  ToolShell00* = object of gobject.Object00
  ToolShell* = ref object of gobject.Object

proc gtk_tool_shell_get_ellipsize_mode(self: ptr ToolShell00): pango.EllipsizeMode {.
    importc, libprag.}

proc getEllipsizeMode*(self: ToolShell | Toolbar | ToolItemGroup): pango.EllipsizeMode =
  gtk_tool_shell_get_ellipsize_mode(cast[ptr ToolShell00](self.impl))

proc ellipsizeMode*(self: ToolShell | Toolbar | ToolItemGroup): pango.EllipsizeMode =
  gtk_tool_shell_get_ellipsize_mode(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_icon_size(self: ptr ToolShell00): int32 {.
    importc, libprag.}

proc getIconSize*(self: ToolShell | Toolbar | ToolItemGroup): int =
  int(gtk_tool_shell_get_icon_size(cast[ptr ToolShell00](self.impl)))

proc iconSize*(self: ToolShell | Toolbar | ToolItemGroup): int =
  int(gtk_tool_shell_get_icon_size(cast[ptr ToolShell00](self.impl)))

proc gtk_tool_shell_get_orientation(self: ptr ToolShell00): Orientation {.
    importc, libprag.}

proc getOrientation*(self: ToolShell | Toolbar | ToolItemGroup): Orientation =
  gtk_tool_shell_get_orientation(cast[ptr ToolShell00](self.impl))

proc orientation*(self: ToolShell | Toolbar | ToolItemGroup): Orientation =
  gtk_tool_shell_get_orientation(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_relief_style(self: ptr ToolShell00): ReliefStyle {.
    importc, libprag.}

proc getReliefStyle*(self: ToolShell | Toolbar | ToolItemGroup): ReliefStyle =
  gtk_tool_shell_get_relief_style(cast[ptr ToolShell00](self.impl))

proc reliefStyle*(self: ToolShell | Toolbar | ToolItemGroup): ReliefStyle =
  gtk_tool_shell_get_relief_style(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_style(self: ptr ToolShell00): ToolbarStyle {.
    importc, libprag.}

proc getStyle*(self: ToolShell | Toolbar | ToolItemGroup): ToolbarStyle =
  gtk_tool_shell_get_style(cast[ptr ToolShell00](self.impl))

proc style*(self: ToolShell | Toolbar | ToolItemGroup): ToolbarStyle =
  gtk_tool_shell_get_style(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_text_alignment(self: ptr ToolShell00): cfloat {.
    importc, libprag.}

proc getTextAlignment*(self: ToolShell | Toolbar | ToolItemGroup): cfloat =
  gtk_tool_shell_get_text_alignment(cast[ptr ToolShell00](self.impl))

proc textAlignment*(self: ToolShell | Toolbar | ToolItemGroup): cfloat =
  gtk_tool_shell_get_text_alignment(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_text_orientation(self: ptr ToolShell00): Orientation {.
    importc, libprag.}

proc getTextOrientation*(self: ToolShell | Toolbar | ToolItemGroup): Orientation =
  gtk_tool_shell_get_text_orientation(cast[ptr ToolShell00](self.impl))

proc textOrientation*(self: ToolShell | Toolbar | ToolItemGroup): Orientation =
  gtk_tool_shell_get_text_orientation(cast[ptr ToolShell00](self.impl))

proc gtk_tool_shell_get_text_size_group(self: ptr ToolShell00): ptr SizeGroup00 {.
    importc, libprag.}

proc getTextSizeGroup*(self: ToolShell | Toolbar | ToolItemGroup): SizeGroup =
  let gobj = gtk_tool_shell_get_text_size_group(cast[ptr ToolShell00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc textSizeGroup*(self: ToolShell | Toolbar | ToolItemGroup): SizeGroup =
  let gobj = gtk_tool_shell_get_text_size_group(cast[ptr ToolShell00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tool_shell_rebuild_menu(self: ptr ToolShell00) {.
    importc, libprag.}

proc rebuildMenu*(self: ToolShell | Toolbar | ToolItemGroup) =
  gtk_tool_shell_rebuild_menu(cast[ptr ToolShell00](self.impl))

type
  ToolbarSpaceStyle* {.size: sizeof(cint), pure.} = enum
    empty = 0
    line = 1

type
  ToplevelAccessible* = ref object of atk.Object
  ToplevelAccessible00* = object of atk.Object00

proc gtk_toplevel_accessible_get_type*(): GType {.importc, libprag.}

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(ToplevelAccessible()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    g_object_set_qdata(self.impl, Quark, nil)
    if not self.ignoreFinalizer and self.impl != nil:
      g_object_remove_toggle_ref(self.impl, toggleNotify, addr(self))
      self.impl = nil

proc gtk_toplevel_accessible_get_children(self: ptr ToplevelAccessible00): ptr glib.List {.
    importc, libprag.}

proc getChildren*(self: ToplevelAccessible): seq[Window] =
  result = glistObjects2seq(Window, gtk_toplevel_accessible_get_children(cast[ptr ToplevelAccessible00](self.impl)), false)

proc children*(self: ToplevelAccessible): seq[Window] =
  result = glistObjects2seq(Window, gtk_toplevel_accessible_get_children(cast[ptr ToplevelAccessible00](self.impl)), false)

type
  TranslateFunc* = proc (path: cstring; funcData: pointer): cstring {.cdecl.}

proc gtk_action_group_set_translate_func(self: ptr ActionGroup00; `func`: TranslateFunc;
    data: pointer; notify: DestroyNotify) {.
    importc, libprag.}

proc setTranslateFunc*(self: ActionGroup | gio.SimpleActionGroup | Application | ApplicationWindow;
    `func`: TranslateFunc; data: pointer; notify: DestroyNotify) =
  gtk_action_group_set_translate_func(cast[ptr ActionGroup00](self.impl), `func`, data, notify)

type
  TreeCellDataFunc* = proc (treeColumn: ptr TreeViewColumn00; cell: ptr CellRenderer00; treeModel: ptr TreeModel00;
    iter: TreeIter; data: pointer) {.cdecl.}

proc gtk_tree_view_column_set_cell_data_func(self: ptr TreeViewColumn00;
    cellRenderer: ptr CellRenderer00; `func`: TreeCellDataFunc; funcData: pointer;
    destroy: DestroyNotify) {.
    importc, libprag.}

proc setCellDataFunc*(self: TreeViewColumn; cellRenderer: CellRenderer;
    `func`: TreeCellDataFunc; funcData: pointer; destroy: DestroyNotify) =
  gtk_tree_view_column_set_cell_data_func(cast[ptr TreeViewColumn00](self.impl), cast[ptr CellRenderer00](cellRenderer.impl), `func`, funcData, destroy)

proc gtk_tree_view_insert_column_with_data_func(self: ptr TreeView00; position: int32;
    title: cstring; cell: ptr CellRenderer00; `func`: TreeCellDataFunc; data: pointer;
    dnotify: DestroyNotify): int32 {.
    importc, libprag.}

proc insertColumnWithDataFunc*(self: TreeView; position: int;
    title: cstring; cell: CellRenderer; `func`: TreeCellDataFunc; data: pointer;
    dnotify: DestroyNotify): int =
  int(gtk_tree_view_insert_column_with_data_func(cast[ptr TreeView00](self.impl), int32(position), title, cast[ptr CellRenderer00](cell.impl), `func`, data, dnotify))

type
  TreeDestroyCountFunc* = proc (treeView: ptr TreeView00; path: ptr TreePath00; children: int32; userData: pointer) {.cdecl.}

proc gtk_tree_view_set_destroy_count_func(self: ptr TreeView00; `func`: TreeDestroyCountFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setDestroyCountFunc*(self: TreeView; `func`: TreeDestroyCountFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_destroy_count_func(cast[ptr TreeView00](self.impl), `func`, data, destroy)

type
  TreeDragDest00* = object of gobject.Object00
  TreeDragDest* = ref object of gobject.Object

proc gtk_tree_drag_dest_drag_data_received(self: ptr TreeDragDest00; dest: ptr TreePath00;
    selectionData: ptr SelectionData00): gboolean {.
    importc, libprag.}

proc dragDataReceived*(self: TreeDragDest | ListStore | TreeStore;
    dest: TreePath; selectionData: SelectionData): bool =
  toBool(gtk_tree_drag_dest_drag_data_received(cast[ptr TreeDragDest00](self.impl), cast[ptr TreePath00](dest.impl), cast[ptr SelectionData00](selectionData.impl)))

proc gtk_tree_drag_dest_row_drop_possible(self: ptr TreeDragDest00; destPath: ptr TreePath00;
    selectionData: ptr SelectionData00): gboolean {.
    importc, libprag.}

proc rowDropPossible*(self: TreeDragDest | ListStore | TreeStore;
    destPath: TreePath; selectionData: SelectionData): bool =
  toBool(gtk_tree_drag_dest_row_drop_possible(cast[ptr TreeDragDest00](self.impl), cast[ptr TreePath00](destPath.impl), cast[ptr SelectionData00](selectionData.impl)))

type
  TreeDragSource00* = object of gobject.Object00
  TreeDragSource* = ref object of gobject.Object

proc gtk_tree_drag_source_drag_data_delete(self: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc dragDataDelete*(self: TreeDragSource | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath): bool =
  toBool(gtk_tree_drag_source_drag_data_delete(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl)))

proc gtk_tree_drag_source_drag_data_get(self: ptr TreeDragSource00; path: ptr TreePath00;
    selectionData: ptr SelectionData00): gboolean {.
    importc, libprag.}

proc dragDataGet*(self: TreeDragSource | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath; selectionData: SelectionData): bool =
  toBool(gtk_tree_drag_source_drag_data_get(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl), cast[ptr SelectionData00](selectionData.impl)))

proc gtk_tree_drag_source_row_draggable(self: ptr TreeDragSource00; path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc rowDraggable*(self: TreeDragSource | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath): bool =
  toBool(gtk_tree_drag_source_row_draggable(cast[ptr TreeDragSource00](self.impl), cast[ptr TreePath00](path.impl)))

type
  TreeIterCompareFunc* = proc (model: ptr TreeModel00; a: TreeIter; b: TreeIter; userData: pointer): int32 {.cdecl.}

type
  TreeModelFilterModifyFunc* = proc (model: ptr TreeModel00; iter: TreeIter; value: var gobject.Value; column: int32;
    data: pointer) {.cdecl.}

proc gtk_tree_model_filter_set_modify_func(self: ptr TreeModelFilter00; nColumns: int32;
    types: ptr GType; `func`: TreeModelFilterModifyFunc; data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setModifyFunc*(self: TreeModelFilter; nColumns: int;
    types: ptr GType; `func`: TreeModelFilterModifyFunc; data: pointer; destroy: DestroyNotify) =
  gtk_tree_model_filter_set_modify_func(cast[ptr TreeModelFilter00](self.impl), int32(nColumns), types, `func`, data, destroy)

type
  TreeModelFilterVisibleFunc* = proc (model: ptr TreeModel00; iter: TreeIter; data: pointer): gboolean {.cdecl.}

proc gtk_tree_model_filter_set_visible_func(self: ptr TreeModelFilter00;
    `func`: TreeModelFilterVisibleFunc; data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setVisibleFunc*(self: TreeModelFilter; `func`: TreeModelFilterVisibleFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_model_filter_set_visible_func(cast[ptr TreeModelFilter00](self.impl), `func`, data, destroy)

type
  TreeModelForeachFunc* = proc (model: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; data: pointer): gboolean {.cdecl.}

proc gtk_tree_model_foreach(self: ptr TreeModel00; `func`: TreeModelForeachFunc;
    userData: pointer) {.
    importc, libprag.}

proc foreach*(self: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    `func`: TreeModelForeachFunc; userData: pointer) =
  gtk_tree_model_foreach(cast[ptr TreeModel00](self.impl), `func`, userData)

type
  TreeRowReference00* {.pure.} = object
  TreeRowReference* = ref object
    impl*: ptr TreeRowReference00
    ignoreFinalizer*: bool

proc gtk_tree_row_reference_get_type*(): GType {.importc, libprag.}

proc gBoxedFreeGtkTreeRowReference*(self: TreeRowReference) =
  if not self.ignoreFinalizer:
    boxedFree(gtk_tree_row_reference_get_type(), cast[ptr TreeRowReference00](self.impl))

when defined(gcDestructors):
  proc `=destroy`*(self: var typeof(TreeRowReference()[])) =
    when defined(gintroDebug):
      echo "destroy ", $typeof(self), ' ', cast[int](unsafeaddr self)
    if not self.ignoreFinalizer and self.impl != nil:
      boxedFree(gtk_tree_row_reference_get_type(), cast[ptr TreeRowReference00](self.impl))
      self.impl = nil

proc newWithFinalizer*(x: var TreeRowReference) =
  when defined(gcDestructors):
    new(x)
  else:
    new(x, gBoxedFreeGtkTreeRowReference)

proc gtk_tree_row_reference_free(self: ptr TreeRowReference00) {.
    importc, libprag.}

proc free*(self: TreeRowReference) =
  gtk_tree_row_reference_free(cast[ptr TreeRowReference00](self.impl))

proc finalizerfree*(self: TreeRowReference) =
  if not self.ignoreFinalizer:
    gtk_tree_row_reference_free(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_new_proxy(proxy: ptr gobject.Object00; model: ptr TreeModel00;
    path: ptr TreePath00): ptr TreeRowReference00 {.
    importc, libprag.}

proc newTreeRowReferenceProxy*(proxy: gobject.Object; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath): TreeRowReference =
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc newTreeRowReferenceProxy*(tdesc: typedesc; proxy: gobject.Object; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath): tdesc =
  assert(result is TreeRowReference)
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc initTreeRowReferenceProxy*[T](result: var T; proxy: gobject.Object; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath) {.deprecated.} =
  assert(result is TreeRowReference)
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_new_proxy(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_row_reference_copy(self: ptr TreeRowReference00): ptr TreeRowReference00 {.
    importc, libprag.}

proc copy*(self: TreeRowReference): TreeRowReference =
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_copy(cast[ptr TreeRowReference00](self.impl))

proc gtk_tree_row_reference_new(model: ptr TreeModel00; path: ptr TreePath00): ptr TreeRowReference00 {.
    importc, libprag.}

proc newTreeRowReference*(model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath): TreeRowReference =
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc newTreeRowReference*(tdesc: typedesc; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath): tdesc =
  assert(result is TreeRowReference)
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc initTreeRowReference*[T](result: var T; model: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath) {.deprecated.} =
  assert(result is TreeRowReference)
  fnew(result, gBoxedFreeGtkTreeRowReference)
  result.impl = gtk_tree_row_reference_new(cast[ptr TreeModel00](model.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_row_reference_get_model(self: ptr TreeRowReference00): ptr TreeModel00 {.
    importc, libprag.}

proc getModel*(self: TreeRowReference): TreeModel =
  let gobj = gtk_tree_row_reference_get_model(cast[ptr TreeRowReference00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc model*(self: TreeRowReference): TreeModel =
  let gobj = gtk_tree_row_reference_get_model(cast[ptr TreeRowReference00](self.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_tree_row_reference_get_path(self: ptr TreeRowReference00): ptr TreePath00 {.
    importc, libprag.}

proc getPath*(self: TreeRowReference): TreePath =
  let impl0 = gtk_tree_row_reference_get_path(cast[ptr TreeRowReference00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc path*(self: TreeRowReference): TreePath =
  let impl0 = gtk_tree_row_reference_get_path(cast[ptr TreeRowReference00](self.impl))
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGtkTreePath)
  result.impl = impl0

proc gtk_tree_row_reference_valid(self: ptr TreeRowReference00): gboolean {.
    importc, libprag.}

proc valid*(self: TreeRowReference): bool =
  toBool(gtk_tree_row_reference_valid(cast[ptr TreeRowReference00](self.impl)))

proc gtk_tree_row_reference_deleted(proxy: ptr gobject.Object00; path: ptr TreePath00) {.
    importc, libprag.}

proc deleted*(proxy: gobject.Object; path: TreePath) =
  gtk_tree_row_reference_deleted(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreePath00](path.impl))

proc gtk_tree_row_reference_inserted(proxy: ptr gobject.Object00; path: ptr TreePath00) {.
    importc, libprag.}

proc inserted*(proxy: gobject.Object; path: TreePath) =
  gtk_tree_row_reference_inserted(cast[ptr gobject.Object00](proxy.impl), cast[ptr TreePath00](path.impl))

type
  TreeSelectionForeachFunc* = proc (model: ptr TreeModel00; path: ptr TreePath00; iter: TreeIter; data: pointer) {.cdecl.}

proc gtk_tree_selection_selected_foreach(self: ptr TreeSelection00; `func`: TreeSelectionForeachFunc;
    data: pointer) {.
    importc, libprag.}

proc selectedForeach*(self: TreeSelection; `func`: TreeSelectionForeachFunc;
    data: pointer) =
  gtk_tree_selection_selected_foreach(cast[ptr TreeSelection00](self.impl), `func`, data)

type
  TreeSelectionFunc* = proc (selection: ptr TreeSelection00; model: ptr TreeModel00; path: ptr TreePath00;
    pathCurrentlySelected: gboolean; data: pointer): gboolean {.cdecl.}

proc gtk_tree_selection_set_select_function(self: ptr TreeSelection00; `func`: TreeSelectionFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSelectFunction*(self: TreeSelection; `func`: TreeSelectionFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_selection_set_select_function(cast[ptr TreeSelection00](self.impl), `func`, data, destroy)

type
  TreeSortable00* = object of gobject.Object00
  TreeSortable* = ref object of gobject.Object

proc scSortColumnChanged*(self: TreeSortable | TreeModelSort | ListStore | TreeStore;  p: proc (self: ptr gobject.Object00; xdata: pointer) {.cdecl.}, xdata: pointer, cf: gobject.ConnectFlags): culong =
  g_signal_connect_data(self.impl, "sort-column-changed", cast[GCallback](p), xdata, nil, cf)

proc gtk_tree_sortable_get_sort_column_id(self: ptr TreeSortable00; sortColumnId: var int32;
    order: var SortType): gboolean {.
    importc, libprag.}

proc getSortColumnId*(self: TreeSortable | TreeModelSort | ListStore | TreeStore;
    sortColumnId: var int; order: var SortType): bool =
  var sortColumnId_00: int32
  result = toBool(gtk_tree_sortable_get_sort_column_id(cast[ptr TreeSortable00](self.impl), sortColumnId_00, order))
  if sortColumnId.addr != nil:
    sortColumnId = int(sortColumnId_00)

proc gtk_tree_sortable_has_default_sort_func(self: ptr TreeSortable00): gboolean {.
    importc, libprag.}

proc hasDefaultSortFunc*(self: TreeSortable | TreeModelSort | ListStore | TreeStore): bool =
  toBool(gtk_tree_sortable_has_default_sort_func(cast[ptr TreeSortable00](self.impl)))

proc gtk_tree_sortable_set_default_sort_func(self: ptr TreeSortable00; sortFunc: TreeIterCompareFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setDefaultSortFunc*(self: TreeSortable | TreeModelSort | ListStore | TreeStore;
    sortFunc: TreeIterCompareFunc; userData: pointer; destroy: DestroyNotify) =
  gtk_tree_sortable_set_default_sort_func(cast[ptr TreeSortable00](self.impl), sortFunc, userData, destroy)

proc gtk_tree_sortable_set_sort_column_id(self: ptr TreeSortable00; sortColumnId: int32;
    order: SortType) {.
    importc, libprag.}

proc setSortColumnId*(self: TreeSortable | TreeModelSort | ListStore | TreeStore;
    sortColumnId: int; order: SortType) =
  gtk_tree_sortable_set_sort_column_id(cast[ptr TreeSortable00](self.impl), int32(sortColumnId), order)

proc gtk_tree_sortable_set_sort_func(self: ptr TreeSortable00; sortColumnId: int32;
    sortFunc: TreeIterCompareFunc; userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSortFunc*(self: TreeSortable | TreeModelSort | ListStore | TreeStore;
    sortColumnId: int; sortFunc: TreeIterCompareFunc; userData: pointer; destroy: DestroyNotify) =
  gtk_tree_sortable_set_sort_func(cast[ptr TreeSortable00](self.impl), int32(sortColumnId), sortFunc, userData, destroy)

proc gtk_tree_sortable_sort_column_changed(self: ptr TreeSortable00) {.
    importc, libprag.}

proc sortColumnChanged*(self: TreeSortable | TreeModelSort | ListStore | TreeStore) =
  gtk_tree_sortable_sort_column_changed(cast[ptr TreeSortable00](self.impl))

type
  TreeViewColumnDropFunc* = proc (treeView: ptr TreeView00; column: ptr TreeViewColumn00; prevColumn: ptr TreeViewColumn00;
    nextColumn: ptr TreeViewColumn00; data: pointer): gboolean {.cdecl.}

proc gtk_tree_view_set_column_drag_function(self: ptr TreeView00; `func`: TreeViewColumnDropFunc;
    userData: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setColumnDragFunction*(self: TreeView; `func`: TreeViewColumnDropFunc;
    userData: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_column_drag_function(cast[ptr TreeView00](self.impl), `func`, userData, destroy)

type
  TreeViewMappingFunc* = proc (treeView: ptr TreeView00; path: ptr TreePath00; userData: pointer) {.cdecl.}

proc gtk_tree_view_map_expanded_rows(self: ptr TreeView00; `func`: TreeViewMappingFunc;
    data: pointer) {.
    importc, libprag.}

proc mapExpandedRows*(self: TreeView; `func`: TreeViewMappingFunc;
    data: pointer) =
  gtk_tree_view_map_expanded_rows(cast[ptr TreeView00](self.impl), `func`, data)

type
  TreeViewRowSeparatorFunc* = proc (model: ptr TreeModel00; iter: TreeIter; data: pointer): gboolean {.cdecl.}

proc gtk_combo_box_set_row_separator_func(self: ptr ComboBox00; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setRowSeparatorFunc*(self: ComboBox; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_combo_box_set_row_separator_func(cast[ptr ComboBox00](self.impl), `func`, data, destroy)

proc gtk_tree_view_set_row_separator_func(self: ptr TreeView00; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setRowSeparatorFunc*(self: TreeView; `func`: TreeViewRowSeparatorFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_row_separator_func(cast[ptr TreeView00](self.impl), `func`, data, destroy)

type
  TreeViewSearchEqualFunc* = proc (model: ptr TreeModel00; column: int32; key: cstring; iter: TreeIter;
    searchData: pointer): gboolean {.cdecl.}

proc gtk_tree_view_set_search_equal_func(self: ptr TreeView00; searchEqualFunc: TreeViewSearchEqualFunc;
    searchUserData: pointer; searchDestroy: DestroyNotify) {.
    importc, libprag.}

proc setSearchEqualFunc*(self: TreeView; searchEqualFunc: TreeViewSearchEqualFunc;
    searchUserData: pointer; searchDestroy: DestroyNotify) =
  gtk_tree_view_set_search_equal_func(cast[ptr TreeView00](self.impl), searchEqualFunc, searchUserData, searchDestroy)

type
  TreeViewSearchPositionFunc* = proc (treeView: ptr TreeView00; searchDialog: ptr Widget00; userData: pointer) {.cdecl.}

proc gtk_tree_view_set_search_position_func(self: ptr TreeView00; `func`: TreeViewSearchPositionFunc;
    data: pointer; destroy: DestroyNotify) {.
    importc, libprag.}

proc setSearchPositionFunc*(self: TreeView; `func`: TreeViewSearchPositionFunc;
    data: pointer; destroy: DestroyNotify) =
  gtk_tree_view_set_search_position_func(cast[ptr TreeView00](self.impl), `func`, data, destroy)

type
  WindowGeometryInfo00* {.pure.} = object
  WindowGeometryInfo* = ref object
    impl*: ptr WindowGeometryInfo00
    ignoreFinalizer*: bool

proc gtk_accel_groups_activate(`object`: ptr gobject.Object00; accelKey: uint32;
    accelMods: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc accelGroupsActivate*(`object`: gobject.Object; accelKey: int; accelMods: gdk.ModifierType): bool =
  toBool(gtk_accel_groups_activate(cast[ptr gobject.Object00](`object`.impl), uint32(accelKey), accelMods))

proc gtk_accel_groups_from_object(`object`: ptr gobject.Object00): ptr glib.SList {.
    importc, libprag.}

proc accelGroupsFromObject*(`object`: gobject.Object): seq[AccelGroup] =
  result = gslistObjects2seq(AccelGroup, gtk_accel_groups_from_object(cast[ptr gobject.Object00](`object`.impl)), false)

proc acceleratorGetDefaultModMask*(): gdk.ModifierType {.
    importc: "gtk_accelerator_get_default_mod_mask", libprag.}

proc gtk_accelerator_get_label(acceleratorKey: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorGetLabel*(acceleratorKey: int; acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_get_label(uint32(acceleratorKey), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_get_label_with_keycode(display: ptr gdk.Display00; acceleratorKey: uint32;
    keycode: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorGetLabelWithKeycode*(display: gdk.Display = nil; acceleratorKey: int;
    keycode: int; acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_get_label_with_keycode(if display.isNil: nil else: cast[ptr gdk.Display00](display.impl), uint32(acceleratorKey), uint32(keycode), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_name(acceleratorKey: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorName*(acceleratorKey: int; acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_name(uint32(acceleratorKey), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_name_with_keycode(display: ptr gdk.Display00; acceleratorKey: uint32;
    keycode: uint32; acceleratorMods: gdk.ModifierType): cstring {.
    importc, libprag.}

proc acceleratorNameWithKeycode*(display: gdk.Display = nil; acceleratorKey: int;
    keycode: int; acceleratorMods: gdk.ModifierType): string =
  let resul0 = gtk_accelerator_name_with_keycode(if display.isNil: nil else: cast[ptr gdk.Display00](display.impl), uint32(acceleratorKey), uint32(keycode), acceleratorMods)
  result = $resul0
  cogfree(resul0)

proc gtk_accelerator_parse(accelerator: cstring; acceleratorKey: var uint32;
    acceleratorMods: var gdk.ModifierType) {.
    importc, libprag.}

proc acceleratorParse*(accelerator: cstring; acceleratorKey: var int = cast[var int](nil);
    acceleratorMods: var gdk.ModifierType = cast[var gdk.ModifierType](nil)) =
  var acceleratorKey_00: uint32
  gtk_accelerator_parse(accelerator, acceleratorKey_00, acceleratorMods)
  if acceleratorKey.addr != nil:
    acceleratorKey = int(acceleratorKey_00)

proc acceleratorSetDefaultModMask*(defaultModMask: gdk.ModifierType) {.
    importc: "gtk_accelerator_set_default_mod_mask", libprag.}

proc gtk_accelerator_valid(keyval: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc acceleratorValid*(keyval: int; modifiers: gdk.ModifierType): bool =
  toBool(gtk_accelerator_valid(uint32(keyval), modifiers))

proc gtk_alternative_dialog_button_order(screen: ptr gdk.Screen00): gboolean {.
    importc, libprag.}

proc alternativeDialogButtonOrder*(screen: gdk.Screen = nil): bool =
  toBool(gtk_alternative_dialog_button_order(if screen.isNil: nil else: cast[ptr gdk.Screen00](screen.impl)))

proc gtk_bindings_activate(`object`: ptr gobject.Object00; keyval: uint32;
    modifiers: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc bindingsActivate*(`object`: gobject.Object; keyval: int; modifiers: gdk.ModifierType): bool =
  toBool(gtk_bindings_activate(cast[ptr gobject.Object00](`object`.impl), uint32(keyval), modifiers))

proc gtk_bindings_activate_event(`object`: ptr gobject.Object00; event: ptr gdk.EventKey00): gboolean {.
    importc, libprag.}

proc bindingsActivateEvent*(`object`: gobject.Object; event: gdk.EventKey): bool =
  toBool(gtk_bindings_activate_event(cast[ptr gobject.Object00](`object`.impl), cast[ptr gdk.EventKey00](event.impl)))

proc gtk_cairo_should_draw_window(cr: ptr cairo.Context00; window: ptr gdk.Window00): gboolean {.
    importc, libprag.}

proc cairoShouldDrawWindow*(cr: cairo.Context; window: gdk.Window): bool =
  toBool(gtk_cairo_should_draw_window(cast[ptr cairo.Context00](cr.impl), cast[ptr gdk.Window00](window.impl)))

proc gtk_cairo_transform_to_window(cr: ptr cairo.Context00; widget: ptr Widget00;
    window: ptr gdk.Window00) {.
    importc, libprag.}

proc cairoTransformToWindow*(cr: cairo.Context; widget: Widget; window: gdk.Window) =
  gtk_cairo_transform_to_window(cast[ptr cairo.Context00](cr.impl), cast[ptr Widget00](widget.impl), cast[ptr gdk.Window00](window.impl))

proc gtk_check_version(requiredMajor: uint32; requiredMinor: uint32; requiredMicro: uint32): cstring {.
    importc, libprag.}

proc checkVersion*(requiredMajor: int; requiredMinor: int; requiredMicro: int): string =
  let resul0 = gtk_check_version(uint32(requiredMajor), uint32(requiredMinor), uint32(requiredMicro))
  if resul0.isNil:
    return
  result = $resul0

proc gtk_device_grab_add(widget: ptr Widget00; device: ptr gdk.Device00;
    blockOthers: gboolean) {.
    importc, libprag.}

proc deviceGrabAdd*(widget: Widget; device: gdk.Device; blockOthers: bool) =
  gtk_device_grab_add(cast[ptr Widget00](widget.impl), cast[ptr gdk.Device00](device.impl), gboolean(blockOthers))

proc gtk_device_grab_remove(widget: ptr Widget00; device: ptr gdk.Device00) {.
    importc, libprag.}

proc deviceGrabRemove*(widget: Widget; device: gdk.Device) =
  gtk_device_grab_remove(cast[ptr Widget00](widget.impl), cast[ptr gdk.Device00](device.impl))

proc disableSetlocale*() {.
    importc: "gtk_disable_setlocale", libprag.}

proc gtk_distribute_natural_allocation(extraSpace: int32; nRequestedSizes: uint32;
    sizes: RequestedSize): int32 {.
    importc, libprag.}

proc distributeNaturalAllocation*(extraSpace: int; nRequestedSizes: int;
    sizes: RequestedSize): int =
  int(gtk_distribute_natural_allocation(int32(extraSpace), uint32(nRequestedSizes), sizes))

proc gtk_drag_cancel(context: ptr gdk.DragContext00) {.
    importc, libprag.}

proc dragCancel*(context: gdk.DragContext) =
  gtk_drag_cancel(cast[ptr gdk.DragContext00](context.impl))

proc gtk_drag_finish(context: ptr gdk.DragContext00; success: gboolean; del: gboolean;
    time: uint32) {.
    importc, libprag.}

proc dragFinish*(context: gdk.DragContext; success: bool; del: bool;
    time: int) =
  gtk_drag_finish(cast[ptr gdk.DragContext00](context.impl), gboolean(success), gboolean(del), uint32(time))

proc gtk_drag_get_source_widget(context: ptr gdk.DragContext00): ptr Widget00 {.
    importc, libprag.}

proc dragGetSourceWidget*(context: gdk.DragContext): Widget =
  let gobj = gtk_drag_get_source_widget(cast[ptr gdk.DragContext00](context.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_drag_set_icon_default(context: ptr gdk.DragContext00) {.
    importc, libprag.}

proc dragSetIconDefault*(context: gdk.DragContext) =
  gtk_drag_set_icon_default(cast[ptr gdk.DragContext00](context.impl))

proc gtk_drag_set_icon_gicon(context: ptr gdk.DragContext00; icon: ptr gio.Icon00;
    hotX: int32; hotY: int32) {.
    importc, libprag.}

proc dragSetIconGicon*(context: gdk.DragContext; icon: gio.Icon; hotX: int;
    hotY: int) =
  gtk_drag_set_icon_gicon(cast[ptr gdk.DragContext00](context.impl), cast[ptr gio.Icon00](icon.impl), int32(hotX), int32(hotY))

proc gtk_drag_set_icon_name(context: ptr gdk.DragContext00; iconName: cstring;
    hotX: int32; hotY: int32) {.
    importc, libprag.}

proc dragSetIconName*(context: gdk.DragContext; iconName: cstring;
    hotX: int; hotY: int) =
  gtk_drag_set_icon_name(cast[ptr gdk.DragContext00](context.impl), iconName, int32(hotX), int32(hotY))

proc gtk_drag_set_icon_pixbuf(context: ptr gdk.DragContext00; pixbuf: ptr gdkpixbuf.Pixbuf00;
    hotX: int32; hotY: int32) {.
    importc, libprag.}

proc dragSetIconPixbuf*(context: gdk.DragContext; pixbuf: gdkpixbuf.Pixbuf;
    hotX: int; hotY: int) =
  gtk_drag_set_icon_pixbuf(cast[ptr gdk.DragContext00](context.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl), int32(hotX), int32(hotY))

proc gtk_drag_set_icon_stock(context: ptr gdk.DragContext00; stockId: cstring;
    hotX: int32; hotY: int32) {.
    importc, libprag.}

proc dragSetIconStock*(context: gdk.DragContext; stockId: cstring;
    hotX: int; hotY: int) =
  gtk_drag_set_icon_stock(cast[ptr gdk.DragContext00](context.impl), stockId, int32(hotX), int32(hotY))

proc gtk_drag_set_icon_surface(context: ptr gdk.DragContext00; surface: ptr cairo.Surface00) {.
    importc, libprag.}

proc dragSetIconSurface*(context: gdk.DragContext; surface: cairo.Surface) =
  gtk_drag_set_icon_surface(cast[ptr gdk.DragContext00](context.impl), cast[ptr cairo.Surface00](surface.impl))

proc gtk_drag_set_icon_widget(context: ptr gdk.DragContext00; widget: ptr Widget00;
    hotX: int32; hotY: int32) {.
    importc, libprag.}

proc dragSetIconWidget*(context: gdk.DragContext; widget: Widget; hotX: int;
    hotY: int) =
  gtk_drag_set_icon_widget(cast[ptr gdk.DragContext00](context.impl), cast[ptr Widget00](widget.impl), int32(hotX), int32(hotY))

proc gtk_draw_insertion_cursor(widget: ptr Widget00; cr: ptr cairo.Context00;
    location: gdk.Rectangle; isPrimary: gboolean; direction: TextDirection;
    drawArrow: gboolean) {.
    importc, libprag.}

proc drawInsertionCursor*(widget: Widget; cr: cairo.Context; location: gdk.Rectangle;
    isPrimary: bool; direction: TextDirection; drawArrow: bool) =
  gtk_draw_insertion_cursor(cast[ptr Widget00](widget.impl), cast[ptr cairo.Context00](cr.impl), location, gboolean(isPrimary), direction, gboolean(drawArrow))

proc gtk_events_pending(): gboolean {.
    importc, libprag.}

proc eventsPending*(): bool =
  toBool(gtk_events_pending())

proc gtk_false(): gboolean {.
    importc, libprag.}

proc false0*(): bool =
  toBool(gtk_false())

proc gtk_get_binary_age(): uint32 {.
    importc, libprag.}

proc getBinaryAge*(): int =
  int(gtk_get_binary_age())

proc gtk_get_current_event(): ptr gdk.Event00 {.
    importc, libprag.}

proc getCurrentEvent*(): gdk.Event =
  let impl0 = gtk_get_current_event()
  if impl0.isNil:
    return nil
  fnew(result, gBoxedFreeGdkEvent)
  result.impl = impl0

proc gtk_get_current_event_device(): ptr gdk.Device00 {.
    importc, libprag.}

proc getCurrentEventDevice*(): gdk.Device =
  let gobj = gtk_get_current_event_device()
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_get_current_event_state(state: var gdk.ModifierType): gboolean {.
    importc, libprag.}

proc getCurrentEventState*(state: var gdk.ModifierType): bool =
  toBool(gtk_get_current_event_state(state))

proc currentEventState*(state: var gdk.ModifierType): bool =
  toBool(gtk_get_current_event_state(state))

proc gtk_get_current_event_time(): uint32 {.
    importc, libprag.}

proc getCurrentEventTime*(): int =
  int(gtk_get_current_event_time())

proc gtk_get_debug_flags(): uint32 {.
    importc, libprag.}

proc getDebugFlags*(): int =
  int(gtk_get_debug_flags())

proc gtk_get_default_language(): ptr pango.Language00 {.
    importc, libprag.}

proc getDefaultLanguage*(): pango.Language =
  fnew(result, gBoxedFreePangoLanguage)
  result.impl = gtk_get_default_language()
  result.impl = cast[typeof(result.impl)](g_boxed_copy(pango_language_get_type(), result.impl))

proc gtk_get_event_widget(event: ptr gdk.Event00): ptr Widget00 {.
    importc, libprag.}

proc getEventWidget*(event: gdk.Event): Widget =
  let gobj = gtk_get_event_widget(cast[ptr gdk.Event00](event.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc eventWidget*(event: gdk.Event): Widget =
  let gobj = gtk_get_event_widget(cast[ptr gdk.Event00](event.impl))
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_get_interface_age(): uint32 {.
    importc, libprag.}

proc getInterfaceAge*(): int =
  int(gtk_get_interface_age())

proc getLocaleDirection*(): TextDirection {.
    importc: "gtk_get_locale_direction", libprag.}

proc gtk_get_major_version(): uint32 {.
    importc, libprag.}

proc getMajorVersion*(): int =
  int(gtk_get_major_version())

proc gtk_get_micro_version(): uint32 {.
    importc, libprag.}

proc getMicroVersion*(): int =
  int(gtk_get_micro_version())

proc gtk_get_minor_version(): uint32 {.
    importc, libprag.}

proc getMinorVersion*(): int =
  int(gtk_get_minor_version())

proc gtk_get_option_group(openDefaultDisplay: gboolean): ptr glib.OptionGroup00 {.
    importc, libprag.}

proc getOptionGroup*(openDefaultDisplay: bool): glib.OptionGroup =
  fnew(result, gBoxedFreeGOptionGroup)
  result.impl = gtk_get_option_group(gboolean(openDefaultDisplay))

proc optionGroup*(openDefaultDisplay: bool): glib.OptionGroup =
  fnew(result, gBoxedFreeGOptionGroup)
  result.impl = gtk_get_option_group(gboolean(openDefaultDisplay))

proc gtk_grab_get_current(): ptr Widget00 {.
    importc, libprag.}

proc grabGetCurrent*(): Widget =
  let gobj = gtk_grab_get_current()
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_init(argc: var int32; argv: var ptr cstring) {.
    importc, libprag.}

proc init*(argc: var int; argv: var seq[string]) =
  var argc_00 = int32(argc)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var argv_00 = seq2CstringArray(argv, fs469n23)
  gtk_init(argc_00, argv_00)
  argc = int(argc_00)
  argv = cstringArrayToSeq(argv_00)

proc gtk_init_check(argc: var int32; argv: var ptr cstring): gboolean {.
    importc, libprag.}

proc initCheck*(argc: var int; argv: var seq[string]): bool =
  var argc_00 = int32(argc)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var argv_00 = seq2CstringArray(argv, fs469n23)
  result = toBool(gtk_init_check(argc_00, argv_00))
  argc = int(argc_00)
  argv = cstringArrayToSeq(argv_00)

proc gtk_init_with_args(argc: var int32; argv: var ptr cstring; parameterString: cstring;
    entries: ptr glib.OptionEntry; translationDomain: cstring; error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc initWithArgs*(argc: var int; argv: var seq[string]; parameterString: cstring = nil;
    entries: ptr glib.OptionEntry; translationDomain: cstring = nil): bool =
  var gerror: ptr glib.Error
  var argc_00 = int32(argc)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var argv_00 = seq2CstringArray(argv, fs469n23)
  let resul0 = gtk_init_with_args(argc_00, argv_00, parameterString, entries, translationDomain, addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)
  argc = int(argc_00)
  argv = cstringArrayToSeq(argv_00)

proc gtk_key_snooper_remove(snooperHandlerId: uint32) {.
    importc, libprag.}

proc keySnooperRemove*(snooperHandlerId: int) =
  gtk_key_snooper_remove(uint32(snooperHandlerId))

proc main*() {.
    importc: "gtk_main", libprag.}

proc gtk_main_do_event(event: ptr gdk.Event00) {.
    importc, libprag.}

proc mainDoEvent*(event: gdk.Event) =
  gtk_main_do_event(cast[ptr gdk.Event00](event.impl))

proc gtk_main_iteration(): gboolean {.
    importc, libprag.}

proc mainIteration*(): bool =
  toBool(gtk_main_iteration())

proc gtk_main_iteration_do(blocking: gboolean): gboolean {.
    importc, libprag.}

proc mainIterationDo*(blocking: bool): bool =
  toBool(gtk_main_iteration_do(gboolean(blocking)))

proc gtk_main_level(): uint32 {.
    importc, libprag.}

proc mainLevel*(): int =
  int(gtk_main_level())

proc mainQuit*() {.
    importc: "gtk_main_quit", libprag.}

proc gtk_paint_arrow(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; arrowType: ArrowType;
    fill: gboolean; x: int32; y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintArrow*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; arrowType: ArrowType;
    fill: bool; x: int; y: int; width: int; height: int) =
  gtk_paint_arrow(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, arrowType, gboolean(fill), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_box(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintBox*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int) =
  gtk_paint_box(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_box_gap(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32; gapSide: PositionType; gapX: int32;
    gapWidth: int32) {.
    importc, libprag.}

proc paintBoxGap*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int; gapSide: PositionType; gapX: int; gapWidth: int) =
  gtk_paint_box_gap(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height), gapSide, int32(gapX), int32(gapWidth))

proc gtk_paint_check(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintCheck*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int) =
  gtk_paint_check(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_diamond(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintDiamond*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int) =
  gtk_paint_diamond(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_expander(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    widget: ptr Widget00; detail: cstring; x: int32; y: int32; expanderStyle: ExpanderStyle) {.
    importc, libprag.}

proc paintExpander*(style: Style; cr: cairo.Context; stateType: StateType;
    widget: Widget = nil; detail: cstring = nil; x: int; y: int; expanderStyle: ExpanderStyle) =
  gtk_paint_expander(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), expanderStyle)

proc gtk_paint_extension(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32; gapSide: PositionType) {.
    importc, libprag.}

proc paintExtension*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int; gapSide: PositionType) =
  gtk_paint_extension(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height), gapSide)

proc gtk_paint_flat_box(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintFlatBox*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int) =
  gtk_paint_flat_box(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_focus(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    widget: ptr Widget00; detail: cstring; x: int32; y: int32; width: int32;
    height: int32) {.
    importc, libprag.}

proc paintFocus*(style: Style; cr: cairo.Context; stateType: StateType;
    widget: Widget = nil; detail: cstring = nil; x: int; y: int; width: int;
    height: int) =
  gtk_paint_focus(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_handle(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32; orientation: Orientation) {.
    importc, libprag.}

proc paintHandle*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int; orientation: Orientation) =
  gtk_paint_handle(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height), orientation)

proc gtk_paint_hline(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    widget: ptr Widget00; detail: cstring; x1: int32; x2: int32; y: int32) {.
    importc, libprag.}

proc paintHline*(style: Style; cr: cairo.Context; stateType: StateType;
    widget: Widget = nil; detail: cstring = nil; x1: int; x2: int; y: int) =
  gtk_paint_hline(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x1), int32(x2), int32(y))

proc gtk_paint_layout(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    useText: gboolean; widget: ptr Widget00; detail: cstring; x: int32; y: int32;
    layout: ptr pango.Layout00) {.
    importc, libprag.}

proc paintLayout*(style: Style; cr: cairo.Context; stateType: StateType;
    useText: bool; widget: Widget = nil; detail: cstring = nil; x: int; y: int;
    layout: pango.Layout) =
  gtk_paint_layout(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, gboolean(useText), if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), cast[ptr pango.Layout00](layout.impl))

proc gtk_paint_option(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintOption*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int) =
  gtk_paint_option(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_resize_grip(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    widget: ptr Widget00; detail: cstring; edge: gdk.WindowEdge; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintResizeGrip*(style: Style; cr: cairo.Context; stateType: StateType;
    widget: Widget = nil; detail: cstring = nil; edge: gdk.WindowEdge; x: int;
    y: int; width: int; height: int) =
  gtk_paint_resize_grip(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, edge, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_shadow(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintShadow*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int) =
  gtk_paint_shadow(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_shadow_gap(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32; gapSide: PositionType; gapX: int32;
    gapWidth: int32) {.
    importc, libprag.}

proc paintShadowGap*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int; gapSide: PositionType; gapX: int; gapWidth: int) =
  gtk_paint_shadow_gap(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height), gapSide, int32(gapX), int32(gapWidth))

proc gtk_paint_slider(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32; orientation: Orientation) {.
    importc, libprag.}

proc paintSlider*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int; orientation: Orientation) =
  gtk_paint_slider(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height), orientation)

proc gtk_paint_spinner(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    widget: ptr Widget00; detail: cstring; step: uint32; x: int32; y: int32;
    width: int32; height: int32) {.
    importc, libprag.}

proc paintSpinner*(style: Style; cr: cairo.Context; stateType: StateType;
    widget: Widget = nil; detail: cstring = nil; step: int; x: int; y: int;
    width: int; height: int) =
  gtk_paint_spinner(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, uint32(step), int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_tab(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    shadowType: ShadowType; widget: ptr Widget00; detail: cstring; x: int32;
    y: int32; width: int32; height: int32) {.
    importc, libprag.}

proc paintTab*(style: Style; cr: cairo.Context; stateType: StateType;
    shadowType: ShadowType; widget: Widget = nil; detail: cstring = nil; x: int;
    y: int; width: int; height: int) =
  gtk_paint_tab(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, shadowType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(x), int32(y), int32(width), int32(height))

proc gtk_paint_vline(style: ptr Style00; cr: ptr cairo.Context00; stateType: StateType;
    widget: ptr Widget00; detail: cstring; y1: int32; y2: int32; x: int32) {.
    importc, libprag.}

proc paintVline*(style: Style; cr: cairo.Context; stateType: StateType;
    widget: Widget = nil; detail: cstring = nil; y1: int; y2: int; x: int) =
  gtk_paint_vline(cast[ptr Style00](style.impl), cast[ptr cairo.Context00](cr.impl), stateType, if widget.isNil: nil else: cast[ptr Widget00](widget.impl), detail, int32(y1), int32(y2), int32(x))

proc gtk_parse_args(argc: var int32; argv: var ptr cstring): gboolean {.
    importc, libprag.}

proc parseArgs*(argc: var int; argv: var seq[string]): bool =
  var argc_00 = int32(argc)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  var argv_00 = seq2CstringArray(argv, fs469n23)
  result = toBool(gtk_parse_args(argc_00, argv_00))
  argc = int(argc_00)
  argv = cstringArrayToSeq(argv_00)

proc gtk_print_run_page_setup_dialog(parent: ptr Window00; pageSetup: ptr PageSetup00;
    settings: ptr PrintSettings00): ptr PageSetup00 {.
    importc, libprag.}

proc printRunPageSetupDialog*(parent: Window = nil; pageSetup: PageSetup = nil;
    settings: PrintSettings): PageSetup =
  let gobj = gtk_print_run_page_setup_dialog(if parent.isNil: nil else: cast[ptr Window00](parent.impl), if pageSetup.isNil: nil else: cast[ptr PageSetup00](pageSetup.impl), cast[ptr PrintSettings00](settings.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_print_run_page_setup_dialog_async(parent: ptr Window00; pageSetup: ptr PageSetup00;
    settings: ptr PrintSettings00; doneCb: PageSetupDoneFunc; data: pointer) {.
    importc, libprag.}

proc printRunPageSetupDialogAsync*(parent: Window = nil; pageSetup: PageSetup = nil;
    settings: PrintSettings; doneCb: PageSetupDoneFunc; data: pointer) =
  gtk_print_run_page_setup_dialog_async(if parent.isNil: nil else: cast[ptr Window00](parent.impl), if pageSetup.isNil: nil else: cast[ptr PageSetup00](pageSetup.impl), cast[ptr PrintSettings00](settings.impl), doneCb, data)

proc gtk_propagate_event(widget: ptr Widget00; event: ptr gdk.Event00) {.
    importc, libprag.}

proc propagateEvent*(widget: Widget; event: gdk.Event) =
  gtk_propagate_event(cast[ptr Widget00](widget.impl), cast[ptr gdk.Event00](event.impl))

proc rcAddDefaultFile*(filename: cstring) {.
    importc: "gtk_rc_add_default_file", libprag.}

proc gtk_rc_find_module_in_path(moduleFile: cstring): cstring {.
    importc, libprag.}

proc rcFindModuleInPath*(moduleFile: cstring): string =
  let resul0 = gtk_rc_find_module_in_path(moduleFile)
  result = $resul0
  cogfree(resul0)

proc gtk_rc_find_pixmap_in_path(settings: ptr Settings00; scanner: ptr glib.Scanner00;
    pixmapFile: cstring): cstring {.
    importc, libprag.}

proc rcFindPixmapInPath*(settings: Settings; scanner: glib.Scanner;
    pixmapFile: cstring): string =
  let resul0 = gtk_rc_find_pixmap_in_path(cast[ptr Settings00](settings.impl), cast[ptr glib.Scanner00](scanner.impl), pixmapFile)
  result = $resul0
  cogfree(resul0)

proc gtk_rc_get_default_files(): ptr cstring {.
    importc, libprag.}

proc rcGetDefaultFiles*(): seq[string] =
  cstringArrayToSeq(gtk_rc_get_default_files())

proc gtk_rc_get_im_module_file(): cstring {.
    importc, libprag.}

proc rcGetImModuleFile*(): string =
  let resul0 = gtk_rc_get_im_module_file()
  result = $resul0
  cogfree(resul0)

proc gtk_rc_get_im_module_path(): cstring {.
    importc, libprag.}

proc rcGetImModulePath*(): string =
  let resul0 = gtk_rc_get_im_module_path()
  result = $resul0
  cogfree(resul0)

proc gtk_rc_get_module_dir(): cstring {.
    importc, libprag.}

proc rcGetModuleDir*(): string =
  let resul0 = gtk_rc_get_module_dir()
  result = $resul0
  cogfree(resul0)

proc gtk_rc_get_style(widget: ptr Widget00): ptr Style00 {.
    importc, libprag.}

proc rcGetStyle*(widget: Widget): Style =
  let gobj = gtk_rc_get_style(cast[ptr Widget00](widget.impl))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_rc_get_style_by_paths(settings: ptr Settings00; widgetPath: cstring;
    classPath: cstring; `type`: GType): ptr Style00 {.
    importc, libprag.}

proc rcGetStyleByPaths*(settings: Settings; widgetPath: cstring = nil;
    classPath: cstring = nil; `type`: GType): Style =
  let gobj = gtk_rc_get_style_by_paths(cast[ptr Settings00](settings.impl), widgetPath, classPath, `type`)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_rc_get_theme_dir(): cstring {.
    importc, libprag.}

proc rcGetThemeDir*(): string =
  let resul0 = gtk_rc_get_theme_dir()
  result = $resul0
  cogfree(resul0)

proc rcParse*(filename: cstring) {.
    importc: "gtk_rc_parse", libprag.}

proc gtk_rc_parse_color(scanner: ptr glib.Scanner00; color: var gdk.Color): uint32 {.
    importc, libprag.}

proc rcParseColor*(scanner: glib.Scanner; color: var gdk.Color): int =
  int(gtk_rc_parse_color(cast[ptr glib.Scanner00](scanner.impl), color))

proc gtk_rc_parse_color_full(scanner: ptr glib.Scanner00; style: ptr RcStyle00;
    color: var gdk.Color): uint32 {.
    importc, libprag.}

proc rcParseColorFull*(scanner: glib.Scanner; style: RcStyle = nil;
    color: var gdk.Color): int =
  int(gtk_rc_parse_color_full(cast[ptr glib.Scanner00](scanner.impl), if style.isNil: nil else: cast[ptr RcStyle00](style.impl), color))

proc gtk_rc_parse_priority(scanner: ptr glib.Scanner00; priority: ptr PathPriorityType): uint32 {.
    importc, libprag.}

proc rcParsePriority*(scanner: glib.Scanner; priority: ptr PathPriorityType): int =
  int(gtk_rc_parse_priority(cast[ptr glib.Scanner00](scanner.impl), priority))

proc gtk_rc_parse_state(scanner: ptr glib.Scanner00; state: var StateType): uint32 {.
    importc, libprag.}

proc rcParseState*(scanner: glib.Scanner; state: var StateType): int =
  int(gtk_rc_parse_state(cast[ptr glib.Scanner00](scanner.impl), state))

proc rcParseString*(rcString: cstring) {.
    importc: "gtk_rc_parse_string", libprag.}

proc gtk_rc_reparse_all(): gboolean {.
    importc, libprag.}

proc rcReparseAll*(): bool =
  toBool(gtk_rc_reparse_all())

proc gtk_rc_reparse_all_for_settings(settings: ptr Settings00; forceLoad: gboolean): gboolean {.
    importc, libprag.}

proc rcReparseAllForSettings*(settings: Settings; forceLoad: bool): bool =
  toBool(gtk_rc_reparse_all_for_settings(cast[ptr Settings00](settings.impl), gboolean(forceLoad)))

proc gtk_rc_reset_styles(settings: ptr Settings00) {.
    importc, libprag.}

proc rcResetStyles*(settings: Settings) =
  gtk_rc_reset_styles(cast[ptr Settings00](settings.impl))

proc gtk_rc_set_default_files(filenames: ptr cstring) {.
    importc, libprag.}

proc rcSetDefaultFiles*(filenames: varargs[string, `$`]) =
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_rc_set_default_files(seq2CstringArray(filenames, fs469n23))

proc gtk_render_activity(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderActivity*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_activity(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_arrow(context: ptr StyleContext00; cr: ptr cairo.Context00;
    angle: cdouble; x: cdouble; y: cdouble; size: cdouble) {.
    importc, libprag.}

proc renderArrow*(context: StyleContext; cr: cairo.Context; angle: cdouble;
    x: cdouble; y: cdouble; size: cdouble) =
  gtk_render_arrow(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), angle, x, y, size)

proc gtk_render_background(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderBackground*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_background(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_background_get_clip(context: ptr StyleContext00; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble; outClip: var gdk.Rectangle) {.
    importc, libprag.}

proc renderBackgroundGetClip*(context: StyleContext; x: cdouble; y: cdouble;
    width: cdouble; height: cdouble; outClip: var gdk.Rectangle) =
  gtk_render_background_get_clip(cast[ptr StyleContext00](context.impl), x, y, width, height, outClip)

proc gtk_render_check(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderCheck*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_check(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_expander(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderExpander*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_expander(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_extension(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType) {.
    importc, libprag.}

proc renderExtension*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType) =
  gtk_render_extension(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height, gapSide)

proc gtk_render_focus(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderFocus*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_focus(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_frame(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderFrame*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_frame(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_frame_gap(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType;
    xy0Gap: cdouble; xy1Gap: cdouble) {.
    importc, libprag.}

proc renderFrameGap*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble; gapSide: PositionType; xy0Gap: cdouble;
    xy1Gap: cdouble) =
  gtk_render_frame_gap(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height, gapSide, xy0Gap, xy1Gap)

proc gtk_render_handle(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderHandle*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_handle(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_icon(context: ptr StyleContext00; cr: ptr cairo.Context00;
    pixbuf: ptr gdkpixbuf.Pixbuf00; x: cdouble; y: cdouble) {.
    importc, libprag.}

proc renderIcon*(context: StyleContext; cr: cairo.Context; pixbuf: gdkpixbuf.Pixbuf;
    x: cdouble; y: cdouble) =
  gtk_render_icon(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr gdkpixbuf.Pixbuf00](pixbuf.impl), x, y)

proc gtk_render_icon_pixbuf(context: ptr StyleContext00; source: ptr IconSource00;
    size: int32): ptr gdkpixbuf.Pixbuf00 {.
    importc, libprag.}

proc renderIconPixbuf*(context: StyleContext; source: IconSource; size: int): gdkpixbuf.Pixbuf =
  let gobj = gtk_render_icon_pixbuf(cast[ptr StyleContext00](context.impl), cast[ptr IconSource00](source.impl), int32(size))
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gdkpixbuf.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    if g_object_is_floating(result.impl).int != 0:
      discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_render_icon_surface(context: ptr StyleContext00; cr: ptr cairo.Context00;
    surface: ptr cairo.Surface00; x: cdouble; y: cdouble) {.
    importc, libprag.}

proc renderIconSurface*(context: StyleContext; cr: cairo.Context; surface: cairo.Surface;
    x: cdouble; y: cdouble) =
  gtk_render_icon_surface(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), cast[ptr cairo.Surface00](surface.impl), x, y)

proc gtk_render_insertion_cursor(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; layout: ptr pango.Layout00; index: int32; direction: pango.Direction) {.
    importc, libprag.}

proc renderInsertionCursor*(context: StyleContext; cr: cairo.Context;
    x: cdouble; y: cdouble; layout: pango.Layout; index: int; direction: pango.Direction) =
  gtk_render_insertion_cursor(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, cast[ptr pango.Layout00](layout.impl), int32(index), direction)

proc gtk_render_layout(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; layout: ptr pango.Layout00) {.
    importc, libprag.}

proc renderLayout*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; layout: pango.Layout) =
  gtk_render_layout(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, cast[ptr pango.Layout00](layout.impl))

proc gtk_render_line(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x0: cdouble; y0: cdouble; x1: cdouble; y1: cdouble) {.
    importc, libprag.}

proc renderLine*(context: StyleContext; cr: cairo.Context; x0: cdouble;
    y0: cdouble; x1: cdouble; y1: cdouble) =
  gtk_render_line(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x0, y0, x1, y1)

proc gtk_render_option(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble) {.
    importc, libprag.}

proc renderOption*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble) =
  gtk_render_option(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height)

proc gtk_render_slider(context: ptr StyleContext00; cr: ptr cairo.Context00;
    x: cdouble; y: cdouble; width: cdouble; height: cdouble; orientation: Orientation) {.
    importc, libprag.}

proc renderSlider*(context: StyleContext; cr: cairo.Context; x: cdouble;
    y: cdouble; width: cdouble; height: cdouble; orientation: Orientation) =
  gtk_render_slider(cast[ptr StyleContext00](context.impl), cast[ptr cairo.Context00](cr.impl), x, y, width, height, orientation)

proc rgbToHsv*(r: cdouble; g: cdouble; b: cdouble; h: var cdouble; s: var cdouble;
    v: var cdouble) {.
    importc: "gtk_rgb_to_hsv", libprag.}

proc gtk_selection_add_target(widget: ptr Widget00; selection: ptr gdk.Atom00;
    target: ptr gdk.Atom00; info: uint32) {.
    importc, libprag.}

proc selectionAddTarget*(widget: Widget; selection: gdk.Atom; target: gdk.Atom;
    info: int) =
  gtk_selection_add_target(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), cast[ptr gdk.Atom00](target.impl), uint32(info))

proc gtk_selection_add_targets(widget: ptr Widget00; selection: ptr gdk.Atom00;
    targets: ptr TargetEntry00; ntargets: uint32) {.
    importc, libprag.}

proc selectionAddTargets*(widget: Widget; selection: gdk.Atom; targets: seq[TargetEntry]) =
  let ntargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_selection_add_targets(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), seq2TargetEntryArray(targets, fs469n23), uint32(ntargets))

proc gtk_selection_clear_targets(widget: ptr Widget00; selection: ptr gdk.Atom00) {.
    importc, libprag.}

proc selectionClearTargets*(widget: Widget; selection: gdk.Atom) =
  gtk_selection_clear_targets(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl))

proc gtk_selection_convert(widget: ptr Widget00; selection: ptr gdk.Atom00;
    target: ptr gdk.Atom00; time: uint32): gboolean {.
    importc, libprag.}

proc selectionConvert*(widget: Widget; selection: gdk.Atom; target: gdk.Atom;
    time: int): bool =
  toBool(gtk_selection_convert(cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), cast[ptr gdk.Atom00](target.impl), uint32(time)))

proc gtk_selection_owner_set(widget: ptr Widget00; selection: ptr gdk.Atom00;
    time: uint32): gboolean {.
    importc, libprag.}

proc selectionOwnerSet*(widget: Widget = nil; selection: gdk.Atom; time: int): bool =
  toBool(gtk_selection_owner_set(if widget.isNil: nil else: cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), uint32(time)))

proc gtk_selection_owner_set_for_display(display: ptr gdk.Display00; widget: ptr Widget00;
    selection: ptr gdk.Atom00; time: uint32): gboolean {.
    importc, libprag.}

proc selectionOwnerSetForDisplay*(display: gdk.Display; widget: Widget = nil;
    selection: gdk.Atom; time: int): bool =
  toBool(gtk_selection_owner_set_for_display(cast[ptr gdk.Display00](display.impl), if widget.isNil: nil else: cast[ptr Widget00](widget.impl), cast[ptr gdk.Atom00](selection.impl), uint32(time)))

proc gtk_selection_remove_all(widget: ptr Widget00) {.
    importc, libprag.}

proc selectionRemoveAll*(widget: Widget) =
  gtk_selection_remove_all(cast[ptr Widget00](widget.impl))

proc gtk_set_debug_flags(flags: uint32) {.
    importc, libprag.}

proc setDebugFlags*(flags: int) =
  gtk_set_debug_flags(uint32(flags))

proc gtk_show_uri(screen: ptr gdk.Screen00; uri: cstring; timestamp: uint32;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc showUri*(screen: gdk.Screen = nil; uri: cstring; timestamp: int): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_show_uri(if screen.isNil: nil else: cast[ptr gdk.Screen00](screen.impl), uri, uint32(timestamp), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_show_uri_on_window(parent: ptr Window00; uri: cstring; timestamp: uint32;
    error: ptr ptr glib.Error = nil): gboolean {.
    importc, libprag.}

proc showUriOnWindow*(parent: Window = nil; uri: cstring; timestamp: int): bool =
  var gerror: ptr glib.Error
  let resul0 = gtk_show_uri_on_window(if parent.isNil: nil else: cast[ptr Window00](parent.impl), uri, uint32(timestamp), addr gerror)
  if gerror != nil:
    let msg = $gerror.message
    g_error_free(gerror[])
    raise newException(GException, msg)
  result = toBool(resul0)

proc gtk_stock_add(items: ptr StockItem; nItems: uint32) {.
    importc, libprag.}

proc stockAdd*(items: ptr StockItem; nItems: int) =
  gtk_stock_add(items, uint32(nItems))

proc gtk_stock_add_static(items: ptr StockItem; nItems: uint32) {.
    importc, libprag.}

proc stockAddStatic*(items: ptr StockItem; nItems: int) =
  gtk_stock_add_static(items, uint32(nItems))

proc stockListIds*(): ptr glib.SList {.
    importc: "gtk_stock_list_ids", libprag.}

proc gtk_stock_lookup(stockId: cstring; item: var StockItem): gboolean {.
    importc, libprag.}

proc stockLookup*(stockId: cstring; item: var StockItem): bool =
  toBool(gtk_stock_lookup(stockId, item))

proc stockSetTranslateFunc*(domain: cstring; `func`: TranslateFunc;
    data: pointer; notify: DestroyNotify) {.
    importc: "gtk_stock_set_translate_func", libprag.}

proc gtk_target_table_free(targets: ptr TargetEntry00; nTargets: int32) {.
    importc, libprag.}

proc targetTableFree*(targets: seq[TargetEntry]) =
  let nTargets = int(targets.len)
  var fs469n23x: array[256, pointer]
  var fs469n23: cstringArray = cast[cstringArray](addr fs469n23x)
  gtk_target_table_free(seq2TargetEntryArray(targets, fs469n23), int32(nTargets))

proc gtk_target_table_new_from_list(list: ptr TargetList00; nTargets: var int32): ptr TargetEntry00 {.
    importc, libprag.}

proc targetTableNewFromList*(list: TargetList; nTargets: var int): seq[TargetEntry] =
  var nTargets_00: int32
  let resul0 = gtk_target_table_new_from_list(cast[ptr TargetList00](list.impl), nTargets_00)
  result = targetEntryArrayToSeq(resul0, nTargets_00.int)
  cogfree(resul0)
  if nTargets.addr != nil:
    nTargets = int(nTargets_00)

proc gtk_targets_include_image(targets: ptr ptr gdk.Atom00; nTargets: int32;
    writable: gboolean): gboolean {.
    importc, libprag.}

proc targetsIncludeImage*(targets: ptr ptr gdk.Atom00; nTargets: int;
    writable: bool): bool =
  toBool(gtk_targets_include_image(targets, int32(nTargets), gboolean(writable)))

proc gtk_targets_include_rich_text(targets: ptr ptr gdk.Atom00; nTargets: int32;
    buffer: ptr TextBuffer00): gboolean {.
    importc, libprag.}

proc targetsIncludeRichText*(targets: ptr ptr gdk.Atom00; nTargets: int;
    buffer: TextBuffer): bool =
  toBool(gtk_targets_include_rich_text(targets, int32(nTargets), cast[ptr TextBuffer00](buffer.impl)))

proc gtk_targets_include_text(targets: ptr ptr gdk.Atom00; nTargets: int32): gboolean {.
    importc, libprag.}

proc targetsIncludeText*(targets: ptr ptr gdk.Atom00; nTargets: int): bool =
  toBool(gtk_targets_include_text(targets, int32(nTargets)))

proc gtk_targets_include_uri(targets: ptr ptr gdk.Atom00; nTargets: int32): gboolean {.
    importc, libprag.}

proc targetsIncludeUri*(targets: ptr ptr gdk.Atom00; nTargets: int): bool =
  toBool(gtk_targets_include_uri(targets, int32(nTargets)))

proc gtk_test_create_simple_window(windowTitle: cstring; dialogText: cstring): ptr Widget00 {.
    importc, libprag.}

proc testCreateSimpleWindow*(windowTitle: cstring; dialogText: cstring): Widget =
  let gobj = gtk_test_create_simple_window(windowTitle, dialogText)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_find_label(widget: ptr Widget00; labelPattern: cstring): ptr Widget00 {.
    importc, libprag.}

proc testFindLabel*(widget: Widget; labelPattern: cstring): Widget =
  let gobj = gtk_test_find_label(cast[ptr Widget00](widget.impl), labelPattern)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_find_sibling(baseWidget: ptr Widget00; widgetType: GType): ptr Widget00 {.
    importc, libprag.}

proc testFindSibling*(baseWidget: Widget; widgetType: GType): Widget =
  let gobj = gtk_test_find_sibling(cast[ptr Widget00](baseWidget.impl), widgetType)
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_find_widget(widget: ptr Widget00; labelPattern: cstring; widgetType: GType): ptr Widget00 {.
    importc, libprag.}

proc testFindWidget*(widget: Widget; labelPattern: cstring; widgetType: GType): Widget =
  let gobj = gtk_test_find_widget(cast[ptr Widget00](widget.impl), labelPattern, widgetType)
  if gobj.isNil:
    return nil
  let qdata = g_object_get_qdata(gobj, Quark)
  if qdata != nil:
    result = cast[type(result)](qdata)
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc gtk_test_list_all_types(nTypes: var uint32): ptr GType {.
    importc, libprag.}

proc testListAllTypes*(nTypes: var int): ptr GType =
  var nTypes_00: uint32
  result = gtk_test_list_all_types(nTypes_00)
  if nTypes.addr != nil:
    nTypes = int(nTypes_00)

proc testRegisterAllTypes*() {.
    importc: "gtk_test_register_all_types", libprag.}

proc gtk_test_slider_get_value(widget: ptr Widget00): cdouble {.
    importc, libprag.}

proc testSliderGetValue*(widget: Widget): cdouble =
  gtk_test_slider_get_value(cast[ptr Widget00](widget.impl))

proc gtk_test_slider_set_perc(widget: ptr Widget00; percentage: cdouble) {.
    importc, libprag.}

proc testSliderSetPerc*(widget: Widget; percentage: cdouble) =
  gtk_test_slider_set_perc(cast[ptr Widget00](widget.impl), percentage)

proc gtk_test_spin_button_click(spinner: ptr SpinButton00; button: uint32;
    upwards: gboolean): gboolean {.
    importc, libprag.}

proc testSpinButtonClick*(spinner: SpinButton; button: int; upwards: bool): bool =
  toBool(gtk_test_spin_button_click(cast[ptr SpinButton00](spinner.impl), uint32(button), gboolean(upwards)))

proc gtk_test_text_get(widget: ptr Widget00): cstring {.
    importc, libprag.}

proc testTextGet*(widget: Widget): string =
  let resul0 = gtk_test_text_get(cast[ptr Widget00](widget.impl))
  result = $resul0
  cogfree(resul0)

proc gtk_test_text_set(widget: ptr Widget00; string: cstring) {.
    importc, libprag.}

proc testTextSet*(widget: Widget; string: cstring) =
  gtk_test_text_set(cast[ptr Widget00](widget.impl), string)

proc gtk_test_widget_click(widget: ptr Widget00; button: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc testWidgetClick*(widget: Widget; button: int; modifiers: gdk.ModifierType): bool =
  toBool(gtk_test_widget_click(cast[ptr Widget00](widget.impl), uint32(button), modifiers))

proc gtk_test_widget_send_key(widget: ptr Widget00; keyval: uint32; modifiers: gdk.ModifierType): gboolean {.
    importc, libprag.}

proc testWidgetSendKey*(widget: Widget; keyval: int; modifiers: gdk.ModifierType): bool =
  toBool(gtk_test_widget_send_key(cast[ptr Widget00](widget.impl), uint32(keyval), modifiers))

proc gtk_test_widget_wait_for_draw(widget: ptr Widget00) {.
    importc, libprag.}

proc testWidgetWaitForDraw*(widget: Widget) =
  gtk_test_widget_wait_for_draw(cast[ptr Widget00](widget.impl))

proc gtk_tree_get_row_drag_data(selectionData: ptr SelectionData00; treeModel: var ptr TreeModel00;
    path: var ptr TreePath00): gboolean {.
    importc, libprag.}

proc treeGetRowDragData*(selectionData: SelectionData; treeModel: var (TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore) = cast[var TreeModel](nil);
    path: var TreePath = cast[var TreePath](nil)): bool =
  var tmpoutgobjectarg: ptr TreeModel00
  if addr(path) != nil:
    fnew(path, gBoxedFreeGtkTreePath)
  result = toBool(gtk_tree_get_row_drag_data(cast[ptr SelectionData00](selectionData.impl), cast[var ptr TreeModel00](if addr(treeModel) == nil: nil else: addr tmpoutgobjectarg), cast[var ptr TreePath00](if addr(path) == nil: nil else: addr path.impl)))
  if path != nil and path.impl == nil:
    path.ignoreFinalizer = true
    path = nil
#  dothemagic(treeModel
  if addr(treeModel) != nil:
    treeModel = nil

  if tmpoutgobjectarg != nil:
    let argqdata = g_object_get_qdata(tmpoutgobjectarg, Quark)
    if argqdata != nil:
      treeModel = cast[type(treeModel)](argqdata)
      assert(treeModel.impl == tmpoutgobjectarg)
    else:
      fnew(treeModel, gtk.finalizeGObject)
      treeModel.impl = tmpoutgobjectarg
      GC_ref(treeModel)
      if g_object_is_floating(treeModel.impl).int != 0:
        discard g_object_ref_sink(treeModel.impl)
      g_object_add_toggle_ref(treeModel.impl, toggleNotify, addr(treeModel[]))
      g_object_unref(treeModel.impl)
      assert(g_object_get_qdata(treeModel.impl, Quark) == nil)
      g_object_set_qdata(treeModel.impl, Quark, addr(treeModel[]))


proc gtk_tree_set_row_drag_data(selectionData: ptr SelectionData00; treeModel: ptr TreeModel00;
    path: ptr TreePath00): gboolean {.
    importc, libprag.}

proc treeSetRowDragData*(selectionData: SelectionData; treeModel: TreeModel | TreeModelSort | ListStore | TreeModelFilter | TreeStore;
    path: TreePath): bool =
  toBool(gtk_tree_set_row_drag_data(cast[ptr SelectionData00](selectionData.impl), cast[ptr TreeModel00](treeModel.impl), cast[ptr TreePath00](path.impl)))

proc gtk_true(): gboolean {.
    importc, libprag.}

proc true1*(): bool =
  toBool(gtk_true())
# === remaining symbols:

# Extern interfaces: (we don't use converters, but explicit procs for now.)

proc implementorIface*(x: gtk.AboutDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.AccelLabel): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ActionBar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Alignment): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.AppChooserButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.AppChooserDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.AppChooserWidget): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc actionGroup*(x: gtk.Application): gio.ActionGroup = cast[gio.ActionGroup](x)

proc actionMap*(x: gtk.Application): gio.ActionMap = cast[gio.ActionMap](x)

proc implementorIface*(x: gtk.ApplicationWindow): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc actionGroup*(x: gtk.ApplicationWindow): gio.ActionGroup = cast[gio.ActionGroup](x)

proc actionMap*(x: gtk.ApplicationWindow): gio.ActionMap = cast[gio.ActionMap](x)

proc implementorIface*(x: gtk.Arrow): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ArrowAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.ArrowAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.AspectFrame): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Assistant): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Bin): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.BooleanCellAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.BooleanCellAccessible): atk.Component = cast[atk.Component](x)

proc tableCell*(x: gtk.BooleanCellAccessible): atk.TableCell = cast[atk.TableCell](x)

proc implementorIface*(x: gtk.Box): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Button): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.ButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.ButtonAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.ButtonAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.ButtonBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Calendar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.CellAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.CellAccessible): atk.Component = cast[atk.Component](x)

proc tableCell*(x: gtk.CellAccessible): atk.TableCell = cast[atk.TableCell](x)

proc implementorIface*(x: gtk.CellView): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.CheckButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.CheckMenuItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.CheckMenuItemAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.CheckMenuItemAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.CheckMenuItemAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.ColorButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ColorChooserDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ColorChooserWidget): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ColorSelection): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ColorSelectionDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ComboBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.ComboBoxAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.ComboBoxAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.ComboBoxAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.ComboBoxText): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Container): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ContainerAccessible): atk.Component = cast[atk.Component](x)

proc action*(x: gtk.ContainerCellAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.ContainerCellAccessible): atk.Component = cast[atk.Component](x)

proc tableCell*(x: gtk.ContainerCellAccessible): atk.TableCell = cast[atk.TableCell](x)

proc implementorIface*(x: gtk.Dialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.DrawingArea): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Entry): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.EntryAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.EntryAccessible): atk.Component = cast[atk.Component](x)

proc editableText*(x: gtk.EntryAccessible): atk.EditableText = cast[atk.EditableText](x)

proc text*(x: gtk.EntryAccessible): atk.Text = cast[atk.Text](x)

proc action*(x: gtk.EntryIconAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.EntryIconAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.EventBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Expander): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.ExpanderAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.ExpanderAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.FileChooserButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.FileChooserDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.FileChooserWidget): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Fixed): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.FlowBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.FlowBoxAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.FlowBoxAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.FlowBoxChild): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.FlowBoxChildAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.FontButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.FontChooserDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.FontChooserWidget): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.FontSelection): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.FontSelectionDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Frame): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.FrameAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.GLArea): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Grid): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HButtonBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HPaned): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HSV): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HScale): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HScrollbar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HSeparator): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HandleBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.HeaderBar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.HeaderBarAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.IconView): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.IconViewAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.IconViewAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.Image): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ImageAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.ImageAccessible): atk.Image = cast[atk.Image](x)

proc action*(x: gtk.ImageCellAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.ImageCellAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.ImageCellAccessible): atk.Image = cast[atk.Image](x)

proc tableCell*(x: gtk.ImageCellAccessible): atk.TableCell = cast[atk.TableCell](x)

proc implementorIface*(x: gtk.ImageMenuItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.InfoBar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Invisible): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Label): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.LabelAccessible): atk.Component = cast[atk.Component](x)

proc hypertext*(x: gtk.LabelAccessible): atk.Hypertext = cast[atk.Hypertext](x)

proc text*(x: gtk.LabelAccessible): atk.Text = cast[atk.Text](x)

proc implementorIface*(x: gtk.Layout): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.LevelBar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.LevelBarAccessible): atk.Component = cast[atk.Component](x)

proc value*(x: gtk.LevelBarAccessible): atk.Value = cast[atk.Value](x)

proc implementorIface*(x: gtk.LinkButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.LinkButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.LinkButtonAccessible): atk.Component = cast[atk.Component](x)

proc hyperlinkImpl*(x: gtk.LinkButtonAccessible): atk.HyperlinkImpl = cast[atk.HyperlinkImpl](x)

proc image*(x: gtk.LinkButtonAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.ListBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ListBoxAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.ListBoxAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.ListBoxRow): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ListBoxRowAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.LockButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.LockButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.LockButtonAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.LockButtonAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.Menu): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.MenuAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.MenuAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.MenuBar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.MenuButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.MenuButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.MenuButtonAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.MenuButtonAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.MenuItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.MenuItemAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.MenuItemAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.MenuItemAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.MenuShell): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.MenuShellAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.MenuShellAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.MenuToolButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.MessageDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Misc): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ModelButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Notebook): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.NotebookAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.NotebookAccessible): atk.Selection = cast[atk.Selection](x)

proc component*(x: gtk.NotebookPageAccessible): atk.Component = cast[atk.Component](x)

proc icon*(x: gtk.NumerableIcon): gio.Icon = cast[gio.Icon](x)

proc implementorIface*(x: gtk.OffscreenWindow): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Overlay): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Paned): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.PanedAccessible): atk.Component = cast[atk.Component](x)

proc value*(x: gtk.PanedAccessible): atk.Value = cast[atk.Value](x)

proc implementorIface*(x: gtk.PlacesSidebar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Plug): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.PlugAccessible): atk.Component = cast[atk.Component](x)

proc window*(x: gtk.PlugAccessible): atk.Window = cast[atk.Window](x)

proc implementorIface*(x: gtk.Popover): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.PopoverAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.PopoverMenu): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ProgressBar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ProgressBarAccessible): atk.Component = cast[atk.Component](x)

proc value*(x: gtk.ProgressBarAccessible): atk.Value = cast[atk.Value](x)

proc implementorIface*(x: gtk.RadioButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.RadioButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.RadioButtonAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.RadioButtonAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.RadioMenuItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.RadioMenuItemAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.RadioMenuItemAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.RadioMenuItemAccessible): atk.Selection = cast[atk.Selection](x)

proc implementorIface*(x: gtk.RadioToolButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Range): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.RangeAccessible): atk.Component = cast[atk.Component](x)

proc value*(x: gtk.RangeAccessible): atk.Value = cast[atk.Value](x)

proc implementorIface*(x: gtk.RecentChooserDialog): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.RecentChooserMenu): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.RecentChooserWidget): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.RendererCellAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.RendererCellAccessible): atk.Component = cast[atk.Component](x)

proc tableCell*(x: gtk.RendererCellAccessible): atk.TableCell = cast[atk.TableCell](x)

proc implementorIface*(x: gtk.Revealer): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Scale): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ScaleAccessible): atk.Component = cast[atk.Component](x)

proc value*(x: gtk.ScaleAccessible): atk.Value = cast[atk.Value](x)

proc implementorIface*(x: gtk.ScaleButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.ScaleButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.ScaleButtonAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.ScaleButtonAccessible): atk.Image = cast[atk.Image](x)

proc value*(x: gtk.ScaleButtonAccessible): atk.Value = cast[atk.Value](x)

proc implementorIface*(x: gtk.Scrollbar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ScrolledWindow): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.ScrolledWindowAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.SearchBar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.SearchEntry): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Separator): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.SeparatorMenuItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.SeparatorToolItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ShortcutLabel): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ShortcutsGroup): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ShortcutsSection): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ShortcutsShortcut): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ShortcutsWindow): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Socket): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.SocketAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.SpinButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.SpinButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.SpinButtonAccessible): atk.Component = cast[atk.Component](x)

proc editableText*(x: gtk.SpinButtonAccessible): atk.EditableText = cast[atk.EditableText](x)

proc text*(x: gtk.SpinButtonAccessible): atk.Text = cast[atk.Text](x)

proc value*(x: gtk.SpinButtonAccessible): atk.Value = cast[atk.Value](x)

proc implementorIface*(x: gtk.Spinner): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.SpinnerAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.SpinnerAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.Stack): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.StackAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.StackSidebar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.StackSwitcher): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Statusbar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.StatusbarAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.Switch): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.SwitchAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.SwitchAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.Table): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.TearoffMenuItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.TextCellAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.TextCellAccessible): atk.Component = cast[atk.Component](x)

proc tableCell*(x: gtk.TextCellAccessible): atk.TableCell = cast[atk.TableCell](x)

proc text*(x: gtk.TextCellAccessible): atk.Text = cast[atk.Text](x)

proc implementorIface*(x: gtk.TextView): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.TextViewAccessible): atk.Component = cast[atk.Component](x)

proc editableText*(x: gtk.TextViewAccessible): atk.EditableText = cast[atk.EditableText](x)

proc streamableContent*(x: gtk.TextViewAccessible): atk.StreamableContent = cast[atk.StreamableContent](x)

proc text*(x: gtk.TextViewAccessible): atk.Text = cast[atk.Text](x)

proc implementorIface*(x: gtk.ToggleButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc action*(x: gtk.ToggleButtonAccessible): atk.Action = cast[atk.Action](x)

proc component*(x: gtk.ToggleButtonAccessible): atk.Component = cast[atk.Component](x)

proc image*(x: gtk.ToggleButtonAccessible): atk.Image = cast[atk.Image](x)

proc implementorIface*(x: gtk.ToggleToolButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ToolButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ToolItem): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ToolItemGroup): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.ToolPalette): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Toolbar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.TreeView): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.TreeViewAccessible): atk.Component = cast[atk.Component](x)

proc selection*(x: gtk.TreeViewAccessible): atk.Selection = cast[atk.Selection](x)

proc table*(x: gtk.TreeViewAccessible): atk.Table = cast[atk.Table](x)

proc implementorIface*(x: gtk.VBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.VButtonBox): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.VPaned): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.VScale): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.VScrollbar): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.VSeparator): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Viewport): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.VolumeButton): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc implementorIface*(x: gtk.Widget): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.WidgetAccessible): atk.Component = cast[atk.Component](x)

proc implementorIface*(x: gtk.Window): atk.ImplementorIface = cast[atk.ImplementorIface](x)

proc component*(x: gtk.WindowAccessible): atk.Component = cast[atk.Component](x)

proc window*(x: gtk.WindowAccessible): atk.Window = cast[atk.Window](x)

proc mainQuit*(w: Window) = mainQuit()

proc init* =
  var argc: int32 = 0
  #var argv: cstringArray = nil
  var argv: ptr cstring = nil
  gtk_init(argc,  argv)

proc setMargin*(w: Widget; m: int) =
  setMarginStart(w, m)
  setMarginEnd(w, m)
  setMarginTop(w, m)
  setMarginBottom(w, m)


# allow connecting GtkText and GtkEntry to "changed" signal of GtkEditable!
proc editable*(x: Text): Editable = cast[Editable](x)

proc editable*(x: Entry): Editable = cast[Editable](x)

#proc loadFromData*(self: CssProvider; data: cstring): bool =
#  loadFromData(self, uint8Array(data), -1)

proc addAction*(self: ApplicationWindow; action: Action | PropertyAction | SimpleAction) =
  g_action_map_add_action(cast[ptr ActionMap00](self.impl), cast[ptr Action00](action.impl))

proc gtk_file_chooser_dialog_new*(title: cstring; parent: ptr Window00; action: FileChooserAction; 
    firstButtonText: cstring = nil): ptr FileChooserDialog00 {.varargs,
    importc: "gtk_file_chooser_dialog_new", libprag.}

proc newFileChooserDialog*(title: cstring = nil; parent: Window = nil; action: FileChooserAction): FileChooserDialog =
  let gobj = gtk_file_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

proc initFileChooserDialog*[T](result: var T; title: cstring = nil; parent: Window = nil; action: FileChooserAction) =
  assert(result is FileChooserDialog)
  let gobj = gtk_file_chooser_dialog_new(title, if parent.isNil: nil else: cast[ptr Window00](parent.impl), action)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    GC_ref(result)
    discard g_object_ref_sink(result.impl)
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[]))
    g_object_unref(result.impl)
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))

import macros, strutils

#include gisup
#include gimpl

include gisup3
include gimplgobj
include gimplgtk
proc getAboutDialog*(builder: Builder; name: string): AboutDialog =
  let gt = gtk_about_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAccelLabel*(builder: Builder; name: string): AccelLabel =
  let gt = gtk_accel_label_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAction*(builder: Builder; name: string): Action =
  let gt = gtk_action_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getActionBar*(builder: Builder; name: string): ActionBar =
  let gt = gtk_action_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getActionGroup*(builder: Builder; name: string): ActionGroup =
  let gt = gtk_action_group_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAlignment*(builder: Builder; name: string): Alignment =
  let gt = gtk_alignment_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAppChooserButton*(builder: Builder; name: string): AppChooserButton =
  let gt = gtk_app_chooser_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAppChooserDialog*(builder: Builder; name: string): AppChooserDialog =
  let gt = gtk_app_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAppChooserWidget*(builder: Builder; name: string): AppChooserWidget =
  let gt = gtk_app_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getApplicationWindow*(builder: Builder; name: string): ApplicationWindow =
  let gt = gtk_application_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getArrow*(builder: Builder; name: string): Arrow =
  let gt = gtk_arrow_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAspectFrame*(builder: Builder; name: string): AspectFrame =
  let gt = gtk_aspect_frame_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getAssistant*(builder: Builder; name: string): Assistant =
  let gt = gtk_assistant_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getBin*(builder: Builder; name: string): Bin =
  let gt = gtk_bin_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getBox*(builder: Builder; name: string): Box =
  let gt = gtk_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getButton*(builder: Builder; name: string): Button =
  let gt = gtk_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getButtonBox*(builder: Builder; name: string): ButtonBox =
  let gt = gtk_button_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCalendar*(builder: Builder; name: string): Calendar =
  let gt = gtk_calendar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCellArea*(builder: Builder; name: string): CellArea =
  let gt = gtk_cell_area_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCellAreaBox*(builder: Builder; name: string): CellAreaBox =
  let gt = gtk_cell_area_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCellView*(builder: Builder; name: string): CellView =
  let gt = gtk_cell_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCheckButton*(builder: Builder; name: string): CheckButton =
  let gt = gtk_check_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getCheckMenuItem*(builder: Builder; name: string): CheckMenuItem =
  let gt = gtk_check_menu_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorButton*(builder: Builder; name: string): ColorButton =
  let gt = gtk_color_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorChooserDialog*(builder: Builder; name: string): ColorChooserDialog =
  let gt = gtk_color_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorChooserWidget*(builder: Builder; name: string): ColorChooserWidget =
  let gt = gtk_color_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorSelection*(builder: Builder; name: string): ColorSelection =
  let gt = gtk_color_selection_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getColorSelectionDialog*(builder: Builder; name: string): ColorSelectionDialog =
  let gt = gtk_color_selection_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getComboBox*(builder: Builder; name: string): ComboBox =
  let gt = gtk_combo_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getComboBoxText*(builder: Builder; name: string): ComboBoxText =
  let gt = gtk_combo_box_text_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getContainer*(builder: Builder; name: string): Container =
  let gt = gtk_container_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getDialog*(builder: Builder; name: string): Dialog =
  let gt = gtk_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getDrawingArea*(builder: Builder; name: string): DrawingArea =
  let gt = gtk_drawing_area_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEntry*(builder: Builder; name: string): Entry =
  let gt = gtk_entry_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEntryCompletion*(builder: Builder; name: string): EntryCompletion =
  let gt = gtk_entry_completion_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getEventBox*(builder: Builder; name: string): EventBox =
  let gt = gtk_event_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getExpander*(builder: Builder; name: string): Expander =
  let gt = gtk_expander_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileChooserButton*(builder: Builder; name: string): FileChooserButton =
  let gt = gtk_file_chooser_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileChooserDialog*(builder: Builder; name: string): FileChooserDialog =
  let gt = gtk_file_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileChooserWidget*(builder: Builder; name: string): FileChooserWidget =
  let gt = gtk_file_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileFilter*(builder: Builder; name: string): FileFilter =
  let gt = gtk_file_filter_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFixed*(builder: Builder; name: string): Fixed =
  let gt = gtk_fixed_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFlowBox*(builder: Builder; name: string): FlowBox =
  let gt = gtk_flow_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFlowBoxChild*(builder: Builder; name: string): FlowBoxChild =
  let gt = gtk_flow_box_child_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontButton*(builder: Builder; name: string): FontButton =
  let gt = gtk_font_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontChooserDialog*(builder: Builder; name: string): FontChooserDialog =
  let gt = gtk_font_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontChooserWidget*(builder: Builder; name: string): FontChooserWidget =
  let gt = gtk_font_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontSelection*(builder: Builder; name: string): FontSelection =
  let gt = gtk_font_selection_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFontSelectionDialog*(builder: Builder; name: string): FontSelectionDialog =
  let gt = gtk_font_selection_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFrame*(builder: Builder; name: string): Frame =
  let gt = gtk_frame_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getGLArea*(builder: Builder; name: string): GLArea =
  let gt = gtk_glarea_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getGrid*(builder: Builder; name: string): Grid =
  let gt = gtk_grid_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHBox*(builder: Builder; name: string): HBox =
  let gt = gtk_hbox_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHButtonBox*(builder: Builder; name: string): HButtonBox =
  let gt = gtk_hbutton_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHPaned*(builder: Builder; name: string): HPaned =
  let gt = gtk_hpaned_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHSV*(builder: Builder; name: string): HSV =
  let gt = gtk_hsv_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHScale*(builder: Builder; name: string): HScale =
  let gt = gtk_hscale_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHScrollbar*(builder: Builder; name: string): HScrollbar =
  let gt = gtk_hscrollbar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHSeparator*(builder: Builder; name: string): HSeparator =
  let gt = gtk_hseparator_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHandleBox*(builder: Builder; name: string): HandleBox =
  let gt = gtk_handle_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getHeaderBar*(builder: Builder; name: string): HeaderBar =
  let gt = gtk_header_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getIconFactory*(builder: Builder; name: string): IconFactory =
  let gt = gtk_icon_factory_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getIconView*(builder: Builder; name: string): IconView =
  let gt = gtk_icon_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getImage*(builder: Builder; name: string): Image =
  let gt = gtk_image_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getImageMenuItem*(builder: Builder; name: string): ImageMenuItem =
  let gt = gtk_image_menu_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getInfoBar*(builder: Builder; name: string): InfoBar =
  let gt = gtk_info_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getInvisible*(builder: Builder; name: string): Invisible =
  let gt = gtk_invisible_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLabel*(builder: Builder; name: string): Label =
  let gt = gtk_label_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLayout*(builder: Builder; name: string): Layout =
  let gt = gtk_layout_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLevelBar*(builder: Builder; name: string): LevelBar =
  let gt = gtk_level_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLinkButton*(builder: Builder; name: string): LinkButton =
  let gt = gtk_link_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListBox*(builder: Builder; name: string): ListBox =
  let gt = gtk_list_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListBoxRow*(builder: Builder; name: string): ListBoxRow =
  let gt = gtk_list_box_row_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getListStore*(builder: Builder; name: string): ListStore =
  let gt = gtk_list_store_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getLockButton*(builder: Builder; name: string): LockButton =
  let gt = gtk_lock_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenu*(builder: Builder; name: string): Menu =
  let gt = gtk_menu_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuBar*(builder: Builder; name: string): MenuBar =
  let gt = gtk_menu_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuButton*(builder: Builder; name: string): MenuButton =
  let gt = gtk_menu_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuItem*(builder: Builder; name: string): MenuItem =
  let gt = gtk_menu_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuShell*(builder: Builder; name: string): MenuShell =
  let gt = gtk_menu_shell_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuToolButton*(builder: Builder; name: string): MenuToolButton =
  let gt = gtk_menu_tool_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMessageDialog*(builder: Builder; name: string): MessageDialog =
  let gt = gtk_message_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMisc*(builder: Builder; name: string): Misc =
  let gt = gtk_misc_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getModelButton*(builder: Builder; name: string): ModelButton =
  let gt = gtk_model_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getNotebook*(builder: Builder; name: string): Notebook =
  let gt = gtk_notebook_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getOffscreenWindow*(builder: Builder; name: string): OffscreenWindow =
  let gt = gtk_offscreen_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getOverlay*(builder: Builder; name: string): Overlay =
  let gt = gtk_overlay_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPaned*(builder: Builder; name: string): Paned =
  let gt = gtk_paned_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPlacesSidebar*(builder: Builder; name: string): PlacesSidebar =
  let gt = gtk_places_sidebar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPlug*(builder: Builder; name: string): Plug =
  let gt = gtk_plug_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPopover*(builder: Builder; name: string): Popover =
  let gt = gtk_popover_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getPopoverMenu*(builder: Builder; name: string): PopoverMenu =
  let gt = gtk_popover_menu_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getProgressBar*(builder: Builder; name: string): ProgressBar =
  let gt = gtk_progress_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRadioAction*(builder: Builder; name: string): RadioAction =
  let gt = gtk_radio_action_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRadioButton*(builder: Builder; name: string): RadioButton =
  let gt = gtk_radio_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRadioMenuItem*(builder: Builder; name: string): RadioMenuItem =
  let gt = gtk_radio_menu_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRadioToolButton*(builder: Builder; name: string): RadioToolButton =
  let gt = gtk_radio_tool_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRange*(builder: Builder; name: string): Range =
  let gt = gtk_range_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRecentAction*(builder: Builder; name: string): RecentAction =
  let gt = gtk_recent_action_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRecentChooserDialog*(builder: Builder; name: string): RecentChooserDialog =
  let gt = gtk_recent_chooser_dialog_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRecentChooserMenu*(builder: Builder; name: string): RecentChooserMenu =
  let gt = gtk_recent_chooser_menu_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRecentChooserWidget*(builder: Builder; name: string): RecentChooserWidget =
  let gt = gtk_recent_chooser_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRecentFilter*(builder: Builder; name: string): RecentFilter =
  let gt = gtk_recent_filter_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getRevealer*(builder: Builder; name: string): Revealer =
  let gt = gtk_revealer_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScale*(builder: Builder; name: string): Scale =
  let gt = gtk_scale_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScaleButton*(builder: Builder; name: string): ScaleButton =
  let gt = gtk_scale_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScrollbar*(builder: Builder; name: string): Scrollbar =
  let gt = gtk_scrollbar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getScrolledWindow*(builder: Builder; name: string): ScrolledWindow =
  let gt = gtk_scrolled_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSearchBar*(builder: Builder; name: string): SearchBar =
  let gt = gtk_search_bar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSearchEntry*(builder: Builder; name: string): SearchEntry =
  let gt = gtk_search_entry_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSeparator*(builder: Builder; name: string): Separator =
  let gt = gtk_separator_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSeparatorMenuItem*(builder: Builder; name: string): SeparatorMenuItem =
  let gt = gtk_separator_menu_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSeparatorToolItem*(builder: Builder; name: string): SeparatorToolItem =
  let gt = gtk_separator_tool_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutLabel*(builder: Builder; name: string): ShortcutLabel =
  let gt = gtk_shortcut_label_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsGroup*(builder: Builder; name: string): ShortcutsGroup =
  let gt = gtk_shortcuts_group_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsSection*(builder: Builder; name: string): ShortcutsSection =
  let gt = gtk_shortcuts_section_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsShortcut*(builder: Builder; name: string): ShortcutsShortcut =
  let gt = gtk_shortcuts_shortcut_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getShortcutsWindow*(builder: Builder; name: string): ShortcutsWindow =
  let gt = gtk_shortcuts_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSizeGroup*(builder: Builder; name: string): SizeGroup =
  let gt = gtk_size_group_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSocket*(builder: Builder; name: string): Socket =
  let gt = gtk_socket_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSpinButton*(builder: Builder; name: string): SpinButton =
  let gt = gtk_spin_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSpinner*(builder: Builder; name: string): Spinner =
  let gt = gtk_spinner_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStack*(builder: Builder; name: string): Stack =
  let gt = gtk_stack_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStackSidebar*(builder: Builder; name: string): StackSidebar =
  let gt = gtk_stack_sidebar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStackSwitcher*(builder: Builder; name: string): StackSwitcher =
  let gt = gtk_stack_switcher_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getStatusbar*(builder: Builder; name: string): Statusbar =
  let gt = gtk_statusbar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getSwitch*(builder: Builder; name: string): Switch =
  let gt = gtk_switch_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTable*(builder: Builder; name: string): Table =
  let gt = gtk_table_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTearoffMenuItem*(builder: Builder; name: string): TearoffMenuItem =
  let gt = gtk_tearoff_menu_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTextTagTable*(builder: Builder; name: string): TextTagTable =
  let gt = gtk_text_tag_table_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTextView*(builder: Builder; name: string): TextView =
  let gt = gtk_text_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToggleAction*(builder: Builder; name: string): ToggleAction =
  let gt = gtk_toggle_action_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToggleButton*(builder: Builder; name: string): ToggleButton =
  let gt = gtk_toggle_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToggleToolButton*(builder: Builder; name: string): ToggleToolButton =
  let gt = gtk_toggle_tool_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToolButton*(builder: Builder; name: string): ToolButton =
  let gt = gtk_tool_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToolItem*(builder: Builder; name: string): ToolItem =
  let gt = gtk_tool_item_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToolItemGroup*(builder: Builder; name: string): ToolItemGroup =
  let gt = gtk_tool_item_group_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToolPalette*(builder: Builder; name: string): ToolPalette =
  let gt = gtk_tool_palette_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getToolbar*(builder: Builder; name: string): Toolbar =
  let gt = gtk_toolbar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTreeStore*(builder: Builder; name: string): TreeStore =
  let gt = gtk_tree_store_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTreeView*(builder: Builder; name: string): TreeView =
  let gt = gtk_tree_view_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getTreeViewColumn*(builder: Builder; name: string): TreeViewColumn =
  let gt = gtk_tree_view_column_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getUIManager*(builder: Builder; name: string): UIManager =
  let gt = gtk_uimanager_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVBox*(builder: Builder; name: string): VBox =
  let gt = gtk_vbox_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVButtonBox*(builder: Builder; name: string): VButtonBox =
  let gt = gtk_vbutton_box_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVPaned*(builder: Builder; name: string): VPaned =
  let gt = gtk_vpaned_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVScale*(builder: Builder; name: string): VScale =
  let gt = gtk_vscale_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVScrollbar*(builder: Builder; name: string): VScrollbar =
  let gt = gtk_vscrollbar_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVSeparator*(builder: Builder; name: string): VSeparator =
  let gt = gtk_vseparator_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getViewport*(builder: Builder; name: string): Viewport =
  let gt = gtk_viewport_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getVolumeButton*(builder: Builder; name: string): VolumeButton =
  let gt = gtk_volume_button_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getWidget*(builder: Builder; name: string): Widget =
  let gt = gtk_widget_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getWindow*(builder: Builder; name: string): Window =
  let gt = gtk_window_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getMenuModel*(builder: Builder; name: string): MenuModel =
  let gt = g_menu_model_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gio.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

proc getFileChooserNative*(builder: Builder; name: string): FileChooserNative =
  let gt = gtk_file_chooser_native_get_type()
  assert(gt != g_type_invalid_get_type())
  let gobj = gtk_builder_get_object(cast[ptr Builder00](builder.impl), name)
  assert(gobj != nil)
  if g_object_get_qdata(gobj, Quark) != nil:
    result = cast[type(result)](g_object_get_qdata(gobj, Quark))
    assert(result.impl == gobj)
  else:
    fnew(result, gtk.finalizeGObject)
    result.impl = gobj
    result.ignoreFinalizer = true
    GC_ref(result) # as following g_object_unref() call will also  execute a GC_unref(result) call
    g_object_add_toggle_ref(result.impl, toggleNotify, addr(result[])) # do toggle_refs make sense at all for builder objects?
    g_object_unref(result.impl) # new for v0.8.4 and GTK4, make close main windows working
    assert(g_object_get_qdata(result.impl, Quark) == nil)
    g_object_set_qdata(result.impl, Quark, addr(result[]))
  assert(toBool(g_type_check_instance_is_a(cast[ptr TypeInstance00](result.impl), gt)))

